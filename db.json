{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/HELP-US-OUT.txt","path":"vendors/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/bower.json","path":"vendors/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/LICENSE","path":"vendors/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/bower.json","path":"vendors/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/README.md","path":"vendors/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/CONTRIBUTING.md","path":"vendors/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/README.md","path":"vendors/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.scrollstop.js","path":"vendors/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.lazyload.js","path":"vendors/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/bower.json","path":"vendors/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","path":"vendors/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","path":"vendors/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","path":"vendors/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/bower.json","path":"vendors/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery/index.js","path":"vendors/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","path":"vendors/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","path":"vendors/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","path":"vendors/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","path":"vendors/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","path":"vendors/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","path":"vendors/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","path":"vendors/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","path":"vendors/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","path":"vendors/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css","path":"vendors/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css.map","path":"vendors/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.min.css","path":"vendors/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","path":"vendors/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","path":"vendors/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.min.js","path":"vendors/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.pack.js","path":"vendors/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/FontAwesome.otf","path":"vendors/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","path":"vendors/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.js","path":"vendors/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","path":"vendors/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","path":"vendors/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","path":"vendors/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/404.html","hash":"3451ccd3230a849cf30ec06f4b2ca7ab4f11002d","modified":1519352794864},{"_id":"themes/next/.bowerrc","hash":"80e096fdc1cf912ee85dd9f7e6e77fd40cf60f10","modified":1508643418000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1508643418000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1508643418000},{"_id":"themes/next/.javascript_ignore","hash":"d619ee13031908cd72666e4ff652d2ea3483b1c3","modified":1508643418000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1508643418000},{"_id":"themes/next/README.en.md","hash":"565ba52b3825b85a9f05b41183caca7f18b741d4","modified":1508643418000},{"_id":"themes/next/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1508643418000},{"_id":"themes/next/_config.yml","hash":"d66e7e4352d29f3c1567e5efda69e42c501dcb73","modified":1519378626883},{"_id":"themes/next/bower.json","hash":"f89c6700a11d81e067cc97273ca6bf96cb88c8f9","modified":1508643418000},{"_id":"themes/next/gulpfile.coffee","hash":"26e5b1b945704c8bc78b928feede895c4c111c95","modified":1508643418000},{"_id":"themes/next/package.json","hash":"63e9c0f1dd9e5d7f51b4ae383981ef939a2ed45d","modified":1508643418000},{"_id":"source/404/index.md","hash":"1f081d7129ecc5880d0992fe90ec98c2fc7547a8","modified":1519352794865},{"_id":"source/_discarded/test.md","hash":"774cfc05535907eb94710066526ca07eb47d39aa","modified":1519372586926},{"_id":"source/_posts/golang.md","hash":"fa8c8b5666547f48bbd5f2090af20a064ee99481","modified":1519372414604},{"_id":"source/about/index.md","hash":"e8767a0fef74236301e5accbe8ee40e39239bd3c","modified":1519366891902},{"_id":"source/tags/index.md","hash":"eec0aee6a3da51eca76d405b84b6d23ea9c2faaa","modified":1519366954155},{"_id":"source/categories/index.md","hash":"ab753cae0f9eac08fb93a3fa4f373f70e7a1ebb4","modified":1519366922707},{"_id":"themes/next/languages/de.yml","hash":"786afba25cfc98845a20d9901823ebeebcd1cbbf","modified":1508643418000},{"_id":"themes/next/languages/default.yml","hash":"9db835c0543ade5a89bc80ec5a898203227cf3d8","modified":1508643418000},{"_id":"themes/next/languages/en.yml","hash":"f03799cbdb5a33064ead080bcac4baca1f6bc5f9","modified":1508643418000},{"_id":"themes/next/languages/fr-FR.yml","hash":"1a084623c39de74301f3e92f9388a3a815a542ca","modified":1508643418000},{"_id":"themes/next/languages/id.yml","hash":"147c01e41b931085ad14250fa900c2249dcbbdd7","modified":1508643418000},{"_id":"themes/next/languages/ja.yml","hash":"a2c7b6301b5474aab798946fb700289df237c3cf","modified":1508643418000},{"_id":"themes/next/languages/pt.yml","hash":"ca239b39bf65c9462e59d51b12f0fe566d453197","modified":1508643418000},{"_id":"themes/next/languages/ru.yml","hash":"cc7b964a46587aea0e57b0a5269d8fd25570858e","modified":1508643418000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"bea452bc49aed171a210d09bd6cddc4e846ea8ab","modified":1508643418000},{"_id":"themes/next/languages/zh-hk.yml","hash":"519ab3d817ec3bc5bfc91159c494b6b3c170bea7","modified":1508643418000},{"_id":"themes/next/languages/zh-tw.yml","hash":"6b1f345aaefc13e6723dc8a6741b59ac05c20dfd","modified":1508643418000},{"_id":"themes/next/layout/_layout.swig","hash":"74157f6cfd679ea11febec632542793f37c5e5d4","modified":1508643418000},{"_id":"themes/next/layout/category.swig","hash":"6422d196ceaff4220d54b8af770e7e957f3364ad","modified":1508643418000},{"_id":"themes/next/layout/index.swig","hash":"427d0b95b854e311ae363088ab39a393bf8fdc8b","modified":1508643418000},{"_id":"themes/next/layout/archive.swig","hash":"b5b59d70fc1563f482fa07afd435752774ad5981","modified":1508643418000},{"_id":"themes/next/layout/page.swig","hash":"8019d02232a6dd1a665b6a4d2daef8e5dd2f0049","modified":1508643418000},{"_id":"themes/next/layout/post.swig","hash":"e2e512142961ddfe77eba29eaa88f4a2ee43ae18","modified":1508643418000},{"_id":"themes/next/layout/tag.swig","hash":"07cf49c49c39a14dfbe9ce8e7d7eea3d4d0a4911","modified":1508643418000},{"_id":"themes/next/scripts/merge-configs.js","hash":"0c56be2e85c694247cfa327ea6d627b99ca265e8","modified":1508643418000},{"_id":"themes/next/test/.jshintrc","hash":"096ed6df627373edd820f24d46b8baf528dee61d","modified":1508643418000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1508643418000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1508643418000},{"_id":"source/images/avatar.jpg","hash":"ec40dfe5946dedbaced35335bb7267411a84b6bb","modified":1484706302506},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1508643418000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"43c3433155ccd9abcbe7dce2e6bfa1f3a66af18b","modified":1508643418000},{"_id":"themes/next/layout/_macro/post.swig","hash":"1ca03011bed92614832b1343b65be92183957dc5","modified":1508643418000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"37e5b7c42ec17b9b6b786c5512bcc481a21c974e","modified":1508643418000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"85327c2174d09c6d69c9033592e6c8f7eb7ac3ba","modified":1508643418000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"b73f9443bee2d3ea383aad52e49ffca8aa97dcc2","modified":1508643418000},{"_id":"themes/next/layout/_partials/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1508643418000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"b883289054ee54a374caad5d4883591beb94bd8b","modified":1508643418000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"0ce71d8322ea7dea82d9371fa2fe13949aa870e3","modified":1508643418000},{"_id":"themes/next/layout/_partials/head.swig","hash":"f83b1c55bedd2c1a3eb734c72c6997795a4e5f99","modified":1508643418000},{"_id":"themes/next/layout/_partials/header.swig","hash":"963a765dc00e6ac43cfc53ffaf5725eb854cf95e","modified":1508643418000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1508643418000},{"_id":"themes/next/layout/_partials/search.swig","hash":"011b9d6c9f0a2f4654908ea20b9391f9b7981271","modified":1508643418000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1508643418000},{"_id":"themes/next/layout/_scripts/baidu-push.swig","hash":"82d060fe055d6e423bbc9199f82dfe5c68e74779","modified":1508643418000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1508643418000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"0b91cadecead8e0b5211cc42b085998d94af503a","modified":1508643418000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1508643418000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1508643418000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1508643418000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"3acce36db0feb11a982c6c799aa6b6b47df2827c","modified":1508643418000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1508643418000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1508643418000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1508643418000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1508643418000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1508643418000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1508643418000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1508643418000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1508643418000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1508643418000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1508643418000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1508643418000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1508643418000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1508643418000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1508643418000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1508643418000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1508643418000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1508643418000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1508643418000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1508643418000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1508643418000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"bd07518060a73795d1250d93a74186444b292a9f","modified":1508643418000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"ff5523d5dacaa77a55a24e50e6e6530c3b98bfad","modified":1508643418000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1508643418000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1508643418000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"7ca5cb4daa58b3504e17f3e02975e794bc634658","modified":1508643418000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"c07f7b2f264e5215b8ed42d67e8cef2477558364","modified":1508643418000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1508643418000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1508643418000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1508643418000},{"_id":"themes/next/layout/_scripts/third-party/analytics.swig","hash":"0a89c04055bade7baa5962f1d5aefe438d83a244","modified":1508643418000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1508643418000},{"_id":"themes/next/layout/_scripts/third-party/comments.swig","hash":"907b931d775d32405d02a25b3b0a3ac03bf804d0","modified":1508643418000},{"_id":"themes/next/layout/_scripts/third-party/lean-analytics.swig","hash":"069bb17fb1db3bc7c85c88efa3ed94ab6becbe2c","modified":1508643418000},{"_id":"themes/next/layout/_scripts/third-party/localsearch.swig","hash":"1561bd0c107d725252c6d746e9ac177fc18f93bf","modified":1508643418000},{"_id":"themes/next/layout/_scripts/third-party/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1508643418000},{"_id":"themes/next/layout/_scripts/third-party/mathjax.swig","hash":"5bafc33f57508d1d04a9930165240f6e9efa8d6d","modified":1508643418000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"715d5b40dc52f319fe4bff0325beb874774d9bd9","modified":1508643418000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"78a83c38f69a8747bb74e420e6c9eeef1ea76525","modified":1508643418000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1508643418000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1508643418000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"3ead77befa064d6327dc7afd0a5af7be59a5f196","modified":1508643418000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"85b279027cb0102b0ad6636486f57f754892c5d4","modified":1508643418000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1508643418000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1508643418000},{"_id":"themes/next/source/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1508643418000},{"_id":"themes/next/source/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1508643418000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1508643418000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1508643418000},{"_id":"themes/next/source/js/src/utils.js","hash":"e5cb720894c4bc28ca8f10b33df127fb394018d9","modified":1508643418000},{"_id":"themes/next/source/vendors/font-awesome/.bower.json","hash":"7da985a99674e54f514d4fd9fcd3bcea6e7e41d5","modified":1508643418000},{"_id":"themes/next/source/vendors/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1508643418000},{"_id":"themes/next/source/vendors/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1508643418000},{"_id":"themes/next/source/vendors/font-awesome/HELP-US-OUT.txt","hash":"69a4c537d167b68a0ccf1c6febd138aeffca60d6","modified":1508643418000},{"_id":"themes/next/source/vendors/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1508643418000},{"_id":"themes/next/source/vendors/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1508643418000},{"_id":"themes/next/source/vendors/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1508643418000},{"_id":"themes/next/source/vendors/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1508643418000},{"_id":"themes/next/source/vendors/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1508643418000},{"_id":"themes/next/source/vendors/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1508643418000},{"_id":"themes/next/source/vendors/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1508643418000},{"_id":"themes/next/source/vendors/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1508643418000},{"_id":"themes/next/source/vendors/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1508643418000},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1508643418000},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1508643418000},{"_id":"themes/next/source/vendors/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1508643418000},{"_id":"themes/next/source/vendors/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1508643418000},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1508643418000},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1508643418000},{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1508643418000},{"_id":"themes/next/source/vendors/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1508643418000},{"_id":"themes/next/source/vendors/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1508643418000},{"_id":"themes/next/layout/_scripts/third-party/analytics/baidu-analytics.swig","hash":"7c43d66da93cde65b473a7d6db2a86f9a42647d6","modified":1508643418000},{"_id":"themes/next/layout/_scripts/third-party/analytics/cnzz-analytics.swig","hash":"44e761721e8ad787ef571a3cc57bbc12d318a2a3","modified":1508643418000},{"_id":"themes/next/layout/_scripts/third-party/analytics/facebook-sdk.swig","hash":"394d008e5e94575280407ad8a1607a028026cbc3","modified":1508643418000},{"_id":"themes/next/layout/_scripts/third-party/analytics/google-analytics.swig","hash":"30a23fa7e816496fdec0e932aa42e2d13098a9c2","modified":1508643418000},{"_id":"themes/next/layout/_scripts/third-party/comments/disqus.swig","hash":"bff3b18f56175c53f3bc6d733166c4d998e08732","modified":1508643418000},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1508643418000},{"_id":"themes/next/layout/_scripts/third-party/comments/duoshuo.swig","hash":"8c7af79407d223486fba72b8150fe045a553bf70","modified":1508643418000},{"_id":"themes/next/layout/_scripts/third-party/analytics/busuanzi-counter.swig","hash":"4fcbf57c4918528ab51d3d042cff92cf5aefb599","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"b49efc66bd055a2d0be7deabfcb02ee72a9a28c8","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"10994990d6e0b4d965a728a22cf7f6ee29cae9f6","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1508643418000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1508643418000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5304f99581da3a31de3ecec959b7adf9002fde83","modified":1508643418000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"54c90cf7bdbf5c596179d8dae6e671bad1292662","modified":1508643418000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"013619c472c7e4b08311c464fcbe9fcf5edde603","modified":1508643418000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1508643418000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"4303776991ef28f5742ca51c7dffe6f12f0acf34","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"6ed60cc621bac096c0ed7534fa25b1a52dc571d4","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"c2c6c4f6434b4f94aac2af5861cd769427f0ee10","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Pisces/_full-image.styl","hash":"938d39eedc6e3d33918c1145a5bf1e79991d3fcf","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"be22ad34f546a07f6d56b424338cdd898683eea4","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"ba0395aa8a717485bcc19b336aa0b228998df464","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"d09280e5b79f3b573edb30f30c7a5f03ac640986","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"d4b7bd610ca03dbb2f5b66631c0e84a79fb4660b","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"1b10ba2d3ad0c063c418dc94a0b7e0db4b342c53","modified":1508643418000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"7506e7490c69a200831393c38d25e91c156bd471","modified":1508643418000},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1508643418000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1508643418000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1508643418000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1508643418000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1508643418000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1508643418000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1508643418000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1508643418000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1508643418000},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css","hash":"3b87c2560832748cd06f9bfd2fd6ea8edbdae8c7","modified":1508643418000},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1508643418000},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.min.css","hash":"05ea25bc9b3ac48993e1fee322d3bc94b49a6e22","modified":1508643418000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","hash":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1508643418000},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1508643418000},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1508643418000},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1508643418000},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1508643418000},{"_id":"themes/next/source/vendors/font-awesome/fonts/FontAwesome.otf","hash":"0112e96f327d413938d37c1693806f468ffdbace","modified":1508643418000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","hash":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1508643418000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","hash":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1508643418000},{"_id":"themes/next/source/vendors/velocity/velocity.js","hash":"e63dc7cea055ca60a95d286f32349d88b10c5a4d","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"c890ce7fe933abad7baf39764a01894924854e92","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"4da051c7f3924fa2db1e73c55b2baf1c2c150255","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"90f8f9706cd7fe829cf06e9959a65fd3f8b994fa","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"3c46efd6601e268093ce6d7b1471d18501878f0d","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"8fae54591877a73dff0b29b2be2e8935e3c63575","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"b25132fe6a7ad67059a2c3afc60feabb479bdd75","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"d543d1377c1f61b70e3adb6da0eb12797552e5f2","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/post/post-more-link.styl","hash":"15063d79b5befc21820baf05d6f20cc1c1787477","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"cbca4842a54950e2934b3b8f3cd940f122111aef","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"e792c8dc41561c96d128e9b421187f1c3dc978a0","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"4eb18b12fa0ea6c35925d9a64f64e2a7dae8c7fd","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2e7ec9aaa3293941106b1bdd09055246aa3c3dc6","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"c44f6a553ec7ea5508f2054a13be33a62a15d3a9","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"7690b9596ec3a49befbe529a5a2649abec0faf76","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"2d3abbc85b979a648e0e579e45f16a6eba49d1e7","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"234facd038f144bd0fe09a31ed1357c5d74c517f","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"618f73450cf541f88a4fddc3d22898aee49d105d","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"8e66c2635d48e11de616bb29c4b1323698eebc0a","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"b03f891883446f3a5548b7cc90d29c77e62f1053","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"795d94561888d31cb7a6ff4a125596809ea69b7d","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"3afc459442c132c480d1d832f1a872f1070bb048","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1508643418000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1508643418000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1508643418000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1508643418000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1508643418000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1508643418000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1508643418000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","hash":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1508643418000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","hash":"2b3c8ba7008cc014d8fb37abc6f9f49aeda83824","modified":1508643418000},{"_id":"public/404.html","hash":"7490204c10671d443680ed76cd7ac00570f6d6ca","modified":1519378697062},{"_id":"public/about/index.html","hash":"4c4a9988be6b62f8c4ec2cafe99f87ab30cdf883","modified":1519378697069},{"_id":"public/tags/index.html","hash":"2374d71ab7d8789d7989034f00ab6df493e806c8","modified":1519378697069},{"_id":"public/categories/index.html","hash":"f9e673d46ec0cfd517da3d70fa6283035001da08","modified":1519378697069},{"_id":"public/archives/index.html","hash":"54a56a2c016d39173a3fd6ed08bc56e3addb7a09","modified":1519378697069},{"_id":"public/archives/2016/index.html","hash":"628a6ad455cb7d7434f48d7336a90b0fadbfa17f","modified":1519378697069},{"_id":"public/archives/2016/06/index.html","hash":"e3112344e61dad82a80607542a9fc243d58d68e0","modified":1519378697069},{"_id":"public/categories/language/index.html","hash":"1b065c926b5ad5c59ea5502f9f154020c769f5f6","modified":1519378697069},{"_id":"public/index.html","hash":"732963940cde7434916e18ae9fa8d3ef4f71f4dc","modified":1519378697069},{"_id":"public/tags/golang/index.html","hash":"dda0d2e2d8c65035cad23dd7e36c6f61b3c3b007","modified":1519378697069},{"_id":"public/language/golang/index.html","hash":"f0126374979d1ee834ab5613e93035cf3b2bac15","modified":1519378697069},{"_id":"public/vendors/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1519378697644},{"_id":"public/vendors/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1519378697644},{"_id":"public/vendors/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1519378697645},{"_id":"public/css/main.css","hash":"c90b82a5baa5312f88c49addea258b8b79da5edb","modified":1519378697645}],"Category":[{"name":"语言","_id":"cjdzqngr7000448kccrne1wd0"}],"Data":[],"Page":[{"_content":"<html>\n<head>\n<meta charset=\"utf-8\">\n<script type=\"text/javascript\">\n\tfunction redirect(){\n\t\tlocation.href=\"https://onelee85.github.io/\";\n\t}\n</script>\n</head>\n\n<body onload=\"redirect();\">\n</body>\n</html>","source":"404.html","raw":"<html>\n<head>\n<meta charset=\"utf-8\">\n<script type=\"text/javascript\">\n\tfunction redirect(){\n\t\tlocation.href=\"https://onelee85.github.io/\";\n\t}\n</script>\n</head>\n\n<body onload=\"redirect();\">\n</body>\n</html>","date":"2018-02-23T09:29:35.584Z","updated":"2018-02-23T02:26:34.864Z","path":"404.html","title":"","comments":1,"layout":"page","_id":"cjdzqngpt000048kce5l28y29","content":"<html>\n<head>\n<meta charset=\"utf-8\">\n<script type=\"text/javascript\">\n\tfunction redirect(){\n\t\tlocation.href=\"https://onelee85.github.io/\";\n\t}\n</script>\n</head>\n\n<body onload=\"redirect();\">\n</body>\n</html>","site":{"data":{}},"excerpt":"","more":"<html>\n<head>\n<meta charset=\"utf-8\">\n<script type=\"text/javascript\">\n\tfunction redirect(){\n\t\tlocation.href=\"https://onelee85.github.io/\";\n\t}\n</script>\n</head>\n\n<body onload=\"redirect();\">\n</body>\n</html>"},{"title":"404","date":"2016-08-31T10:31:34.000Z","_content":"","source":"404/index.md","raw":"---\ntitle: 404\ndate: 2016-08-31 18:31:34\npermalink: /404\n---\n","updated":"2018-02-23T02:26:34.865Z","path":"/404.html","comments":1,"layout":"page","_id":"cjdzqngqx000148kcchti1pm7","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"关于我","comments":0,"_content":"\n# 关于我\n\nJames 湖南人，热爱美食\n\n# 技术兴趣\n\n高性能服务端编程和分布式系统相关\n\n","source":"about/index.md","raw":"---\ntitle: 关于我\ncomments: false\n---\n\n# 关于我\n\nJames 湖南人，热爱美食\n\n# 技术兴趣\n\n高性能服务端编程和分布式系统相关\n\n","date":"2018-02-23T09:29:35.584Z","updated":"2018-02-23T06:21:31.902Z","path":"about/index.html","layout":"page","_id":"cjdzqngr7000348kck849sron","content":"<h1 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h1><p>James 湖南人，热爱美食</p>\n<h1 id=\"技术兴趣\"><a href=\"#技术兴趣\" class=\"headerlink\" title=\"技术兴趣\"></a>技术兴趣</h1><p>高性能服务端编程和分布式系统相关</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h1><p>James 湖南人，热爱美食</p>\n<h1 id=\"技术兴趣\"><a href=\"#技术兴趣\" class=\"headerlink\" title=\"技术兴趣\"></a>技术兴趣</h1><p>高性能服务端编程和分布式系统相关</p>\n"},{"title":"tags","date":"2016-06-13T15:10:40.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2016-06-13 23:10:40\ntype: \"tags\"\ncomments: false\n---\n","updated":"2018-02-23T06:22:34.155Z","path":"tags/index.html","layout":"page","_id":"cjdzqngrh000648kclptko8zh","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"categories","date":"2016-06-05T08:20:37.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2016-06-05 16:20:37\ntype: \"categories\"\ncomments: false\n---","updated":"2018-02-23T06:22:02.707Z","path":"categories/index.html","layout":"page","_id":"cjdzqngrh000748kcrruynksw","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"The go programming language 学习笔记一","date":"2016-06-16T00:09:00.000Z","_content":"\n# 1. Introduction\n\n本文是学习The go programming language的总结的第一部分，全文的组织结构如下：\n\n- Program Structure\n- Basic Data Types\n- Composite Types\n\n<!-- more -->\n\n# 2. Program Structure\n\n## 2.1 Names\n\n- 合法的命令为以字母为下划线开头，并且除关键字外的字符串（GO对大小写敏感）\n- 如果一个命令定义在函数外面，并且它的首字母是大写的，那么它可以被package外的代码访问到；如果定义在函数外部，但首字母是小写，那么能被package内部访问到\n- GO推荐用驼峰命名法来命名，即parseRequestLine是推荐的，但parse\\_request\\_line是不推荐的\n- 缩写的名称，一般全用大写，例如ASCII、HTML等\n\n## 2.2 Declarations\n\n以一个例子来说明\n\n```go\npackage main\n\nimport \"fmt\"\n\nconst boilingF = 212.0\n\nfunc main() {\n\tvar f = boilingF;\n    var c = (f - 32) * 5 / 9;\n    fmt.Printf(\"boiling point = %g F or %g C\", f, c);\n}\n```\n- 常量boilingF是package级别的定义\n- 变量f和c是本地变量，属于函数main内部\n- 函数的定义为函数名+参数列表+返回值，main函数把后两者省略掉了\n\n## 2.3 Variables\n\n变量的声明形式为\n\n```go\nvar name type = expression\n```\n\n- 如果type被省略，那么根据expression字段的类型推断出来\n- 如果expression被省略，那么初始化成zero value,对于numbers为0，对于boolean为false，对于strings为空，对于interface和reference type(slice，pointer，map，channel，function）为nil。\n\n可以在一条语句中声明多个变量\n\n```go\nvar i, j, k int\nvar b, f, s = true, 2.3, \"four\n```\n\n### 2.3.1 Short Variable Declarations\n\n```go\nname := expression\n```\n\n会以expression的type来推断name的type，并且以expression初始化name\n\n大部分的局部变量会用Short Variable Declaration方式来定义，两种情况除外\n\n- 声明的变量的类型和初始化的expression不一致，用var显式地声明\n- 声明的时候不需要初始化，后续会赋值\n\n`:=`和`=`的区别是，前者是声明，后者是赋值\n\n在`:=`语句中，不用声明所有的变量，如果有变量已经声明过，就相当于转成了赋值操作，但是，必须至少有一个变量没有声明过，因为`:=`语句要求至少新声明一个变量。\n\n```go\n//声明了out变量，err是赋值\nin ,err := os.Open(infile)\nout, err := os.Create(outfile)\n\n//编译错误，第二个语句没有新声明任何的变量\nf, err := os.Open(infile)\nf, err := os.Create(outfile)\n```\n\n### 2.3.2 Pointers\n\npointer存储的是变量的地址，可以通过pointer来间接的更新变量的值。\n\n**简单例子**\n\n```go\nx := 1\np := &x\nfmt.Println(*p) //1\n*p = 2\nfmt.Println(x)  //2\n```\n\n**局部变量返回成指针也是安全的**\n\n```go\nvar p = f()\n\nfunc f() *int {\n\tv := 1\n    return &v\n}\n```\n\n和C不一样，在GO中这是合法的，v在函数返回后继续存在。\n\n### 2.3.3 The *new* function\n\nnew返回的也是指针，例如\n```go\np := new(int)\nfmt.Println(*p)\n*p = 2\nfmt.Println(*p)\n```\n\n下面两个函数是等价的，即new和普通的局部变量区别不大\n\n```go\nfunc newInt() *int {\n\treturn new(int)\n}\n\nfunc newInt() *int {\n\tvar dummpy\n    return &dummpy\n}\n```\n\n一般来说，new创建出来的变量地址是不同的，但是，有可能struct {} 这样的空结构体，地址是相同的，取决于编译器的实现。\n\n### 2.3.4 Lifetime of Variables\n\n- package级别的变量，生命周期是整个程序运行期间\n- 局部变量是在声明语句开始后，到变量已经无法使用（即没有符号引用它，包括变量名或者指针）\n\n局部变量既可能在heap上创建，也可能在stack上创建，和是否用new无关\n\n```go\nvar global *int\n\nfunc f() {\n\tvar x int\n    x = 1\n    global = &x\n}\n\nfunc g() {\n\ty := new(int)\n    *y = 1\n}\n```\nx是在heap上创建的，因为一直被global引用，而y是stack创建，因为出了函数后，就没有使用了。\n\nGO的垃圾回收就是通过判断变量是否还被符号引用来做的，如果没有符号引用了，即表明可以回收这块的内存空间。\n\n## 2.4 Assignment\n\n赋值语句会让变量的值更新，例如\n\n```go\nx = 1\n*p = true\nperson.name = \"bob\"\ncount[x] = count[x] * scale\n```\n\n### 2.4.1 Tuple Assignment\n\n元组赋值例子如下\n\n```go\nx, y = y, x\n```\n\n有些操作，会返回多个值，可以使用元组操作，例如\n\n```go\nv, ok = m[key]\nv, ok = x.(T)\nv, ok = <-ch\n```\n\n### 2.4.2 Assignability\n\n赋值操作的左右类型必须是一致的；nil可用于interface和reference type的赋值\n\n## 2.5 Type Declarations\n\n定义type的形式如下\n```go\ntype name underlying-type\n```\n\ntype和underlying-type之间是不能直接赋值的，因为它们不是相同的类型。\n\n比较运算符可以用来比较相同的type，或者type和underlying-type，但是不能用于比较named type，例如\n\n```go\ntype Celsius float64\ntype Fahrenheit float64\nvar c Celsius\nvar f Fahrenheit\nc == 0 //true\nf >=0 //true\nc == f //compile error\n```\nc和f不能直接比较，两个都属于named type。\n\n## 2.6 Package and Files\n\n每个package相当于独立的命名空间，一般在同一个目录下的一个或多个文件可以组成一个package。\n\n例如，对于package `gopl.io/ch1/helloworld`对应的path是`$GOPATH/src/gopl.io/ch1/helloworld`。\n\n以一个例子来说明，例如，我们需要建立一个温度转换的package，名字为`gopl.io/ch2/tempconv`\n\n有两个文件，分别是`tempconv.go`和`conv.go`\n\n```go\npackage tempconv\n\ntype Celsius float64\ntype Fahrenheit float64\n\nconst (\n\tAbsoluteZeroC Celsius = -273.15\n    FreezingC Celsius = 0\n    BoilingC Celsius = 100\n)\n\nfunc (C Celsius) String() string {\n\tfmt.Sprintf(\"%gC\", c)\n}\n\nfunc (f Fahrenheit) String() string {\n\tfmt.Printf(\"%gF\", f)\n}\n```\n\n```go\npackage tempconv\n\nfunc CToF(c Celsius) Fahrenheit {\n\treturn Fahrenheit(c * 9 / 5 + 32)\n}\n\nfunc FToC(f Fahrenheit) Celsius {\n\treturn Celsius((f - 32) * 5 / 9)\n}\n```\n\npackage中以大写开头的全局变量或函数都能被外部调用到。\n\n### 2.6.1 Imports\n\n以import语句来导入package，例如\n\n```go\nimport (\n\t\"fmt\"\n    \"os\"\n    \"strconv\"\n    \"gopl.io/ch2/tempconv\"\n)\n```\n\n在GO里面，如果导入一个package，但是没有引用，会报编译错误。\n\n有`golang.org/x/tools/cmd/goimports`工具，可以自动的插入和删除需要的package。\n\n### 2.6.2 Package Initialization\n\npackage初始化会按照变量声明的顺序初始化。如果对于一些比较复杂的数据结构，可能仅仅通过初始化语句无法完成初始化，这时候可以把初始化操作放到init函数中，init函数会自动的被执行。\n\npackage初始化之前，会先把要导入的package初始化。对于package main会在最后初始化，可以保证在main函数执行之前，其他package已经完成初始化了。\n\n## 2.7 Scope\n\nScope代表变量的声明在程序哪个位置，而lifetime则表示变量在程序执行的可以被引用的时间段。前者是编译时期的特性，而后者是运行时的特性。\n\nScope一般包括universe，package，file和function。\n\n- 内置类型，函数，常量为universe level\n- 定义在函数外，可以被相同package的任意file引用，称为package level\n- 通过文件中import过，例如 import fmt，则fmt的函数在本文件都是可用的，称为file level\n- 函数内部的定义，只有函数内部应用，则为function level\n\n和C一样，范围越小的变量会隐藏范围大的变量。\n\n**for语句**\n\nfor定义了两个block\n\n- 显式的block，用{}包起来\n- 隐式的block，如初始化中的变量，范围是for循环条件，自增以及显式的block内\n\n**if语句**\n\n```go\nif x := f(); x == 0 {\n\tfmt.Println(x)\n} else if y := g(x); x == y {\n\tfmt.Println(x, y)\n} else {\n\tfmt.Println(x, y)\n}\nfmt.Println(x, y) //compile error: x和y在这里不可见\n\n\nif f, err := os.Open(fname),; err != nil { //complie error: unused f\n\treturn err\n}\n\nf.ReadByte() //compile error: undefined f\nf.Close() // compile error: undefined f\n```\n\n# 3. Basic Data Types\n\nGO的Data Type有四大类：basic types，aggregate types，reference types和interface types。Basic types包括numbers，strings和booleans；Aggregate types包括array和struct；Reference types包括pointers，slices，maps，functions和channels。\n\n## 3.1 Integers\n\nGO的numbers类型包括integers，floating-point numbers和complex numbers。\n\n对于integers，有四种有符号整数和四种无符号整数。\n\n- int8, int16, int32和int64\n- uint8, uint16, uint32和uint64\n\n除了带字节大小的类型之外，还包括int和uint，可能是32bit或者64bit，由编译器决定，编程时不要假定这个大小。\n\nrune是int32的named type，用来存储单个unicode字符。\n\nbyte是int8的named type。\n\nuintptr的大小可以存储下系统中任意的内存地址，一般用来和C Library交互的时候。\n\n采用二进制补码的方式编码，所以对于int8来讲，其范围为[-128, 127]\n\n操作符的优先级如下\n\n```go\n*\t/\t%\t<<\t>>\t&\t&^\n+\t-\t|\t^\n==\t！=\t<\t<=\t>\t>=\n&&\n||\n```\n对于%操作符，符号是跟着被除数走的，例如`-5%3`和`-5%-3`的余数都是-2。\n\n对于算术运算，可能会溢出\n\n```go\nvar u uint8 = 255\nfmt.Println(u, u+1, u*u) //255 0 1\n```\n\n对于移位操作符\n\n- `<<`不管是有符号数或者无符号数，都是末尾补0\n- `>>`对于有符号数，会在左边补符号位，对于无符号数，会在末尾补0\n\n对于遍历操作，一般用有符号数\n\n```go\nvar i uint = 0\nfor ; i >= 0; i-- {\n\n}\n```\n\n上面是个死循环，因为uint一定是大于或等于0的，故遍历的索引一般用有符号数。\n\n## 3.2 Floating-Point Numbers\n\nGO提供两种float类型，即float32和float64，采用IEEE 754标准。\n\n## 3.3 Complex Numbers\n\nGO提供两种complex类型，即complex64和complex128，底层组件分别用float32和float64。\n\n使用例子如下\n\n```go\nvar x complex128 = complex(1, 2)  //1 + 2i\nvar y complex128 = complex(3, 4)  //3 + 4i\nfmt.Println(x*y)                  //-5 + 10i\nfmt.Println(real(x*y))\t\t\t  //-5\nfmt.Println(imag)(x*y))\t\t\t  //10\n```\n## 3.4 Booleans\n\nbool类型的值只有false和true两种。bool类型和number类型之间没有隐式的转换，一般通过如下方式\n\n```go\nfunc btoi(b bool) int {\n\tif b {\n    \treturn 1\n    }\n    return 0\n}\n\nfunc itob(i int) bool {\n\treturn i != 0\n}\n```\n\n## 3.5 Strings\n\n内置len函数可以计算string类型的长度。\n\nsubstring操作通过s[i:j]，表示从i开始，共j-i个字符，因此，不包括j。\n\ni的默认值为0，j的默认值为len(s)，因此\n\n```go\ns[:5] = s[0:5]\ns[7:] = s[7:len(s)]\ns[:] = s[0:len(s)]\n```\nstring类型是不可修改的，例如\n\n```\ns = \"hello\"\ns += “world”\ns[0] = 'L' // compile error\n```\ns开始指向\"hello\"字符串，执行`+=`操作后，并不是修改原来字符串变成\"hello world\"，而是完全分配新的内存空间，把\"hello world\"存进去，然后修改s指向这块内存空间。\n\n因为string的不可修改，所以substring可以和原来的string共享内存空间。\n\n### 3.5.1 String Literals\n\n- 用双引号，例如\"hello world\"\n- 用\\来做转义\n\nGO还提供\\`...\\`来作为raw string literal的声明，即里面的转义字符像\\，换行都不会特殊处理，所以，可以放到多行。一般可以放\\等特别多的字符串。\n\n### 3.5.2 Unicode\n\nUnicode是为了解决各国文字无法在ASCII表示出来的困境，Unicode也分为多种\n\n- UTF-32，每个Unicode字符都采用32位存储\n- UTF-8，每个Unicode字符的存储空间不定，采用前缀的方式来区分\n\n### 3.5.3 UTF-8\n\nUTF-32的缺点有\n\n- 对于普通的ASCII也要采用32位存储，不兼容\n- 对于常用的65536个Unicode字符，其实用16位就行，32位会浪费大量的存储空间\n\nGO里面有专门的package`unicode/utf8`来处理UTF-8格式的编解码等。\n\n## 3.6 Constants\n\nconst类型的语义是在运行期间，变量的值不会发生变化。const可用于boolean，string和number。\n\n### 3.6.1 The Constant Genrator itoa\n\n和C不同的是，const默认的是和上一个值相同，例如\n\n```go\nconst (\n    a = 1\n    b\n    c\n)\n```\n此时，b和c都是为1。\n\nGO里边提供itoa来实现C中enum值自增的方法，如下\n\n```go\ntype Weekday int\nconst (\n    Sunday Weekday = itoa\n    MOnday\n    Tuesday\n    Wednesday\n    Thursday\n    Friday\n    Saturday\n)\n```\n\n上面定义中，Sunday为0，Monday为1，以此类推。\n\n还有如下用法\n\n```go\ntype Flags uint\n\nconst (\n    FlagUp flags = 1 << itoa\n    FlagBroadcast\n    FlagLoopback\n    FlagPointToPoint\n    FlagMulticast\n)\n```\n当itoa递增时，每个const会赋值成`1 << itoa`对应的值。\n\n更有趣的有\n\n```go\nconst (\n\t_ = 1 << (10 * itoa)\n    KiB //1024\n    MiB //1048576\n    GiB //1073741824\n    TiB\n    PiB\n    EiB\n    ZiB\n    YiB\n)\n```\n\n### 3.6.2 Untyped Constants\n\nuntyped const可以不绑定到特定的类型，这样的const一般至少有256位的精度，所以，可以参与更高精度的计算。在赋值的时候，untyped const会隐式的转换到对应的类型，例如\n\n```go\nvar x float32 = math.Pi //untyped const\nvar y float64 = math.Pi\nvar z complex128 = math.Pi\n\nconst Pi64 float64 = math.Pi\nvar x float32 = float32(Pi64) //需要转类型转成，因为不是untyped const\nvar y float64 = Pi64\nvar z complex128 = complex128(Pi64)\n```\n共有六种类型的untyped const，分别是untyped boolean，untyped integer，untyped rune，untyped rune，untyped floating-point，untyped complex和untyped string。\n\n例如，true和false是untyped boolean，字符串常量是untyped string。\n\n```go\nvar f float64 = 3 + 0i  //untyped complex -> float64\nf = 2                   //untyped integer -> float64\nf = 1e123\t\t\t\t//untyped floating-point -> float64\nf = 'a'\t\t\t\t\t//untyped rune -> float64\n```\n这种隐式的转换需要左边的变量能表示右边的值，有些情况是不能转换的，如下\n\n```go\nconst (\n    deadbeef = 0Xdeadbeef\n    a = uint32(deadbeef) // uint32 with value 3735928559\n    b = float32(deadbeef) // float32 with value \n    d = int32(deadbeef) // compile error: overflow\n    e = float64(1e309) //compile error: const overflows float64\n    f = uint(-1) //compile error: const underflows uint\n)\n```\n\n在变量声明中，如果没有指定类型，会由untyped const来隐式地决定类型\n\n```go\ni := 0  //integer\nr := '\\000' //rune\nf := 0.0 //float64\nc := 0i //complex128\n```\n\n# 4. Composite Types\n\n本章讨论了array，slice，map和struct四种类型，其中array和struct是集合类型，其包含的字节大小数量是固定的；相反，slice和map是动态的，当有新的元素加入时，大小会增加。\n\n## 4.1 Arrays\n\narray是固定大小的，包含0个或多个元素，其中内置`len`函数可以求array的元素个数。\n\n```go\nvar a [3]int // 0, 0, 0\nfmt.Println(a[0]) //print a[0]\nfmt.Println(a[len(a)-1]) //print the last element\n\nfor i, v := range a {\n\tfmt.Println(\"%d %d\\n\", i, v)\n}\nfor _, v := range a {\n\tfmt.Printf(\"%d\", v)\n}\n```\n\narray中的元素默认初始化为zero value。\n\n可以用`...`来根据初始化元素个数来自动确定array的元素个数\n\n```go\nq := [...]int{1, 2, 3}\nfmt.Println(\"%T\\n\", q) // \"[3]int\"\n```\n\narray的元素个数也是包含在类型信息中的，因此`[3]int`和`[4]int`是不同的类型，array声明时候指定的个数必须是const表达式，在编译期间就能确定其值。\n\n可以通过下表初始化指定的下表的值，例如\n\n```go\nr := [...]int{99:-1}\n```\n\n这条语句就最后一个元素声明为-1，前99个元素为默认的0。\n\n如果array的元素是可比较的，那么array是可比较的，并且只有同类型的array才能比较，其中类型包含size信息。\n\n```go\na := [2]int{1, 2}\nb := [...]int{1, 2}\nc := [3]int{1, 2, 3}\nfmt.Println(a == b) // true\nfmt.Println(a == c) // compile error\n```\n在GO中，array作为函数参数是传值的，即会将array拷贝给函数参数，然后函数内部修改不会改变原来的array，例如\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar a [3]int = [3]int{1, 2, 3}\n\tadd(a)\n\tfor _, v := range a {\n\t\tfmt.Println(v)\n\t}\n}\n\nfunc add(a [3]int) {\n\ta[0] += 1\n\ta[1] += 1\n\ta[2] += 1\n\tfor _, v := range a {\n\t\tfmt.Println(v)\n\t}\n}\n\n```\n如果需要修改array元素的值，则必须通过array的指针来完成。\n\narray的缺点：\n1. 大小是固定的，不可删除或增加元素\n2. 修改内部的值必须通过指针操作，比较麻烦\n\n因此，在GO中，大部分时间都会用slice。\n\n## 4.2 Slices\n\nslice是可变长度的串，一般写成`[]T`,其中元素的类型是`T`。\n\nslice可以表示一个array的子串。通常，slice包含三个组件：pointer，length和capacity，其中pointer指向第一个元素，length表示slice的元素个数，capacity表示slice的长度限制。内置的`len`和`cap`可以获取slice的length和capacity。\n\n多个slice可以共享底层的array，slice指向底层的array，如果把slice传递给函数参数，那么是可以达到修改底层array元素的目的的，例如\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\ta := [...]int{0, 1, 2, 3, 4, 5}\n\treverse(a[:])\n\tfmt.Println(a)\n}\n\nfunc reverse(a []int) {\n\tfor i, j := 0, len(a)-1; i < j; i, j = i+1, j-1 {\n\t\ta[i], a[j] = a[j], a[i]\n\t}\n}\n\ncharles@Charles-PC:~/code/go/bin$ ./slice \n[5 4 3 2 1 0]\n```\n创建slice的时候，不需要指定元素的个数，初始化的时候，隐式的创建了一个array，并把slice指向它。对于slice来讲，它互相是**不可比较的**。\n\n因为slice会随着底层array的元素值变化而变化，因此，对于slice来讲，不能作为map的key。**建议禁止slice之间的比较**,最多只能让slice和nil做比较，如下\n\n```go\nvar s[] int //len(s) == 0, s == nil\ns = nil //len(s) == 0, s == nil\ns = []int(nil) //len(s) == 0, s == nil\ns = []int{} //len(s) == 0, s != nil\n```\n判断slice是否为空，应该用`len(s) == 0`来判断。除了判断是否为空，其他情况下nil和空的slice表现一致，因此reverse(nil)是可以正常工作的。\n\n内置的make函数，可以指定type，length和capacity，如下\n\n```go\nmake([]T, len)\nmake([]T, len ,cap)\n```\n在实现中，make也是创建一个array，然后返回一个指向它的引用。第一种make下，len就包含了整个array；第二中make，只有cap才能包含整个array。\n\n### 4.2.1 The append function\n\n内置的append函数可以添加元素到slice，为了更好的理解append是如何工作的，实现一个特殊化的appendInt函数来说明。\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc appendInt(x []int, y int) []int {\n\tvar z []int\n\tzlen := len(x) + 1\n\tif zlen <= cap(x) {\n\t\tz = x[:zlen]\n\t} else {\n\t\tzcap := zlen\n\t\tif zcap < 2*len(x) {\n\t\t\tzcap = 2 * len(x)\n\t\t}\n\t\tz = make([]int, zlen, zcap)\n\t\tcopy(z, x)\n\t}\n\tz[len(x)] = y\n\treturn z\n}\n\nfunc main() {\n\tvar x []int\n\tfor i := 0; i < 20; i++ {\n\t\tx = appendInt(x, i)\n\t\tfmt.Println(x, len(x), cap(x))\n\t}\n}\n\n```\n\n像appendInt一样，内置的append函数也可能按照既定的策略重新分配内存，所以，我们不能假设append之后，slice的内存地址没有发生变化，因此，每次append都要将append的返回值赋值给slice。\n\n不仅仅是append，任何改变slice的len或者cap值的函数，或者把它指向新的underlying-array的，都需要重新赋值。\n\nslice的内部定义像下面的结构体\n\n```go\ntype IntSlice struct {\n\tptr *int\n    len, cap int\n}\n```\n每次要改变slice的值，都必须要显式的赋值\n\n内置的append还可以一次性的追加多个元素。\n\n### 4.2.2 In-Place Slice Techniques\n\n在本地修改slice，避免重新分配underlying-array。\n\n本节以几个例子说明，第一个是nonempty，字符串列表中，返回非空的字符串列表。\n\n```go\nfunc nonempty(strings []string) []string {\n\ti := 0\n    for _, s := range string {\n    \tif s != \"\" {\n        \tstrings[i] = s\n            i++\n        }\n    }\n}\n\nfunc nonempty2(strings []string) []string {\n\tout := strings[:0]\n    for _, s := range strings {\n    \tif s ！= “” {\n        \tout = append(out, s)\n        }\n    }\n}\n```\n\n还可以用append来实现一个stack\n\n```go\nstack = append(stack, v) //push\ntop := stack[len(stack) - 1] // top of stack\nstack = stack[:len(stack)-1] // pop\n```\n\n从字符串列表中间删掉一个字符串\n\n```go\nfunc remove(slice []int, i int) []int {\n\tcopy(slice[i:], slice[i+1:])\n    return slice[:len(slice)-1]\n}\n\nfunc main() {\n\ts := int {5, 6, 7, 8, 9}\n    fmt.Println(remove(s, 2)) //[5, 6, 8, 9]\n}\n```\n\n## 4.3 Maps\n\n在Go中，map是hash table的引用，map类型写成map[K]V，对于K，需要能使用==进行比较。\n\nmap的创建方式\n\n```go\nages := make(map[string]int)\nages[\"alice\"] = 31\nages[\"charlie\"] = 34\n\nages := map[string]int {\n\t\"alice\" : 31,\n    \"charlie\": 34,\n}\n```\nmap元素的访问和删除\n\n```go\nages[\"alice\"] = 32 // access\ndelete(ages, \"alice\") //delete\n```\n访问不在map中的key，会返回zero value。注意，map不是变量，所以不能对其元素进行取地址，原因是hash table可能会动态变化，导致原来的地址失效。\n\nmap的遍历\n\n```go\nfor name, age := range ages {\n\tfmt.Println(\"%s:%d\", name, age)\n}\n```\nmap的遍历的顺序是随机的，所以，我们不能假设它按照某个特定的顺序来遍历。\n\nmap的zero value是nil，即没有引用任何的hash table。\n\n```go\nvar ages map[string] int\nfmt.Println(ages == nil)\nfmt.Println(len(ages) == 0)\n```\n\n对于nil的map，delete，len和range都可以正常的工作，但是，往里面存数据就会panic。\n\n```go\nvar ages map[string] int\nages[\"carol\"] = 21 // panic\n```\n有时候，需要判断某个key是否存在map中，需要使用下面的测试\n\n```go\nage, ok := ages[\"bob\"]\nif !ok {\n\t//不存在\n}\n```\n\nmap不能比较，需要自己写函数遍历key来依次比较。\n\nGO语言中没有set，可以用map[string]bool来代替。\n\n有时候，我们希望slice作为key，但是slice类型是不能比较的，需要自己写函数，例如\n\n```go\n\nvar m = make(map[string]int)\nfunc k(list []string) string {return fmt.Sprintf(\"%q\", list)}\nfunc Add(list []string) {m[k(list)]++}\nfunc Count(list []string) int {return m[k(list)]}\n```\n\n对于其他不可比较的类型，也可以采用本方法，并且k(x)不一定要是string，可以计算成任何可以比较的类型。\n\n## 4.4 Structs\n\nstruct把0个或多个类型聚合在一起，每个都叫做field，例如\n\n```go\ntype Employee struct {\n\tID int\n    Name string\n    Address string\n    DoB time.Time\n    Position string\n    Salary int\n    ManagerID int\n}\nvar dillbert Employee\ndilbert.Salary = 5000\n```\n可以用`.`来访问struct里面的变量，值得说明的是，指针也能用`.`访问内部的field。\n\n```go\nvar employOfTheMonth *employee = &dilbert\nemployOfTheMonth.Postion += \"(proactive team player)\"\n```\n上面的指针访问等价于\n\n```go\n(*employeeOfTheMonth).Position += \"(proactive team player)\"\n```\nfield的顺序和类型关系很大，如果改变了它们的位置，就是另一种类型了。\n\nstruct中的field如果是大写的话，那么是export的，否则不是。\n\nstruct中不能定义自身，但是可以定义自身的指针，例如\n\n```go\ntype tree struct {\n\tvalue int\n    left, right *tree\n}\n```\nstruct的zero value是其中所有的field都是zero value。\n\nstruct中如果没有field，则是empty struct，写成`struct {}`。\n\n### 4.4.1 Struct Literals\n\nstruct literal有两种，如下\n\n```go\ntype Point struct {X, Y int}\np := Point{1, 2}\np := Point{X : 1}\n```\n如果struct不是export的，则不可以在package外声明它\n\n```go\npackage p\ntype T struct {a, b int}\n\npackage q\nimport \"p\"\nvar _ = p.T{a : 1, b : 2} //compile error\nvar _ = p.T{1, 2} // compile error\n```\n尽管最后一行没有使用unexported的field，但是它隐式地使用它们了。\n\nstruct作为函数参数是值传递的，如果是大的struct，最好使用指针来传递，这样可以提升效率。\n\n因为struct经常使用指针所以可以用如下声明\n\n```go\npp ：= &Point{1, 2}\n\npp := new(Point)\n*pp = Point{1, 2}\n```\n### 4.4.2 Comparing Structs\n\n当struct的所有field都可以比较时，则struct本身也是可比较的。\n\n### 4.4.3 Struct Embedding and Anonymous Fields\n\n通过在struct内部定义匿名的struct，可以快速访问到底层struct的field，如下\n\n```go\ntype Point struct {\n\tX, Y int\n}\ntype Circle struct {\n\tCenter Point\n    Radius int\n}\ntype Wheel struct {\n\tC Circle\n    Spokes int\n}\n\nvar w Wheel\nw.C.Center.X = 8\n```\n可以看出，从Wheel变量中，要访问Point的X需要使用三个`.`，书写效率比较低，可以使用以下方式解决\n\n```go\ntype Circle struct {\n\tPoint\n    Radius int\n}\ntype Wheel struct {\n\tCircle\n    Spokes int\n}\nvar w Wheel\nw.X = 8\nw.Y = 8\nw.Radius = 9\n```\n使用上述方法可以快速访问到内部结构体中的field，但是这种方式对于struct literal是不行的\n\n```go\nw = Wheel {8, 8, 5, 20} //compile error\nw = Wheel {X : 8, Y : 8, Radius: 5, Spokes: 20} //compile error\nw = Wheel {Circle{Point{8, 8}, 5}, 20}\n\nw = Wheel {\n\tCircle : Circle {\n    \tPoint : Point {X:8, Y:8}\n        Radius : 5\n    },\n    Spokes: 20\n}\n```\n匿名的同类型的struct，只能出现在一个struct内一次，否则无法区分它们。\n\n## 4.5 JSON\n\nJSON是 JavaScript Object Notation的缩写。GO的标准库中有`encoding/json`来处理JSON格式，本节就是关于这个package相关的知识。\n\nJSON中基础类型包括numbers(decimal或scientific notation)，booleans(true or false)和strings。\n\nJSON有array和object，array以方括号扩起来，并且逗号分割的一系列元素；object是string到value的mapping， 例如\n\n```go\nboolean true\nnumber -273.15\nstring \"she said hello world\"\narray [\"gold\", \"siliver\"]\nobject {\"year\" : 1980,\n\t\t\"event\": \"archery\",\n        \"medals\": [\"gold\", \"silver\"]}\n```\n\nJSON的array可以用来编码GO的array和slice；而JSON的object可以用来编码GO的map(string作为key)和struct(不明白怎么编码？)。\n\n由GO数据结构转换成JSON的过程称为marshaling，通过`json.Marshal`函数实现，如下\n\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n)\n\ntype Movie struct {\n\tTitle  string\n\tYear   int  `json:“released”`\n\tColor  bool `json:\"color,omitempty\"`\n\tActors []string\n}\n\nfunc main() {\n\tvar movies = []Movie{\n\t\t{Title: \"Casablana\", Year: 1942, Color: false, Actors: []string{\"A\", \"B\"}},\n\t\t{Title: \"Casablana2\", Year: 1943, Color: true, Actors: []string{\"A\", \"B\"}},\n\t}\n\tdata, err := json.Marshal(movies)\n\n\tif err != nil {\n\t\tlog.Fatalf(\"JSON Marshaling failed: %s\", err)\n\t}\n\tfmt.Printf(\"%s\\n\", data)\n}\n\ncharles@Charles-PC:~/code/go$ bin/json \n[{\"Title\":\"Casablana\",\"released\":1942,\"Actors\":[\"A\",\"B\"]},{\"Title\":\"Casablana2\",\"released\":1943,\"color\":true,\"Actors\":[\"A\",\"B\"]}]\n\n```\n上面的字符串如果多了的话，可读性不是很强，可以用`MarshalIndent`来生成一个可读性较强的。\n\nGO只会对exported的field做Marshal。从上面的输出可以看出，Year转成了released的输出，Color转换成color，并且在为false的时候，不输出，这都是由它们字段后面的json标记控制的。\n\nMarshaling的反操作为unmarshaling，即把JSON结构转成GO的结构体，通过`json.Unmarshal`来实现。Unmarshaling的时候，可以选择需要的字段来做解码，如下\n\n```go\nvar titles []struct{Title string}\nif err := json.Unmarshal(data, &title); err != nil {\n\tlog.Fatalf(\"JSON unmarshaling failed:%s\", err)\n}\nfmt.Println(titles)\n```\n如上所示，只会把Title字段解析出来，其余字段会被略去。\n\n## 4.6 Text and HTML Templates\n\n除了简单的Printf外，GO还提供了强大的模板库，例如`text/template`和`html/template`，模板库本身有自己的语言规则，例如，一个简单的例子为\n\n```go\nconst templ = `{{.TotalCount}} issues:\n{{range.Items}}----------------------------------\nNumber : {{.Number}}\nUser : {{.User.Login}}\nTitle : {{.Title | printf \".64s\"}\nAge : {{.CreateAT | daysAgo}} days\n{{end}}\n\nfunction daysAgo(t time.Time) int {\n\treturn int(time.Since(t).Hours() / 24)\n}\n```\n上面的range和end，表示中间是一个循环。 `.CreateAT | daysAgo`表示讲CreateAT作为参数传入daysAgo函数处理。\n\n产生输出需要两个步骤\n\n1. 解析模板\n2. 在特定输入下执行模板\n\n解析模板只需要做一次，后面就可以无限制地执行模板，具体的例子如下\n\n```go\nvar report = template.Must(template.New(\"issue-list\")).Funcs(template.FuncMap{\"daysAgo\": daysAgo}).Parse(templ)\n\nfunc main() {\n\tresult, err := github.SearchIssues(os.Args[1:])\n    if err != nil {\n    \tlog.Fatal(err)\n    }\n    if err := report.Execute(os.Stdout, result); err ！= nil {\n    \tlog.Fatal(err)\n    }\n}\n```\n上面的是Text模板，HTML模板与之不同的是，里面可以写HTML标签，它会输入的动态数据做自动的转义，防止JS注入等攻击，例子如下\n\n```go\nimport \"html/template\"\n\nvar issueList = template.Must(template.New(\"issuelist\").Parse(`\n<h1>{{.TotalCount}} issues</h1>\n<table>\n<tr style='text-align: left'>\n  <th>#</th>\n  <th>State</th>\n  <th>User</th>\n  <th>Title</th>\n</tr>\n{{range .Items}}\n<tr>\n  <td><a href='{{.HTMLURL}}'>{{.Number}}</a></td>\n  <td>{{.State}}</td>\n  <td><a href='{{.User.HTMLURL}}'>{{.User.Login}}</a></td>\n  <td><a href='{{.HTMLURL}}'>{{.Title}}</a></td>\n</tr>\n{{end}}\n</table>\n`))\n\n//!-template\n\n//!+\nfunc main() {\n\tresult, err := github.SearchIssues(os.Args[1:])\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tif err := issueList.Execute(os.Stdout, result); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n\n```\n\n\n\n","source":"_posts/golang.md","raw":"title: The go programming language 学习笔记一\ncategories:\n  - 语言\ntags:\n  - golang\ndate: 2016-06-16 08:09:00\n---\n\n# 1. Introduction\n\n本文是学习The go programming language的总结的第一部分，全文的组织结构如下：\n\n- Program Structure\n- Basic Data Types\n- Composite Types\n\n<!-- more -->\n\n# 2. Program Structure\n\n## 2.1 Names\n\n- 合法的命令为以字母为下划线开头，并且除关键字外的字符串（GO对大小写敏感）\n- 如果一个命令定义在函数外面，并且它的首字母是大写的，那么它可以被package外的代码访问到；如果定义在函数外部，但首字母是小写，那么能被package内部访问到\n- GO推荐用驼峰命名法来命名，即parseRequestLine是推荐的，但parse\\_request\\_line是不推荐的\n- 缩写的名称，一般全用大写，例如ASCII、HTML等\n\n## 2.2 Declarations\n\n以一个例子来说明\n\n```go\npackage main\n\nimport \"fmt\"\n\nconst boilingF = 212.0\n\nfunc main() {\n\tvar f = boilingF;\n    var c = (f - 32) * 5 / 9;\n    fmt.Printf(\"boiling point = %g F or %g C\", f, c);\n}\n```\n- 常量boilingF是package级别的定义\n- 变量f和c是本地变量，属于函数main内部\n- 函数的定义为函数名+参数列表+返回值，main函数把后两者省略掉了\n\n## 2.3 Variables\n\n变量的声明形式为\n\n```go\nvar name type = expression\n```\n\n- 如果type被省略，那么根据expression字段的类型推断出来\n- 如果expression被省略，那么初始化成zero value,对于numbers为0，对于boolean为false，对于strings为空，对于interface和reference type(slice，pointer，map，channel，function）为nil。\n\n可以在一条语句中声明多个变量\n\n```go\nvar i, j, k int\nvar b, f, s = true, 2.3, \"four\n```\n\n### 2.3.1 Short Variable Declarations\n\n```go\nname := expression\n```\n\n会以expression的type来推断name的type，并且以expression初始化name\n\n大部分的局部变量会用Short Variable Declaration方式来定义，两种情况除外\n\n- 声明的变量的类型和初始化的expression不一致，用var显式地声明\n- 声明的时候不需要初始化，后续会赋值\n\n`:=`和`=`的区别是，前者是声明，后者是赋值\n\n在`:=`语句中，不用声明所有的变量，如果有变量已经声明过，就相当于转成了赋值操作，但是，必须至少有一个变量没有声明过，因为`:=`语句要求至少新声明一个变量。\n\n```go\n//声明了out变量，err是赋值\nin ,err := os.Open(infile)\nout, err := os.Create(outfile)\n\n//编译错误，第二个语句没有新声明任何的变量\nf, err := os.Open(infile)\nf, err := os.Create(outfile)\n```\n\n### 2.3.2 Pointers\n\npointer存储的是变量的地址，可以通过pointer来间接的更新变量的值。\n\n**简单例子**\n\n```go\nx := 1\np := &x\nfmt.Println(*p) //1\n*p = 2\nfmt.Println(x)  //2\n```\n\n**局部变量返回成指针也是安全的**\n\n```go\nvar p = f()\n\nfunc f() *int {\n\tv := 1\n    return &v\n}\n```\n\n和C不一样，在GO中这是合法的，v在函数返回后继续存在。\n\n### 2.3.3 The *new* function\n\nnew返回的也是指针，例如\n```go\np := new(int)\nfmt.Println(*p)\n*p = 2\nfmt.Println(*p)\n```\n\n下面两个函数是等价的，即new和普通的局部变量区别不大\n\n```go\nfunc newInt() *int {\n\treturn new(int)\n}\n\nfunc newInt() *int {\n\tvar dummpy\n    return &dummpy\n}\n```\n\n一般来说，new创建出来的变量地址是不同的，但是，有可能struct {} 这样的空结构体，地址是相同的，取决于编译器的实现。\n\n### 2.3.4 Lifetime of Variables\n\n- package级别的变量，生命周期是整个程序运行期间\n- 局部变量是在声明语句开始后，到变量已经无法使用（即没有符号引用它，包括变量名或者指针）\n\n局部变量既可能在heap上创建，也可能在stack上创建，和是否用new无关\n\n```go\nvar global *int\n\nfunc f() {\n\tvar x int\n    x = 1\n    global = &x\n}\n\nfunc g() {\n\ty := new(int)\n    *y = 1\n}\n```\nx是在heap上创建的，因为一直被global引用，而y是stack创建，因为出了函数后，就没有使用了。\n\nGO的垃圾回收就是通过判断变量是否还被符号引用来做的，如果没有符号引用了，即表明可以回收这块的内存空间。\n\n## 2.4 Assignment\n\n赋值语句会让变量的值更新，例如\n\n```go\nx = 1\n*p = true\nperson.name = \"bob\"\ncount[x] = count[x] * scale\n```\n\n### 2.4.1 Tuple Assignment\n\n元组赋值例子如下\n\n```go\nx, y = y, x\n```\n\n有些操作，会返回多个值，可以使用元组操作，例如\n\n```go\nv, ok = m[key]\nv, ok = x.(T)\nv, ok = <-ch\n```\n\n### 2.4.2 Assignability\n\n赋值操作的左右类型必须是一致的；nil可用于interface和reference type的赋值\n\n## 2.5 Type Declarations\n\n定义type的形式如下\n```go\ntype name underlying-type\n```\n\ntype和underlying-type之间是不能直接赋值的，因为它们不是相同的类型。\n\n比较运算符可以用来比较相同的type，或者type和underlying-type，但是不能用于比较named type，例如\n\n```go\ntype Celsius float64\ntype Fahrenheit float64\nvar c Celsius\nvar f Fahrenheit\nc == 0 //true\nf >=0 //true\nc == f //compile error\n```\nc和f不能直接比较，两个都属于named type。\n\n## 2.6 Package and Files\n\n每个package相当于独立的命名空间，一般在同一个目录下的一个或多个文件可以组成一个package。\n\n例如，对于package `gopl.io/ch1/helloworld`对应的path是`$GOPATH/src/gopl.io/ch1/helloworld`。\n\n以一个例子来说明，例如，我们需要建立一个温度转换的package，名字为`gopl.io/ch2/tempconv`\n\n有两个文件，分别是`tempconv.go`和`conv.go`\n\n```go\npackage tempconv\n\ntype Celsius float64\ntype Fahrenheit float64\n\nconst (\n\tAbsoluteZeroC Celsius = -273.15\n    FreezingC Celsius = 0\n    BoilingC Celsius = 100\n)\n\nfunc (C Celsius) String() string {\n\tfmt.Sprintf(\"%gC\", c)\n}\n\nfunc (f Fahrenheit) String() string {\n\tfmt.Printf(\"%gF\", f)\n}\n```\n\n```go\npackage tempconv\n\nfunc CToF(c Celsius) Fahrenheit {\n\treturn Fahrenheit(c * 9 / 5 + 32)\n}\n\nfunc FToC(f Fahrenheit) Celsius {\n\treturn Celsius((f - 32) * 5 / 9)\n}\n```\n\npackage中以大写开头的全局变量或函数都能被外部调用到。\n\n### 2.6.1 Imports\n\n以import语句来导入package，例如\n\n```go\nimport (\n\t\"fmt\"\n    \"os\"\n    \"strconv\"\n    \"gopl.io/ch2/tempconv\"\n)\n```\n\n在GO里面，如果导入一个package，但是没有引用，会报编译错误。\n\n有`golang.org/x/tools/cmd/goimports`工具，可以自动的插入和删除需要的package。\n\n### 2.6.2 Package Initialization\n\npackage初始化会按照变量声明的顺序初始化。如果对于一些比较复杂的数据结构，可能仅仅通过初始化语句无法完成初始化，这时候可以把初始化操作放到init函数中，init函数会自动的被执行。\n\npackage初始化之前，会先把要导入的package初始化。对于package main会在最后初始化，可以保证在main函数执行之前，其他package已经完成初始化了。\n\n## 2.7 Scope\n\nScope代表变量的声明在程序哪个位置，而lifetime则表示变量在程序执行的可以被引用的时间段。前者是编译时期的特性，而后者是运行时的特性。\n\nScope一般包括universe，package，file和function。\n\n- 内置类型，函数，常量为universe level\n- 定义在函数外，可以被相同package的任意file引用，称为package level\n- 通过文件中import过，例如 import fmt，则fmt的函数在本文件都是可用的，称为file level\n- 函数内部的定义，只有函数内部应用，则为function level\n\n和C一样，范围越小的变量会隐藏范围大的变量。\n\n**for语句**\n\nfor定义了两个block\n\n- 显式的block，用{}包起来\n- 隐式的block，如初始化中的变量，范围是for循环条件，自增以及显式的block内\n\n**if语句**\n\n```go\nif x := f(); x == 0 {\n\tfmt.Println(x)\n} else if y := g(x); x == y {\n\tfmt.Println(x, y)\n} else {\n\tfmt.Println(x, y)\n}\nfmt.Println(x, y) //compile error: x和y在这里不可见\n\n\nif f, err := os.Open(fname),; err != nil { //complie error: unused f\n\treturn err\n}\n\nf.ReadByte() //compile error: undefined f\nf.Close() // compile error: undefined f\n```\n\n# 3. Basic Data Types\n\nGO的Data Type有四大类：basic types，aggregate types，reference types和interface types。Basic types包括numbers，strings和booleans；Aggregate types包括array和struct；Reference types包括pointers，slices，maps，functions和channels。\n\n## 3.1 Integers\n\nGO的numbers类型包括integers，floating-point numbers和complex numbers。\n\n对于integers，有四种有符号整数和四种无符号整数。\n\n- int8, int16, int32和int64\n- uint8, uint16, uint32和uint64\n\n除了带字节大小的类型之外，还包括int和uint，可能是32bit或者64bit，由编译器决定，编程时不要假定这个大小。\n\nrune是int32的named type，用来存储单个unicode字符。\n\nbyte是int8的named type。\n\nuintptr的大小可以存储下系统中任意的内存地址，一般用来和C Library交互的时候。\n\n采用二进制补码的方式编码，所以对于int8来讲，其范围为[-128, 127]\n\n操作符的优先级如下\n\n```go\n*\t/\t%\t<<\t>>\t&\t&^\n+\t-\t|\t^\n==\t！=\t<\t<=\t>\t>=\n&&\n||\n```\n对于%操作符，符号是跟着被除数走的，例如`-5%3`和`-5%-3`的余数都是-2。\n\n对于算术运算，可能会溢出\n\n```go\nvar u uint8 = 255\nfmt.Println(u, u+1, u*u) //255 0 1\n```\n\n对于移位操作符\n\n- `<<`不管是有符号数或者无符号数，都是末尾补0\n- `>>`对于有符号数，会在左边补符号位，对于无符号数，会在末尾补0\n\n对于遍历操作，一般用有符号数\n\n```go\nvar i uint = 0\nfor ; i >= 0; i-- {\n\n}\n```\n\n上面是个死循环，因为uint一定是大于或等于0的，故遍历的索引一般用有符号数。\n\n## 3.2 Floating-Point Numbers\n\nGO提供两种float类型，即float32和float64，采用IEEE 754标准。\n\n## 3.3 Complex Numbers\n\nGO提供两种complex类型，即complex64和complex128，底层组件分别用float32和float64。\n\n使用例子如下\n\n```go\nvar x complex128 = complex(1, 2)  //1 + 2i\nvar y complex128 = complex(3, 4)  //3 + 4i\nfmt.Println(x*y)                  //-5 + 10i\nfmt.Println(real(x*y))\t\t\t  //-5\nfmt.Println(imag)(x*y))\t\t\t  //10\n```\n## 3.4 Booleans\n\nbool类型的值只有false和true两种。bool类型和number类型之间没有隐式的转换，一般通过如下方式\n\n```go\nfunc btoi(b bool) int {\n\tif b {\n    \treturn 1\n    }\n    return 0\n}\n\nfunc itob(i int) bool {\n\treturn i != 0\n}\n```\n\n## 3.5 Strings\n\n内置len函数可以计算string类型的长度。\n\nsubstring操作通过s[i:j]，表示从i开始，共j-i个字符，因此，不包括j。\n\ni的默认值为0，j的默认值为len(s)，因此\n\n```go\ns[:5] = s[0:5]\ns[7:] = s[7:len(s)]\ns[:] = s[0:len(s)]\n```\nstring类型是不可修改的，例如\n\n```\ns = \"hello\"\ns += “world”\ns[0] = 'L' // compile error\n```\ns开始指向\"hello\"字符串，执行`+=`操作后，并不是修改原来字符串变成\"hello world\"，而是完全分配新的内存空间，把\"hello world\"存进去，然后修改s指向这块内存空间。\n\n因为string的不可修改，所以substring可以和原来的string共享内存空间。\n\n### 3.5.1 String Literals\n\n- 用双引号，例如\"hello world\"\n- 用\\来做转义\n\nGO还提供\\`...\\`来作为raw string literal的声明，即里面的转义字符像\\，换行都不会特殊处理，所以，可以放到多行。一般可以放\\等特别多的字符串。\n\n### 3.5.2 Unicode\n\nUnicode是为了解决各国文字无法在ASCII表示出来的困境，Unicode也分为多种\n\n- UTF-32，每个Unicode字符都采用32位存储\n- UTF-8，每个Unicode字符的存储空间不定，采用前缀的方式来区分\n\n### 3.5.3 UTF-8\n\nUTF-32的缺点有\n\n- 对于普通的ASCII也要采用32位存储，不兼容\n- 对于常用的65536个Unicode字符，其实用16位就行，32位会浪费大量的存储空间\n\nGO里面有专门的package`unicode/utf8`来处理UTF-8格式的编解码等。\n\n## 3.6 Constants\n\nconst类型的语义是在运行期间，变量的值不会发生变化。const可用于boolean，string和number。\n\n### 3.6.1 The Constant Genrator itoa\n\n和C不同的是，const默认的是和上一个值相同，例如\n\n```go\nconst (\n    a = 1\n    b\n    c\n)\n```\n此时，b和c都是为1。\n\nGO里边提供itoa来实现C中enum值自增的方法，如下\n\n```go\ntype Weekday int\nconst (\n    Sunday Weekday = itoa\n    MOnday\n    Tuesday\n    Wednesday\n    Thursday\n    Friday\n    Saturday\n)\n```\n\n上面定义中，Sunday为0，Monday为1，以此类推。\n\n还有如下用法\n\n```go\ntype Flags uint\n\nconst (\n    FlagUp flags = 1 << itoa\n    FlagBroadcast\n    FlagLoopback\n    FlagPointToPoint\n    FlagMulticast\n)\n```\n当itoa递增时，每个const会赋值成`1 << itoa`对应的值。\n\n更有趣的有\n\n```go\nconst (\n\t_ = 1 << (10 * itoa)\n    KiB //1024\n    MiB //1048576\n    GiB //1073741824\n    TiB\n    PiB\n    EiB\n    ZiB\n    YiB\n)\n```\n\n### 3.6.2 Untyped Constants\n\nuntyped const可以不绑定到特定的类型，这样的const一般至少有256位的精度，所以，可以参与更高精度的计算。在赋值的时候，untyped const会隐式的转换到对应的类型，例如\n\n```go\nvar x float32 = math.Pi //untyped const\nvar y float64 = math.Pi\nvar z complex128 = math.Pi\n\nconst Pi64 float64 = math.Pi\nvar x float32 = float32(Pi64) //需要转类型转成，因为不是untyped const\nvar y float64 = Pi64\nvar z complex128 = complex128(Pi64)\n```\n共有六种类型的untyped const，分别是untyped boolean，untyped integer，untyped rune，untyped rune，untyped floating-point，untyped complex和untyped string。\n\n例如，true和false是untyped boolean，字符串常量是untyped string。\n\n```go\nvar f float64 = 3 + 0i  //untyped complex -> float64\nf = 2                   //untyped integer -> float64\nf = 1e123\t\t\t\t//untyped floating-point -> float64\nf = 'a'\t\t\t\t\t//untyped rune -> float64\n```\n这种隐式的转换需要左边的变量能表示右边的值，有些情况是不能转换的，如下\n\n```go\nconst (\n    deadbeef = 0Xdeadbeef\n    a = uint32(deadbeef) // uint32 with value 3735928559\n    b = float32(deadbeef) // float32 with value \n    d = int32(deadbeef) // compile error: overflow\n    e = float64(1e309) //compile error: const overflows float64\n    f = uint(-1) //compile error: const underflows uint\n)\n```\n\n在变量声明中，如果没有指定类型，会由untyped const来隐式地决定类型\n\n```go\ni := 0  //integer\nr := '\\000' //rune\nf := 0.0 //float64\nc := 0i //complex128\n```\n\n# 4. Composite Types\n\n本章讨论了array，slice，map和struct四种类型，其中array和struct是集合类型，其包含的字节大小数量是固定的；相反，slice和map是动态的，当有新的元素加入时，大小会增加。\n\n## 4.1 Arrays\n\narray是固定大小的，包含0个或多个元素，其中内置`len`函数可以求array的元素个数。\n\n```go\nvar a [3]int // 0, 0, 0\nfmt.Println(a[0]) //print a[0]\nfmt.Println(a[len(a)-1]) //print the last element\n\nfor i, v := range a {\n\tfmt.Println(\"%d %d\\n\", i, v)\n}\nfor _, v := range a {\n\tfmt.Printf(\"%d\", v)\n}\n```\n\narray中的元素默认初始化为zero value。\n\n可以用`...`来根据初始化元素个数来自动确定array的元素个数\n\n```go\nq := [...]int{1, 2, 3}\nfmt.Println(\"%T\\n\", q) // \"[3]int\"\n```\n\narray的元素个数也是包含在类型信息中的，因此`[3]int`和`[4]int`是不同的类型，array声明时候指定的个数必须是const表达式，在编译期间就能确定其值。\n\n可以通过下表初始化指定的下表的值，例如\n\n```go\nr := [...]int{99:-1}\n```\n\n这条语句就最后一个元素声明为-1，前99个元素为默认的0。\n\n如果array的元素是可比较的，那么array是可比较的，并且只有同类型的array才能比较，其中类型包含size信息。\n\n```go\na := [2]int{1, 2}\nb := [...]int{1, 2}\nc := [3]int{1, 2, 3}\nfmt.Println(a == b) // true\nfmt.Println(a == c) // compile error\n```\n在GO中，array作为函数参数是传值的，即会将array拷贝给函数参数，然后函数内部修改不会改变原来的array，例如\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar a [3]int = [3]int{1, 2, 3}\n\tadd(a)\n\tfor _, v := range a {\n\t\tfmt.Println(v)\n\t}\n}\n\nfunc add(a [3]int) {\n\ta[0] += 1\n\ta[1] += 1\n\ta[2] += 1\n\tfor _, v := range a {\n\t\tfmt.Println(v)\n\t}\n}\n\n```\n如果需要修改array元素的值，则必须通过array的指针来完成。\n\narray的缺点：\n1. 大小是固定的，不可删除或增加元素\n2. 修改内部的值必须通过指针操作，比较麻烦\n\n因此，在GO中，大部分时间都会用slice。\n\n## 4.2 Slices\n\nslice是可变长度的串，一般写成`[]T`,其中元素的类型是`T`。\n\nslice可以表示一个array的子串。通常，slice包含三个组件：pointer，length和capacity，其中pointer指向第一个元素，length表示slice的元素个数，capacity表示slice的长度限制。内置的`len`和`cap`可以获取slice的length和capacity。\n\n多个slice可以共享底层的array，slice指向底层的array，如果把slice传递给函数参数，那么是可以达到修改底层array元素的目的的，例如\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\ta := [...]int{0, 1, 2, 3, 4, 5}\n\treverse(a[:])\n\tfmt.Println(a)\n}\n\nfunc reverse(a []int) {\n\tfor i, j := 0, len(a)-1; i < j; i, j = i+1, j-1 {\n\t\ta[i], a[j] = a[j], a[i]\n\t}\n}\n\ncharles@Charles-PC:~/code/go/bin$ ./slice \n[5 4 3 2 1 0]\n```\n创建slice的时候，不需要指定元素的个数，初始化的时候，隐式的创建了一个array，并把slice指向它。对于slice来讲，它互相是**不可比较的**。\n\n因为slice会随着底层array的元素值变化而变化，因此，对于slice来讲，不能作为map的key。**建议禁止slice之间的比较**,最多只能让slice和nil做比较，如下\n\n```go\nvar s[] int //len(s) == 0, s == nil\ns = nil //len(s) == 0, s == nil\ns = []int(nil) //len(s) == 0, s == nil\ns = []int{} //len(s) == 0, s != nil\n```\n判断slice是否为空，应该用`len(s) == 0`来判断。除了判断是否为空，其他情况下nil和空的slice表现一致，因此reverse(nil)是可以正常工作的。\n\n内置的make函数，可以指定type，length和capacity，如下\n\n```go\nmake([]T, len)\nmake([]T, len ,cap)\n```\n在实现中，make也是创建一个array，然后返回一个指向它的引用。第一种make下，len就包含了整个array；第二中make，只有cap才能包含整个array。\n\n### 4.2.1 The append function\n\n内置的append函数可以添加元素到slice，为了更好的理解append是如何工作的，实现一个特殊化的appendInt函数来说明。\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc appendInt(x []int, y int) []int {\n\tvar z []int\n\tzlen := len(x) + 1\n\tif zlen <= cap(x) {\n\t\tz = x[:zlen]\n\t} else {\n\t\tzcap := zlen\n\t\tif zcap < 2*len(x) {\n\t\t\tzcap = 2 * len(x)\n\t\t}\n\t\tz = make([]int, zlen, zcap)\n\t\tcopy(z, x)\n\t}\n\tz[len(x)] = y\n\treturn z\n}\n\nfunc main() {\n\tvar x []int\n\tfor i := 0; i < 20; i++ {\n\t\tx = appendInt(x, i)\n\t\tfmt.Println(x, len(x), cap(x))\n\t}\n}\n\n```\n\n像appendInt一样，内置的append函数也可能按照既定的策略重新分配内存，所以，我们不能假设append之后，slice的内存地址没有发生变化，因此，每次append都要将append的返回值赋值给slice。\n\n不仅仅是append，任何改变slice的len或者cap值的函数，或者把它指向新的underlying-array的，都需要重新赋值。\n\nslice的内部定义像下面的结构体\n\n```go\ntype IntSlice struct {\n\tptr *int\n    len, cap int\n}\n```\n每次要改变slice的值，都必须要显式的赋值\n\n内置的append还可以一次性的追加多个元素。\n\n### 4.2.2 In-Place Slice Techniques\n\n在本地修改slice，避免重新分配underlying-array。\n\n本节以几个例子说明，第一个是nonempty，字符串列表中，返回非空的字符串列表。\n\n```go\nfunc nonempty(strings []string) []string {\n\ti := 0\n    for _, s := range string {\n    \tif s != \"\" {\n        \tstrings[i] = s\n            i++\n        }\n    }\n}\n\nfunc nonempty2(strings []string) []string {\n\tout := strings[:0]\n    for _, s := range strings {\n    \tif s ！= “” {\n        \tout = append(out, s)\n        }\n    }\n}\n```\n\n还可以用append来实现一个stack\n\n```go\nstack = append(stack, v) //push\ntop := stack[len(stack) - 1] // top of stack\nstack = stack[:len(stack)-1] // pop\n```\n\n从字符串列表中间删掉一个字符串\n\n```go\nfunc remove(slice []int, i int) []int {\n\tcopy(slice[i:], slice[i+1:])\n    return slice[:len(slice)-1]\n}\n\nfunc main() {\n\ts := int {5, 6, 7, 8, 9}\n    fmt.Println(remove(s, 2)) //[5, 6, 8, 9]\n}\n```\n\n## 4.3 Maps\n\n在Go中，map是hash table的引用，map类型写成map[K]V，对于K，需要能使用==进行比较。\n\nmap的创建方式\n\n```go\nages := make(map[string]int)\nages[\"alice\"] = 31\nages[\"charlie\"] = 34\n\nages := map[string]int {\n\t\"alice\" : 31,\n    \"charlie\": 34,\n}\n```\nmap元素的访问和删除\n\n```go\nages[\"alice\"] = 32 // access\ndelete(ages, \"alice\") //delete\n```\n访问不在map中的key，会返回zero value。注意，map不是变量，所以不能对其元素进行取地址，原因是hash table可能会动态变化，导致原来的地址失效。\n\nmap的遍历\n\n```go\nfor name, age := range ages {\n\tfmt.Println(\"%s:%d\", name, age)\n}\n```\nmap的遍历的顺序是随机的，所以，我们不能假设它按照某个特定的顺序来遍历。\n\nmap的zero value是nil，即没有引用任何的hash table。\n\n```go\nvar ages map[string] int\nfmt.Println(ages == nil)\nfmt.Println(len(ages) == 0)\n```\n\n对于nil的map，delete，len和range都可以正常的工作，但是，往里面存数据就会panic。\n\n```go\nvar ages map[string] int\nages[\"carol\"] = 21 // panic\n```\n有时候，需要判断某个key是否存在map中，需要使用下面的测试\n\n```go\nage, ok := ages[\"bob\"]\nif !ok {\n\t//不存在\n}\n```\n\nmap不能比较，需要自己写函数遍历key来依次比较。\n\nGO语言中没有set，可以用map[string]bool来代替。\n\n有时候，我们希望slice作为key，但是slice类型是不能比较的，需要自己写函数，例如\n\n```go\n\nvar m = make(map[string]int)\nfunc k(list []string) string {return fmt.Sprintf(\"%q\", list)}\nfunc Add(list []string) {m[k(list)]++}\nfunc Count(list []string) int {return m[k(list)]}\n```\n\n对于其他不可比较的类型，也可以采用本方法，并且k(x)不一定要是string，可以计算成任何可以比较的类型。\n\n## 4.4 Structs\n\nstruct把0个或多个类型聚合在一起，每个都叫做field，例如\n\n```go\ntype Employee struct {\n\tID int\n    Name string\n    Address string\n    DoB time.Time\n    Position string\n    Salary int\n    ManagerID int\n}\nvar dillbert Employee\ndilbert.Salary = 5000\n```\n可以用`.`来访问struct里面的变量，值得说明的是，指针也能用`.`访问内部的field。\n\n```go\nvar employOfTheMonth *employee = &dilbert\nemployOfTheMonth.Postion += \"(proactive team player)\"\n```\n上面的指针访问等价于\n\n```go\n(*employeeOfTheMonth).Position += \"(proactive team player)\"\n```\nfield的顺序和类型关系很大，如果改变了它们的位置，就是另一种类型了。\n\nstruct中的field如果是大写的话，那么是export的，否则不是。\n\nstruct中不能定义自身，但是可以定义自身的指针，例如\n\n```go\ntype tree struct {\n\tvalue int\n    left, right *tree\n}\n```\nstruct的zero value是其中所有的field都是zero value。\n\nstruct中如果没有field，则是empty struct，写成`struct {}`。\n\n### 4.4.1 Struct Literals\n\nstruct literal有两种，如下\n\n```go\ntype Point struct {X, Y int}\np := Point{1, 2}\np := Point{X : 1}\n```\n如果struct不是export的，则不可以在package外声明它\n\n```go\npackage p\ntype T struct {a, b int}\n\npackage q\nimport \"p\"\nvar _ = p.T{a : 1, b : 2} //compile error\nvar _ = p.T{1, 2} // compile error\n```\n尽管最后一行没有使用unexported的field，但是它隐式地使用它们了。\n\nstruct作为函数参数是值传递的，如果是大的struct，最好使用指针来传递，这样可以提升效率。\n\n因为struct经常使用指针所以可以用如下声明\n\n```go\npp ：= &Point{1, 2}\n\npp := new(Point)\n*pp = Point{1, 2}\n```\n### 4.4.2 Comparing Structs\n\n当struct的所有field都可以比较时，则struct本身也是可比较的。\n\n### 4.4.3 Struct Embedding and Anonymous Fields\n\n通过在struct内部定义匿名的struct，可以快速访问到底层struct的field，如下\n\n```go\ntype Point struct {\n\tX, Y int\n}\ntype Circle struct {\n\tCenter Point\n    Radius int\n}\ntype Wheel struct {\n\tC Circle\n    Spokes int\n}\n\nvar w Wheel\nw.C.Center.X = 8\n```\n可以看出，从Wheel变量中，要访问Point的X需要使用三个`.`，书写效率比较低，可以使用以下方式解决\n\n```go\ntype Circle struct {\n\tPoint\n    Radius int\n}\ntype Wheel struct {\n\tCircle\n    Spokes int\n}\nvar w Wheel\nw.X = 8\nw.Y = 8\nw.Radius = 9\n```\n使用上述方法可以快速访问到内部结构体中的field，但是这种方式对于struct literal是不行的\n\n```go\nw = Wheel {8, 8, 5, 20} //compile error\nw = Wheel {X : 8, Y : 8, Radius: 5, Spokes: 20} //compile error\nw = Wheel {Circle{Point{8, 8}, 5}, 20}\n\nw = Wheel {\n\tCircle : Circle {\n    \tPoint : Point {X:8, Y:8}\n        Radius : 5\n    },\n    Spokes: 20\n}\n```\n匿名的同类型的struct，只能出现在一个struct内一次，否则无法区分它们。\n\n## 4.5 JSON\n\nJSON是 JavaScript Object Notation的缩写。GO的标准库中有`encoding/json`来处理JSON格式，本节就是关于这个package相关的知识。\n\nJSON中基础类型包括numbers(decimal或scientific notation)，booleans(true or false)和strings。\n\nJSON有array和object，array以方括号扩起来，并且逗号分割的一系列元素；object是string到value的mapping， 例如\n\n```go\nboolean true\nnumber -273.15\nstring \"she said hello world\"\narray [\"gold\", \"siliver\"]\nobject {\"year\" : 1980,\n\t\t\"event\": \"archery\",\n        \"medals\": [\"gold\", \"silver\"]}\n```\n\nJSON的array可以用来编码GO的array和slice；而JSON的object可以用来编码GO的map(string作为key)和struct(不明白怎么编码？)。\n\n由GO数据结构转换成JSON的过程称为marshaling，通过`json.Marshal`函数实现，如下\n\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n)\n\ntype Movie struct {\n\tTitle  string\n\tYear   int  `json:“released”`\n\tColor  bool `json:\"color,omitempty\"`\n\tActors []string\n}\n\nfunc main() {\n\tvar movies = []Movie{\n\t\t{Title: \"Casablana\", Year: 1942, Color: false, Actors: []string{\"A\", \"B\"}},\n\t\t{Title: \"Casablana2\", Year: 1943, Color: true, Actors: []string{\"A\", \"B\"}},\n\t}\n\tdata, err := json.Marshal(movies)\n\n\tif err != nil {\n\t\tlog.Fatalf(\"JSON Marshaling failed: %s\", err)\n\t}\n\tfmt.Printf(\"%s\\n\", data)\n}\n\ncharles@Charles-PC:~/code/go$ bin/json \n[{\"Title\":\"Casablana\",\"released\":1942,\"Actors\":[\"A\",\"B\"]},{\"Title\":\"Casablana2\",\"released\":1943,\"color\":true,\"Actors\":[\"A\",\"B\"]}]\n\n```\n上面的字符串如果多了的话，可读性不是很强，可以用`MarshalIndent`来生成一个可读性较强的。\n\nGO只会对exported的field做Marshal。从上面的输出可以看出，Year转成了released的输出，Color转换成color，并且在为false的时候，不输出，这都是由它们字段后面的json标记控制的。\n\nMarshaling的反操作为unmarshaling，即把JSON结构转成GO的结构体，通过`json.Unmarshal`来实现。Unmarshaling的时候，可以选择需要的字段来做解码，如下\n\n```go\nvar titles []struct{Title string}\nif err := json.Unmarshal(data, &title); err != nil {\n\tlog.Fatalf(\"JSON unmarshaling failed:%s\", err)\n}\nfmt.Println(titles)\n```\n如上所示，只会把Title字段解析出来，其余字段会被略去。\n\n## 4.6 Text and HTML Templates\n\n除了简单的Printf外，GO还提供了强大的模板库，例如`text/template`和`html/template`，模板库本身有自己的语言规则，例如，一个简单的例子为\n\n```go\nconst templ = `{{.TotalCount}} issues:\n{{range.Items}}----------------------------------\nNumber : {{.Number}}\nUser : {{.User.Login}}\nTitle : {{.Title | printf \".64s\"}\nAge : {{.CreateAT | daysAgo}} days\n{{end}}\n\nfunction daysAgo(t time.Time) int {\n\treturn int(time.Since(t).Hours() / 24)\n}\n```\n上面的range和end，表示中间是一个循环。 `.CreateAT | daysAgo`表示讲CreateAT作为参数传入daysAgo函数处理。\n\n产生输出需要两个步骤\n\n1. 解析模板\n2. 在特定输入下执行模板\n\n解析模板只需要做一次，后面就可以无限制地执行模板，具体的例子如下\n\n```go\nvar report = template.Must(template.New(\"issue-list\")).Funcs(template.FuncMap{\"daysAgo\": daysAgo}).Parse(templ)\n\nfunc main() {\n\tresult, err := github.SearchIssues(os.Args[1:])\n    if err != nil {\n    \tlog.Fatal(err)\n    }\n    if err := report.Execute(os.Stdout, result); err ！= nil {\n    \tlog.Fatal(err)\n    }\n}\n```\n上面的是Text模板，HTML模板与之不同的是，里面可以写HTML标签，它会输入的动态数据做自动的转义，防止JS注入等攻击，例子如下\n\n```go\nimport \"html/template\"\n\nvar issueList = template.Must(template.New(\"issuelist\").Parse(`\n<h1>{{.TotalCount}} issues</h1>\n<table>\n<tr style='text-align: left'>\n  <th>#</th>\n  <th>State</th>\n  <th>User</th>\n  <th>Title</th>\n</tr>\n{{range .Items}}\n<tr>\n  <td><a href='{{.HTMLURL}}'>{{.Number}}</a></td>\n  <td>{{.State}}</td>\n  <td><a href='{{.User.HTMLURL}}'>{{.User.Login}}</a></td>\n  <td><a href='{{.HTMLURL}}'>{{.Title}}</a></td>\n</tr>\n{{end}}\n</table>\n`))\n\n//!-template\n\n//!+\nfunc main() {\n\tresult, err := github.SearchIssues(os.Args[1:])\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tif err := issueList.Execute(os.Stdout, result); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n\n```\n\n\n\n","slug":"golang","published":1,"updated":"2018-02-23T07:53:34.604Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdzqngr7000248kchfztmwiw","content":"<h1 id=\"1-Introduction\"><a href=\"#1-Introduction\" class=\"headerlink\" title=\"1. Introduction\"></a>1. Introduction</h1><p>本文是学习The go programming language的总结的第一部分，全文的组织结构如下：</p>\n<ul>\n<li>Program Structure</li>\n<li>Basic Data Types</li>\n<li>Composite Types</li>\n</ul>\n<a id=\"more\"></a>\n<h1 id=\"2-Program-Structure\"><a href=\"#2-Program-Structure\" class=\"headerlink\" title=\"2. Program Structure\"></a>2. Program Structure</h1><h2 id=\"2-1-Names\"><a href=\"#2-1-Names\" class=\"headerlink\" title=\"2.1 Names\"></a>2.1 Names</h2><ul>\n<li>合法的命令为以字母为下划线开头，并且除关键字外的字符串（GO对大小写敏感）</li>\n<li>如果一个命令定义在函数外面，并且它的首字母是大写的，那么它可以被package外的代码访问到；如果定义在函数外部，但首字母是小写，那么能被package内部访问到</li>\n<li>GO推荐用驼峰命名法来命名，即parseRequestLine是推荐的，但parse_request_line是不推荐的</li>\n<li>缩写的名称，一般全用大写，例如ASCII、HTML等</li>\n</ul>\n<h2 id=\"2-2-Declarations\"><a href=\"#2-2-Declarations\" class=\"headerlink\" title=\"2.2 Declarations\"></a>2.2 Declarations</h2><p>以一个例子来说明</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> boilingF = <span class=\"number\">212.0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> f = boilingF;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> c = (f - <span class=\"number\">32</span>) * <span class=\"number\">5</span> / <span class=\"number\">9</span>;</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"boiling point = %g F or %g C\"</span>, f, c);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>常量boilingF是package级别的定义</li>\n<li>变量f和c是本地变量，属于函数main内部</li>\n<li>函数的定义为函数名+参数列表+返回值，main函数把后两者省略掉了</li>\n</ul>\n<h2 id=\"2-3-Variables\"><a href=\"#2-3-Variables\" class=\"headerlink\" title=\"2.3 Variables\"></a>2.3 Variables</h2><p>变量的声明形式为</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name <span class=\"keyword\">type</span> = expression</span><br></pre></td></tr></table></figure>\n<ul>\n<li>如果type被省略，那么根据expression字段的类型推断出来</li>\n<li>如果expression被省略，那么初始化成zero value,对于numbers为0，对于boolean为false，对于strings为空，对于interface和reference type(slice，pointer，map，channel，function）为nil。</li>\n</ul>\n<p>可以在一条语句中声明多个变量</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> i, j, k <span class=\"keyword\">int</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> b, f, s = <span class=\"literal\">true</span>, <span class=\"number\">2.3</span>, <span class=\"string\">\"four</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2-3-1-Short-Variable-Declarations\"><a href=\"#2-3-1-Short-Variable-Declarations\" class=\"headerlink\" title=\"2.3.1 Short Variable Declarations\"></a>2.3.1 Short Variable Declarations</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name := expression</span><br></pre></td></tr></table></figure>\n<p>会以expression的type来推断name的type，并且以expression初始化name</p>\n<p>大部分的局部变量会用Short Variable Declaration方式来定义，两种情况除外</p>\n<ul>\n<li>声明的变量的类型和初始化的expression不一致，用var显式地声明</li>\n<li>声明的时候不需要初始化，后续会赋值</li>\n</ul>\n<p><code>:=</code>和<code>=</code>的区别是，前者是声明，后者是赋值</p>\n<p>在<code>:=</code>语句中，不用声明所有的变量，如果有变量已经声明过，就相当于转成了赋值操作，但是，必须至少有一个变量没有声明过，因为<code>:=</code>语句要求至少新声明一个变量。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//声明了out变量，err是赋值</span></span><br><span class=\"line\">in ,err := os.Open(infile)</span><br><span class=\"line\">out, err := os.Create(outfile)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//编译错误，第二个语句没有新声明任何的变量</span></span><br><span class=\"line\">f, err := os.Open(infile)</span><br><span class=\"line\">f, err := os.Create(outfile)</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-3-2-Pointers\"><a href=\"#2-3-2-Pointers\" class=\"headerlink\" title=\"2.3.2 Pointers\"></a>2.3.2 Pointers</h3><p>pointer存储的是变量的地址，可以通过pointer来间接的更新变量的值。</p>\n<p><strong>简单例子</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x := <span class=\"number\">1</span></span><br><span class=\"line\">p := &amp;x</span><br><span class=\"line\">fmt.Println(*p) <span class=\"comment\">//1</span></span><br><span class=\"line\">*p = <span class=\"number\">2</span></span><br><span class=\"line\">fmt.Println(x)  <span class=\"comment\">//2</span></span><br></pre></td></tr></table></figure>\n<p><strong>局部变量返回成指针也是安全的</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p = f()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f</span><span class=\"params\">()</span> *<span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\tv := <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;v</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>和C不一样，在GO中这是合法的，v在函数返回后继续存在。</p>\n<h3 id=\"2-3-3-The-new-function\"><a href=\"#2-3-3-The-new-function\" class=\"headerlink\" title=\"2.3.3 The new function\"></a>2.3.3 The <em>new</em> function</h3><p>new返回的也是指针，例如<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p := <span class=\"built_in\">new</span>(<span class=\"keyword\">int</span>)</span><br><span class=\"line\">fmt.Println(*p)</span><br><span class=\"line\">*p = <span class=\"number\">2</span></span><br><span class=\"line\">fmt.Println(*p)</span><br></pre></td></tr></table></figure></p>\n<p>下面两个函数是等价的，即new和普通的局部变量区别不大</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newInt</span><span class=\"params\">()</span> *<span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">new</span>(<span class=\"keyword\">int</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newInt</span><span class=\"params\">()</span> *<span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> dummpy</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;dummpy</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一般来说，new创建出来的变量地址是不同的，但是，有可能struct {} 这样的空结构体，地址是相同的，取决于编译器的实现。</p>\n<h3 id=\"2-3-4-Lifetime-of-Variables\"><a href=\"#2-3-4-Lifetime-of-Variables\" class=\"headerlink\" title=\"2.3.4 Lifetime of Variables\"></a>2.3.4 Lifetime of Variables</h3><ul>\n<li>package级别的变量，生命周期是整个程序运行期间</li>\n<li>局部变量是在声明语句开始后，到变量已经无法使用（即没有符号引用它，包括变量名或者指针）</li>\n</ul>\n<p>局部变量既可能在heap上创建，也可能在stack上创建，和是否用new无关</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> global *<span class=\"keyword\">int</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> x <span class=\"keyword\">int</span></span><br><span class=\"line\">    x = <span class=\"number\">1</span></span><br><span class=\"line\">    global = &amp;x</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">g</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\ty := <span class=\"built_in\">new</span>(<span class=\"keyword\">int</span>)</span><br><span class=\"line\">    *y = <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>x是在heap上创建的，因为一直被global引用，而y是stack创建，因为出了函数后，就没有使用了。</p>\n<p>GO的垃圾回收就是通过判断变量是否还被符号引用来做的，如果没有符号引用了，即表明可以回收这块的内存空间。</p>\n<h2 id=\"2-4-Assignment\"><a href=\"#2-4-Assignment\" class=\"headerlink\" title=\"2.4 Assignment\"></a>2.4 Assignment</h2><p>赋值语句会让变量的值更新，例如</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = <span class=\"number\">1</span></span><br><span class=\"line\">*p = <span class=\"literal\">true</span></span><br><span class=\"line\">person.name = <span class=\"string\">\"bob\"</span></span><br><span class=\"line\">count[x] = count[x] * scale</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-4-1-Tuple-Assignment\"><a href=\"#2-4-1-Tuple-Assignment\" class=\"headerlink\" title=\"2.4.1 Tuple Assignment\"></a>2.4.1 Tuple Assignment</h3><p>元组赋值例子如下</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x, y = y, x</span><br></pre></td></tr></table></figure>\n<p>有些操作，会返回多个值，可以使用元组操作，例如</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">v, ok = m[key]</span><br><span class=\"line\">v, ok = x.(T)</span><br><span class=\"line\">v, ok = &lt;-ch</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-4-2-Assignability\"><a href=\"#2-4-2-Assignability\" class=\"headerlink\" title=\"2.4.2 Assignability\"></a>2.4.2 Assignability</h3><p>赋值操作的左右类型必须是一致的；nil可用于interface和reference type的赋值</p>\n<h2 id=\"2-5-Type-Declarations\"><a href=\"#2-5-Type-Declarations\" class=\"headerlink\" title=\"2.5 Type Declarations\"></a>2.5 Type Declarations</h2><p>定义type的形式如下<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> name underlying-<span class=\"keyword\">type</span></span><br></pre></td></tr></table></figure></p>\n<p>type和underlying-type之间是不能直接赋值的，因为它们不是相同的类型。</p>\n<p>比较运算符可以用来比较相同的type，或者type和underlying-type，但是不能用于比较named type，例如</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Celsius <span class=\"keyword\">float64</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Fahrenheit <span class=\"keyword\">float64</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> c Celsius</span><br><span class=\"line\"><span class=\"keyword\">var</span> f Fahrenheit</span><br><span class=\"line\">c == <span class=\"number\">0</span> <span class=\"comment\">//true</span></span><br><span class=\"line\">f &gt;=<span class=\"number\">0</span> <span class=\"comment\">//true</span></span><br><span class=\"line\">c == f <span class=\"comment\">//compile error</span></span><br></pre></td></tr></table></figure>\n<p>c和f不能直接比较，两个都属于named type。</p>\n<h2 id=\"2-6-Package-and-Files\"><a href=\"#2-6-Package-and-Files\" class=\"headerlink\" title=\"2.6 Package and Files\"></a>2.6 Package and Files</h2><p>每个package相当于独立的命名空间，一般在同一个目录下的一个或多个文件可以组成一个package。</p>\n<p>例如，对于package <code>gopl.io/ch1/helloworld</code>对应的path是<code>$GOPATH/src/gopl.io/ch1/helloworld</code>。</p>\n<p>以一个例子来说明，例如，我们需要建立一个温度转换的package，名字为<code>gopl.io/ch2/tempconv</code></p>\n<p>有两个文件，分别是<code>tempconv.go</code>和<code>conv.go</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> tempconv</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Celsius <span class=\"keyword\">float64</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Fahrenheit <span class=\"keyword\">float64</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">\tAbsoluteZeroC Celsius = <span class=\"number\">-273.15</span></span><br><span class=\"line\">    FreezingC Celsius = <span class=\"number\">0</span></span><br><span class=\"line\">    BoilingC Celsius = <span class=\"number\">100</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(C Celsius)</span> <span class=\"title\">String</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">\tfmt.Sprintf(<span class=\"string\">\"%gC\"</span>, c)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f Fahrenheit)</span> <span class=\"title\">String</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%gF\"</span>, f)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> tempconv</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">CToF</span><span class=\"params\">(c Celsius)</span> <span class=\"title\">Fahrenheit</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> Fahrenheit(c * <span class=\"number\">9</span> / <span class=\"number\">5</span> + <span class=\"number\">32</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">FToC</span><span class=\"params\">(f Fahrenheit)</span> <span class=\"title\">Celsius</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> Celsius((f - <span class=\"number\">32</span>) * <span class=\"number\">5</span> / <span class=\"number\">9</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>package中以大写开头的全局变量或函数都能被外部调用到。</p>\n<h3 id=\"2-6-1-Imports\"><a href=\"#2-6-1-Imports\" class=\"headerlink\" title=\"2.6.1 Imports\"></a>2.6.1 Imports</h3><p>以import语句来导入package，例如</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">    <span class=\"string\">\"os\"</span></span><br><span class=\"line\">    <span class=\"string\">\"strconv\"</span></span><br><span class=\"line\">    <span class=\"string\">\"gopl.io/ch2/tempconv\"</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>在GO里面，如果导入一个package，但是没有引用，会报编译错误。</p>\n<p>有<code>golang.org/x/tools/cmd/goimports</code>工具，可以自动的插入和删除需要的package。</p>\n<h3 id=\"2-6-2-Package-Initialization\"><a href=\"#2-6-2-Package-Initialization\" class=\"headerlink\" title=\"2.6.2 Package Initialization\"></a>2.6.2 Package Initialization</h3><p>package初始化会按照变量声明的顺序初始化。如果对于一些比较复杂的数据结构，可能仅仅通过初始化语句无法完成初始化，这时候可以把初始化操作放到init函数中，init函数会自动的被执行。</p>\n<p>package初始化之前，会先把要导入的package初始化。对于package main会在最后初始化，可以保证在main函数执行之前，其他package已经完成初始化了。</p>\n<h2 id=\"2-7-Scope\"><a href=\"#2-7-Scope\" class=\"headerlink\" title=\"2.7 Scope\"></a>2.7 Scope</h2><p>Scope代表变量的声明在程序哪个位置，而lifetime则表示变量在程序执行的可以被引用的时间段。前者是编译时期的特性，而后者是运行时的特性。</p>\n<p>Scope一般包括universe，package，file和function。</p>\n<ul>\n<li>内置类型，函数，常量为universe level</li>\n<li>定义在函数外，可以被相同package的任意file引用，称为package level</li>\n<li>通过文件中import过，例如 import fmt，则fmt的函数在本文件都是可用的，称为file level</li>\n<li>函数内部的定义，只有函数内部应用，则为function level</li>\n</ul>\n<p>和C一样，范围越小的变量会隐藏范围大的变量。</p>\n<p><strong>for语句</strong></p>\n<p>for定义了两个block</p>\n<ul>\n<li>显式的block，用{}包起来</li>\n<li>隐式的block，如初始化中的变量，范围是for循环条件，自增以及显式的block内</li>\n</ul>\n<p><strong>if语句</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> x := f(); x == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\tfmt.Println(x)</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> y := g(x); x == y &#123;</span><br><span class=\"line\">\tfmt.Println(x, y)</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\tfmt.Println(x, y)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fmt.Println(x, y) <span class=\"comment\">//compile error: x和y在这里不可见</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> f, err := os.Open(fname),; err != <span class=\"literal\">nil</span> &#123; <span class=\"comment\">//complie error: unused f</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f.ReadByte() <span class=\"comment\">//compile error: undefined f</span></span><br><span class=\"line\">f.Close() <span class=\"comment\">// compile error: undefined f</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"3-Basic-Data-Types\"><a href=\"#3-Basic-Data-Types\" class=\"headerlink\" title=\"3. Basic Data Types\"></a>3. Basic Data Types</h1><p>GO的Data Type有四大类：basic types，aggregate types，reference types和interface types。Basic types包括numbers，strings和booleans；Aggregate types包括array和struct；Reference types包括pointers，slices，maps，functions和channels。</p>\n<h2 id=\"3-1-Integers\"><a href=\"#3-1-Integers\" class=\"headerlink\" title=\"3.1 Integers\"></a>3.1 Integers</h2><p>GO的numbers类型包括integers，floating-point numbers和complex numbers。</p>\n<p>对于integers，有四种有符号整数和四种无符号整数。</p>\n<ul>\n<li>int8, int16, int32和int64</li>\n<li>uint8, uint16, uint32和uint64</li>\n</ul>\n<p>除了带字节大小的类型之外，还包括int和uint，可能是32bit或者64bit，由编译器决定，编程时不要假定这个大小。</p>\n<p>rune是int32的named type，用来存储单个unicode字符。</p>\n<p>byte是int8的named type。</p>\n<p>uintptr的大小可以存储下系统中任意的内存地址，一般用来和C Library交互的时候。</p>\n<p>采用二进制补码的方式编码，所以对于int8来讲，其范围为[-128, 127]</p>\n<p>操作符的优先级如下</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*\t/\t%\t&lt;&lt;\t&gt;&gt;\t&amp;\t&amp;^</span><br><span class=\"line\">+\t-\t|\t^</span><br><span class=\"line\">==\t！=\t&lt;\t&lt;=\t&gt;\t&gt;=</span><br><span class=\"line\">&amp;&amp;</span><br><span class=\"line\">||</span><br></pre></td></tr></table></figure>\n<p>对于%操作符，符号是跟着被除数走的，例如<code>-5%3</code>和<code>-5%-3</code>的余数都是-2。</p>\n<p>对于算术运算，可能会溢出</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> u <span class=\"keyword\">uint8</span> = <span class=\"number\">255</span></span><br><span class=\"line\">fmt.Println(u, u+<span class=\"number\">1</span>, u*u) <span class=\"comment\">//255 0 1</span></span><br></pre></td></tr></table></figure>\n<p>对于移位操作符</p>\n<ul>\n<li><code>&lt;&lt;</code>不管是有符号数或者无符号数，都是末尾补0</li>\n<li><code>&gt;&gt;</code>对于有符号数，会在左边补符号位，对于无符号数，会在末尾补0</li>\n</ul>\n<p>对于遍历操作，一般用有符号数</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> i <span class=\"keyword\">uint</span> = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> ; i &gt;= <span class=\"number\">0</span>; i-- &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面是个死循环，因为uint一定是大于或等于0的，故遍历的索引一般用有符号数。</p>\n<h2 id=\"3-2-Floating-Point-Numbers\"><a href=\"#3-2-Floating-Point-Numbers\" class=\"headerlink\" title=\"3.2 Floating-Point Numbers\"></a>3.2 Floating-Point Numbers</h2><p>GO提供两种float类型，即float32和float64，采用IEEE 754标准。</p>\n<h2 id=\"3-3-Complex-Numbers\"><a href=\"#3-3-Complex-Numbers\" class=\"headerlink\" title=\"3.3 Complex Numbers\"></a>3.3 Complex Numbers</h2><p>GO提供两种complex类型，即complex64和complex128，底层组件分别用float32和float64。</p>\n<p>使用例子如下</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x <span class=\"keyword\">complex128</span> = <span class=\"built_in\">complex</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>)  <span class=\"comment\">//1 + 2i</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> y <span class=\"keyword\">complex128</span> = <span class=\"built_in\">complex</span>(<span class=\"number\">3</span>, <span class=\"number\">4</span>)  <span class=\"comment\">//3 + 4i</span></span><br><span class=\"line\">fmt.Println(x*y)                  <span class=\"comment\">//-5 + 10i</span></span><br><span class=\"line\">fmt.Println(<span class=\"built_in\">real</span>(x*y))\t\t\t  <span class=\"comment\">//-5</span></span><br><span class=\"line\">fmt.Println(<span class=\"built_in\">imag</span>)(x*y))\t\t\t  <span class=\"comment\">//10</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"3-4-Booleans\"><a href=\"#3-4-Booleans\" class=\"headerlink\" title=\"3.4 Booleans\"></a>3.4 Booleans</h2><p>bool类型的值只有false和true两种。bool类型和number类型之间没有隐式的转换，一般通过如下方式</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">btoi</span><span class=\"params\">(b <span class=\"keyword\">bool</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b &#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">itob</span><span class=\"params\">(i <span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> i != <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-5-Strings\"><a href=\"#3-5-Strings\" class=\"headerlink\" title=\"3.5 Strings\"></a>3.5 Strings</h2><p>内置len函数可以计算string类型的长度。</p>\n<p>substring操作通过s[i:j]，表示从i开始，共j-i个字符，因此，不包括j。</p>\n<p>i的默认值为0，j的默认值为len(s)，因此</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s[:<span class=\"number\">5</span>] = s[<span class=\"number\">0</span>:<span class=\"number\">5</span>]</span><br><span class=\"line\">s[<span class=\"number\">7</span>:] = s[<span class=\"number\">7</span>:<span class=\"built_in\">len</span>(s)]</span><br><span class=\"line\">s[:] = s[<span class=\"number\">0</span>:<span class=\"built_in\">len</span>(s)]</span><br></pre></td></tr></table></figure>\n<p>string类型是不可修改的，例如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = &quot;hello&quot;</span><br><span class=\"line\">s += “world”</span><br><span class=\"line\">s[0] = &apos;L&apos; // compile error</span><br></pre></td></tr></table></figure>\n<p>s开始指向”hello”字符串，执行<code>+=</code>操作后，并不是修改原来字符串变成”hello world”，而是完全分配新的内存空间，把”hello world”存进去，然后修改s指向这块内存空间。</p>\n<p>因为string的不可修改，所以substring可以和原来的string共享内存空间。</p>\n<h3 id=\"3-5-1-String-Literals\"><a href=\"#3-5-1-String-Literals\" class=\"headerlink\" title=\"3.5.1 String Literals\"></a>3.5.1 String Literals</h3><ul>\n<li>用双引号，例如”hello world”</li>\n<li>用\\来做转义</li>\n</ul>\n<p>GO还提供`…`来作为raw string literal的声明，即里面的转义字符像\\，换行都不会特殊处理，所以，可以放到多行。一般可以放\\等特别多的字符串。</p>\n<h3 id=\"3-5-2-Unicode\"><a href=\"#3-5-2-Unicode\" class=\"headerlink\" title=\"3.5.2 Unicode\"></a>3.5.2 Unicode</h3><p>Unicode是为了解决各国文字无法在ASCII表示出来的困境，Unicode也分为多种</p>\n<ul>\n<li>UTF-32，每个Unicode字符都采用32位存储</li>\n<li>UTF-8，每个Unicode字符的存储空间不定，采用前缀的方式来区分</li>\n</ul>\n<h3 id=\"3-5-3-UTF-8\"><a href=\"#3-5-3-UTF-8\" class=\"headerlink\" title=\"3.5.3 UTF-8\"></a>3.5.3 UTF-8</h3><p>UTF-32的缺点有</p>\n<ul>\n<li>对于普通的ASCII也要采用32位存储，不兼容</li>\n<li>对于常用的65536个Unicode字符，其实用16位就行，32位会浪费大量的存储空间</li>\n</ul>\n<p>GO里面有专门的package<code>unicode/utf8</code>来处理UTF-8格式的编解码等。</p>\n<h2 id=\"3-6-Constants\"><a href=\"#3-6-Constants\" class=\"headerlink\" title=\"3.6 Constants\"></a>3.6 Constants</h2><p>const类型的语义是在运行期间，变量的值不会发生变化。const可用于boolean，string和number。</p>\n<h3 id=\"3-6-1-The-Constant-Genrator-itoa\"><a href=\"#3-6-1-The-Constant-Genrator-itoa\" class=\"headerlink\" title=\"3.6.1 The Constant Genrator itoa\"></a>3.6.1 The Constant Genrator itoa</h3><p>和C不同的是，const默认的是和上一个值相同，例如</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">    a = <span class=\"number\">1</span></span><br><span class=\"line\">    b</span><br><span class=\"line\">    c</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>此时，b和c都是为1。</p>\n<p>GO里边提供itoa来实现C中enum值自增的方法，如下</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Weekday <span class=\"keyword\">int</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">    Sunday Weekday = itoa</span><br><span class=\"line\">    MOnday</span><br><span class=\"line\">    Tuesday</span><br><span class=\"line\">    Wednesday</span><br><span class=\"line\">    Thursday</span><br><span class=\"line\">    Friday</span><br><span class=\"line\">    Saturday</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>上面定义中，Sunday为0，Monday为1，以此类推。</p>\n<p>还有如下用法</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Flags <span class=\"keyword\">uint</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">    FlagUp flags = <span class=\"number\">1</span> &lt;&lt; itoa</span><br><span class=\"line\">    FlagBroadcast</span><br><span class=\"line\">    FlagLoopback</span><br><span class=\"line\">    FlagPointToPoint</span><br><span class=\"line\">    FlagMulticast</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>当itoa递增时，每个const会赋值成<code>1 &lt;&lt; itoa</code>对应的值。</p>\n<p>更有趣的有</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">\t_ = <span class=\"number\">1</span> &lt;&lt; (<span class=\"number\">10</span> * itoa)</span><br><span class=\"line\">    KiB <span class=\"comment\">//1024</span></span><br><span class=\"line\">    MiB <span class=\"comment\">//1048576</span></span><br><span class=\"line\">    GiB <span class=\"comment\">//1073741824</span></span><br><span class=\"line\">    TiB</span><br><span class=\"line\">    PiB</span><br><span class=\"line\">    EiB</span><br><span class=\"line\">    ZiB</span><br><span class=\"line\">    YiB</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-6-2-Untyped-Constants\"><a href=\"#3-6-2-Untyped-Constants\" class=\"headerlink\" title=\"3.6.2 Untyped Constants\"></a>3.6.2 Untyped Constants</h3><p>untyped const可以不绑定到特定的类型，这样的const一般至少有256位的精度，所以，可以参与更高精度的计算。在赋值的时候，untyped const会隐式的转换到对应的类型，例如</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x <span class=\"keyword\">float32</span> = math.Pi <span class=\"comment\">//untyped const</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> y <span class=\"keyword\">float64</span> = math.Pi</span><br><span class=\"line\"><span class=\"keyword\">var</span> z <span class=\"keyword\">complex128</span> = math.Pi</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Pi64 <span class=\"keyword\">float64</span> = math.Pi</span><br><span class=\"line\"><span class=\"keyword\">var</span> x <span class=\"keyword\">float32</span> = <span class=\"keyword\">float32</span>(Pi64) <span class=\"comment\">//需要转类型转成，因为不是untyped const</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> y <span class=\"keyword\">float64</span> = Pi64</span><br><span class=\"line\"><span class=\"keyword\">var</span> z <span class=\"keyword\">complex128</span> = <span class=\"keyword\">complex128</span>(Pi64)</span><br></pre></td></tr></table></figure>\n<p>共有六种类型的untyped const，分别是untyped boolean，untyped integer，untyped rune，untyped rune，untyped floating-point，untyped complex和untyped string。</p>\n<p>例如，true和false是untyped boolean，字符串常量是untyped string。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> f <span class=\"keyword\">float64</span> = <span class=\"number\">3</span> + <span class=\"number\">0i</span>  <span class=\"comment\">//untyped complex -&gt; float64</span></span><br><span class=\"line\">f = <span class=\"number\">2</span>                   <span class=\"comment\">//untyped integer -&gt; float64</span></span><br><span class=\"line\">f = <span class=\"number\">1e123</span>\t\t\t\t<span class=\"comment\">//untyped floating-point -&gt; float64</span></span><br><span class=\"line\">f = <span class=\"string\">'a'</span>\t\t\t\t\t<span class=\"comment\">//untyped rune -&gt; float64</span></span><br></pre></td></tr></table></figure>\n<p>这种隐式的转换需要左边的变量能表示右边的值，有些情况是不能转换的，如下</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">    deadbeef = <span class=\"number\">0Xdeadbeef</span></span><br><span class=\"line\">    a = <span class=\"keyword\">uint32</span>(deadbeef) <span class=\"comment\">// uint32 with value 3735928559</span></span><br><span class=\"line\">    b = <span class=\"keyword\">float32</span>(deadbeef) <span class=\"comment\">// float32 with value </span></span><br><span class=\"line\">    d = <span class=\"keyword\">int32</span>(deadbeef) <span class=\"comment\">// compile error: overflow</span></span><br><span class=\"line\">    e = <span class=\"keyword\">float64</span>(<span class=\"number\">1e309</span>) <span class=\"comment\">//compile error: const overflows float64</span></span><br><span class=\"line\">    f = <span class=\"keyword\">uint</span>(<span class=\"number\">-1</span>) <span class=\"comment\">//compile error: const underflows uint</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>在变量声明中，如果没有指定类型，会由untyped const来隐式地决定类型</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i := <span class=\"number\">0</span>  <span class=\"comment\">//integer</span></span><br><span class=\"line\">r := <span class=\"string\">'\\000'</span> <span class=\"comment\">//rune</span></span><br><span class=\"line\">f := <span class=\"number\">0.0</span> <span class=\"comment\">//float64</span></span><br><span class=\"line\">c := <span class=\"number\">0i</span> <span class=\"comment\">//complex128</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"4-Composite-Types\"><a href=\"#4-Composite-Types\" class=\"headerlink\" title=\"4. Composite Types\"></a>4. Composite Types</h1><p>本章讨论了array，slice，map和struct四种类型，其中array和struct是集合类型，其包含的字节大小数量是固定的；相反，slice和map是动态的，当有新的元素加入时，大小会增加。</p>\n<h2 id=\"4-1-Arrays\"><a href=\"#4-1-Arrays\" class=\"headerlink\" title=\"4.1 Arrays\"></a>4.1 Arrays</h2><p>array是固定大小的，包含0个或多个元素，其中内置<code>len</code>函数可以求array的元素个数。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a [<span class=\"number\">3</span>]<span class=\"keyword\">int</span> <span class=\"comment\">// 0, 0, 0</span></span><br><span class=\"line\">fmt.Println(a[<span class=\"number\">0</span>]) <span class=\"comment\">//print a[0]</span></span><br><span class=\"line\">fmt.Println(a[<span class=\"built_in\">len</span>(a)<span class=\"number\">-1</span>]) <span class=\"comment\">//print the last element</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i, v := <span class=\"keyword\">range</span> a &#123;</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">\"%d %d\\n\"</span>, i, v)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> _, v := <span class=\"keyword\">range</span> a &#123;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%d\"</span>, v)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>array中的元素默认初始化为zero value。</p>\n<p>可以用<code>...</code>来根据初始化元素个数来自动确定array的元素个数</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">q := [...]<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;</span><br><span class=\"line\">fmt.Println(<span class=\"string\">\"%T\\n\"</span>, q) <span class=\"comment\">// \"[3]int\"</span></span><br></pre></td></tr></table></figure>\n<p>array的元素个数也是包含在类型信息中的，因此<code>[3]int</code>和<code>[4]int</code>是不同的类型，array声明时候指定的个数必须是const表达式，在编译期间就能确定其值。</p>\n<p>可以通过下表初始化指定的下表的值，例如</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">r := [...]<span class=\"keyword\">int</span>&#123;<span class=\"number\">99</span>:<span class=\"number\">-1</span>&#125;</span><br></pre></td></tr></table></figure>\n<p>这条语句就最后一个元素声明为-1，前99个元素为默认的0。</p>\n<p>如果array的元素是可比较的，那么array是可比较的，并且只有同类型的array才能比较，其中类型包含size信息。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a := [<span class=\"number\">2</span>]<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;</span><br><span class=\"line\">b := [...]<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;</span><br><span class=\"line\">c := [<span class=\"number\">3</span>]<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;</span><br><span class=\"line\">fmt.Println(a == b) <span class=\"comment\">// true</span></span><br><span class=\"line\">fmt.Println(a == c) <span class=\"comment\">// compile error</span></span><br></pre></td></tr></table></figure>\n<p>在GO中，array作为函数参数是传值的，即会将array拷贝给函数参数，然后函数内部修改不会改变原来的array，例如</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> a [<span class=\"number\">3</span>]<span class=\"keyword\">int</span> = [<span class=\"number\">3</span>]<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;</span><br><span class=\"line\">\tadd(a)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, v := <span class=\"keyword\">range</span> a &#123;</span><br><span class=\"line\">\t\tfmt.Println(v)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">add</span><span class=\"params\">(a [3]<span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\ta[<span class=\"number\">0</span>] += <span class=\"number\">1</span></span><br><span class=\"line\">\ta[<span class=\"number\">1</span>] += <span class=\"number\">1</span></span><br><span class=\"line\">\ta[<span class=\"number\">2</span>] += <span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, v := <span class=\"keyword\">range</span> a &#123;</span><br><span class=\"line\">\t\tfmt.Println(v)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果需要修改array元素的值，则必须通过array的指针来完成。</p>\n<p>array的缺点：</p>\n<ol>\n<li>大小是固定的，不可删除或增加元素</li>\n<li>修改内部的值必须通过指针操作，比较麻烦</li>\n</ol>\n<p>因此，在GO中，大部分时间都会用slice。</p>\n<h2 id=\"4-2-Slices\"><a href=\"#4-2-Slices\" class=\"headerlink\" title=\"4.2 Slices\"></a>4.2 Slices</h2><p>slice是可变长度的串，一般写成<code>[]T</code>,其中元素的类型是<code>T</code>。</p>\n<p>slice可以表示一个array的子串。通常，slice包含三个组件：pointer，length和capacity，其中pointer指向第一个元素，length表示slice的元素个数，capacity表示slice的长度限制。内置的<code>len</code>和<code>cap</code>可以获取slice的length和capacity。</p>\n<p>多个slice可以共享底层的array，slice指向底层的array，如果把slice传递给函数参数，那么是可以达到修改底层array元素的目的的，例如</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\ta := [...]<span class=\"keyword\">int</span>&#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>&#125;</span><br><span class=\"line\">\treverse(a[:])</span><br><span class=\"line\">\tfmt.Println(a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">reverse</span><span class=\"params\">(a []<span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i, j := <span class=\"number\">0</span>, <span class=\"built_in\">len</span>(a)<span class=\"number\">-1</span>; i &lt; j; i, j = i+<span class=\"number\">1</span>, j<span class=\"number\">-1</span> &#123;</span><br><span class=\"line\">\t\ta[i], a[j] = a[j], a[i]</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">charles@Charles-PC:~/code/<span class=\"keyword\">go</span>/bin$ ./slice </span><br><span class=\"line\">[<span class=\"number\">5</span> <span class=\"number\">4</span> <span class=\"number\">3</span> <span class=\"number\">2</span> <span class=\"number\">1</span> <span class=\"number\">0</span>]</span><br></pre></td></tr></table></figure>\n<p>创建slice的时候，不需要指定元素的个数，初始化的时候，隐式的创建了一个array，并把slice指向它。对于slice来讲，它互相是<strong>不可比较的</strong>。</p>\n<p>因为slice会随着底层array的元素值变化而变化，因此，对于slice来讲，不能作为map的key。<strong>建议禁止slice之间的比较</strong>,最多只能让slice和nil做比较，如下</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s[] <span class=\"keyword\">int</span> <span class=\"comment\">//len(s) == 0, s == nil</span></span><br><span class=\"line\">s = <span class=\"literal\">nil</span> <span class=\"comment\">//len(s) == 0, s == nil</span></span><br><span class=\"line\">s = []<span class=\"keyword\">int</span>(<span class=\"literal\">nil</span>) <span class=\"comment\">//len(s) == 0, s == nil</span></span><br><span class=\"line\">s = []<span class=\"keyword\">int</span>&#123;&#125; <span class=\"comment\">//len(s) == 0, s != nil</span></span><br></pre></td></tr></table></figure>\n<p>判断slice是否为空，应该用<code>len(s) == 0</code>来判断。除了判断是否为空，其他情况下nil和空的slice表现一致，因此reverse(nil)是可以正常工作的。</p>\n<p>内置的make函数，可以指定type，length和capacity，如下</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">make</span>([]T, <span class=\"built_in\">len</span>)</span><br><span class=\"line\"><span class=\"built_in\">make</span>([]T, <span class=\"built_in\">len</span> ,<span class=\"built_in\">cap</span>)</span><br></pre></td></tr></table></figure>\n<p>在实现中，make也是创建一个array，然后返回一个指向它的引用。第一种make下，len就包含了整个array；第二中make，只有cap才能包含整个array。</p>\n<h3 id=\"4-2-1-The-append-function\"><a href=\"#4-2-1-The-append-function\" class=\"headerlink\" title=\"4.2.1 The append function\"></a>4.2.1 The append function</h3><p>内置的append函数可以添加元素到slice，为了更好的理解append是如何工作的，实现一个特殊化的appendInt函数来说明。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">appendInt</span><span class=\"params\">(x []<span class=\"keyword\">int</span>, y <span class=\"keyword\">int</span>)</span> []<span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> z []<span class=\"keyword\">int</span></span><br><span class=\"line\">\tzlen := <span class=\"built_in\">len</span>(x) + <span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> zlen &lt;= <span class=\"built_in\">cap</span>(x) &#123;</span><br><span class=\"line\">\t\tz = x[:zlen]</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tzcap := zlen</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> zcap &lt; <span class=\"number\">2</span>*<span class=\"built_in\">len</span>(x) &#123;</span><br><span class=\"line\">\t\t\tzcap = <span class=\"number\">2</span> * <span class=\"built_in\">len</span>(x)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tz = <span class=\"built_in\">make</span>([]<span class=\"keyword\">int</span>, zlen, zcap)</span><br><span class=\"line\">\t\t<span class=\"built_in\">copy</span>(z, x)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tz[<span class=\"built_in\">len</span>(x)] = y</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> z</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> x []<span class=\"keyword\">int</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">20</span>; i++ &#123;</span><br><span class=\"line\">\t\tx = appendInt(x, i)</span><br><span class=\"line\">\t\tfmt.Println(x, <span class=\"built_in\">len</span>(x), <span class=\"built_in\">cap</span>(x))</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>像appendInt一样，内置的append函数也可能按照既定的策略重新分配内存，所以，我们不能假设append之后，slice的内存地址没有发生变化，因此，每次append都要将append的返回值赋值给slice。</p>\n<p>不仅仅是append，任何改变slice的len或者cap值的函数，或者把它指向新的underlying-array的，都需要重新赋值。</p>\n<p>slice的内部定义像下面的结构体</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> IntSlice <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tptr *<span class=\"keyword\">int</span></span><br><span class=\"line\">    <span class=\"built_in\">len</span>, <span class=\"built_in\">cap</span> <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>每次要改变slice的值，都必须要显式的赋值</p>\n<p>内置的append还可以一次性的追加多个元素。</p>\n<h3 id=\"4-2-2-In-Place-Slice-Techniques\"><a href=\"#4-2-2-In-Place-Slice-Techniques\" class=\"headerlink\" title=\"4.2.2 In-Place Slice Techniques\"></a>4.2.2 In-Place Slice Techniques</h3><p>在本地修改slice，避免重新分配underlying-array。</p>\n<p>本节以几个例子说明，第一个是nonempty，字符串列表中，返回非空的字符串列表。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">nonempty</span><span class=\"params\">(strings []<span class=\"keyword\">string</span>)</span> []<span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">\ti := <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, s := <span class=\"keyword\">range</span> <span class=\"keyword\">string</span> &#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">if</span> s != <span class=\"string\">\"\"</span> &#123;</span><br><span class=\"line\">        \tstrings[i] = s</span><br><span class=\"line\">            i++</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">nonempty2</span><span class=\"params\">(strings []<span class=\"keyword\">string</span>)</span> []<span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">\tout := strings[:<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, s := <span class=\"keyword\">range</span> strings &#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">if</span> s ！= “” &#123;</span><br><span class=\"line\">        \tout = <span class=\"built_in\">append</span>(out, s)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>还可以用append来实现一个stack</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stack = <span class=\"built_in\">append</span>(stack, v) <span class=\"comment\">//push</span></span><br><span class=\"line\">top := stack[<span class=\"built_in\">len</span>(stack) - <span class=\"number\">1</span>] <span class=\"comment\">// top of stack</span></span><br><span class=\"line\">stack = stack[:<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>] <span class=\"comment\">// pop</span></span><br></pre></td></tr></table></figure>\n<p>从字符串列表中间删掉一个字符串</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">remove</span><span class=\"params\">(slice []<span class=\"keyword\">int</span>, i <span class=\"keyword\">int</span>)</span> []<span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">copy</span>(slice[i:], slice[i+<span class=\"number\">1</span>:])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> slice[:<span class=\"built_in\">len</span>(slice)<span class=\"number\">-1</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\ts := <span class=\"keyword\">int</span> &#123;<span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>&#125;</span><br><span class=\"line\">    fmt.Println(remove(s, <span class=\"number\">2</span>)) <span class=\"comment\">//[5, 6, 8, 9]</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-3-Maps\"><a href=\"#4-3-Maps\" class=\"headerlink\" title=\"4.3 Maps\"></a>4.3 Maps</h2><p>在Go中，map是hash table的引用，map类型写成map[K]V，对于K，需要能使用==进行比较。</p>\n<p>map的创建方式</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ages := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span>)</span><br><span class=\"line\">ages[<span class=\"string\">\"alice\"</span>] = <span class=\"number\">31</span></span><br><span class=\"line\">ages[<span class=\"string\">\"charlie\"</span>] = <span class=\"number\">34</span></span><br><span class=\"line\"></span><br><span class=\"line\">ages := <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span> &#123;</span><br><span class=\"line\">\t<span class=\"string\">\"alice\"</span> : <span class=\"number\">31</span>,</span><br><span class=\"line\">    <span class=\"string\">\"charlie\"</span>: <span class=\"number\">34</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>map元素的访问和删除</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ages[<span class=\"string\">\"alice\"</span>] = <span class=\"number\">32</span> <span class=\"comment\">// access</span></span><br><span class=\"line\"><span class=\"built_in\">delete</span>(ages, <span class=\"string\">\"alice\"</span>) <span class=\"comment\">//delete</span></span><br></pre></td></tr></table></figure>\n<p>访问不在map中的key，会返回zero value。注意，map不是变量，所以不能对其元素进行取地址，原因是hash table可能会动态变化，导致原来的地址失效。</p>\n<p>map的遍历</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> name, age := <span class=\"keyword\">range</span> ages &#123;</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">\"%s:%d\"</span>, name, age)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>map的遍历的顺序是随机的，所以，我们不能假设它按照某个特定的顺序来遍历。</p>\n<p>map的zero value是nil，即没有引用任何的hash table。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ages <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>] <span class=\"keyword\">int</span></span><br><span class=\"line\">fmt.Println(ages == <span class=\"literal\">nil</span>)</span><br><span class=\"line\">fmt.Println(<span class=\"built_in\">len</span>(ages) == <span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure>\n<p>对于nil的map，delete，len和range都可以正常的工作，但是，往里面存数据就会panic。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ages <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>] <span class=\"keyword\">int</span></span><br><span class=\"line\">ages[<span class=\"string\">\"carol\"</span>] = <span class=\"number\">21</span> <span class=\"comment\">// panic</span></span><br></pre></td></tr></table></figure>\n<p>有时候，需要判断某个key是否存在map中，需要使用下面的测试</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">age, ok := ages[<span class=\"string\">\"bob\"</span>]</span><br><span class=\"line\"><span class=\"keyword\">if</span> !ok &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//不存在</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>map不能比较，需要自己写函数遍历key来依次比较。</p>\n<p>GO语言中没有set，可以用map[string]bool来代替。</p>\n<p>有时候，我们希望slice作为key，但是slice类型是不能比较的，需要自己写函数，例如</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> m = <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">k</span><span class=\"params\">(list []<span class=\"keyword\">string</span>)</span> <span class=\"title\">string</span></span> &#123;<span class=\"keyword\">return</span> fmt.Sprintf(<span class=\"string\">\"%q\"</span>, list)&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Add</span><span class=\"params\">(list []<span class=\"keyword\">string</span>)</span></span> &#123;m[k(list)]++&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Count</span><span class=\"params\">(list []<span class=\"keyword\">string</span>)</span> <span class=\"title\">int</span></span> &#123;<span class=\"keyword\">return</span> m[k(list)]&#125;</span><br></pre></td></tr></table></figure>\n<p>对于其他不可比较的类型，也可以采用本方法，并且k(x)不一定要是string，可以计算成任何可以比较的类型。</p>\n<h2 id=\"4-4-Structs\"><a href=\"#4-4-Structs\" class=\"headerlink\" title=\"4.4 Structs\"></a>4.4 Structs</h2><p>struct把0个或多个类型聚合在一起，每个都叫做field，例如</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Employee <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tID <span class=\"keyword\">int</span></span><br><span class=\"line\">    Name <span class=\"keyword\">string</span></span><br><span class=\"line\">    Address <span class=\"keyword\">string</span></span><br><span class=\"line\">    DoB time.Time</span><br><span class=\"line\">    Position <span class=\"keyword\">string</span></span><br><span class=\"line\">    Salary <span class=\"keyword\">int</span></span><br><span class=\"line\">    ManagerID <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> dillbert Employee</span><br><span class=\"line\">dilbert.Salary = <span class=\"number\">5000</span></span><br></pre></td></tr></table></figure>\n<p>可以用<code>.</code>来访问struct里面的变量，值得说明的是，指针也能用<code>.</code>访问内部的field。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> employOfTheMonth *employee = &amp;dilbert</span><br><span class=\"line\">employOfTheMonth.Postion += <span class=\"string\">\"(proactive team player)\"</span></span><br></pre></td></tr></table></figure>\n<p>上面的指针访问等价于</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(*employeeOfTheMonth).Position += <span class=\"string\">\"(proactive team player)\"</span></span><br></pre></td></tr></table></figure>\n<p>field的顺序和类型关系很大，如果改变了它们的位置，就是另一种类型了。</p>\n<p>struct中的field如果是大写的话，那么是export的，否则不是。</p>\n<p>struct中不能定义自身，但是可以定义自身的指针，例如</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> tree <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tvalue <span class=\"keyword\">int</span></span><br><span class=\"line\">    left, right *tree</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>struct的zero value是其中所有的field都是zero value。</p>\n<p>struct中如果没有field，则是empty struct，写成<code>struct {}</code>。</p>\n<h3 id=\"4-4-1-Struct-Literals\"><a href=\"#4-4-1-Struct-Literals\" class=\"headerlink\" title=\"4.4.1 Struct Literals\"></a>4.4.1 Struct Literals</h3><p>struct literal有两种，如下</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Point <span class=\"keyword\">struct</span> &#123;X, Y <span class=\"keyword\">int</span>&#125;</span><br><span class=\"line\">p := Point&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;</span><br><span class=\"line\">p := Point&#123;X : <span class=\"number\">1</span>&#125;</span><br></pre></td></tr></table></figure>\n<p>如果struct不是export的，则不可以在package外声明它</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> p</span><br><span class=\"line\"><span class=\"keyword\">type</span> T <span class=\"keyword\">struct</span> &#123;a, b <span class=\"keyword\">int</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">package</span> q</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"p\"</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> _ = p.T&#123;a : <span class=\"number\">1</span>, b : <span class=\"number\">2</span>&#125; <span class=\"comment\">//compile error</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> _ = p.T&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125; <span class=\"comment\">// compile error</span></span><br></pre></td></tr></table></figure>\n<p>尽管最后一行没有使用unexported的field，但是它隐式地使用它们了。</p>\n<p>struct作为函数参数是值传递的，如果是大的struct，最好使用指针来传递，这样可以提升效率。</p>\n<p>因为struct经常使用指针所以可以用如下声明</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pp ：= &amp;Point&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">pp := <span class=\"built_in\">new</span>(Point)</span><br><span class=\"line\">*pp = Point&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-4-2-Comparing-Structs\"><a href=\"#4-4-2-Comparing-Structs\" class=\"headerlink\" title=\"4.4.2 Comparing Structs\"></a>4.4.2 Comparing Structs</h3><p>当struct的所有field都可以比较时，则struct本身也是可比较的。</p>\n<h3 id=\"4-4-3-Struct-Embedding-and-Anonymous-Fields\"><a href=\"#4-4-3-Struct-Embedding-and-Anonymous-Fields\" class=\"headerlink\" title=\"4.4.3 Struct Embedding and Anonymous Fields\"></a>4.4.3 Struct Embedding and Anonymous Fields</h3><p>通过在struct内部定义匿名的struct，可以快速访问到底层struct的field，如下</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Point <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tX, Y <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> Circle <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tCenter Point</span><br><span class=\"line\">    Radius <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> Wheel <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tC Circle</span><br><span class=\"line\">    Spokes <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> w Wheel</span><br><span class=\"line\">w.C.Center.X = <span class=\"number\">8</span></span><br></pre></td></tr></table></figure>\n<p>可以看出，从Wheel变量中，要访问Point的X需要使用三个<code>.</code>，书写效率比较低，可以使用以下方式解决</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Circle <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tPoint</span><br><span class=\"line\">    Radius <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> Wheel <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tCircle</span><br><span class=\"line\">    Spokes <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> w Wheel</span><br><span class=\"line\">w.X = <span class=\"number\">8</span></span><br><span class=\"line\">w.Y = <span class=\"number\">8</span></span><br><span class=\"line\">w.Radius = <span class=\"number\">9</span></span><br></pre></td></tr></table></figure>\n<p>使用上述方法可以快速访问到内部结构体中的field，但是这种方式对于struct literal是不行的</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">w = Wheel &#123;<span class=\"number\">8</span>, <span class=\"number\">8</span>, <span class=\"number\">5</span>, <span class=\"number\">20</span>&#125; <span class=\"comment\">//compile error</span></span><br><span class=\"line\">w = Wheel &#123;X : <span class=\"number\">8</span>, Y : <span class=\"number\">8</span>, Radius: <span class=\"number\">5</span>, Spokes: <span class=\"number\">20</span>&#125; <span class=\"comment\">//compile error</span></span><br><span class=\"line\">w = Wheel &#123;Circle&#123;Point&#123;<span class=\"number\">8</span>, <span class=\"number\">8</span>&#125;, <span class=\"number\">5</span>&#125;, <span class=\"number\">20</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">w = Wheel &#123;</span><br><span class=\"line\">\tCircle : Circle &#123;</span><br><span class=\"line\">    \tPoint : Point &#123;X:<span class=\"number\">8</span>, Y:<span class=\"number\">8</span>&#125;</span><br><span class=\"line\">        Radius : <span class=\"number\">5</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    Spokes: <span class=\"number\">20</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>匿名的同类型的struct，只能出现在一个struct内一次，否则无法区分它们。</p>\n<h2 id=\"4-5-JSON\"><a href=\"#4-5-JSON\" class=\"headerlink\" title=\"4.5 JSON\"></a>4.5 JSON</h2><p>JSON是 JavaScript Object Notation的缩写。GO的标准库中有<code>encoding/json</code>来处理JSON格式，本节就是关于这个package相关的知识。</p>\n<p>JSON中基础类型包括numbers(decimal或scientific notation)，booleans(true or false)和strings。</p>\n<p>JSON有array和object，array以方括号扩起来，并且逗号分割的一系列元素；object是string到value的mapping， 例如</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">boolean <span class=\"literal\">true</span></span><br><span class=\"line\">number <span class=\"number\">-273.15</span></span><br><span class=\"line\"><span class=\"keyword\">string</span> <span class=\"string\">\"she said hello world\"</span></span><br><span class=\"line\">array [<span class=\"string\">\"gold\"</span>, <span class=\"string\">\"siliver\"</span>]</span><br><span class=\"line\">object &#123;<span class=\"string\">\"year\"</span> : <span class=\"number\">1980</span>,</span><br><span class=\"line\">\t\t<span class=\"string\">\"event\"</span>: <span class=\"string\">\"archery\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"medals\"</span>: [<span class=\"string\">\"gold\"</span>, <span class=\"string\">\"silver\"</span>]&#125;</span><br></pre></td></tr></table></figure>\n<p>JSON的array可以用来编码GO的array和slice；而JSON的object可以用来编码GO的map(string作为key)和struct(不明白怎么编码？)。</p>\n<p>由GO数据结构转换成JSON的过程称为marshaling，通过<code>json.Marshal</code>函数实现，如下</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"encoding/json\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"log\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Movie <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tTitle  <span class=\"keyword\">string</span></span><br><span class=\"line\">\tYear   <span class=\"keyword\">int</span>  <span class=\"string\">`json:“released”`</span></span><br><span class=\"line\">\tColor  <span class=\"keyword\">bool</span> <span class=\"string\">`json:\"color,omitempty\"`</span></span><br><span class=\"line\">\tActors []<span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> movies = []Movie&#123;</span><br><span class=\"line\">\t\t&#123;Title: <span class=\"string\">\"Casablana\"</span>, Year: <span class=\"number\">1942</span>, Color: <span class=\"literal\">false</span>, Actors: []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"A\"</span>, <span class=\"string\">\"B\"</span>&#125;&#125;,</span><br><span class=\"line\">\t\t&#123;Title: <span class=\"string\">\"Casablana2\"</span>, Year: <span class=\"number\">1943</span>, Color: <span class=\"literal\">true</span>, Actors: []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"A\"</span>, <span class=\"string\">\"B\"</span>&#125;&#125;,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tdata, err := json.Marshal(movies)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Fatalf(<span class=\"string\">\"JSON Marshaling failed: %s\"</span>, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%s\\n\"</span>, data)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">charles@Charles-PC:~/code/<span class=\"keyword\">go</span>$ bin/json </span><br><span class=\"line\">[&#123;<span class=\"string\">\"Title\"</span>:<span class=\"string\">\"Casablana\"</span>,<span class=\"string\">\"released\"</span>:<span class=\"number\">1942</span>,<span class=\"string\">\"Actors\"</span>:[<span class=\"string\">\"A\"</span>,<span class=\"string\">\"B\"</span>]&#125;,&#123;<span class=\"string\">\"Title\"</span>:<span class=\"string\">\"Casablana2\"</span>,<span class=\"string\">\"released\"</span>:<span class=\"number\">1943</span>,<span class=\"string\">\"color\"</span>:<span class=\"literal\">true</span>,<span class=\"string\">\"Actors\"</span>:[<span class=\"string\">\"A\"</span>,<span class=\"string\">\"B\"</span>]&#125;]</span><br></pre></td></tr></table></figure>\n<p>上面的字符串如果多了的话，可读性不是很强，可以用<code>MarshalIndent</code>来生成一个可读性较强的。</p>\n<p>GO只会对exported的field做Marshal。从上面的输出可以看出，Year转成了released的输出，Color转换成color，并且在为false的时候，不输出，这都是由它们字段后面的json标记控制的。</p>\n<p>Marshaling的反操作为unmarshaling，即把JSON结构转成GO的结构体，通过<code>json.Unmarshal</code>来实现。Unmarshaling的时候，可以选择需要的字段来做解码，如下</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> titles []<span class=\"keyword\">struct</span>&#123;Title <span class=\"keyword\">string</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> err := json.Unmarshal(data, &amp;title); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\tlog.Fatalf(<span class=\"string\">\"JSON unmarshaling failed:%s\"</span>, err)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fmt.Println(titles)</span><br></pre></td></tr></table></figure>\n<p>如上所示，只会把Title字段解析出来，其余字段会被略去。</p>\n<h2 id=\"4-6-Text-and-HTML-Templates\"><a href=\"#4-6-Text-and-HTML-Templates\" class=\"headerlink\" title=\"4.6 Text and HTML Templates\"></a>4.6 Text and HTML Templates</h2><p>除了简单的Printf外，GO还提供了强大的模板库，例如<code>text/template</code>和<code>html/template</code>，模板库本身有自己的语言规则，例如，一个简单的例子为</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> templ = <span class=\"string\">`&#123;&#123;.TotalCount&#125;&#125; issues:</span></span><br><span class=\"line\"><span class=\"string\">&#123;&#123;range.Items&#125;&#125;----------------------------------</span></span><br><span class=\"line\"><span class=\"string\">Number : &#123;&#123;.Number&#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\">User : &#123;&#123;.User.Login&#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\">Title : &#123;&#123;.Title | printf \".64s\"&#125;</span></span><br><span class=\"line\"><span class=\"string\">Age : &#123;&#123;.CreateAT | daysAgo&#125;&#125; days</span></span><br><span class=\"line\"><span class=\"string\">&#123;&#123;end&#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">function daysAgo(t time.Time) int &#123;</span></span><br><span class=\"line\"><span class=\"string\">\treturn int(time.Since(t).Hours() / 24)</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>上面的range和end，表示中间是一个循环。 <code>.CreateAT | daysAgo</code>表示讲CreateAT作为参数传入daysAgo函数处理。</p>\n<p>产生输出需要两个步骤</p>\n<ol>\n<li>解析模板</li>\n<li>在特定输入下执行模板</li>\n</ol>\n<p>解析模板只需要做一次，后面就可以无限制地执行模板，具体的例子如下</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> report = template.Must(template.New(<span class=\"string\">\"issue-list\"</span>)).Funcs(template.FuncMap&#123;<span class=\"string\">\"daysAgo\"</span>: daysAgo&#125;).Parse(templ)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tresult, err := github.SearchIssues(os.Args[<span class=\"number\">1</span>:])</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    \tlog.Fatal(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err := report.Execute(os.Stdout, result); err ！= <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    \tlog.Fatal(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的是Text模板，HTML模板与之不同的是，里面可以写HTML标签，它会输入的动态数据做自动的转义，防止JS注入等攻击，例子如下</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"html/template\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> issueList = template.Must(template.New(<span class=\"string\">\"issuelist\"</span>).Parse(<span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">&lt;h1&gt;&#123;&#123;.TotalCount&#125;&#125; issues&lt;/h1&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;table&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;tr style='text-align: left'&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;th&gt;#&lt;/th&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;th&gt;State&lt;/th&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;th&gt;User&lt;/th&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;th&gt;Title&lt;/th&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/tr&gt;</span></span><br><span class=\"line\"><span class=\"string\">&#123;&#123;range .Items&#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\">&lt;tr&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;td&gt;&lt;a href='&#123;&#123;.HTMLURL&#125;&#125;'&gt;&#123;&#123;.Number&#125;&#125;&lt;/a&gt;&lt;/td&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;td&gt;&#123;&#123;.State&#125;&#125;&lt;/td&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;td&gt;&lt;a href='&#123;&#123;.User.HTMLURL&#125;&#125;'&gt;&#123;&#123;.User.Login&#125;&#125;&lt;/a&gt;&lt;/td&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;td&gt;&lt;a href='&#123;&#123;.HTMLURL&#125;&#125;'&gt;&#123;&#123;.Title&#125;&#125;&lt;/a&gt;&lt;/td&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/tr&gt;</span></span><br><span class=\"line\"><span class=\"string\">&#123;&#123;end&#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/table&gt;</span></span><br><span class=\"line\"><span class=\"string\">`</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//!-template</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//!+</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tresult, err := github.SearchIssues(os.Args[<span class=\"number\">1</span>:])</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Fatal(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err := issueList.Execute(os.Stdout, result); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Fatal(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h1 id=\"1-Introduction\"><a href=\"#1-Introduction\" class=\"headerlink\" title=\"1. Introduction\"></a>1. Introduction</h1><p>本文是学习The go programming language的总结的第一部分，全文的组织结构如下：</p>\n<ul>\n<li>Program Structure</li>\n<li>Basic Data Types</li>\n<li>Composite Types</li>\n</ul>","more":"<h1 id=\"2-Program-Structure\"><a href=\"#2-Program-Structure\" class=\"headerlink\" title=\"2. Program Structure\"></a>2. Program Structure</h1><h2 id=\"2-1-Names\"><a href=\"#2-1-Names\" class=\"headerlink\" title=\"2.1 Names\"></a>2.1 Names</h2><ul>\n<li>合法的命令为以字母为下划线开头，并且除关键字外的字符串（GO对大小写敏感）</li>\n<li>如果一个命令定义在函数外面，并且它的首字母是大写的，那么它可以被package外的代码访问到；如果定义在函数外部，但首字母是小写，那么能被package内部访问到</li>\n<li>GO推荐用驼峰命名法来命名，即parseRequestLine是推荐的，但parse_request_line是不推荐的</li>\n<li>缩写的名称，一般全用大写，例如ASCII、HTML等</li>\n</ul>\n<h2 id=\"2-2-Declarations\"><a href=\"#2-2-Declarations\" class=\"headerlink\" title=\"2.2 Declarations\"></a>2.2 Declarations</h2><p>以一个例子来说明</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> boilingF = <span class=\"number\">212.0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> f = boilingF;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> c = (f - <span class=\"number\">32</span>) * <span class=\"number\">5</span> / <span class=\"number\">9</span>;</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"boiling point = %g F or %g C\"</span>, f, c);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>常量boilingF是package级别的定义</li>\n<li>变量f和c是本地变量，属于函数main内部</li>\n<li>函数的定义为函数名+参数列表+返回值，main函数把后两者省略掉了</li>\n</ul>\n<h2 id=\"2-3-Variables\"><a href=\"#2-3-Variables\" class=\"headerlink\" title=\"2.3 Variables\"></a>2.3 Variables</h2><p>变量的声明形式为</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name <span class=\"keyword\">type</span> = expression</span><br></pre></td></tr></table></figure>\n<ul>\n<li>如果type被省略，那么根据expression字段的类型推断出来</li>\n<li>如果expression被省略，那么初始化成zero value,对于numbers为0，对于boolean为false，对于strings为空，对于interface和reference type(slice，pointer，map，channel，function）为nil。</li>\n</ul>\n<p>可以在一条语句中声明多个变量</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> i, j, k <span class=\"keyword\">int</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> b, f, s = <span class=\"literal\">true</span>, <span class=\"number\">2.3</span>, <span class=\"string\">\"four</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2-3-1-Short-Variable-Declarations\"><a href=\"#2-3-1-Short-Variable-Declarations\" class=\"headerlink\" title=\"2.3.1 Short Variable Declarations\"></a>2.3.1 Short Variable Declarations</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name := expression</span><br></pre></td></tr></table></figure>\n<p>会以expression的type来推断name的type，并且以expression初始化name</p>\n<p>大部分的局部变量会用Short Variable Declaration方式来定义，两种情况除外</p>\n<ul>\n<li>声明的变量的类型和初始化的expression不一致，用var显式地声明</li>\n<li>声明的时候不需要初始化，后续会赋值</li>\n</ul>\n<p><code>:=</code>和<code>=</code>的区别是，前者是声明，后者是赋值</p>\n<p>在<code>:=</code>语句中，不用声明所有的变量，如果有变量已经声明过，就相当于转成了赋值操作，但是，必须至少有一个变量没有声明过，因为<code>:=</code>语句要求至少新声明一个变量。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//声明了out变量，err是赋值</span></span><br><span class=\"line\">in ,err := os.Open(infile)</span><br><span class=\"line\">out, err := os.Create(outfile)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//编译错误，第二个语句没有新声明任何的变量</span></span><br><span class=\"line\">f, err := os.Open(infile)</span><br><span class=\"line\">f, err := os.Create(outfile)</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-3-2-Pointers\"><a href=\"#2-3-2-Pointers\" class=\"headerlink\" title=\"2.3.2 Pointers\"></a>2.3.2 Pointers</h3><p>pointer存储的是变量的地址，可以通过pointer来间接的更新变量的值。</p>\n<p><strong>简单例子</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x := <span class=\"number\">1</span></span><br><span class=\"line\">p := &amp;x</span><br><span class=\"line\">fmt.Println(*p) <span class=\"comment\">//1</span></span><br><span class=\"line\">*p = <span class=\"number\">2</span></span><br><span class=\"line\">fmt.Println(x)  <span class=\"comment\">//2</span></span><br></pre></td></tr></table></figure>\n<p><strong>局部变量返回成指针也是安全的</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p = f()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f</span><span class=\"params\">()</span> *<span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\tv := <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;v</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>和C不一样，在GO中这是合法的，v在函数返回后继续存在。</p>\n<h3 id=\"2-3-3-The-new-function\"><a href=\"#2-3-3-The-new-function\" class=\"headerlink\" title=\"2.3.3 The new function\"></a>2.3.3 The <em>new</em> function</h3><p>new返回的也是指针，例如<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p := <span class=\"built_in\">new</span>(<span class=\"keyword\">int</span>)</span><br><span class=\"line\">fmt.Println(*p)</span><br><span class=\"line\">*p = <span class=\"number\">2</span></span><br><span class=\"line\">fmt.Println(*p)</span><br></pre></td></tr></table></figure></p>\n<p>下面两个函数是等价的，即new和普通的局部变量区别不大</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newInt</span><span class=\"params\">()</span> *<span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">new</span>(<span class=\"keyword\">int</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newInt</span><span class=\"params\">()</span> *<span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> dummpy</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;dummpy</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一般来说，new创建出来的变量地址是不同的，但是，有可能struct {} 这样的空结构体，地址是相同的，取决于编译器的实现。</p>\n<h3 id=\"2-3-4-Lifetime-of-Variables\"><a href=\"#2-3-4-Lifetime-of-Variables\" class=\"headerlink\" title=\"2.3.4 Lifetime of Variables\"></a>2.3.4 Lifetime of Variables</h3><ul>\n<li>package级别的变量，生命周期是整个程序运行期间</li>\n<li>局部变量是在声明语句开始后，到变量已经无法使用（即没有符号引用它，包括变量名或者指针）</li>\n</ul>\n<p>局部变量既可能在heap上创建，也可能在stack上创建，和是否用new无关</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> global *<span class=\"keyword\">int</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> x <span class=\"keyword\">int</span></span><br><span class=\"line\">    x = <span class=\"number\">1</span></span><br><span class=\"line\">    global = &amp;x</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">g</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\ty := <span class=\"built_in\">new</span>(<span class=\"keyword\">int</span>)</span><br><span class=\"line\">    *y = <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>x是在heap上创建的，因为一直被global引用，而y是stack创建，因为出了函数后，就没有使用了。</p>\n<p>GO的垃圾回收就是通过判断变量是否还被符号引用来做的，如果没有符号引用了，即表明可以回收这块的内存空间。</p>\n<h2 id=\"2-4-Assignment\"><a href=\"#2-4-Assignment\" class=\"headerlink\" title=\"2.4 Assignment\"></a>2.4 Assignment</h2><p>赋值语句会让变量的值更新，例如</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = <span class=\"number\">1</span></span><br><span class=\"line\">*p = <span class=\"literal\">true</span></span><br><span class=\"line\">person.name = <span class=\"string\">\"bob\"</span></span><br><span class=\"line\">count[x] = count[x] * scale</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-4-1-Tuple-Assignment\"><a href=\"#2-4-1-Tuple-Assignment\" class=\"headerlink\" title=\"2.4.1 Tuple Assignment\"></a>2.4.1 Tuple Assignment</h3><p>元组赋值例子如下</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x, y = y, x</span><br></pre></td></tr></table></figure>\n<p>有些操作，会返回多个值，可以使用元组操作，例如</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">v, ok = m[key]</span><br><span class=\"line\">v, ok = x.(T)</span><br><span class=\"line\">v, ok = &lt;-ch</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-4-2-Assignability\"><a href=\"#2-4-2-Assignability\" class=\"headerlink\" title=\"2.4.2 Assignability\"></a>2.4.2 Assignability</h3><p>赋值操作的左右类型必须是一致的；nil可用于interface和reference type的赋值</p>\n<h2 id=\"2-5-Type-Declarations\"><a href=\"#2-5-Type-Declarations\" class=\"headerlink\" title=\"2.5 Type Declarations\"></a>2.5 Type Declarations</h2><p>定义type的形式如下<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> name underlying-<span class=\"keyword\">type</span></span><br></pre></td></tr></table></figure></p>\n<p>type和underlying-type之间是不能直接赋值的，因为它们不是相同的类型。</p>\n<p>比较运算符可以用来比较相同的type，或者type和underlying-type，但是不能用于比较named type，例如</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Celsius <span class=\"keyword\">float64</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Fahrenheit <span class=\"keyword\">float64</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> c Celsius</span><br><span class=\"line\"><span class=\"keyword\">var</span> f Fahrenheit</span><br><span class=\"line\">c == <span class=\"number\">0</span> <span class=\"comment\">//true</span></span><br><span class=\"line\">f &gt;=<span class=\"number\">0</span> <span class=\"comment\">//true</span></span><br><span class=\"line\">c == f <span class=\"comment\">//compile error</span></span><br></pre></td></tr></table></figure>\n<p>c和f不能直接比较，两个都属于named type。</p>\n<h2 id=\"2-6-Package-and-Files\"><a href=\"#2-6-Package-and-Files\" class=\"headerlink\" title=\"2.6 Package and Files\"></a>2.6 Package and Files</h2><p>每个package相当于独立的命名空间，一般在同一个目录下的一个或多个文件可以组成一个package。</p>\n<p>例如，对于package <code>gopl.io/ch1/helloworld</code>对应的path是<code>$GOPATH/src/gopl.io/ch1/helloworld</code>。</p>\n<p>以一个例子来说明，例如，我们需要建立一个温度转换的package，名字为<code>gopl.io/ch2/tempconv</code></p>\n<p>有两个文件，分别是<code>tempconv.go</code>和<code>conv.go</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> tempconv</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Celsius <span class=\"keyword\">float64</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Fahrenheit <span class=\"keyword\">float64</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">\tAbsoluteZeroC Celsius = <span class=\"number\">-273.15</span></span><br><span class=\"line\">    FreezingC Celsius = <span class=\"number\">0</span></span><br><span class=\"line\">    BoilingC Celsius = <span class=\"number\">100</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(C Celsius)</span> <span class=\"title\">String</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">\tfmt.Sprintf(<span class=\"string\">\"%gC\"</span>, c)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f Fahrenheit)</span> <span class=\"title\">String</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%gF\"</span>, f)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> tempconv</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">CToF</span><span class=\"params\">(c Celsius)</span> <span class=\"title\">Fahrenheit</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> Fahrenheit(c * <span class=\"number\">9</span> / <span class=\"number\">5</span> + <span class=\"number\">32</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">FToC</span><span class=\"params\">(f Fahrenheit)</span> <span class=\"title\">Celsius</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> Celsius((f - <span class=\"number\">32</span>) * <span class=\"number\">5</span> / <span class=\"number\">9</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>package中以大写开头的全局变量或函数都能被外部调用到。</p>\n<h3 id=\"2-6-1-Imports\"><a href=\"#2-6-1-Imports\" class=\"headerlink\" title=\"2.6.1 Imports\"></a>2.6.1 Imports</h3><p>以import语句来导入package，例如</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">    <span class=\"string\">\"os\"</span></span><br><span class=\"line\">    <span class=\"string\">\"strconv\"</span></span><br><span class=\"line\">    <span class=\"string\">\"gopl.io/ch2/tempconv\"</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>在GO里面，如果导入一个package，但是没有引用，会报编译错误。</p>\n<p>有<code>golang.org/x/tools/cmd/goimports</code>工具，可以自动的插入和删除需要的package。</p>\n<h3 id=\"2-6-2-Package-Initialization\"><a href=\"#2-6-2-Package-Initialization\" class=\"headerlink\" title=\"2.6.2 Package Initialization\"></a>2.6.2 Package Initialization</h3><p>package初始化会按照变量声明的顺序初始化。如果对于一些比较复杂的数据结构，可能仅仅通过初始化语句无法完成初始化，这时候可以把初始化操作放到init函数中，init函数会自动的被执行。</p>\n<p>package初始化之前，会先把要导入的package初始化。对于package main会在最后初始化，可以保证在main函数执行之前，其他package已经完成初始化了。</p>\n<h2 id=\"2-7-Scope\"><a href=\"#2-7-Scope\" class=\"headerlink\" title=\"2.7 Scope\"></a>2.7 Scope</h2><p>Scope代表变量的声明在程序哪个位置，而lifetime则表示变量在程序执行的可以被引用的时间段。前者是编译时期的特性，而后者是运行时的特性。</p>\n<p>Scope一般包括universe，package，file和function。</p>\n<ul>\n<li>内置类型，函数，常量为universe level</li>\n<li>定义在函数外，可以被相同package的任意file引用，称为package level</li>\n<li>通过文件中import过，例如 import fmt，则fmt的函数在本文件都是可用的，称为file level</li>\n<li>函数内部的定义，只有函数内部应用，则为function level</li>\n</ul>\n<p>和C一样，范围越小的变量会隐藏范围大的变量。</p>\n<p><strong>for语句</strong></p>\n<p>for定义了两个block</p>\n<ul>\n<li>显式的block，用{}包起来</li>\n<li>隐式的block，如初始化中的变量，范围是for循环条件，自增以及显式的block内</li>\n</ul>\n<p><strong>if语句</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> x := f(); x == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\tfmt.Println(x)</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> y := g(x); x == y &#123;</span><br><span class=\"line\">\tfmt.Println(x, y)</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\tfmt.Println(x, y)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fmt.Println(x, y) <span class=\"comment\">//compile error: x和y在这里不可见</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> f, err := os.Open(fname),; err != <span class=\"literal\">nil</span> &#123; <span class=\"comment\">//complie error: unused f</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f.ReadByte() <span class=\"comment\">//compile error: undefined f</span></span><br><span class=\"line\">f.Close() <span class=\"comment\">// compile error: undefined f</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"3-Basic-Data-Types\"><a href=\"#3-Basic-Data-Types\" class=\"headerlink\" title=\"3. Basic Data Types\"></a>3. Basic Data Types</h1><p>GO的Data Type有四大类：basic types，aggregate types，reference types和interface types。Basic types包括numbers，strings和booleans；Aggregate types包括array和struct；Reference types包括pointers，slices，maps，functions和channels。</p>\n<h2 id=\"3-1-Integers\"><a href=\"#3-1-Integers\" class=\"headerlink\" title=\"3.1 Integers\"></a>3.1 Integers</h2><p>GO的numbers类型包括integers，floating-point numbers和complex numbers。</p>\n<p>对于integers，有四种有符号整数和四种无符号整数。</p>\n<ul>\n<li>int8, int16, int32和int64</li>\n<li>uint8, uint16, uint32和uint64</li>\n</ul>\n<p>除了带字节大小的类型之外，还包括int和uint，可能是32bit或者64bit，由编译器决定，编程时不要假定这个大小。</p>\n<p>rune是int32的named type，用来存储单个unicode字符。</p>\n<p>byte是int8的named type。</p>\n<p>uintptr的大小可以存储下系统中任意的内存地址，一般用来和C Library交互的时候。</p>\n<p>采用二进制补码的方式编码，所以对于int8来讲，其范围为[-128, 127]</p>\n<p>操作符的优先级如下</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*\t/\t%\t&lt;&lt;\t&gt;&gt;\t&amp;\t&amp;^</span><br><span class=\"line\">+\t-\t|\t^</span><br><span class=\"line\">==\t！=\t&lt;\t&lt;=\t&gt;\t&gt;=</span><br><span class=\"line\">&amp;&amp;</span><br><span class=\"line\">||</span><br></pre></td></tr></table></figure>\n<p>对于%操作符，符号是跟着被除数走的，例如<code>-5%3</code>和<code>-5%-3</code>的余数都是-2。</p>\n<p>对于算术运算，可能会溢出</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> u <span class=\"keyword\">uint8</span> = <span class=\"number\">255</span></span><br><span class=\"line\">fmt.Println(u, u+<span class=\"number\">1</span>, u*u) <span class=\"comment\">//255 0 1</span></span><br></pre></td></tr></table></figure>\n<p>对于移位操作符</p>\n<ul>\n<li><code>&lt;&lt;</code>不管是有符号数或者无符号数，都是末尾补0</li>\n<li><code>&gt;&gt;</code>对于有符号数，会在左边补符号位，对于无符号数，会在末尾补0</li>\n</ul>\n<p>对于遍历操作，一般用有符号数</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> i <span class=\"keyword\">uint</span> = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> ; i &gt;= <span class=\"number\">0</span>; i-- &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面是个死循环，因为uint一定是大于或等于0的，故遍历的索引一般用有符号数。</p>\n<h2 id=\"3-2-Floating-Point-Numbers\"><a href=\"#3-2-Floating-Point-Numbers\" class=\"headerlink\" title=\"3.2 Floating-Point Numbers\"></a>3.2 Floating-Point Numbers</h2><p>GO提供两种float类型，即float32和float64，采用IEEE 754标准。</p>\n<h2 id=\"3-3-Complex-Numbers\"><a href=\"#3-3-Complex-Numbers\" class=\"headerlink\" title=\"3.3 Complex Numbers\"></a>3.3 Complex Numbers</h2><p>GO提供两种complex类型，即complex64和complex128，底层组件分别用float32和float64。</p>\n<p>使用例子如下</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x <span class=\"keyword\">complex128</span> = <span class=\"built_in\">complex</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>)  <span class=\"comment\">//1 + 2i</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> y <span class=\"keyword\">complex128</span> = <span class=\"built_in\">complex</span>(<span class=\"number\">3</span>, <span class=\"number\">4</span>)  <span class=\"comment\">//3 + 4i</span></span><br><span class=\"line\">fmt.Println(x*y)                  <span class=\"comment\">//-5 + 10i</span></span><br><span class=\"line\">fmt.Println(<span class=\"built_in\">real</span>(x*y))\t\t\t  <span class=\"comment\">//-5</span></span><br><span class=\"line\">fmt.Println(<span class=\"built_in\">imag</span>)(x*y))\t\t\t  <span class=\"comment\">//10</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"3-4-Booleans\"><a href=\"#3-4-Booleans\" class=\"headerlink\" title=\"3.4 Booleans\"></a>3.4 Booleans</h2><p>bool类型的值只有false和true两种。bool类型和number类型之间没有隐式的转换，一般通过如下方式</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">btoi</span><span class=\"params\">(b <span class=\"keyword\">bool</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b &#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">itob</span><span class=\"params\">(i <span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> i != <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-5-Strings\"><a href=\"#3-5-Strings\" class=\"headerlink\" title=\"3.5 Strings\"></a>3.5 Strings</h2><p>内置len函数可以计算string类型的长度。</p>\n<p>substring操作通过s[i:j]，表示从i开始，共j-i个字符，因此，不包括j。</p>\n<p>i的默认值为0，j的默认值为len(s)，因此</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s[:<span class=\"number\">5</span>] = s[<span class=\"number\">0</span>:<span class=\"number\">5</span>]</span><br><span class=\"line\">s[<span class=\"number\">7</span>:] = s[<span class=\"number\">7</span>:<span class=\"built_in\">len</span>(s)]</span><br><span class=\"line\">s[:] = s[<span class=\"number\">0</span>:<span class=\"built_in\">len</span>(s)]</span><br></pre></td></tr></table></figure>\n<p>string类型是不可修改的，例如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = &quot;hello&quot;</span><br><span class=\"line\">s += “world”</span><br><span class=\"line\">s[0] = &apos;L&apos; // compile error</span><br></pre></td></tr></table></figure>\n<p>s开始指向”hello”字符串，执行<code>+=</code>操作后，并不是修改原来字符串变成”hello world”，而是完全分配新的内存空间，把”hello world”存进去，然后修改s指向这块内存空间。</p>\n<p>因为string的不可修改，所以substring可以和原来的string共享内存空间。</p>\n<h3 id=\"3-5-1-String-Literals\"><a href=\"#3-5-1-String-Literals\" class=\"headerlink\" title=\"3.5.1 String Literals\"></a>3.5.1 String Literals</h3><ul>\n<li>用双引号，例如”hello world”</li>\n<li>用\\来做转义</li>\n</ul>\n<p>GO还提供`…`来作为raw string literal的声明，即里面的转义字符像\\，换行都不会特殊处理，所以，可以放到多行。一般可以放\\等特别多的字符串。</p>\n<h3 id=\"3-5-2-Unicode\"><a href=\"#3-5-2-Unicode\" class=\"headerlink\" title=\"3.5.2 Unicode\"></a>3.5.2 Unicode</h3><p>Unicode是为了解决各国文字无法在ASCII表示出来的困境，Unicode也分为多种</p>\n<ul>\n<li>UTF-32，每个Unicode字符都采用32位存储</li>\n<li>UTF-8，每个Unicode字符的存储空间不定，采用前缀的方式来区分</li>\n</ul>\n<h3 id=\"3-5-3-UTF-8\"><a href=\"#3-5-3-UTF-8\" class=\"headerlink\" title=\"3.5.3 UTF-8\"></a>3.5.3 UTF-8</h3><p>UTF-32的缺点有</p>\n<ul>\n<li>对于普通的ASCII也要采用32位存储，不兼容</li>\n<li>对于常用的65536个Unicode字符，其实用16位就行，32位会浪费大量的存储空间</li>\n</ul>\n<p>GO里面有专门的package<code>unicode/utf8</code>来处理UTF-8格式的编解码等。</p>\n<h2 id=\"3-6-Constants\"><a href=\"#3-6-Constants\" class=\"headerlink\" title=\"3.6 Constants\"></a>3.6 Constants</h2><p>const类型的语义是在运行期间，变量的值不会发生变化。const可用于boolean，string和number。</p>\n<h3 id=\"3-6-1-The-Constant-Genrator-itoa\"><a href=\"#3-6-1-The-Constant-Genrator-itoa\" class=\"headerlink\" title=\"3.6.1 The Constant Genrator itoa\"></a>3.6.1 The Constant Genrator itoa</h3><p>和C不同的是，const默认的是和上一个值相同，例如</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">    a = <span class=\"number\">1</span></span><br><span class=\"line\">    b</span><br><span class=\"line\">    c</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>此时，b和c都是为1。</p>\n<p>GO里边提供itoa来实现C中enum值自增的方法，如下</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Weekday <span class=\"keyword\">int</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">    Sunday Weekday = itoa</span><br><span class=\"line\">    MOnday</span><br><span class=\"line\">    Tuesday</span><br><span class=\"line\">    Wednesday</span><br><span class=\"line\">    Thursday</span><br><span class=\"line\">    Friday</span><br><span class=\"line\">    Saturday</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>上面定义中，Sunday为0，Monday为1，以此类推。</p>\n<p>还有如下用法</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Flags <span class=\"keyword\">uint</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">    FlagUp flags = <span class=\"number\">1</span> &lt;&lt; itoa</span><br><span class=\"line\">    FlagBroadcast</span><br><span class=\"line\">    FlagLoopback</span><br><span class=\"line\">    FlagPointToPoint</span><br><span class=\"line\">    FlagMulticast</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>当itoa递增时，每个const会赋值成<code>1 &lt;&lt; itoa</code>对应的值。</p>\n<p>更有趣的有</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">\t_ = <span class=\"number\">1</span> &lt;&lt; (<span class=\"number\">10</span> * itoa)</span><br><span class=\"line\">    KiB <span class=\"comment\">//1024</span></span><br><span class=\"line\">    MiB <span class=\"comment\">//1048576</span></span><br><span class=\"line\">    GiB <span class=\"comment\">//1073741824</span></span><br><span class=\"line\">    TiB</span><br><span class=\"line\">    PiB</span><br><span class=\"line\">    EiB</span><br><span class=\"line\">    ZiB</span><br><span class=\"line\">    YiB</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-6-2-Untyped-Constants\"><a href=\"#3-6-2-Untyped-Constants\" class=\"headerlink\" title=\"3.6.2 Untyped Constants\"></a>3.6.2 Untyped Constants</h3><p>untyped const可以不绑定到特定的类型，这样的const一般至少有256位的精度，所以，可以参与更高精度的计算。在赋值的时候，untyped const会隐式的转换到对应的类型，例如</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x <span class=\"keyword\">float32</span> = math.Pi <span class=\"comment\">//untyped const</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> y <span class=\"keyword\">float64</span> = math.Pi</span><br><span class=\"line\"><span class=\"keyword\">var</span> z <span class=\"keyword\">complex128</span> = math.Pi</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Pi64 <span class=\"keyword\">float64</span> = math.Pi</span><br><span class=\"line\"><span class=\"keyword\">var</span> x <span class=\"keyword\">float32</span> = <span class=\"keyword\">float32</span>(Pi64) <span class=\"comment\">//需要转类型转成，因为不是untyped const</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> y <span class=\"keyword\">float64</span> = Pi64</span><br><span class=\"line\"><span class=\"keyword\">var</span> z <span class=\"keyword\">complex128</span> = <span class=\"keyword\">complex128</span>(Pi64)</span><br></pre></td></tr></table></figure>\n<p>共有六种类型的untyped const，分别是untyped boolean，untyped integer，untyped rune，untyped rune，untyped floating-point，untyped complex和untyped string。</p>\n<p>例如，true和false是untyped boolean，字符串常量是untyped string。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> f <span class=\"keyword\">float64</span> = <span class=\"number\">3</span> + <span class=\"number\">0i</span>  <span class=\"comment\">//untyped complex -&gt; float64</span></span><br><span class=\"line\">f = <span class=\"number\">2</span>                   <span class=\"comment\">//untyped integer -&gt; float64</span></span><br><span class=\"line\">f = <span class=\"number\">1e123</span>\t\t\t\t<span class=\"comment\">//untyped floating-point -&gt; float64</span></span><br><span class=\"line\">f = <span class=\"string\">'a'</span>\t\t\t\t\t<span class=\"comment\">//untyped rune -&gt; float64</span></span><br></pre></td></tr></table></figure>\n<p>这种隐式的转换需要左边的变量能表示右边的值，有些情况是不能转换的，如下</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">    deadbeef = <span class=\"number\">0Xdeadbeef</span></span><br><span class=\"line\">    a = <span class=\"keyword\">uint32</span>(deadbeef) <span class=\"comment\">// uint32 with value 3735928559</span></span><br><span class=\"line\">    b = <span class=\"keyword\">float32</span>(deadbeef) <span class=\"comment\">// float32 with value </span></span><br><span class=\"line\">    d = <span class=\"keyword\">int32</span>(deadbeef) <span class=\"comment\">// compile error: overflow</span></span><br><span class=\"line\">    e = <span class=\"keyword\">float64</span>(<span class=\"number\">1e309</span>) <span class=\"comment\">//compile error: const overflows float64</span></span><br><span class=\"line\">    f = <span class=\"keyword\">uint</span>(<span class=\"number\">-1</span>) <span class=\"comment\">//compile error: const underflows uint</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>在变量声明中，如果没有指定类型，会由untyped const来隐式地决定类型</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i := <span class=\"number\">0</span>  <span class=\"comment\">//integer</span></span><br><span class=\"line\">r := <span class=\"string\">'\\000'</span> <span class=\"comment\">//rune</span></span><br><span class=\"line\">f := <span class=\"number\">0.0</span> <span class=\"comment\">//float64</span></span><br><span class=\"line\">c := <span class=\"number\">0i</span> <span class=\"comment\">//complex128</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"4-Composite-Types\"><a href=\"#4-Composite-Types\" class=\"headerlink\" title=\"4. Composite Types\"></a>4. Composite Types</h1><p>本章讨论了array，slice，map和struct四种类型，其中array和struct是集合类型，其包含的字节大小数量是固定的；相反，slice和map是动态的，当有新的元素加入时，大小会增加。</p>\n<h2 id=\"4-1-Arrays\"><a href=\"#4-1-Arrays\" class=\"headerlink\" title=\"4.1 Arrays\"></a>4.1 Arrays</h2><p>array是固定大小的，包含0个或多个元素，其中内置<code>len</code>函数可以求array的元素个数。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a [<span class=\"number\">3</span>]<span class=\"keyword\">int</span> <span class=\"comment\">// 0, 0, 0</span></span><br><span class=\"line\">fmt.Println(a[<span class=\"number\">0</span>]) <span class=\"comment\">//print a[0]</span></span><br><span class=\"line\">fmt.Println(a[<span class=\"built_in\">len</span>(a)<span class=\"number\">-1</span>]) <span class=\"comment\">//print the last element</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i, v := <span class=\"keyword\">range</span> a &#123;</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">\"%d %d\\n\"</span>, i, v)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> _, v := <span class=\"keyword\">range</span> a &#123;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%d\"</span>, v)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>array中的元素默认初始化为zero value。</p>\n<p>可以用<code>...</code>来根据初始化元素个数来自动确定array的元素个数</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">q := [...]<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;</span><br><span class=\"line\">fmt.Println(<span class=\"string\">\"%T\\n\"</span>, q) <span class=\"comment\">// \"[3]int\"</span></span><br></pre></td></tr></table></figure>\n<p>array的元素个数也是包含在类型信息中的，因此<code>[3]int</code>和<code>[4]int</code>是不同的类型，array声明时候指定的个数必须是const表达式，在编译期间就能确定其值。</p>\n<p>可以通过下表初始化指定的下表的值，例如</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">r := [...]<span class=\"keyword\">int</span>&#123;<span class=\"number\">99</span>:<span class=\"number\">-1</span>&#125;</span><br></pre></td></tr></table></figure>\n<p>这条语句就最后一个元素声明为-1，前99个元素为默认的0。</p>\n<p>如果array的元素是可比较的，那么array是可比较的，并且只有同类型的array才能比较，其中类型包含size信息。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a := [<span class=\"number\">2</span>]<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;</span><br><span class=\"line\">b := [...]<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;</span><br><span class=\"line\">c := [<span class=\"number\">3</span>]<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;</span><br><span class=\"line\">fmt.Println(a == b) <span class=\"comment\">// true</span></span><br><span class=\"line\">fmt.Println(a == c) <span class=\"comment\">// compile error</span></span><br></pre></td></tr></table></figure>\n<p>在GO中，array作为函数参数是传值的，即会将array拷贝给函数参数，然后函数内部修改不会改变原来的array，例如</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> a [<span class=\"number\">3</span>]<span class=\"keyword\">int</span> = [<span class=\"number\">3</span>]<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;</span><br><span class=\"line\">\tadd(a)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, v := <span class=\"keyword\">range</span> a &#123;</span><br><span class=\"line\">\t\tfmt.Println(v)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">add</span><span class=\"params\">(a [3]<span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\ta[<span class=\"number\">0</span>] += <span class=\"number\">1</span></span><br><span class=\"line\">\ta[<span class=\"number\">1</span>] += <span class=\"number\">1</span></span><br><span class=\"line\">\ta[<span class=\"number\">2</span>] += <span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, v := <span class=\"keyword\">range</span> a &#123;</span><br><span class=\"line\">\t\tfmt.Println(v)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果需要修改array元素的值，则必须通过array的指针来完成。</p>\n<p>array的缺点：</p>\n<ol>\n<li>大小是固定的，不可删除或增加元素</li>\n<li>修改内部的值必须通过指针操作，比较麻烦</li>\n</ol>\n<p>因此，在GO中，大部分时间都会用slice。</p>\n<h2 id=\"4-2-Slices\"><a href=\"#4-2-Slices\" class=\"headerlink\" title=\"4.2 Slices\"></a>4.2 Slices</h2><p>slice是可变长度的串，一般写成<code>[]T</code>,其中元素的类型是<code>T</code>。</p>\n<p>slice可以表示一个array的子串。通常，slice包含三个组件：pointer，length和capacity，其中pointer指向第一个元素，length表示slice的元素个数，capacity表示slice的长度限制。内置的<code>len</code>和<code>cap</code>可以获取slice的length和capacity。</p>\n<p>多个slice可以共享底层的array，slice指向底层的array，如果把slice传递给函数参数，那么是可以达到修改底层array元素的目的的，例如</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\ta := [...]<span class=\"keyword\">int</span>&#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>&#125;</span><br><span class=\"line\">\treverse(a[:])</span><br><span class=\"line\">\tfmt.Println(a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">reverse</span><span class=\"params\">(a []<span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i, j := <span class=\"number\">0</span>, <span class=\"built_in\">len</span>(a)<span class=\"number\">-1</span>; i &lt; j; i, j = i+<span class=\"number\">1</span>, j<span class=\"number\">-1</span> &#123;</span><br><span class=\"line\">\t\ta[i], a[j] = a[j], a[i]</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">charles@Charles-PC:~/code/<span class=\"keyword\">go</span>/bin$ ./slice </span><br><span class=\"line\">[<span class=\"number\">5</span> <span class=\"number\">4</span> <span class=\"number\">3</span> <span class=\"number\">2</span> <span class=\"number\">1</span> <span class=\"number\">0</span>]</span><br></pre></td></tr></table></figure>\n<p>创建slice的时候，不需要指定元素的个数，初始化的时候，隐式的创建了一个array，并把slice指向它。对于slice来讲，它互相是<strong>不可比较的</strong>。</p>\n<p>因为slice会随着底层array的元素值变化而变化，因此，对于slice来讲，不能作为map的key。<strong>建议禁止slice之间的比较</strong>,最多只能让slice和nil做比较，如下</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s[] <span class=\"keyword\">int</span> <span class=\"comment\">//len(s) == 0, s == nil</span></span><br><span class=\"line\">s = <span class=\"literal\">nil</span> <span class=\"comment\">//len(s) == 0, s == nil</span></span><br><span class=\"line\">s = []<span class=\"keyword\">int</span>(<span class=\"literal\">nil</span>) <span class=\"comment\">//len(s) == 0, s == nil</span></span><br><span class=\"line\">s = []<span class=\"keyword\">int</span>&#123;&#125; <span class=\"comment\">//len(s) == 0, s != nil</span></span><br></pre></td></tr></table></figure>\n<p>判断slice是否为空，应该用<code>len(s) == 0</code>来判断。除了判断是否为空，其他情况下nil和空的slice表现一致，因此reverse(nil)是可以正常工作的。</p>\n<p>内置的make函数，可以指定type，length和capacity，如下</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">make</span>([]T, <span class=\"built_in\">len</span>)</span><br><span class=\"line\"><span class=\"built_in\">make</span>([]T, <span class=\"built_in\">len</span> ,<span class=\"built_in\">cap</span>)</span><br></pre></td></tr></table></figure>\n<p>在实现中，make也是创建一个array，然后返回一个指向它的引用。第一种make下，len就包含了整个array；第二中make，只有cap才能包含整个array。</p>\n<h3 id=\"4-2-1-The-append-function\"><a href=\"#4-2-1-The-append-function\" class=\"headerlink\" title=\"4.2.1 The append function\"></a>4.2.1 The append function</h3><p>内置的append函数可以添加元素到slice，为了更好的理解append是如何工作的，实现一个特殊化的appendInt函数来说明。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">appendInt</span><span class=\"params\">(x []<span class=\"keyword\">int</span>, y <span class=\"keyword\">int</span>)</span> []<span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> z []<span class=\"keyword\">int</span></span><br><span class=\"line\">\tzlen := <span class=\"built_in\">len</span>(x) + <span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> zlen &lt;= <span class=\"built_in\">cap</span>(x) &#123;</span><br><span class=\"line\">\t\tz = x[:zlen]</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tzcap := zlen</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> zcap &lt; <span class=\"number\">2</span>*<span class=\"built_in\">len</span>(x) &#123;</span><br><span class=\"line\">\t\t\tzcap = <span class=\"number\">2</span> * <span class=\"built_in\">len</span>(x)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tz = <span class=\"built_in\">make</span>([]<span class=\"keyword\">int</span>, zlen, zcap)</span><br><span class=\"line\">\t\t<span class=\"built_in\">copy</span>(z, x)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tz[<span class=\"built_in\">len</span>(x)] = y</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> z</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> x []<span class=\"keyword\">int</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">20</span>; i++ &#123;</span><br><span class=\"line\">\t\tx = appendInt(x, i)</span><br><span class=\"line\">\t\tfmt.Println(x, <span class=\"built_in\">len</span>(x), <span class=\"built_in\">cap</span>(x))</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>像appendInt一样，内置的append函数也可能按照既定的策略重新分配内存，所以，我们不能假设append之后，slice的内存地址没有发生变化，因此，每次append都要将append的返回值赋值给slice。</p>\n<p>不仅仅是append，任何改变slice的len或者cap值的函数，或者把它指向新的underlying-array的，都需要重新赋值。</p>\n<p>slice的内部定义像下面的结构体</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> IntSlice <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tptr *<span class=\"keyword\">int</span></span><br><span class=\"line\">    <span class=\"built_in\">len</span>, <span class=\"built_in\">cap</span> <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>每次要改变slice的值，都必须要显式的赋值</p>\n<p>内置的append还可以一次性的追加多个元素。</p>\n<h3 id=\"4-2-2-In-Place-Slice-Techniques\"><a href=\"#4-2-2-In-Place-Slice-Techniques\" class=\"headerlink\" title=\"4.2.2 In-Place Slice Techniques\"></a>4.2.2 In-Place Slice Techniques</h3><p>在本地修改slice，避免重新分配underlying-array。</p>\n<p>本节以几个例子说明，第一个是nonempty，字符串列表中，返回非空的字符串列表。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">nonempty</span><span class=\"params\">(strings []<span class=\"keyword\">string</span>)</span> []<span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">\ti := <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, s := <span class=\"keyword\">range</span> <span class=\"keyword\">string</span> &#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">if</span> s != <span class=\"string\">\"\"</span> &#123;</span><br><span class=\"line\">        \tstrings[i] = s</span><br><span class=\"line\">            i++</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">nonempty2</span><span class=\"params\">(strings []<span class=\"keyword\">string</span>)</span> []<span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">\tout := strings[:<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, s := <span class=\"keyword\">range</span> strings &#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">if</span> s ！= “” &#123;</span><br><span class=\"line\">        \tout = <span class=\"built_in\">append</span>(out, s)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>还可以用append来实现一个stack</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stack = <span class=\"built_in\">append</span>(stack, v) <span class=\"comment\">//push</span></span><br><span class=\"line\">top := stack[<span class=\"built_in\">len</span>(stack) - <span class=\"number\">1</span>] <span class=\"comment\">// top of stack</span></span><br><span class=\"line\">stack = stack[:<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>] <span class=\"comment\">// pop</span></span><br></pre></td></tr></table></figure>\n<p>从字符串列表中间删掉一个字符串</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">remove</span><span class=\"params\">(slice []<span class=\"keyword\">int</span>, i <span class=\"keyword\">int</span>)</span> []<span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">copy</span>(slice[i:], slice[i+<span class=\"number\">1</span>:])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> slice[:<span class=\"built_in\">len</span>(slice)<span class=\"number\">-1</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\ts := <span class=\"keyword\">int</span> &#123;<span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>&#125;</span><br><span class=\"line\">    fmt.Println(remove(s, <span class=\"number\">2</span>)) <span class=\"comment\">//[5, 6, 8, 9]</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-3-Maps\"><a href=\"#4-3-Maps\" class=\"headerlink\" title=\"4.3 Maps\"></a>4.3 Maps</h2><p>在Go中，map是hash table的引用，map类型写成map[K]V，对于K，需要能使用==进行比较。</p>\n<p>map的创建方式</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ages := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span>)</span><br><span class=\"line\">ages[<span class=\"string\">\"alice\"</span>] = <span class=\"number\">31</span></span><br><span class=\"line\">ages[<span class=\"string\">\"charlie\"</span>] = <span class=\"number\">34</span></span><br><span class=\"line\"></span><br><span class=\"line\">ages := <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span> &#123;</span><br><span class=\"line\">\t<span class=\"string\">\"alice\"</span> : <span class=\"number\">31</span>,</span><br><span class=\"line\">    <span class=\"string\">\"charlie\"</span>: <span class=\"number\">34</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>map元素的访问和删除</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ages[<span class=\"string\">\"alice\"</span>] = <span class=\"number\">32</span> <span class=\"comment\">// access</span></span><br><span class=\"line\"><span class=\"built_in\">delete</span>(ages, <span class=\"string\">\"alice\"</span>) <span class=\"comment\">//delete</span></span><br></pre></td></tr></table></figure>\n<p>访问不在map中的key，会返回zero value。注意，map不是变量，所以不能对其元素进行取地址，原因是hash table可能会动态变化，导致原来的地址失效。</p>\n<p>map的遍历</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> name, age := <span class=\"keyword\">range</span> ages &#123;</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">\"%s:%d\"</span>, name, age)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>map的遍历的顺序是随机的，所以，我们不能假设它按照某个特定的顺序来遍历。</p>\n<p>map的zero value是nil，即没有引用任何的hash table。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ages <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>] <span class=\"keyword\">int</span></span><br><span class=\"line\">fmt.Println(ages == <span class=\"literal\">nil</span>)</span><br><span class=\"line\">fmt.Println(<span class=\"built_in\">len</span>(ages) == <span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure>\n<p>对于nil的map，delete，len和range都可以正常的工作，但是，往里面存数据就会panic。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ages <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>] <span class=\"keyword\">int</span></span><br><span class=\"line\">ages[<span class=\"string\">\"carol\"</span>] = <span class=\"number\">21</span> <span class=\"comment\">// panic</span></span><br></pre></td></tr></table></figure>\n<p>有时候，需要判断某个key是否存在map中，需要使用下面的测试</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">age, ok := ages[<span class=\"string\">\"bob\"</span>]</span><br><span class=\"line\"><span class=\"keyword\">if</span> !ok &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//不存在</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>map不能比较，需要自己写函数遍历key来依次比较。</p>\n<p>GO语言中没有set，可以用map[string]bool来代替。</p>\n<p>有时候，我们希望slice作为key，但是slice类型是不能比较的，需要自己写函数，例如</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> m = <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">k</span><span class=\"params\">(list []<span class=\"keyword\">string</span>)</span> <span class=\"title\">string</span></span> &#123;<span class=\"keyword\">return</span> fmt.Sprintf(<span class=\"string\">\"%q\"</span>, list)&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Add</span><span class=\"params\">(list []<span class=\"keyword\">string</span>)</span></span> &#123;m[k(list)]++&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Count</span><span class=\"params\">(list []<span class=\"keyword\">string</span>)</span> <span class=\"title\">int</span></span> &#123;<span class=\"keyword\">return</span> m[k(list)]&#125;</span><br></pre></td></tr></table></figure>\n<p>对于其他不可比较的类型，也可以采用本方法，并且k(x)不一定要是string，可以计算成任何可以比较的类型。</p>\n<h2 id=\"4-4-Structs\"><a href=\"#4-4-Structs\" class=\"headerlink\" title=\"4.4 Structs\"></a>4.4 Structs</h2><p>struct把0个或多个类型聚合在一起，每个都叫做field，例如</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Employee <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tID <span class=\"keyword\">int</span></span><br><span class=\"line\">    Name <span class=\"keyword\">string</span></span><br><span class=\"line\">    Address <span class=\"keyword\">string</span></span><br><span class=\"line\">    DoB time.Time</span><br><span class=\"line\">    Position <span class=\"keyword\">string</span></span><br><span class=\"line\">    Salary <span class=\"keyword\">int</span></span><br><span class=\"line\">    ManagerID <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> dillbert Employee</span><br><span class=\"line\">dilbert.Salary = <span class=\"number\">5000</span></span><br></pre></td></tr></table></figure>\n<p>可以用<code>.</code>来访问struct里面的变量，值得说明的是，指针也能用<code>.</code>访问内部的field。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> employOfTheMonth *employee = &amp;dilbert</span><br><span class=\"line\">employOfTheMonth.Postion += <span class=\"string\">\"(proactive team player)\"</span></span><br></pre></td></tr></table></figure>\n<p>上面的指针访问等价于</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(*employeeOfTheMonth).Position += <span class=\"string\">\"(proactive team player)\"</span></span><br></pre></td></tr></table></figure>\n<p>field的顺序和类型关系很大，如果改变了它们的位置，就是另一种类型了。</p>\n<p>struct中的field如果是大写的话，那么是export的，否则不是。</p>\n<p>struct中不能定义自身，但是可以定义自身的指针，例如</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> tree <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tvalue <span class=\"keyword\">int</span></span><br><span class=\"line\">    left, right *tree</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>struct的zero value是其中所有的field都是zero value。</p>\n<p>struct中如果没有field，则是empty struct，写成<code>struct {}</code>。</p>\n<h3 id=\"4-4-1-Struct-Literals\"><a href=\"#4-4-1-Struct-Literals\" class=\"headerlink\" title=\"4.4.1 Struct Literals\"></a>4.4.1 Struct Literals</h3><p>struct literal有两种，如下</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Point <span class=\"keyword\">struct</span> &#123;X, Y <span class=\"keyword\">int</span>&#125;</span><br><span class=\"line\">p := Point&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;</span><br><span class=\"line\">p := Point&#123;X : <span class=\"number\">1</span>&#125;</span><br></pre></td></tr></table></figure>\n<p>如果struct不是export的，则不可以在package外声明它</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> p</span><br><span class=\"line\"><span class=\"keyword\">type</span> T <span class=\"keyword\">struct</span> &#123;a, b <span class=\"keyword\">int</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">package</span> q</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"p\"</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> _ = p.T&#123;a : <span class=\"number\">1</span>, b : <span class=\"number\">2</span>&#125; <span class=\"comment\">//compile error</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> _ = p.T&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125; <span class=\"comment\">// compile error</span></span><br></pre></td></tr></table></figure>\n<p>尽管最后一行没有使用unexported的field，但是它隐式地使用它们了。</p>\n<p>struct作为函数参数是值传递的，如果是大的struct，最好使用指针来传递，这样可以提升效率。</p>\n<p>因为struct经常使用指针所以可以用如下声明</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pp ：= &amp;Point&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">pp := <span class=\"built_in\">new</span>(Point)</span><br><span class=\"line\">*pp = Point&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-4-2-Comparing-Structs\"><a href=\"#4-4-2-Comparing-Structs\" class=\"headerlink\" title=\"4.4.2 Comparing Structs\"></a>4.4.2 Comparing Structs</h3><p>当struct的所有field都可以比较时，则struct本身也是可比较的。</p>\n<h3 id=\"4-4-3-Struct-Embedding-and-Anonymous-Fields\"><a href=\"#4-4-3-Struct-Embedding-and-Anonymous-Fields\" class=\"headerlink\" title=\"4.4.3 Struct Embedding and Anonymous Fields\"></a>4.4.3 Struct Embedding and Anonymous Fields</h3><p>通过在struct内部定义匿名的struct，可以快速访问到底层struct的field，如下</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Point <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tX, Y <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> Circle <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tCenter Point</span><br><span class=\"line\">    Radius <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> Wheel <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tC Circle</span><br><span class=\"line\">    Spokes <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> w Wheel</span><br><span class=\"line\">w.C.Center.X = <span class=\"number\">8</span></span><br></pre></td></tr></table></figure>\n<p>可以看出，从Wheel变量中，要访问Point的X需要使用三个<code>.</code>，书写效率比较低，可以使用以下方式解决</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Circle <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tPoint</span><br><span class=\"line\">    Radius <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> Wheel <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tCircle</span><br><span class=\"line\">    Spokes <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> w Wheel</span><br><span class=\"line\">w.X = <span class=\"number\">8</span></span><br><span class=\"line\">w.Y = <span class=\"number\">8</span></span><br><span class=\"line\">w.Radius = <span class=\"number\">9</span></span><br></pre></td></tr></table></figure>\n<p>使用上述方法可以快速访问到内部结构体中的field，但是这种方式对于struct literal是不行的</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">w = Wheel &#123;<span class=\"number\">8</span>, <span class=\"number\">8</span>, <span class=\"number\">5</span>, <span class=\"number\">20</span>&#125; <span class=\"comment\">//compile error</span></span><br><span class=\"line\">w = Wheel &#123;X : <span class=\"number\">8</span>, Y : <span class=\"number\">8</span>, Radius: <span class=\"number\">5</span>, Spokes: <span class=\"number\">20</span>&#125; <span class=\"comment\">//compile error</span></span><br><span class=\"line\">w = Wheel &#123;Circle&#123;Point&#123;<span class=\"number\">8</span>, <span class=\"number\">8</span>&#125;, <span class=\"number\">5</span>&#125;, <span class=\"number\">20</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">w = Wheel &#123;</span><br><span class=\"line\">\tCircle : Circle &#123;</span><br><span class=\"line\">    \tPoint : Point &#123;X:<span class=\"number\">8</span>, Y:<span class=\"number\">8</span>&#125;</span><br><span class=\"line\">        Radius : <span class=\"number\">5</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    Spokes: <span class=\"number\">20</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>匿名的同类型的struct，只能出现在一个struct内一次，否则无法区分它们。</p>\n<h2 id=\"4-5-JSON\"><a href=\"#4-5-JSON\" class=\"headerlink\" title=\"4.5 JSON\"></a>4.5 JSON</h2><p>JSON是 JavaScript Object Notation的缩写。GO的标准库中有<code>encoding/json</code>来处理JSON格式，本节就是关于这个package相关的知识。</p>\n<p>JSON中基础类型包括numbers(decimal或scientific notation)，booleans(true or false)和strings。</p>\n<p>JSON有array和object，array以方括号扩起来，并且逗号分割的一系列元素；object是string到value的mapping， 例如</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">boolean <span class=\"literal\">true</span></span><br><span class=\"line\">number <span class=\"number\">-273.15</span></span><br><span class=\"line\"><span class=\"keyword\">string</span> <span class=\"string\">\"she said hello world\"</span></span><br><span class=\"line\">array [<span class=\"string\">\"gold\"</span>, <span class=\"string\">\"siliver\"</span>]</span><br><span class=\"line\">object &#123;<span class=\"string\">\"year\"</span> : <span class=\"number\">1980</span>,</span><br><span class=\"line\">\t\t<span class=\"string\">\"event\"</span>: <span class=\"string\">\"archery\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"medals\"</span>: [<span class=\"string\">\"gold\"</span>, <span class=\"string\">\"silver\"</span>]&#125;</span><br></pre></td></tr></table></figure>\n<p>JSON的array可以用来编码GO的array和slice；而JSON的object可以用来编码GO的map(string作为key)和struct(不明白怎么编码？)。</p>\n<p>由GO数据结构转换成JSON的过程称为marshaling，通过<code>json.Marshal</code>函数实现，如下</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"encoding/json\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"log\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Movie <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tTitle  <span class=\"keyword\">string</span></span><br><span class=\"line\">\tYear   <span class=\"keyword\">int</span>  <span class=\"string\">`json:“released”`</span></span><br><span class=\"line\">\tColor  <span class=\"keyword\">bool</span> <span class=\"string\">`json:\"color,omitempty\"`</span></span><br><span class=\"line\">\tActors []<span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> movies = []Movie&#123;</span><br><span class=\"line\">\t\t&#123;Title: <span class=\"string\">\"Casablana\"</span>, Year: <span class=\"number\">1942</span>, Color: <span class=\"literal\">false</span>, Actors: []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"A\"</span>, <span class=\"string\">\"B\"</span>&#125;&#125;,</span><br><span class=\"line\">\t\t&#123;Title: <span class=\"string\">\"Casablana2\"</span>, Year: <span class=\"number\">1943</span>, Color: <span class=\"literal\">true</span>, Actors: []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"A\"</span>, <span class=\"string\">\"B\"</span>&#125;&#125;,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tdata, err := json.Marshal(movies)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Fatalf(<span class=\"string\">\"JSON Marshaling failed: %s\"</span>, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%s\\n\"</span>, data)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">charles@Charles-PC:~/code/<span class=\"keyword\">go</span>$ bin/json </span><br><span class=\"line\">[&#123;<span class=\"string\">\"Title\"</span>:<span class=\"string\">\"Casablana\"</span>,<span class=\"string\">\"released\"</span>:<span class=\"number\">1942</span>,<span class=\"string\">\"Actors\"</span>:[<span class=\"string\">\"A\"</span>,<span class=\"string\">\"B\"</span>]&#125;,&#123;<span class=\"string\">\"Title\"</span>:<span class=\"string\">\"Casablana2\"</span>,<span class=\"string\">\"released\"</span>:<span class=\"number\">1943</span>,<span class=\"string\">\"color\"</span>:<span class=\"literal\">true</span>,<span class=\"string\">\"Actors\"</span>:[<span class=\"string\">\"A\"</span>,<span class=\"string\">\"B\"</span>]&#125;]</span><br></pre></td></tr></table></figure>\n<p>上面的字符串如果多了的话，可读性不是很强，可以用<code>MarshalIndent</code>来生成一个可读性较强的。</p>\n<p>GO只会对exported的field做Marshal。从上面的输出可以看出，Year转成了released的输出，Color转换成color，并且在为false的时候，不输出，这都是由它们字段后面的json标记控制的。</p>\n<p>Marshaling的反操作为unmarshaling，即把JSON结构转成GO的结构体，通过<code>json.Unmarshal</code>来实现。Unmarshaling的时候，可以选择需要的字段来做解码，如下</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> titles []<span class=\"keyword\">struct</span>&#123;Title <span class=\"keyword\">string</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> err := json.Unmarshal(data, &amp;title); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\tlog.Fatalf(<span class=\"string\">\"JSON unmarshaling failed:%s\"</span>, err)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fmt.Println(titles)</span><br></pre></td></tr></table></figure>\n<p>如上所示，只会把Title字段解析出来，其余字段会被略去。</p>\n<h2 id=\"4-6-Text-and-HTML-Templates\"><a href=\"#4-6-Text-and-HTML-Templates\" class=\"headerlink\" title=\"4.6 Text and HTML Templates\"></a>4.6 Text and HTML Templates</h2><p>除了简单的Printf外，GO还提供了强大的模板库，例如<code>text/template</code>和<code>html/template</code>，模板库本身有自己的语言规则，例如，一个简单的例子为</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> templ = <span class=\"string\">`&#123;&#123;.TotalCount&#125;&#125; issues:</span></span><br><span class=\"line\"><span class=\"string\">&#123;&#123;range.Items&#125;&#125;----------------------------------</span></span><br><span class=\"line\"><span class=\"string\">Number : &#123;&#123;.Number&#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\">User : &#123;&#123;.User.Login&#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\">Title : &#123;&#123;.Title | printf \".64s\"&#125;</span></span><br><span class=\"line\"><span class=\"string\">Age : &#123;&#123;.CreateAT | daysAgo&#125;&#125; days</span></span><br><span class=\"line\"><span class=\"string\">&#123;&#123;end&#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">function daysAgo(t time.Time) int &#123;</span></span><br><span class=\"line\"><span class=\"string\">\treturn int(time.Since(t).Hours() / 24)</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>上面的range和end，表示中间是一个循环。 <code>.CreateAT | daysAgo</code>表示讲CreateAT作为参数传入daysAgo函数处理。</p>\n<p>产生输出需要两个步骤</p>\n<ol>\n<li>解析模板</li>\n<li>在特定输入下执行模板</li>\n</ol>\n<p>解析模板只需要做一次，后面就可以无限制地执行模板，具体的例子如下</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> report = template.Must(template.New(<span class=\"string\">\"issue-list\"</span>)).Funcs(template.FuncMap&#123;<span class=\"string\">\"daysAgo\"</span>: daysAgo&#125;).Parse(templ)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tresult, err := github.SearchIssues(os.Args[<span class=\"number\">1</span>:])</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    \tlog.Fatal(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err := report.Execute(os.Stdout, result); err ！= <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    \tlog.Fatal(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的是Text模板，HTML模板与之不同的是，里面可以写HTML标签，它会输入的动态数据做自动的转义，防止JS注入等攻击，例子如下</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"html/template\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> issueList = template.Must(template.New(<span class=\"string\">\"issuelist\"</span>).Parse(<span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">&lt;h1&gt;&#123;&#123;.TotalCount&#125;&#125; issues&lt;/h1&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;table&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;tr style='text-align: left'&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;th&gt;#&lt;/th&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;th&gt;State&lt;/th&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;th&gt;User&lt;/th&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;th&gt;Title&lt;/th&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/tr&gt;</span></span><br><span class=\"line\"><span class=\"string\">&#123;&#123;range .Items&#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\">&lt;tr&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;td&gt;&lt;a href='&#123;&#123;.HTMLURL&#125;&#125;'&gt;&#123;&#123;.Number&#125;&#125;&lt;/a&gt;&lt;/td&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;td&gt;&#123;&#123;.State&#125;&#125;&lt;/td&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;td&gt;&lt;a href='&#123;&#123;.User.HTMLURL&#125;&#125;'&gt;&#123;&#123;.User.Login&#125;&#125;&lt;/a&gt;&lt;/td&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;td&gt;&lt;a href='&#123;&#123;.HTMLURL&#125;&#125;'&gt;&#123;&#123;.Title&#125;&#125;&lt;/a&gt;&lt;/td&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/tr&gt;</span></span><br><span class=\"line\"><span class=\"string\">&#123;&#123;end&#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/table&gt;</span></span><br><span class=\"line\"><span class=\"string\">`</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//!-template</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//!+</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tresult, err := github.SearchIssues(os.Args[<span class=\"number\">1</span>:])</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Fatal(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err := issueList.Execute(os.Stdout, result); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Fatal(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjdzqngr7000248kchfztmwiw","category_id":"cjdzqngr7000448kccrne1wd0","_id":"cjdzqngrr000948kc0lguq15d"}],"PostTag":[{"post_id":"cjdzqngr7000248kchfztmwiw","tag_id":"cjdzqngrh000548kcfvi3d8y3","_id":"cjdzqngrr000848kc9ulpfwup"}],"Tag":[{"name":"golang","_id":"cjdzqngrh000548kcfvi3d8y3"}]}}