{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next/source/CNAME","path":"CNAME","modified":0,"renderable":1},{"_id":"source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":0},{"_id":"source/images/arraylist/ArrayList_add.png","path":"images/arraylist/ArrayList_add.png","modified":0,"renderable":0},{"_id":"source/images/arraylist/ArrayList_base.png","path":"images/arraylist/ArrayList_base.png","modified":0,"renderable":0},{"_id":"source/images/arraylist/ArrayList_grow.png","path":"images/arraylist/ArrayList_grow.png","modified":0,"renderable":0},{"_id":"source/images/hashmap/HashMap_addEntry.png","path":"images/hashmap/HashMap_addEntry.png","modified":0,"renderable":0},{"_id":"source/images/hashmap/HashMap_base.png","path":"images/hashmap/HashMap_base.png","modified":0,"renderable":0},{"_id":"source/images/hashmap/HashMap_getEntry.png","path":"images/hashmap/HashMap_getEntry.png","modified":0,"renderable":0},{"_id":"source/images/jvm/array.jpg","path":"images/jvm/array.jpg","modified":0,"renderable":0},{"_id":"source/images/jvm/jvm_heap.jpg","path":"images/jvm/jvm_heap.jpg","modified":0,"renderable":0},{"_id":"source/images/jvm/jvm_struct.jpg","path":"images/jvm/jvm_struct.jpg","modified":0,"renderable":0},{"_id":"source/images/jvm/jvm_struct2.jpg","path":"images/jvm/jvm_struct2.jpg","modified":0,"renderable":0},{"_id":"source/images/linklist/LinkedList_add.png","path":"images/linklist/LinkedList_add.png","modified":0,"renderable":0},{"_id":"source/images/linklist/LinkedList_base.png","path":"images/linklist/LinkedList_base.png","modified":0,"renderable":0},{"_id":"source/images/linklist/LinkedList_remove.png","path":"images/linklist/LinkedList_remove.png","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"source/images/hashmap/HashMap_removeEntryForKey.png","path":"images/hashmap/HashMap_removeEntryForKey.png","modified":0,"renderable":0},{"_id":"source/images/threadpool/工作流程.jpg","path":"images/threadpool/工作流程.jpg","modified":0,"renderable":0},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/LICENSE","path":"vendors/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/README.md","path":"vendors/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/bower.json","path":"vendors/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/HELP-US-OUT.txt","path":"vendors/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/bower.json","path":"vendors/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/CONTRIBUTING.md","path":"vendors/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/bower.json","path":"vendors/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.lazyload.js","path":"vendors/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.scrollstop.js","path":"vendors/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/bower.json","path":"vendors/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","path":"vendors/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","path":"vendors/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","path":"vendors/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/README.md","path":"vendors/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery/index.js","path":"vendors/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","path":"vendors/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","path":"vendors/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css","path":"vendors/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.min.css","path":"vendors/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css.map","path":"vendors/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.min.js","path":"vendors/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.pack.js","path":"vendors/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","path":"vendors/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","path":"vendors/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","path":"vendors/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","path":"vendors/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","path":"vendors/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","path":"vendors/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","path":"vendors/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","path":"vendors/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","path":"vendors/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","path":"vendors/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/FontAwesome.otf","path":"vendors/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.js","path":"vendors/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","path":"vendors/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","path":"vendors/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","path":"vendors/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"source/images/synchronized/lockstatus.png","path":"images/synchronized/lockstatus.png","modified":0,"renderable":0},{"_id":"source/images/synchronized/object.png","path":"images/synchronized/object.png","modified":0,"renderable":0},{"_id":"source/images/synchronized/thread.png","path":"images/synchronized/thread.png","modified":0,"renderable":0},{"_id":"source/images/synchronized/syn_class.png","path":"images/synchronized/syn_class.png","modified":0,"renderable":0},{"_id":"source/images/docker/docker_struct.png","path":"images/docker/docker_struct.png","modified":0,"renderable":0},{"_id":"source/images/blockchain/arch.png","path":"images/blockchain/arch.png","modified":0,"renderable":0},{"_id":"source/images/blockchain/blockchain.png","path":"images/blockchain/blockchain.png","modified":0,"renderable":0},{"_id":"source/images/binarysearch/example1.png","path":"images/binarysearch/example1.png","modified":0,"renderable":0},{"_id":"source/images/binarysearch/example2.png","path":"images/binarysearch/example2.png","modified":0,"renderable":0},{"_id":"source/images/concurrentHashMap/image004.jpg","path":"images/concurrentHashMap/image004.jpg","modified":0,"renderable":0},{"_id":"source/images/concurrentHashMap/image005.jpg","path":"images/concurrentHashMap/image005.jpg","modified":0,"renderable":0}],"Cache":[{"_id":"source/404.html","hash":"3451ccd3230a849cf30ec06f4b2ca7ab4f11002d","modified":1519352794864},{"_id":"themes/next/.bowerrc","hash":"80e096fdc1cf912ee85dd9f7e6e77fd40cf60f10","modified":1508643418000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1508643418000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1508643418000},{"_id":"themes/next/.javascript_ignore","hash":"d619ee13031908cd72666e4ff652d2ea3483b1c3","modified":1508643418000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1508643418000},{"_id":"themes/next/README.en.md","hash":"565ba52b3825b85a9f05b41183caca7f18b741d4","modified":1508643418000},{"_id":"themes/next/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1508643418000},{"_id":"themes/next/_config.yml","hash":"1910e5e86015e6436b8f7a440c572836f8ce0371","modified":1519439061745},{"_id":"themes/next/bower.json","hash":"f89c6700a11d81e067cc97273ca6bf96cb88c8f9","modified":1508643418000},{"_id":"themes/next/gulpfile.coffee","hash":"26e5b1b945704c8bc78b928feede895c4c111c95","modified":1508643418000},{"_id":"themes/next/package.json","hash":"63e9c0f1dd9e5d7f51b4ae383981ef939a2ed45d","modified":1508643418000},{"_id":"source/404/index.md","hash":"1f081d7129ecc5880d0992fe90ec98c2fc7547a8","modified":1519352794865},{"_id":"source/_discarded/Java垃圾回收探究-1.md","hash":"793a49266c2c2cc587b203af0e42d57e6bfa627e","modified":1519884577392},{"_id":"source/_posts/HashMap.md","hash":"1f5a14ea185860abd2f7760559975e43bf19045f","modified":1519460303594},{"_id":"source/_discarded/test.md","hash":"774cfc05535907eb94710066526ca07eb47d39aa","modified":1519372586926},{"_id":"source/_posts/Javagc.md","hash":"40a4e84918e93c0c73c949237809dfced6fc17ed","modified":1519894103213},{"_id":"source/_posts/LinkedList.md","hash":"ee427a00f6312e5b7bdb1f39918dac8ed8528447","modified":1519611748180},{"_id":"source/_posts/synchronized_lock.md","hash":"b38b12f364939dd042a39cb601bd2f7bec6734f9","modified":1520318089296},{"_id":"source/_posts/threadpool.md","hash":"306bebc3e53de519d0c4f8b0e5d82c066ef17f8a","modified":1519712767449},{"_id":"source/about/index.md","hash":"e8767a0fef74236301e5accbe8ee40e39239bd3c","modified":1519366891902},{"_id":"source/_posts/arraylist.md","hash":"f8b1eb7d03b20dac7c232d3154aa43a7727648ef","modified":1519459612023},{"_id":"source/categories/index.md","hash":"ab753cae0f9eac08fb93a3fa4f373f70e7a1ebb4","modified":1519366922707},{"_id":"source/_posts/jvm_memory.md","hash":"f2cfa62b2ab0f1b43790671feb8eee32b6c0a78c","modified":1519868209979},{"_id":"source/tags/index.md","hash":"eec0aee6a3da51eca76d405b84b6d23ea9c2faaa","modified":1519366954155},{"_id":"themes/next/languages/de.yml","hash":"786afba25cfc98845a20d9901823ebeebcd1cbbf","modified":1508643418000},{"_id":"themes/next/languages/default.yml","hash":"9db835c0543ade5a89bc80ec5a898203227cf3d8","modified":1508643418000},{"_id":"themes/next/languages/fr-FR.yml","hash":"1a084623c39de74301f3e92f9388a3a815a542ca","modified":1508643418000},{"_id":"themes/next/languages/en.yml","hash":"f03799cbdb5a33064ead080bcac4baca1f6bc5f9","modified":1508643418000},{"_id":"themes/next/languages/id.yml","hash":"147c01e41b931085ad14250fa900c2249dcbbdd7","modified":1508643418000},{"_id":"themes/next/languages/ja.yml","hash":"a2c7b6301b5474aab798946fb700289df237c3cf","modified":1508643418000},{"_id":"themes/next/languages/pt.yml","hash":"ca239b39bf65c9462e59d51b12f0fe566d453197","modified":1508643418000},{"_id":"themes/next/languages/ru.yml","hash":"cc7b964a46587aea0e57b0a5269d8fd25570858e","modified":1508643418000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"bea452bc49aed171a210d09bd6cddc4e846ea8ab","modified":1508643418000},{"_id":"themes/next/languages/zh-hk.yml","hash":"519ab3d817ec3bc5bfc91159c494b6b3c170bea7","modified":1508643418000},{"_id":"themes/next/languages/zh-tw.yml","hash":"6b1f345aaefc13e6723dc8a6741b59ac05c20dfd","modified":1508643418000},{"_id":"themes/next/layout/_layout.swig","hash":"74157f6cfd679ea11febec632542793f37c5e5d4","modified":1508643418000},{"_id":"themes/next/layout/archive.swig","hash":"b5b59d70fc1563f482fa07afd435752774ad5981","modified":1508643418000},{"_id":"themes/next/layout/category.swig","hash":"6422d196ceaff4220d54b8af770e7e957f3364ad","modified":1508643418000},{"_id":"themes/next/layout/index.swig","hash":"427d0b95b854e311ae363088ab39a393bf8fdc8b","modified":1508643418000},{"_id":"themes/next/layout/page.swig","hash":"8019d02232a6dd1a665b6a4d2daef8e5dd2f0049","modified":1508643418000},{"_id":"themes/next/layout/tag.swig","hash":"07cf49c49c39a14dfbe9ce8e7d7eea3d4d0a4911","modified":1508643418000},{"_id":"themes/next/layout/post.swig","hash":"e2e512142961ddfe77eba29eaa88f4a2ee43ae18","modified":1508643418000},{"_id":"themes/next/source/CNAME","hash":"febc197e98f40f090cef2354869a2bf63921a07c","modified":1519439436313},{"_id":"themes/next/scripts/merge-configs.js","hash":"0c56be2e85c694247cfa327ea6d627b99ca265e8","modified":1508643418000},{"_id":"themes/next/test/.jshintrc","hash":"096ed6df627373edd820f24d46b8baf528dee61d","modified":1508643418000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1508643418000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1508643418000},{"_id":"source/images/avatar.jpg","hash":"ec40dfe5946dedbaced35335bb7267411a84b6bb","modified":1484706302506},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1508643418000},{"_id":"source/images/arraylist/ArrayList_add.png","hash":"6f14151eeba2344a0a5829ce36807cfa94c361c3","modified":1519458350141},{"_id":"source/images/arraylist/ArrayList_base.png","hash":"f031419ae27e024778f116480abf279191dea885","modified":1519458333318},{"_id":"source/images/arraylist/ArrayList_grow.png","hash":"b924e37892279f98b512963160ff0e66dba29911","modified":1519458340117},{"_id":"source/images/hashmap/HashMap_addEntry.png","hash":"413e4049c486c08e4303caf36a8af92b1afedd12","modified":1519460021938},{"_id":"source/images/hashmap/HashMap_base.png","hash":"925e94e3097898d266b8eb1889f07f47b236f860","modified":1519460015550},{"_id":"source/images/hashmap/HashMap_getEntry.png","hash":"660e0faf3eeef4cfe877b22eba4c2bb56590b65b","modified":1519460018646},{"_id":"source/images/jvm/array.jpg","hash":"09569845fccf6b8f54e5b94046823113e51e01eb","modified":1519798317541},{"_id":"source/images/jvm/jvm_heap.jpg","hash":"5527eb3274a46bf8cef51528c125b132ac857077","modified":1519800463882},{"_id":"source/images/jvm/jvm_struct.jpg","hash":"3ba46ae13a36c96bb6fd18a1e721e389839155a0","modified":1519797466835},{"_id":"source/images/jvm/jvm_struct2.jpg","hash":"175c7038a429759c88c31c2f5f22c071d22ca42b","modified":1519798060900},{"_id":"source/images/linklist/LinkedList_add.png","hash":"9e1625a7b779f21d6d33fec6b9446164322062f2","modified":1519611101941},{"_id":"source/images/linklist/LinkedList_base.png","hash":"13adabf1f86405f40b681cf6ea462da7128a7f1d","modified":1519611099098},{"_id":"source/images/linklist/LinkedList_remove.png","hash":"3f6480e185cba1ae835e9f7558bd46113afda2ab","modified":1519611104495},{"_id":"themes/next/layout/_partials/comments.swig","hash":"b73f9443bee2d3ea383aad52e49ffca8aa97dcc2","modified":1508643418000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"0ce71d8322ea7dea82d9371fa2fe13949aa870e3","modified":1508643418000},{"_id":"themes/next/layout/_partials/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1508643418000},{"_id":"themes/next/layout/_partials/head.swig","hash":"f83b1c55bedd2c1a3eb734c72c6997795a4e5f99","modified":1508643418000},{"_id":"themes/next/layout/_partials/header.swig","hash":"963a765dc00e6ac43cfc53ffaf5725eb854cf95e","modified":1508643418000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1508643418000},{"_id":"themes/next/layout/_partials/search.swig","hash":"011b9d6c9f0a2f4654908ea20b9391f9b7981271","modified":1508643418000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"43c3433155ccd9abcbe7dce2e6bfa1f3a66af18b","modified":1508643418000},{"_id":"themes/next/layout/_macro/post.swig","hash":"1ca03011bed92614832b1343b65be92183957dc5","modified":1508643418000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"37e5b7c42ec17b9b6b786c5512bcc481a21c974e","modified":1508643418000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"b883289054ee54a374caad5d4883591beb94bd8b","modified":1508643418000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"85327c2174d09c6d69c9033592e6c8f7eb7ac3ba","modified":1508643418000},{"_id":"themes/next/layout/_scripts/baidu-push.swig","hash":"82d060fe055d6e423bbc9199f82dfe5c68e74779","modified":1508643418000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1508643418000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1508643418000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"0b91cadecead8e0b5211cc42b085998d94af503a","modified":1508643418000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1508643418000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1508643418000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1508643418000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1508643418000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1508643418000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1508643418000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1508643418000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1508643418000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1508643418000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1508643418000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1508643418000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1508643418000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1508643418000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1508643418000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1508643418000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"3acce36db0feb11a982c6c799aa6b6b47df2827c","modified":1508643418000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1508643418000},{"_id":"source/images/hashmap/HashMap_removeEntryForKey.png","hash":"9ff4ce53602c95a6fa8e1bdbb85c2a258d254be6","modified":1519460024927},{"_id":"source/images/threadpool/工作流程.jpg","hash":"c2ea780babdea00adf46a199710c09b9b27f3efc","modified":1519696328516},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1508643418000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1508643418000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1508643418000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1508643418000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1508643418000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1508643418000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1508643418000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"bd07518060a73795d1250d93a74186444b292a9f","modified":1508643418000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"ff5523d5dacaa77a55a24e50e6e6530c3b98bfad","modified":1508643418000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1508643418000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1508643418000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"7ca5cb4daa58b3504e17f3e02975e794bc634658","modified":1508643418000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"c07f7b2f264e5215b8ed42d67e8cef2477558364","modified":1508643418000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1508643418000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1508643418000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1508643418000},{"_id":"themes/next/layout/_scripts/third-party/analytics.swig","hash":"0a89c04055bade7baa5962f1d5aefe438d83a244","modified":1508643418000},{"_id":"themes/next/layout/_scripts/third-party/comments.swig","hash":"907b931d775d32405d02a25b3b0a3ac03bf804d0","modified":1508643418000},{"_id":"themes/next/layout/_scripts/third-party/lean-analytics.swig","hash":"069bb17fb1db3bc7c85c88efa3ed94ab6becbe2c","modified":1508643418000},{"_id":"themes/next/layout/_scripts/third-party/localsearch.swig","hash":"1561bd0c107d725252c6d746e9ac177fc18f93bf","modified":1508643418000},{"_id":"themes/next/layout/_scripts/third-party/mathjax.swig","hash":"5bafc33f57508d1d04a9930165240f6e9efa8d6d","modified":1508643418000},{"_id":"themes/next/layout/_scripts/third-party/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1508643418000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1508643418000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"715d5b40dc52f319fe4bff0325beb874774d9bd9","modified":1508643418000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"78a83c38f69a8747bb74e420e6c9eeef1ea76525","modified":1508643418000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1508643418000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"3ead77befa064d6327dc7afd0a5af7be59a5f196","modified":1508643418000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1508643418000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1508643418000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1508643418000},{"_id":"themes/next/source/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1508643418000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1508643418000},{"_id":"themes/next/source/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1508643418000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1508643418000},{"_id":"themes/next/source/js/src/utils.js","hash":"e5cb720894c4bc28ca8f10b33df127fb394018d9","modified":1508643418000},{"_id":"themes/next/source/vendors/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1508643418000},{"_id":"themes/next/source/vendors/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1508643418000},{"_id":"themes/next/source/vendors/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1508643418000},{"_id":"themes/next/source/vendors/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1508643418000},{"_id":"themes/next/source/vendors/font-awesome/.bower.json","hash":"7da985a99674e54f514d4fd9fcd3bcea6e7e41d5","modified":1508643418000},{"_id":"themes/next/source/vendors/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1508643418000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"85b279027cb0102b0ad6636486f57f754892c5d4","modified":1508643418000},{"_id":"themes/next/source/vendors/font-awesome/HELP-US-OUT.txt","hash":"69a4c537d167b68a0ccf1c6febd138aeffca60d6","modified":1508643418000},{"_id":"themes/next/source/vendors/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1508643418000},{"_id":"themes/next/source/vendors/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1508643418000},{"_id":"themes/next/source/vendors/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1508643418000},{"_id":"themes/next/source/vendors/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1508643418000},{"_id":"themes/next/source/vendors/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1508643418000},{"_id":"themes/next/source/vendors/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1508643418000},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1508643418000},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1508643418000},{"_id":"themes/next/source/vendors/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1508643418000},{"_id":"themes/next/source/vendors/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1508643418000},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1508643418000},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1508643418000},{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1508643418000},{"_id":"themes/next/source/vendors/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1508643418000},{"_id":"themes/next/source/vendors/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"b49efc66bd055a2d0be7deabfcb02ee72a9a28c8","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"10994990d6e0b4d965a728a22cf7f6ee29cae9f6","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1508643418000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1508643418000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5304f99581da3a31de3ecec959b7adf9002fde83","modified":1508643418000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"54c90cf7bdbf5c596179d8dae6e671bad1292662","modified":1508643418000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1508643418000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"013619c472c7e4b08311c464fcbe9fcf5edde603","modified":1508643418000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1508643418000},{"_id":"themes/next/layout/_scripts/third-party/analytics/cnzz-analytics.swig","hash":"44e761721e8ad787ef571a3cc57bbc12d318a2a3","modified":1508643418000},{"_id":"themes/next/layout/_scripts/third-party/analytics/facebook-sdk.swig","hash":"394d008e5e94575280407ad8a1607a028026cbc3","modified":1508643418000},{"_id":"themes/next/layout/_scripts/third-party/analytics/google-analytics.swig","hash":"30a23fa7e816496fdec0e932aa42e2d13098a9c2","modified":1508643418000},{"_id":"themes/next/layout/_scripts/third-party/analytics/baidu-analytics.swig","hash":"7c43d66da93cde65b473a7d6db2a86f9a42647d6","modified":1508643418000},{"_id":"themes/next/layout/_scripts/third-party/analytics/busuanzi-counter.swig","hash":"4fcbf57c4918528ab51d3d042cff92cf5aefb599","modified":1508643418000},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1508643418000},{"_id":"themes/next/layout/_scripts/third-party/comments/disqus.swig","hash":"bff3b18f56175c53f3bc6d733166c4d998e08732","modified":1508643418000},{"_id":"themes/next/layout/_scripts/third-party/comments/duoshuo.swig","hash":"8c7af79407d223486fba72b8150fe045a553bf70","modified":1508643418000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"7506e7490c69a200831393c38d25e91c156bd471","modified":1508643418000},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1508643418000},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1508643418000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","hash":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1508643418000},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css","hash":"3b87c2560832748cd06f9bfd2fd6ea8edbdae8c7","modified":1508643418000},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.min.css","hash":"05ea25bc9b3ac48993e1fee322d3bc94b49a6e22","modified":1508643418000},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"4303776991ef28f5742ca51c7dffe6f12f0acf34","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"6ed60cc621bac096c0ed7534fa25b1a52dc571d4","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"c2c6c4f6434b4f94aac2af5861cd769427f0ee10","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"be22ad34f546a07f6d56b424338cdd898683eea4","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"ba0395aa8a717485bcc19b336aa0b228998df464","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Pisces/_full-image.styl","hash":"938d39eedc6e3d33918c1145a5bf1e79991d3fcf","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"d09280e5b79f3b573edb30f30c7a5f03ac640986","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"d4b7bd610ca03dbb2f5b66631c0e84a79fb4660b","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"1b10ba2d3ad0c063c418dc94a0b7e0db4b342c53","modified":1508643418000},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1508643418000},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1508643418000},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1508643418000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1508643418000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1508643418000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1508643418000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1508643418000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1508643418000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1508643418000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1508643418000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1508643418000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","hash":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1508643418000},{"_id":"themes/next/source/vendors/font-awesome/fonts/FontAwesome.otf","hash":"0112e96f327d413938d37c1693806f468ffdbace","modified":1508643418000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","hash":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1508643418000},{"_id":"themes/next/source/vendors/velocity/velocity.js","hash":"e63dc7cea055ca60a95d286f32349d88b10c5a4d","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"4da051c7f3924fa2db1e73c55b2baf1c2c150255","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"c890ce7fe933abad7baf39764a01894924854e92","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"90f8f9706cd7fe829cf06e9959a65fd3f8b994fa","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"3c46efd6601e268093ce6d7b1471d18501878f0d","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"8fae54591877a73dff0b29b2be2e8935e3c63575","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"b25132fe6a7ad67059a2c3afc60feabb479bdd75","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/post/post-more-link.styl","hash":"15063d79b5befc21820baf05d6f20cc1c1787477","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"cbca4842a54950e2934b3b8f3cd940f122111aef","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"e792c8dc41561c96d128e9b421187f1c3dc978a0","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"d543d1377c1f61b70e3adb6da0eb12797552e5f2","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"4eb18b12fa0ea6c35925d9a64f64e2a7dae8c7fd","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2e7ec9aaa3293941106b1bdd09055246aa3c3dc6","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"c44f6a553ec7ea5508f2054a13be33a62a15d3a9","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"7690b9596ec3a49befbe529a5a2649abec0faf76","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"2d3abbc85b979a648e0e579e45f16a6eba49d1e7","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"234facd038f144bd0fe09a31ed1357c5d74c517f","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"b03f891883446f3a5548b7cc90d29c77e62f1053","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"795d94561888d31cb7a6ff4a125596809ea69b7d","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"3afc459442c132c480d1d832f1a872f1070bb048","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"618f73450cf541f88a4fddc3d22898aee49d105d","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"8e66c2635d48e11de616bb29c4b1323698eebc0a","modified":1508643418000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","hash":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1508643418000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1508643418000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1508643418000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1508643418000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1508643418000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1508643418000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1508643418000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","hash":"2b3c8ba7008cc014d8fb37abc6f9f49aeda83824","modified":1508643418000},{"_id":"source/_posts/synchronized.md","hash":"6f0fb88d79dd705b5f7eefe1ffbdc40177dc6672","modified":1521096071291},{"_id":"source/images/synchronized/lockstatus.png","hash":"45028314addef8dca99f71ed6b9ac92782e71f31","modified":1520390832291},{"_id":"source/images/synchronized/object.png","hash":"49174afca507acfcf22d7098c3cc720ca2cab508","modified":1520329937797},{"_id":"source/images/synchronized/thread.png","hash":"ff3d368e89872c6235c992e0c6ff71d6ded6d25c","modified":1520324751565},{"_id":"source/images/synchronized/syn_class.png","hash":"0e900db684bf6ef74e249f0ee90e8fb560fe840c","modified":1520325561853},{"_id":"public/404.html","hash":"b65b2e8cd60f7e75344202b2e4f81e5f632693d5","modified":1526868727665},{"_id":"public/categories/index.html","hash":"c33adb10aeb5d4d4df8bcb4395b7f399de809715","modified":1526868727790},{"_id":"public/about/index.html","hash":"b4d0de908738a687d5486f6c6dd1d265fa1b73b7","modified":1526868727673},{"_id":"public/tags/index.html","hash":"f8c8c955683fb82bbac3acbf472a08c83b03cb7d","modified":1526868727789},{"_id":"public/categories/language/index.html","hash":"28b257070432fd36e8530ab09013ebf62f90a0b0","modified":1526868727790},{"_id":"public/categories/product/index.html","hash":"9b898a2b3d3431717bf49479eb35e443fd0370af","modified":1526868727791},{"_id":"public/tags/Java/index.html","hash":"909a1c1a65f4599488bf4f8e71edac89125fa310","modified":1526868727792},{"_id":"public/tags/GC/index.html","hash":"e7d9cf3ba9348f721967eb00ba81ab833ea31f34","modified":1526868727792},{"_id":"public/tags/synchronized/index.html","hash":"d110f8486d9048de917fd34184e390c4ec8e74c4","modified":1526868727792},{"_id":"public/tags/lock/index.html","hash":"c9328413c29450721a9b4db938f01f4a2a2c144b","modified":1526868727792},{"_id":"public/tags/java/index.html","hash":"6bc4cc79e31541a68beb664ca9be698f6a1f00a9","modified":1526868727792},{"_id":"public/tags/threadpool/index.html","hash":"09069e60b43dbe455055649fbc624e1adeb27f08","modified":1526868727792},{"_id":"public/tags/jvm/index.html","hash":"a678ec23352835ad2f02b3f957f9f7dad1025c75","modified":1526868727793},{"_id":"public/archives/index.html","hash":"d7c0c5cc9bddf7c09bb5f2f8d6d7d8505c36c966","modified":1526868727794},{"_id":"public/archives/2013/index.html","hash":"64357bf3fa06d4115b6821f9d395152b66205fc3","modified":1526868727791},{"_id":"public/archives/2013/02/index.html","hash":"d4677d0f9dcb05248f32d318cd50899973b51800","modified":1526868727791},{"_id":"public/archives/2013/05/index.html","hash":"5dffea917459999c8c38f843725dd3cb865ee90d","modified":1526868727791},{"_id":"public/archives/2013/06/index.html","hash":"88101f328c2d9434c679028aa9f72732f57a24c2","modified":1526868727791},{"_id":"public/archives/2013/07/index.html","hash":"5988bf1d78860e8f8eadbabe95d7211541c52247","modified":1526868727791},{"_id":"public/product/threadpool/index.html","hash":"4653c4ba9155a82e1a76282f295c53b511c3c826","modified":1526868727793},{"_id":"public/language/synchronized/index.html","hash":"73871f25e0fcc16a8beb0a59b182db53f4feb3a8","modified":1526868727793},{"_id":"public/language/HashMap/index.html","hash":"bb9d9b12475914262c1decb203fd1e955528a23d","modified":1526868727794},{"_id":"public/language/arraylist/index.html","hash":"8bb4fb9ca963747ce452dd20c3f933876474faf4","modified":1526868727793},{"_id":"public/language/Javagc/index.html","hash":"0004b8d3fb3c8bbc461dca893d11cf8af1860a49","modified":1526868727793},{"_id":"public/language/jvm_memory/index.html","hash":"26b9f1e263212619c0fcaa9df645a918de175c9e","modified":1526868727794},{"_id":"public/language/LinkedList/index.html","hash":"5d0b19bb7ad7e6fd4916741f8279fd058165099d","modified":1526868727794},{"_id":"public/index.html","hash":"a05e132a9feeb9d493c4fecdb08f9996dcbc3aa6","modified":1526868727794},{"_id":"public/CNAME","hash":"febc197e98f40f090cef2354869a2bf63921a07c","modified":1521080794166},{"_id":"public/images/arraylist/ArrayList_add.png","hash":"6f14151eeba2344a0a5829ce36807cfa94c361c3","modified":1521080794166},{"_id":"public/images/arraylist/ArrayList_base.png","hash":"f031419ae27e024778f116480abf279191dea885","modified":1521080794166},{"_id":"public/images/arraylist/ArrayList_grow.png","hash":"b924e37892279f98b512963160ff0e66dba29911","modified":1521080794166},{"_id":"public/images/hashmap/HashMap_addEntry.png","hash":"413e4049c486c08e4303caf36a8af92b1afedd12","modified":1521080794166},{"_id":"public/images/hashmap/HashMap_base.png","hash":"925e94e3097898d266b8eb1889f07f47b236f860","modified":1521080794166},{"_id":"public/images/hashmap/HashMap_getEntry.png","hash":"660e0faf3eeef4cfe877b22eba4c2bb56590b65b","modified":1521080794166},{"_id":"public/images/jvm/jvm_heap.jpg","hash":"5527eb3274a46bf8cef51528c125b132ac857077","modified":1521080794166},{"_id":"public/images/jvm/array.jpg","hash":"09569845fccf6b8f54e5b94046823113e51e01eb","modified":1521080794166},{"_id":"public/images/jvm/jvm_struct.jpg","hash":"3ba46ae13a36c96bb6fd18a1e721e389839155a0","modified":1521080794166},{"_id":"public/images/jvm/jvm_struct2.jpg","hash":"175c7038a429759c88c31c2f5f22c071d22ca42b","modified":1521080794166},{"_id":"public/images/linklist/LinkedList_add.png","hash":"9e1625a7b779f21d6d33fec6b9446164322062f2","modified":1521080794166},{"_id":"public/images/linklist/LinkedList_base.png","hash":"13adabf1f86405f40b681cf6ea462da7128a7f1d","modified":1521080794167},{"_id":"public/images/linklist/LinkedList_remove.png","hash":"3f6480e185cba1ae835e9f7558bd46113afda2ab","modified":1521080794167},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1521080794167},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1521080794169},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1521080794169},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1521080794169},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1521080794169},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1521080794169},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1521080794169},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1521080794169},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1521080794169},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1521080794169},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1521080794169},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1521080794169},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1521080794169},{"_id":"public/vendors/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1521080794169},{"_id":"public/vendors/font-awesome/HELP-US-OUT.txt","hash":"69a4c537d167b68a0ccf1c6febd138aeffca60d6","modified":1521080794169},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.woff2","hash":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1521080794169},{"_id":"public/vendors/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1521080794170},{"_id":"public/vendors/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1521080794170},{"_id":"public/vendors/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1521080794170},{"_id":"public/vendors/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1521080794170},{"_id":"public/vendors/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1521080794170},{"_id":"public/vendors/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1521080794170},{"_id":"public/vendors/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1521080794170},{"_id":"public/vendors/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1521080794170},{"_id":"public/images/synchronized/lockstatus.png","hash":"45028314addef8dca99f71ed6b9ac92782e71f31","modified":1521080794170},{"_id":"public/images/synchronized/object.png","hash":"49174afca507acfcf22d7098c3cc720ca2cab508","modified":1521080794170},{"_id":"public/images/synchronized/thread.png","hash":"ff3d368e89872c6235c992e0c6ff71d6ded6d25c","modified":1521080794170},{"_id":"public/images/avatar.jpg","hash":"ec40dfe5946dedbaced35335bb7267411a84b6bb","modified":1521080794879},{"_id":"public/images/hashmap/HashMap_removeEntryForKey.png","hash":"9ff4ce53602c95a6fa8e1bdbb85c2a258d254be6","modified":1521080794879},{"_id":"public/images/threadpool/工作流程.jpg","hash":"c2ea780babdea00adf46a199710c09b9b27f3efc","modified":1521080794885},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.woff","hash":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1521080794885},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.eot","hash":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1521080794885},{"_id":"public/images/synchronized/syn_class.png","hash":"0e900db684bf6ef74e249f0ee90e8fb560fe840c","modified":1521080794885},{"_id":"public/vendors/font-awesome/fonts/FontAwesome.otf","hash":"0112e96f327d413938d37c1693806f468ffdbace","modified":1521080794885},{"_id":"public/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1521080794895},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1521080794895},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1521080794895},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1521080794895},{"_id":"public/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1521080794895},{"_id":"public/js/src/utils.js","hash":"e5cb720894c4bc28ca8f10b33df127fb394018d9","modified":1521080794895},{"_id":"public/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1521080794895},{"_id":"public/vendors/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1521080794895},{"_id":"public/vendors/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1521080794895},{"_id":"public/vendors/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1521080794895},{"_id":"public/vendors/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1521080794895},{"_id":"public/vendors/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1521080794895},{"_id":"public/vendors/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1521080794896},{"_id":"public/vendors/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1521080794896},{"_id":"public/vendors/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1521080794896},{"_id":"public/js/src/schemes/pisces.js","hash":"7506e7490c69a200831393c38d25e91c156bd471","modified":1521080794896},{"_id":"public/vendors/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1521080794896},{"_id":"public/vendors/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1521080794896},{"_id":"public/vendors/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1521080794896},{"_id":"public/vendors/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1521080794896},{"_id":"public/vendors/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1521080794896},{"_id":"public/vendors/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1521080794896},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1521080794896},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1521080794896},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1521080794896},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1521080794896},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1521080794896},{"_id":"public/css/main.css","hash":"38126bba9b0379deebb098e469d3109a31fd5fab","modified":1521080794896},{"_id":"public/vendors/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1521080794896},{"_id":"public/vendors/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1521080794896},{"_id":"public/vendors/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1521080794896},{"_id":"public/vendors/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1521080794896},{"_id":"public/vendors/font-awesome/css/font-awesome.min.css","hash":"05ea25bc9b3ac48993e1fee322d3bc94b49a6e22","modified":1521080794896},{"_id":"public/vendors/font-awesome/css/font-awesome.css","hash":"3b87c2560832748cd06f9bfd2fd6ea8edbdae8c7","modified":1521080794896},{"_id":"public/vendors/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1521080794896},{"_id":"public/vendors/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1521080794896},{"_id":"public/vendors/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1521080794896},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.ttf","hash":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1521080794896},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.svg","hash":"2b3c8ba7008cc014d8fb37abc6f9f49aeda83824","modified":1521080794914},{"_id":"source/_posts/Docker.md","hash":"ccb57b76d1efd4a50e827ab95bce11212f710617","modified":1521702796585},{"_id":"source/images/docker/docker_struct.png","hash":"6599cbb2f94af8b05127b0b57d798f15e067a9b7","modified":1521537103581},{"_id":"public/archives/2017/index.html","hash":"bbe390207e9d6ab09f5f5910355d1efa345b55b6","modified":1526868727791},{"_id":"public/archives/2017/03/index.html","hash":"8076a7645152398d6122dad5dacafe0979cd1815","modified":1526868727792},{"_id":"public/tags/docker/index.html","hash":"fab41436c3f0bee7798c20bf23424948fe661278","modified":1526868727793},{"_id":"public/product/Docker/index.html","hash":"ef0df6f469ad8a0cb552cc2029699d1d88eccf66","modified":1526868727793},{"_id":"public/images/docker/docker_struct.png","hash":"6599cbb2f94af8b05127b0b57d798f15e067a9b7","modified":1521702831526},{"_id":"source/_posts/blockchain.md","hash":"013cb3bc630d71e260b12f22f3d11a58fd2971de","modified":1522830635237},{"_id":"source/images/blockchain/arch.png","hash":"7cae91f67f3a8b8cad8a29295f80c6e1d3615b59","modified":1522828736968},{"_id":"source/images/blockchain/blockchain.png","hash":"37e85ca67fe73cd927f95aad2682d84675ac73e2","modified":1522828549129},{"_id":"public/archives/2017/12/index.html","hash":"0e576f4b0ef13ddbc071a423205ffc39bbf7df16","modified":1526868727792},{"_id":"public/categories/blocklink/index.html","hash":"9e0b764ac9b02badd7d85dcb710e538c7cc1a081","modified":1526868727790},{"_id":"public/tags/区块链/index.html","hash":"593bb50b23e19aae122b2ffd2816ee5ffd4fab2c","modified":1526868727793},{"_id":"public/blocklink/blockchain/index.html","hash":"a991544e973cffa4cf5d31daeb77a7e1f6befbc4","modified":1526868727793},{"_id":"public/images/blockchain/arch.png","hash":"7cae91f67f3a8b8cad8a29295f80c6e1d3615b59","modified":1523152169572},{"_id":"public/images/blockchain/blockchain.png","hash":"37e85ca67fe73cd927f95aad2682d84675ac73e2","modified":1523152169593},{"_id":"source/_posts/binarysearch.md","hash":"7dd8dc248ee2630c18bbad9d258c591efe55e3ec","modified":1524043661501},{"_id":"public/archives/2015/index.html","hash":"6265ad2c2ec3e927e98eb66fe757ac0a57e5c4fe","modified":1526868727792},{"_id":"public/archives/2015/04/index.html","hash":"5fc155ed1460ec4be788d752e3ac54456dcdfdf6","modified":1526868727792},{"_id":"public/categories/algorithm/index.html","hash":"4f2b067a01c38cb0e29f10e68eef8669e729192e","modified":1526868727790},{"_id":"public/tags/二分查找/index.html","hash":"3c9bb7d3008802b87fb5598c14bc7ac1e096db75","modified":1526868727793},{"_id":"public/algorithm/binarysearch/index.html","hash":"fc775a1d5108679d3f0cececf29f988b3ffbc52f","modified":1526868727793},{"_id":"source/images/binarysearch/example1.png","hash":"6be8345b5824f64696e95c3900168cc8e5729003","modified":1524040660152},{"_id":"source/images/binarysearch/example2.png","hash":"c68720c8334e10b97718f4b9570c2ab5cd761810","modified":1524042208436},{"_id":"public/images/binarysearch/example1.png","hash":"6be8345b5824f64696e95c3900168cc8e5729003","modified":1524043802132},{"_id":"public/images/binarysearch/example2.png","hash":"c68720c8334e10b97718f4b9570c2ab5cd761810","modified":1524043802133},{"_id":"source/_posts/ConcurrentHashMap.md","hash":"4ca8c78cfd4dcc2fdc104fc00455a58c48bc56c6","modified":1524219511417},{"_id":"source/images/concurrentHashMap/image004.jpg","hash":"084ecde3dab2392c8dfacc687a2e9f124a9a6742","modified":1524216531158},{"_id":"source/images/concurrentHashMap/image005.jpg","hash":"21f7e88adba926244c9b8960839bfc5cf531c84c","modified":1524216711168},{"_id":"public/page/2/index.html","hash":"99ccb7a4c2c36b91535249d10eb81f9d7688a897","modified":1526868727794},{"_id":"public/archives/page/2/index.html","hash":"e6cf285593266d50e6b65c26b6f304b752402651","modified":1526868727791},{"_id":"public/archives/2013/08/index.html","hash":"3f7332c3f5c8cc3da6c84f6035bf9b12d5f0a34b","modified":1526868727791},{"_id":"public/tags/ConcurrentHashMap/index.html","hash":"9a40fa783f23050d898d9b40899a57b687ab2a97","modified":1526868727793},{"_id":"public/language/ConcurrentHashMap/index.html","hash":"1e848cf9b94e92778b8a62614417755e6b276b1d","modified":1526868727793},{"_id":"public/images/concurrentHashMap/image004.jpg","hash":"084ecde3dab2392c8dfacc687a2e9f124a9a6742","modified":1524894540415},{"_id":"public/images/concurrentHashMap/image005.jpg","hash":"21f7e88adba926244c9b8960839bfc5cf531c84c","modified":1524894540415},{"_id":"source/_posts/RedisLock.md","hash":"9a386db488739f543729ad377261693720e35139","modified":1526009276524},{"_id":"public/categories/架构/index.html","hash":"7cbe530d53068a8241d519f56cc03341da73fe6a","modified":1526868727790},{"_id":"public/archives/2017/05/index.html","hash":"890c6f309b69782270fb3cda69906b3edffd472e","modified":1526868727792},{"_id":"public/架构/RedisLock/index.html","hash":"ad3a778cff3fcb427f0eb347d78e58a9d7d6e100","modified":1526868727793},{"_id":"public/tags/redis/index.html","hash":"36bae6845e7ccd5739251a01948f788833f98a71","modified":1526868727793},{"_id":"source/_posts/quicksort.md","hash":"333c80f38e564ef5381a8252b423b4347e559b5a","modified":1526868707308},{"_id":"public/archives/2015/05/index.html","hash":"b9eee42403678220d5a14a5e6e5e2004df4e8873","modified":1526868727807},{"_id":"public/tags/快速排序/index.html","hash":"5617ff8051cd50f98ffc0a17174af7ef9fb89379","modified":1526868727807},{"_id":"public/algorithm/quicksort/index.html","hash":"2687c1031c1b313f7a009d9e0526e2970e8ae650","modified":1526868727807}],"Category":[{"name":"语言","_id":"cjefa5boh00056skch6ssboy5"},{"name":"实战","_id":"cjefa5bpm000n6skcy7e486jl"},{"name":"区块链","_id":"cjfktbq2p0001w0kc5gqcdado"},{"name":"算法","_id":"cjfrwqk2f0001wckcf0yvcysy"},{"name":"架构","_id":"cjh09eiol0001okkcnedll8dc"}],"Data":[],"Page":[{"_content":"<html>\n<head>\n<meta charset=\"utf-8\">\n<script type=\"text/javascript\">\n\tfunction redirect(){\n\t\tlocation.href=\"https://onelee85.github.io/\";\n\t}\n</script>\n</head>\n\n<body onload=\"redirect();\">\n</body>\n</html>","source":"404.html","raw":"<html>\n<head>\n<meta charset=\"utf-8\">\n<script type=\"text/javascript\">\n\tfunction redirect(){\n\t\tlocation.href=\"https://onelee85.github.io/\";\n\t}\n</script>\n</head>\n\n<body onload=\"redirect();\">\n</body>\n</html>","date":"2018-02-23T09:29:35.584Z","updated":"2018-02-23T02:26:34.864Z","path":"404.html","title":"","comments":1,"layout":"page","_id":"cjefa5bmd00006skc7b1exrb9","content":"<html>\n<head>\n<meta charset=\"utf-8\">\n<script type=\"text/javascript\">\n\tfunction redirect(){\n\t\tlocation.href=\"https://onelee85.github.io/\";\n\t}\n</script>\n</head>\n\n<body onload=\"redirect();\">\n</body>\n</html>","site":{"data":{}},"excerpt":"","more":"<html>\n<head>\n<meta charset=\"utf-8\">\n<script type=\"text/javascript\">\n\tfunction redirect(){\n\t\tlocation.href=\"https://onelee85.github.io/\";\n\t}\n</script>\n</head>\n\n<body onload=\"redirect();\">\n</body>\n</html>"},{"title":"404","date":"2016-08-31T10:31:34.000Z","_content":"","source":"404/index.md","raw":"---\ntitle: 404\ndate: 2016-08-31 18:31:34\npermalink: /404\n---\n","updated":"2018-02-23T02:26:34.865Z","path":"/404.html","comments":1,"layout":"page","_id":"cjefa5bny00016skchdhkkf96","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"categories","date":"2016-06-05T08:20:37.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2016-06-05 16:20:37\ntype: \"categories\"\ncomments: false\n---","updated":"2018-02-23T06:22:02.707Z","path":"categories/index.html","layout":"page","_id":"cjefa5bo900036skcm37qxwwz","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"关于我","comments":0,"_content":"\n# 关于我\n\nJames 湖南人，热爱美食\n\n# 技术兴趣\n\n高性能服务端编程和分布式系统相关\n\n","source":"about/index.md","raw":"---\ntitle: 关于我\ncomments: false\n---\n\n# 关于我\n\nJames 湖南人，热爱美食\n\n# 技术兴趣\n\n高性能服务端编程和分布式系统相关\n\n","date":"2018-02-23T09:29:35.584Z","updated":"2018-02-23T06:21:31.902Z","path":"about/index.html","layout":"page","_id":"cjefa5bol00076skcogqzg32q","content":"<h1 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h1><p>James 湖南人，热爱美食</p>\n<h1 id=\"技术兴趣\"><a href=\"#技术兴趣\" class=\"headerlink\" title=\"技术兴趣\"></a>技术兴趣</h1><p>高性能服务端编程和分布式系统相关</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h1><p>James 湖南人，热爱美食</p>\n<h1 id=\"技术兴趣\"><a href=\"#技术兴趣\" class=\"headerlink\" title=\"技术兴趣\"></a>技术兴趣</h1><p>高性能服务端编程和分布式系统相关</p>\n"},{"title":"tags","date":"2016-06-13T15:10:40.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2016-06-13 23:10:40\ntype: \"tags\"\ncomments: false\n---\n","updated":"2018-02-23T06:22:34.155Z","path":"tags/index.html","layout":"page","_id":"cjefa5bor00096skc18z8qxo8","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Java垃圾回收探究","author":"James","date":"2013-06-01T06:09:00.000Z","_content":"\n# 介绍\n\nJava的内存分配与回收全部由JVM垃圾回收进程自动完成。与C语言不同，Java开发者不需要自己编写代码实现垃圾回收。本文主要通过几个方面来探索Java垃圾回收\n\n1. 什么时候需要垃圾回收\n2. 垃圾回收算法有哪些\n3. 垃圾回收器如何工作\n\n<!-- more -->\n\n# 内存的分配\n\n根据分析[JVM内存](/language/jvm_memory/)我们得知**堆**内存是主要用来保存运行时的对象实例,所以我们主要关注点就集中在堆内存。\n\nJ在JVM的堆内存空间中分为年老代和年轻代。将大量（据统计差不多90%以上）创建了没多久就会消亡的对象存储在年轻代，而年老代中存放生命周期长久的实例对象。\n\n![heap](/images/jvm/jvm_heap.jpg)\n\n1.新生代（Young Generation）\n\n2.老年代（Old Generation）实例将从S1提升到Tenured（终身代）\n\n3.久代（Permanent Generation）包含类、方法等细节的元信息\n\n\n\n# 垃圾回收的条件\n\n如何判定对象是否存活的？\n\n## 根搜索算法\n\n思路: 通过一系列的名为`GC Roots`的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到`GC Roots`没有任何引用链相连时，则证明此对象是不可用的。\n\n`GC Roots` 的对象包括下面几种:\n\n1. 虚拟机栈（栈帧中的本地变量表）中的引用的对象。\n2. 方法区中的类静态属性引用的对象。\n3. 方法区中的常量引用的对象。\n4. 本地方法栈中JNI（Native方法）的引用的对象。\n\n# 回收算法\n\n## 引用计数法\n\n引用计数是垃圾收集器中的早期策略。在这种方法中，堆中每个对象实例都有一个引用计数。当一个对象被创建时，且将该对象实例分配给一个变量，该变量计数设置为1。当任何其它变量被赋值为这个对象的引用时，计数加1（a = b,则b引用的对象实例的计数器+1），但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数器减1。任何引用计数器为0的对象实例可以被当作垃圾收集。当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器减1。**缺点**是无法检测出循环引用。如父对象有一个对子对象的引用，子对象反过来引用父对象。这样，他们的引用计数永远不可能为0.\n\n## 标记-清除算法\n\n标记-清除算法采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象进行回收。此算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片。\n\n## 标记-整理算法\n\n标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往空闲空间移动，并更新对应的指针。标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。\n\n## 复制算法\n\n该算法的提出是为了克服句柄的开销和解决堆碎片的垃圾回收。它开始时把堆分成 一个对象 面和多个空闲面， 程序从对象面为对象分配空间，当对象满了，基于copying算法的垃圾 收集就从根集中扫描活动对象，并将每个 活动对象复制到空闲面(使得活动对象所占的内存之间没有空闲洞)，这样空闲面变成了对象面，原来的对象面变成了空闲面，程序会在新的对象面中分配内存。\n\n\n\n# 回收策略\n\n在JVM中**不同的对象的生命周期是不一样的**。因此，不同生命周期的对象可以采取不同的回收算法，以便提高回收效率。\n\n## **年轻代（Young Generation）** 复制算法\n\n1. 所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。\n2. 新生代内存按照8:1:1的比例分为一个eden区和两个survivor(survivor0,survivor1)区。大部分对象在Eden区中生成。回收时先将eden区存活对象复制到一个survivor0区，然后清空eden区，当这个survivor0区也存放满了时，则将eden区和survivor0区存活对象复制到另一个survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后将survivor0区和survivor1区交换，即保持survivor1区为空， 如此往复。\n3. 当survivor1区不足以存放 eden和survivor0的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次Full GC，也就是新生代、老年代都进行回收。\n4. 新生代发生的GC也叫做Minor GC，MinorGC发生频率比较高(不一定等Eden区满了才触发)。\n\n## **年老代（Old Generation）**标记-整理算法\n\n1. 在年轻代中经历了N次垃圾回收后仍然存活的对象(`MaxTenuringThreshold`控制进入老年前生存次数)，会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。\n2. 年老代内存比新生代大很多(大概比例是1:2)，当老年代内存满时触发Major GC即Full GC，Full GC发生频率比较低，老年代对象存活时间比较长，存活率标记高。\n\n## **持久代（Permanent Generation）**\n\n​\t用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate 等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。\n\n# 垃圾收集器\n\n新生代收集器使用的收集器：Serial、PraNew、Parallel Scavenge\n\n老年代收集器使用的收集器：Serial Old、Parallel Old、CMS\n\n\n\n## **Serial收集器（复制算法)**\n\n新生代单线程收集器，标记和清理都是单线程，优点是简单高效。\n\n## **Serial Old收集器(标记-整理算法)**\n\n老年代单线程收集器，Serial收集器的老年代版本。\n\n## **ParNew收集器(停止-复制算法)　**\n\n新生代收集器，可以认为是Serial收集器的多线程版本,在多核CPU环境下有着比Serial更好的表现。\n\n## **Parallel Scavenge收集器(停止-复制算法)**\n\n并行收集器，追求高吞吐量，高效利用CPU。吞吐量一般为99%， 吞吐量= 用户线程时间/(用户线程时间+GC线程时间)。适合后台应用等对交互相应要求不高的场景。\n\n## **Parallel Old收集器(停止-复制算法)**\n\nParallel Scavenge收集器的老年代版本，并行收集器，吞吐量优先\n\n## **CMS(Concurrent Mark Sweep)收集器（标记-清理算法）**\n\n高并发、低停顿，追求最短GC回收停顿时间，cpu占用比较高，响应时间快，停顿时间短，多核cpu 追求高响应时间的选择\n\n## G1垃圾回收器\n\nG1垃圾回收器适用于堆内存很大的情况，他将堆内存分割成不同的区域，并且并发的对其进行垃圾回收。G1也可以在回收内存之后对剩余的堆内存空间进行压缩。并发扫描标记垃圾回收器在STW情况下压缩内存。G1垃圾回收会优先选择第一块垃圾最多的区域\n\n通过JVM参数 `–XX:+UseG1GC` 使用G1垃圾回收器\n\n# 常用JVM参数配置\n\n- **-Xmn**设置Young的空间大小\n- **-XX:NewRatio= 3** 为Tenured:Young的初始尺寸比例（设置了大小就不再设置此值），此时Young占用整个HeapSize的1/4大小\n- **-XX:SurvivorRatio= 6**：为Eden:Survivor比例大小，此时一个Survivor占用Young的1/8大小，而Eden占用3/4大小。\n- **-XX:MaxTenuringThreshold=3**：一般一个对象在Young经过多少次GC后会被移动到OLD区。\n- **-XX:+UseParNewGC**：对Yong区域启用并行回收算法。\n- **-XX:+UseConcMarkSweepGC** 启动并发GC，一般针对Tenured区域。\n\n\n\n# 实战问题\n\n常见的OOM现象有以下几种：\n\n1. heapSize溢出：**java.lang.OutOfMemoryError：**java heap space\n\n   这个需要设置Java虚拟机的内存情况\n\n2. PermSize溢出：**java.lang.OutOfMemoryError：**PermGen space\n\n   需要设置Perm相关参数以及检查内存中的常量情况，jdk1.7中的常量池移到了堆中。\n\n3. 栈内存溢出错误：**StackOverflowError**\n\n   通常都是程序的问题，JVM对栈帧的大小设置已经很大了，比如递归\n\n4. native Thread溢出，注意线程Stack的大小，以及本身操作系统的限制。","source":"_posts/Javagc.md","raw":"title: Java垃圾回收探究\nauthor: James\ntags:\n  - Java\n  - GC\ncategories:\n  - 语言\ndate: 2013-06-01 14:09:00\n---\n\n# 介绍\n\nJava的内存分配与回收全部由JVM垃圾回收进程自动完成。与C语言不同，Java开发者不需要自己编写代码实现垃圾回收。本文主要通过几个方面来探索Java垃圾回收\n\n1. 什么时候需要垃圾回收\n2. 垃圾回收算法有哪些\n3. 垃圾回收器如何工作\n\n<!-- more -->\n\n# 内存的分配\n\n根据分析[JVM内存](/language/jvm_memory/)我们得知**堆**内存是主要用来保存运行时的对象实例,所以我们主要关注点就集中在堆内存。\n\nJ在JVM的堆内存空间中分为年老代和年轻代。将大量（据统计差不多90%以上）创建了没多久就会消亡的对象存储在年轻代，而年老代中存放生命周期长久的实例对象。\n\n![heap](/images/jvm/jvm_heap.jpg)\n\n1.新生代（Young Generation）\n\n2.老年代（Old Generation）实例将从S1提升到Tenured（终身代）\n\n3.久代（Permanent Generation）包含类、方法等细节的元信息\n\n\n\n# 垃圾回收的条件\n\n如何判定对象是否存活的？\n\n## 根搜索算法\n\n思路: 通过一系列的名为`GC Roots`的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到`GC Roots`没有任何引用链相连时，则证明此对象是不可用的。\n\n`GC Roots` 的对象包括下面几种:\n\n1. 虚拟机栈（栈帧中的本地变量表）中的引用的对象。\n2. 方法区中的类静态属性引用的对象。\n3. 方法区中的常量引用的对象。\n4. 本地方法栈中JNI（Native方法）的引用的对象。\n\n# 回收算法\n\n## 引用计数法\n\n引用计数是垃圾收集器中的早期策略。在这种方法中，堆中每个对象实例都有一个引用计数。当一个对象被创建时，且将该对象实例分配给一个变量，该变量计数设置为1。当任何其它变量被赋值为这个对象的引用时，计数加1（a = b,则b引用的对象实例的计数器+1），但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数器减1。任何引用计数器为0的对象实例可以被当作垃圾收集。当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器减1。**缺点**是无法检测出循环引用。如父对象有一个对子对象的引用，子对象反过来引用父对象。这样，他们的引用计数永远不可能为0.\n\n## 标记-清除算法\n\n标记-清除算法采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象进行回收。此算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片。\n\n## 标记-整理算法\n\n标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往空闲空间移动，并更新对应的指针。标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。\n\n## 复制算法\n\n该算法的提出是为了克服句柄的开销和解决堆碎片的垃圾回收。它开始时把堆分成 一个对象 面和多个空闲面， 程序从对象面为对象分配空间，当对象满了，基于copying算法的垃圾 收集就从根集中扫描活动对象，并将每个 活动对象复制到空闲面(使得活动对象所占的内存之间没有空闲洞)，这样空闲面变成了对象面，原来的对象面变成了空闲面，程序会在新的对象面中分配内存。\n\n\n\n# 回收策略\n\n在JVM中**不同的对象的生命周期是不一样的**。因此，不同生命周期的对象可以采取不同的回收算法，以便提高回收效率。\n\n## **年轻代（Young Generation）** 复制算法\n\n1. 所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。\n2. 新生代内存按照8:1:1的比例分为一个eden区和两个survivor(survivor0,survivor1)区。大部分对象在Eden区中生成。回收时先将eden区存活对象复制到一个survivor0区，然后清空eden区，当这个survivor0区也存放满了时，则将eden区和survivor0区存活对象复制到另一个survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后将survivor0区和survivor1区交换，即保持survivor1区为空， 如此往复。\n3. 当survivor1区不足以存放 eden和survivor0的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次Full GC，也就是新生代、老年代都进行回收。\n4. 新生代发生的GC也叫做Minor GC，MinorGC发生频率比较高(不一定等Eden区满了才触发)。\n\n## **年老代（Old Generation）**标记-整理算法\n\n1. 在年轻代中经历了N次垃圾回收后仍然存活的对象(`MaxTenuringThreshold`控制进入老年前生存次数)，会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。\n2. 年老代内存比新生代大很多(大概比例是1:2)，当老年代内存满时触发Major GC即Full GC，Full GC发生频率比较低，老年代对象存活时间比较长，存活率标记高。\n\n## **持久代（Permanent Generation）**\n\n​\t用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate 等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。\n\n# 垃圾收集器\n\n新生代收集器使用的收集器：Serial、PraNew、Parallel Scavenge\n\n老年代收集器使用的收集器：Serial Old、Parallel Old、CMS\n\n\n\n## **Serial收集器（复制算法)**\n\n新生代单线程收集器，标记和清理都是单线程，优点是简单高效。\n\n## **Serial Old收集器(标记-整理算法)**\n\n老年代单线程收集器，Serial收集器的老年代版本。\n\n## **ParNew收集器(停止-复制算法)　**\n\n新生代收集器，可以认为是Serial收集器的多线程版本,在多核CPU环境下有着比Serial更好的表现。\n\n## **Parallel Scavenge收集器(停止-复制算法)**\n\n并行收集器，追求高吞吐量，高效利用CPU。吞吐量一般为99%， 吞吐量= 用户线程时间/(用户线程时间+GC线程时间)。适合后台应用等对交互相应要求不高的场景。\n\n## **Parallel Old收集器(停止-复制算法)**\n\nParallel Scavenge收集器的老年代版本，并行收集器，吞吐量优先\n\n## **CMS(Concurrent Mark Sweep)收集器（标记-清理算法）**\n\n高并发、低停顿，追求最短GC回收停顿时间，cpu占用比较高，响应时间快，停顿时间短，多核cpu 追求高响应时间的选择\n\n## G1垃圾回收器\n\nG1垃圾回收器适用于堆内存很大的情况，他将堆内存分割成不同的区域，并且并发的对其进行垃圾回收。G1也可以在回收内存之后对剩余的堆内存空间进行压缩。并发扫描标记垃圾回收器在STW情况下压缩内存。G1垃圾回收会优先选择第一块垃圾最多的区域\n\n通过JVM参数 `–XX:+UseG1GC` 使用G1垃圾回收器\n\n# 常用JVM参数配置\n\n- **-Xmn**设置Young的空间大小\n- **-XX:NewRatio= 3** 为Tenured:Young的初始尺寸比例（设置了大小就不再设置此值），此时Young占用整个HeapSize的1/4大小\n- **-XX:SurvivorRatio= 6**：为Eden:Survivor比例大小，此时一个Survivor占用Young的1/8大小，而Eden占用3/4大小。\n- **-XX:MaxTenuringThreshold=3**：一般一个对象在Young经过多少次GC后会被移动到OLD区。\n- **-XX:+UseParNewGC**：对Yong区域启用并行回收算法。\n- **-XX:+UseConcMarkSweepGC** 启动并发GC，一般针对Tenured区域。\n\n\n\n# 实战问题\n\n常见的OOM现象有以下几种：\n\n1. heapSize溢出：**java.lang.OutOfMemoryError：**java heap space\n\n   这个需要设置Java虚拟机的内存情况\n\n2. PermSize溢出：**java.lang.OutOfMemoryError：**PermGen space\n\n   需要设置Perm相关参数以及检查内存中的常量情况，jdk1.7中的常量池移到了堆中。\n\n3. 栈内存溢出错误：**StackOverflowError**\n\n   通常都是程序的问题，JVM对栈帧的大小设置已经很大了，比如递归\n\n4. native Thread溢出，注意线程Stack的大小，以及本身操作系统的限制。","slug":"Javagc","published":1,"updated":"2018-03-01T08:48:23.213Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjefa5bo100026skcf0id5b8s","content":"<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p>Java的内存分配与回收全部由JVM垃圾回收进程自动完成。与C语言不同，Java开发者不需要自己编写代码实现垃圾回收。本文主要通过几个方面来探索Java垃圾回收</p>\n<ol>\n<li>什么时候需要垃圾回收</li>\n<li>垃圾回收算法有哪些</li>\n<li>垃圾回收器如何工作</li>\n</ol>\n<a id=\"more\"></a>\n<h1 id=\"内存的分配\"><a href=\"#内存的分配\" class=\"headerlink\" title=\"内存的分配\"></a>内存的分配</h1><p>根据分析<a href=\"/language/jvm_memory/\">JVM内存</a>我们得知<strong>堆</strong>内存是主要用来保存运行时的对象实例,所以我们主要关注点就集中在堆内存。</p>\n<p>J在JVM的堆内存空间中分为年老代和年轻代。将大量（据统计差不多90%以上）创建了没多久就会消亡的对象存储在年轻代，而年老代中存放生命周期长久的实例对象。</p>\n<p><img src=\"/images/jvm/jvm_heap.jpg\" alt=\"heap\"></p>\n<p>1.新生代（Young Generation）</p>\n<p>2.老年代（Old Generation）实例将从S1提升到Tenured（终身代）</p>\n<p>3.久代（Permanent Generation）包含类、方法等细节的元信息</p>\n<h1 id=\"垃圾回收的条件\"><a href=\"#垃圾回收的条件\" class=\"headerlink\" title=\"垃圾回收的条件\"></a>垃圾回收的条件</h1><p>如何判定对象是否存活的？</p>\n<h2 id=\"根搜索算法\"><a href=\"#根搜索算法\" class=\"headerlink\" title=\"根搜索算法\"></a>根搜索算法</h2><p>思路: 通过一系列的名为<code>GC Roots</code>的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到<code>GC Roots</code>没有任何引用链相连时，则证明此对象是不可用的。</p>\n<p><code>GC Roots</code> 的对象包括下面几种:</p>\n<ol>\n<li>虚拟机栈（栈帧中的本地变量表）中的引用的对象。</li>\n<li>方法区中的类静态属性引用的对象。</li>\n<li>方法区中的常量引用的对象。</li>\n<li>本地方法栈中JNI（Native方法）的引用的对象。</li>\n</ol>\n<h1 id=\"回收算法\"><a href=\"#回收算法\" class=\"headerlink\" title=\"回收算法\"></a>回收算法</h1><h2 id=\"引用计数法\"><a href=\"#引用计数法\" class=\"headerlink\" title=\"引用计数法\"></a>引用计数法</h2><p>引用计数是垃圾收集器中的早期策略。在这种方法中，堆中每个对象实例都有一个引用计数。当一个对象被创建时，且将该对象实例分配给一个变量，该变量计数设置为1。当任何其它变量被赋值为这个对象的引用时，计数加1（a = b,则b引用的对象实例的计数器+1），但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数器减1。任何引用计数器为0的对象实例可以被当作垃圾收集。当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器减1。<strong>缺点</strong>是无法检测出循环引用。如父对象有一个对子对象的引用，子对象反过来引用父对象。这样，他们的引用计数永远不可能为0.</p>\n<h2 id=\"标记-清除算法\"><a href=\"#标记-清除算法\" class=\"headerlink\" title=\"标记-清除算法\"></a>标记-清除算法</h2><p>标记-清除算法采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象进行回收。此算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片。</p>\n<h2 id=\"标记-整理算法\"><a href=\"#标记-整理算法\" class=\"headerlink\" title=\"标记-整理算法\"></a>标记-整理算法</h2><p>标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往空闲空间移动，并更新对应的指针。标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。</p>\n<h2 id=\"复制算法\"><a href=\"#复制算法\" class=\"headerlink\" title=\"复制算法\"></a>复制算法</h2><p>该算法的提出是为了克服句柄的开销和解决堆碎片的垃圾回收。它开始时把堆分成 一个对象 面和多个空闲面， 程序从对象面为对象分配空间，当对象满了，基于copying算法的垃圾 收集就从根集中扫描活动对象，并将每个 活动对象复制到空闲面(使得活动对象所占的内存之间没有空闲洞)，这样空闲面变成了对象面，原来的对象面变成了空闲面，程序会在新的对象面中分配内存。</p>\n<h1 id=\"回收策略\"><a href=\"#回收策略\" class=\"headerlink\" title=\"回收策略\"></a>回收策略</h1><p>在JVM中<strong>不同的对象的生命周期是不一样的</strong>。因此，不同生命周期的对象可以采取不同的回收算法，以便提高回收效率。</p>\n<h2 id=\"年轻代（Young-Generation）-复制算法\"><a href=\"#年轻代（Young-Generation）-复制算法\" class=\"headerlink\" title=\"年轻代（Young Generation） 复制算法\"></a><strong>年轻代（Young Generation）</strong> 复制算法</h2><ol>\n<li>所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。</li>\n<li>新生代内存按照8:1:1的比例分为一个eden区和两个survivor(survivor0,survivor1)区。大部分对象在Eden区中生成。回收时先将eden区存活对象复制到一个survivor0区，然后清空eden区，当这个survivor0区也存放满了时，则将eden区和survivor0区存活对象复制到另一个survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后将survivor0区和survivor1区交换，即保持survivor1区为空， 如此往复。</li>\n<li>当survivor1区不足以存放 eden和survivor0的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次Full GC，也就是新生代、老年代都进行回收。</li>\n<li>新生代发生的GC也叫做Minor GC，MinorGC发生频率比较高(不一定等Eden区满了才触发)。</li>\n</ol>\n<h2 id=\"年老代（Old-Generation）标记-整理算法\"><a href=\"#年老代（Old-Generation）标记-整理算法\" class=\"headerlink\" title=\"年老代（Old Generation）标记-整理算法\"></a><strong>年老代（Old Generation）</strong>标记-整理算法</h2><ol>\n<li>在年轻代中经历了N次垃圾回收后仍然存活的对象(<code>MaxTenuringThreshold</code>控制进入老年前生存次数)，会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。</li>\n<li>年老代内存比新生代大很多(大概比例是1:2)，当老年代内存满时触发Major GC即Full GC，Full GC发生频率比较低，老年代对象存活时间比较长，存活率标记高。</li>\n</ol>\n<h2 id=\"持久代（Permanent-Generation）\"><a href=\"#持久代（Permanent-Generation）\" class=\"headerlink\" title=\"持久代（Permanent Generation）\"></a><strong>持久代（Permanent Generation）</strong></h2><p>​    用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate 等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。</p>\n<h1 id=\"垃圾收集器\"><a href=\"#垃圾收集器\" class=\"headerlink\" title=\"垃圾收集器\"></a>垃圾收集器</h1><p>新生代收集器使用的收集器：Serial、PraNew、Parallel Scavenge</p>\n<p>老年代收集器使用的收集器：Serial Old、Parallel Old、CMS</p>\n<h2 id=\"Serial收集器（复制算法\"><a href=\"#Serial收集器（复制算法\" class=\"headerlink\" title=\"Serial收集器（复制算法)\"></a><strong>Serial收集器（复制算法)</strong></h2><p>新生代单线程收集器，标记和清理都是单线程，优点是简单高效。</p>\n<h2 id=\"Serial-Old收集器-标记-整理算法\"><a href=\"#Serial-Old收集器-标记-整理算法\" class=\"headerlink\" title=\"Serial Old收集器(标记-整理算法)\"></a><strong>Serial Old收集器(标记-整理算法)</strong></h2><p>老年代单线程收集器，Serial收集器的老年代版本。</p>\n<h2 id=\"ParNew收集器-停止-复制算法\"><a href=\"#ParNew收集器-停止-复制算法\" class=\"headerlink\" title=\"ParNew收集器(停止-复制算法)　\"></a><strong>ParNew收集器(停止-复制算法)　</strong></h2><p>新生代收集器，可以认为是Serial收集器的多线程版本,在多核CPU环境下有着比Serial更好的表现。</p>\n<h2 id=\"Parallel-Scavenge收集器-停止-复制算法\"><a href=\"#Parallel-Scavenge收集器-停止-复制算法\" class=\"headerlink\" title=\"Parallel Scavenge收集器(停止-复制算法)\"></a><strong>Parallel Scavenge收集器(停止-复制算法)</strong></h2><p>并行收集器，追求高吞吐量，高效利用CPU。吞吐量一般为99%， 吞吐量= 用户线程时间/(用户线程时间+GC线程时间)。适合后台应用等对交互相应要求不高的场景。</p>\n<h2 id=\"Parallel-Old收集器-停止-复制算法\"><a href=\"#Parallel-Old收集器-停止-复制算法\" class=\"headerlink\" title=\"Parallel Old收集器(停止-复制算法)\"></a><strong>Parallel Old收集器(停止-复制算法)</strong></h2><p>Parallel Scavenge收集器的老年代版本，并行收集器，吞吐量优先</p>\n<h2 id=\"CMS-Concurrent-Mark-Sweep-收集器（标记-清理算法）\"><a href=\"#CMS-Concurrent-Mark-Sweep-收集器（标记-清理算法）\" class=\"headerlink\" title=\"CMS(Concurrent Mark Sweep)收集器（标记-清理算法）\"></a><strong>CMS(Concurrent Mark Sweep)收集器（标记-清理算法）</strong></h2><p>高并发、低停顿，追求最短GC回收停顿时间，cpu占用比较高，响应时间快，停顿时间短，多核cpu 追求高响应时间的选择</p>\n<h2 id=\"G1垃圾回收器\"><a href=\"#G1垃圾回收器\" class=\"headerlink\" title=\"G1垃圾回收器\"></a>G1垃圾回收器</h2><p>G1垃圾回收器适用于堆内存很大的情况，他将堆内存分割成不同的区域，并且并发的对其进行垃圾回收。G1也可以在回收内存之后对剩余的堆内存空间进行压缩。并发扫描标记垃圾回收器在STW情况下压缩内存。G1垃圾回收会优先选择第一块垃圾最多的区域</p>\n<p>通过JVM参数 <code>–XX:+UseG1GC</code> 使用G1垃圾回收器</p>\n<h1 id=\"常用JVM参数配置\"><a href=\"#常用JVM参数配置\" class=\"headerlink\" title=\"常用JVM参数配置\"></a>常用JVM参数配置</h1><ul>\n<li><strong>-Xmn</strong>设置Young的空间大小</li>\n<li><strong>-XX:NewRatio= 3</strong> 为Tenured:Young的初始尺寸比例（设置了大小就不再设置此值），此时Young占用整个HeapSize的1/4大小</li>\n<li><strong>-XX:SurvivorRatio= 6</strong>：为Eden:Survivor比例大小，此时一个Survivor占用Young的1/8大小，而Eden占用3/4大小。</li>\n<li><strong>-XX:MaxTenuringThreshold=3</strong>：一般一个对象在Young经过多少次GC后会被移动到OLD区。</li>\n<li><strong>-XX:+UseParNewGC</strong>：对Yong区域启用并行回收算法。</li>\n<li><strong>-XX:+UseConcMarkSweepGC</strong> 启动并发GC，一般针对Tenured区域。</li>\n</ul>\n<h1 id=\"实战问题\"><a href=\"#实战问题\" class=\"headerlink\" title=\"实战问题\"></a>实战问题</h1><p>常见的OOM现象有以下几种：</p>\n<ol>\n<li><p>heapSize溢出：<strong>java.lang.OutOfMemoryError：</strong>java heap space</p>\n<p>这个需要设置Java虚拟机的内存情况</p>\n</li>\n<li><p>PermSize溢出：<strong>java.lang.OutOfMemoryError：</strong>PermGen space</p>\n<p>需要设置Perm相关参数以及检查内存中的常量情况，jdk1.7中的常量池移到了堆中。</p>\n</li>\n<li><p>栈内存溢出错误：<strong>StackOverflowError</strong></p>\n<p>通常都是程序的问题，JVM对栈帧的大小设置已经很大了，比如递归</p>\n</li>\n<li><p>native Thread溢出，注意线程Stack的大小，以及本身操作系统的限制。</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p>Java的内存分配与回收全部由JVM垃圾回收进程自动完成。与C语言不同，Java开发者不需要自己编写代码实现垃圾回收。本文主要通过几个方面来探索Java垃圾回收</p>\n<ol>\n<li>什么时候需要垃圾回收</li>\n<li>垃圾回收算法有哪些</li>\n<li>垃圾回收器如何工作</li>\n</ol>","more":"<h1 id=\"内存的分配\"><a href=\"#内存的分配\" class=\"headerlink\" title=\"内存的分配\"></a>内存的分配</h1><p>根据分析<a href=\"/language/jvm_memory/\">JVM内存</a>我们得知<strong>堆</strong>内存是主要用来保存运行时的对象实例,所以我们主要关注点就集中在堆内存。</p>\n<p>J在JVM的堆内存空间中分为年老代和年轻代。将大量（据统计差不多90%以上）创建了没多久就会消亡的对象存储在年轻代，而年老代中存放生命周期长久的实例对象。</p>\n<p><img src=\"/images/jvm/jvm_heap.jpg\" alt=\"heap\"></p>\n<p>1.新生代（Young Generation）</p>\n<p>2.老年代（Old Generation）实例将从S1提升到Tenured（终身代）</p>\n<p>3.久代（Permanent Generation）包含类、方法等细节的元信息</p>\n<h1 id=\"垃圾回收的条件\"><a href=\"#垃圾回收的条件\" class=\"headerlink\" title=\"垃圾回收的条件\"></a>垃圾回收的条件</h1><p>如何判定对象是否存活的？</p>\n<h2 id=\"根搜索算法\"><a href=\"#根搜索算法\" class=\"headerlink\" title=\"根搜索算法\"></a>根搜索算法</h2><p>思路: 通过一系列的名为<code>GC Roots</code>的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到<code>GC Roots</code>没有任何引用链相连时，则证明此对象是不可用的。</p>\n<p><code>GC Roots</code> 的对象包括下面几种:</p>\n<ol>\n<li>虚拟机栈（栈帧中的本地变量表）中的引用的对象。</li>\n<li>方法区中的类静态属性引用的对象。</li>\n<li>方法区中的常量引用的对象。</li>\n<li>本地方法栈中JNI（Native方法）的引用的对象。</li>\n</ol>\n<h1 id=\"回收算法\"><a href=\"#回收算法\" class=\"headerlink\" title=\"回收算法\"></a>回收算法</h1><h2 id=\"引用计数法\"><a href=\"#引用计数法\" class=\"headerlink\" title=\"引用计数法\"></a>引用计数法</h2><p>引用计数是垃圾收集器中的早期策略。在这种方法中，堆中每个对象实例都有一个引用计数。当一个对象被创建时，且将该对象实例分配给一个变量，该变量计数设置为1。当任何其它变量被赋值为这个对象的引用时，计数加1（a = b,则b引用的对象实例的计数器+1），但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数器减1。任何引用计数器为0的对象实例可以被当作垃圾收集。当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器减1。<strong>缺点</strong>是无法检测出循环引用。如父对象有一个对子对象的引用，子对象反过来引用父对象。这样，他们的引用计数永远不可能为0.</p>\n<h2 id=\"标记-清除算法\"><a href=\"#标记-清除算法\" class=\"headerlink\" title=\"标记-清除算法\"></a>标记-清除算法</h2><p>标记-清除算法采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象进行回收。此算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片。</p>\n<h2 id=\"标记-整理算法\"><a href=\"#标记-整理算法\" class=\"headerlink\" title=\"标记-整理算法\"></a>标记-整理算法</h2><p>标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往空闲空间移动，并更新对应的指针。标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。</p>\n<h2 id=\"复制算法\"><a href=\"#复制算法\" class=\"headerlink\" title=\"复制算法\"></a>复制算法</h2><p>该算法的提出是为了克服句柄的开销和解决堆碎片的垃圾回收。它开始时把堆分成 一个对象 面和多个空闲面， 程序从对象面为对象分配空间，当对象满了，基于copying算法的垃圾 收集就从根集中扫描活动对象，并将每个 活动对象复制到空闲面(使得活动对象所占的内存之间没有空闲洞)，这样空闲面变成了对象面，原来的对象面变成了空闲面，程序会在新的对象面中分配内存。</p>\n<h1 id=\"回收策略\"><a href=\"#回收策略\" class=\"headerlink\" title=\"回收策略\"></a>回收策略</h1><p>在JVM中<strong>不同的对象的生命周期是不一样的</strong>。因此，不同生命周期的对象可以采取不同的回收算法，以便提高回收效率。</p>\n<h2 id=\"年轻代（Young-Generation）-复制算法\"><a href=\"#年轻代（Young-Generation）-复制算法\" class=\"headerlink\" title=\"年轻代（Young Generation） 复制算法\"></a><strong>年轻代（Young Generation）</strong> 复制算法</h2><ol>\n<li>所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。</li>\n<li>新生代内存按照8:1:1的比例分为一个eden区和两个survivor(survivor0,survivor1)区。大部分对象在Eden区中生成。回收时先将eden区存活对象复制到一个survivor0区，然后清空eden区，当这个survivor0区也存放满了时，则将eden区和survivor0区存活对象复制到另一个survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后将survivor0区和survivor1区交换，即保持survivor1区为空， 如此往复。</li>\n<li>当survivor1区不足以存放 eden和survivor0的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次Full GC，也就是新生代、老年代都进行回收。</li>\n<li>新生代发生的GC也叫做Minor GC，MinorGC发生频率比较高(不一定等Eden区满了才触发)。</li>\n</ol>\n<h2 id=\"年老代（Old-Generation）标记-整理算法\"><a href=\"#年老代（Old-Generation）标记-整理算法\" class=\"headerlink\" title=\"年老代（Old Generation）标记-整理算法\"></a><strong>年老代（Old Generation）</strong>标记-整理算法</h2><ol>\n<li>在年轻代中经历了N次垃圾回收后仍然存活的对象(<code>MaxTenuringThreshold</code>控制进入老年前生存次数)，会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。</li>\n<li>年老代内存比新生代大很多(大概比例是1:2)，当老年代内存满时触发Major GC即Full GC，Full GC发生频率比较低，老年代对象存活时间比较长，存活率标记高。</li>\n</ol>\n<h2 id=\"持久代（Permanent-Generation）\"><a href=\"#持久代（Permanent-Generation）\" class=\"headerlink\" title=\"持久代（Permanent Generation）\"></a><strong>持久代（Permanent Generation）</strong></h2><p>​    用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate 等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。</p>\n<h1 id=\"垃圾收集器\"><a href=\"#垃圾收集器\" class=\"headerlink\" title=\"垃圾收集器\"></a>垃圾收集器</h1><p>新生代收集器使用的收集器：Serial、PraNew、Parallel Scavenge</p>\n<p>老年代收集器使用的收集器：Serial Old、Parallel Old、CMS</p>\n<h2 id=\"Serial收集器（复制算法\"><a href=\"#Serial收集器（复制算法\" class=\"headerlink\" title=\"Serial收集器（复制算法)\"></a><strong>Serial收集器（复制算法)</strong></h2><p>新生代单线程收集器，标记和清理都是单线程，优点是简单高效。</p>\n<h2 id=\"Serial-Old收集器-标记-整理算法\"><a href=\"#Serial-Old收集器-标记-整理算法\" class=\"headerlink\" title=\"Serial Old收集器(标记-整理算法)\"></a><strong>Serial Old收集器(标记-整理算法)</strong></h2><p>老年代单线程收集器，Serial收集器的老年代版本。</p>\n<h2 id=\"ParNew收集器-停止-复制算法\"><a href=\"#ParNew收集器-停止-复制算法\" class=\"headerlink\" title=\"ParNew收集器(停止-复制算法)　\"></a><strong>ParNew收集器(停止-复制算法)　</strong></h2><p>新生代收集器，可以认为是Serial收集器的多线程版本,在多核CPU环境下有着比Serial更好的表现。</p>\n<h2 id=\"Parallel-Scavenge收集器-停止-复制算法\"><a href=\"#Parallel-Scavenge收集器-停止-复制算法\" class=\"headerlink\" title=\"Parallel Scavenge收集器(停止-复制算法)\"></a><strong>Parallel Scavenge收集器(停止-复制算法)</strong></h2><p>并行收集器，追求高吞吐量，高效利用CPU。吞吐量一般为99%， 吞吐量= 用户线程时间/(用户线程时间+GC线程时间)。适合后台应用等对交互相应要求不高的场景。</p>\n<h2 id=\"Parallel-Old收集器-停止-复制算法\"><a href=\"#Parallel-Old收集器-停止-复制算法\" class=\"headerlink\" title=\"Parallel Old收集器(停止-复制算法)\"></a><strong>Parallel Old收集器(停止-复制算法)</strong></h2><p>Parallel Scavenge收集器的老年代版本，并行收集器，吞吐量优先</p>\n<h2 id=\"CMS-Concurrent-Mark-Sweep-收集器（标记-清理算法）\"><a href=\"#CMS-Concurrent-Mark-Sweep-收集器（标记-清理算法）\" class=\"headerlink\" title=\"CMS(Concurrent Mark Sweep)收集器（标记-清理算法）\"></a><strong>CMS(Concurrent Mark Sweep)收集器（标记-清理算法）</strong></h2><p>高并发、低停顿，追求最短GC回收停顿时间，cpu占用比较高，响应时间快，停顿时间短，多核cpu 追求高响应时间的选择</p>\n<h2 id=\"G1垃圾回收器\"><a href=\"#G1垃圾回收器\" class=\"headerlink\" title=\"G1垃圾回收器\"></a>G1垃圾回收器</h2><p>G1垃圾回收器适用于堆内存很大的情况，他将堆内存分割成不同的区域，并且并发的对其进行垃圾回收。G1也可以在回收内存之后对剩余的堆内存空间进行压缩。并发扫描标记垃圾回收器在STW情况下压缩内存。G1垃圾回收会优先选择第一块垃圾最多的区域</p>\n<p>通过JVM参数 <code>–XX:+UseG1GC</code> 使用G1垃圾回收器</p>\n<h1 id=\"常用JVM参数配置\"><a href=\"#常用JVM参数配置\" class=\"headerlink\" title=\"常用JVM参数配置\"></a>常用JVM参数配置</h1><ul>\n<li><strong>-Xmn</strong>设置Young的空间大小</li>\n<li><strong>-XX:NewRatio= 3</strong> 为Tenured:Young的初始尺寸比例（设置了大小就不再设置此值），此时Young占用整个HeapSize的1/4大小</li>\n<li><strong>-XX:SurvivorRatio= 6</strong>：为Eden:Survivor比例大小，此时一个Survivor占用Young的1/8大小，而Eden占用3/4大小。</li>\n<li><strong>-XX:MaxTenuringThreshold=3</strong>：一般一个对象在Young经过多少次GC后会被移动到OLD区。</li>\n<li><strong>-XX:+UseParNewGC</strong>：对Yong区域启用并行回收算法。</li>\n<li><strong>-XX:+UseConcMarkSweepGC</strong> 启动并发GC，一般针对Tenured区域。</li>\n</ul>\n<h1 id=\"实战问题\"><a href=\"#实战问题\" class=\"headerlink\" title=\"实战问题\"></a>实战问题</h1><p>常见的OOM现象有以下几种：</p>\n<ol>\n<li><p>heapSize溢出：<strong>java.lang.OutOfMemoryError：</strong>java heap space</p>\n<p>这个需要设置Java虚拟机的内存情况</p>\n</li>\n<li><p>PermSize溢出：<strong>java.lang.OutOfMemoryError：</strong>PermGen space</p>\n<p>需要设置Perm相关参数以及检查内存中的常量情况，jdk1.7中的常量池移到了堆中。</p>\n</li>\n<li><p>栈内存溢出错误：<strong>StackOverflowError</strong></p>\n<p>通常都是程序的问题，JVM对栈帧的大小设置已经很大了，比如递归</p>\n</li>\n<li><p>native Thread溢出，注意线程Stack的大小，以及本身操作系统的限制。</p>\n</li>\n</ol>"},{"title":"HashMap源码学习","author":"James","date":"2013-06-24T08:10:00.000Z","_content":"# 介绍\n*HashMap*实现了*Map*接口，即允许放入`key`为`null`的元素，也允许插入`value`为`null`的元素；除该类未实现同步外，其余跟`Hashtable`大致相同；跟*TreeMap*不同，该容器不保证元素顺序，根据需要该容器可能会对元素重新哈希，元素的顺序也会被重新打散，因此不同时间迭代同一个*HashMap*的顺序可能会不同。\n根据对冲突的处理方式不同，哈希表有两种实现方式，一种开放地址方式（Open addressing），另一种是冲突链表方式（Separate chaining with linked lists）。**Java *HashMap*采用的是冲突链表方式**。\n<!-- more -->\n![HashMap_base](/images/hashmap/HashMap_base.png)\n\n从上图容易看出，如果选择合适的哈希函数，`put()`和`get()`方法可以在常数时间内完成。但在对*HashMap*进行迭代时，需要遍历整个table以及后面跟的冲突链表。因此对于迭代比较频繁的场景，不宜将*HashMap*的初始大小设的过大。\n\n有两个参数可以影响*HashMap*的性能：初始容量（inital capacity）和负载系数（load factor）。初始容量指定了初始`table`的大小，负载系数用来指定自动扩容的临界值。当`entry`的数量超过`capacity*load_factor`时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。\n\n将对象放入到*HashMap*或*HashSet*中时，有两个方法需要特别关心：`hashCode()`和`equals()`。**`hashCode()`方法决定了对象会被放到哪个`bucket`里，当多个对象的哈希值冲突时，`equals()`方法决定了这些对象是否是“同一个对象”**。所以，如果要将自定义的对象放入到`HashMap`或`HashSet`中，需要*@Override*`hashCode()`和`equals()`方法。\n\n# 方法剖析\n\n## get()\n\n`get(Object key)`方法根据指定的`key`值返回对应的`value`，该方法调用了`getEntry(Object key)`得到相应的`entry`，然后返回`entry.getValue()`。因此`getEntry()`是算法的核心。\n算法思想是首先通过`hash()`函数得到对应`bucket`的下标，然后依次遍历冲突链表，通过`key.equals(k)`方法来判断是否是要找的那个`entry`。\n![HashMap_getEntry](/images/hashmap/HashMap_getEntry.png)\n上图中`hash(k)&(table.length-1)`等价于`hash(k)%table.length`，原因是*HashMap*要求`table.length`必须是2的指数，因此`table.length-1`就是二进制低位全是1，跟`hash(k)`相与会将哈希值的高位全抹掉，剩下的就是余数了。\n```Java\n//getEntry()方法\nfinal Entry<K,V> getEntry(Object key) {\n\t......\n\tint hash = (key == null) ? 0 : hash(key);\n    for (Entry<K,V> e = table[hash&(table.length-1)];//得到冲突链表\n         e != null; e = e.next) {//依次遍历冲突链表中的每个entry\n        Object k;\n        //依据equals()方法判断是否相等\n        if (e.hash == hash &&\n            ((k = e.key) == key || (key != null && key.equals(k))))\n            return e;\n    }\n    return null;\n}\n```\n\n## put()\n\n`put(K key, V value)`方法是将指定的`key, value`对添加到`map`里。该方法首先会对`map`做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于`getEntry()`方法；如果没有找到，则会通过`addEntry(int hash, K key, V value, int bucketIndex)`方法插入新的`entry`，插入方式为**头插法**。\n![HashMap_addEntry](/images/hashmap/HashMap_addEntry.png)\n```Java\n//addEntry()\nvoid addEntry(int hash, K key, V value, int bucketIndex) {\n    if ((size >= threshold) && (null != table[bucketIndex])) {\n        resize(2 * table.length);//自动扩容，并重新哈希\n        hash = (null != key) ? hash(key) : 0;\n        bucketIndex = hash & (table.length-1);//hash%table.length\n    }\n    //在冲突链表头部插入新的entry\n    Entry<K,V> e = table[bucketIndex];\n    table[bucketIndex] = new Entry<>(hash, key, value, e);\n    size++;\n}\n```\n\n## remove()\n\n`remove(Object key)`的作用是删除`key`值对应的`entry`，该方法的具体逻辑是在`removeEntryForKey(Object key)`里实现的。`removeEntryForKey()`方法会首先找到`key`值对应的`entry`，然后删除该`entry`（修改链表的相应引用）。查找过程跟`getEntry()`过程类似。\n![HashMap_removeEntryForKey](/images/hashmap/HashMap_removeEntryForKey.png)\n```Java\n//removeEntryForKey()\nfinal Entry<K,V> removeEntryForKey(Object key) {\n\t......\n\tint hash = (key == null) ? 0 : hash(key);\n    int i = indexFor(hash, table.length);//hash&(table.length-1)\n    Entry<K,V> prev = table[i];//得到冲突链表\n    Entry<K,V> e = prev;\n    while (e != null) {//遍历冲突链表\n        Entry<K,V> next = e.next;\n        Object k;\n        if (e.hash == hash &&\n            ((k = e.key) == key || (key != null && key.equals(k)))) {//找到要删除的entry\n            modCount++; size--;\n            if (prev == e) table[i] = next;//删除的是冲突链表的第一个entry\n            else prev.next = next;\n            return e;\n        }\n        prev = e; e = next;\n    }\n    return e;\n}\n```\n\n\n","source":"_posts/HashMap.md","raw":"title: HashMap源码学习\nauthor: James\ntags:\n  - Java\ncategories:\n  - 语言\ndate: 2013-06-24 16:10:00\n---\n# 介绍\n*HashMap*实现了*Map*接口，即允许放入`key`为`null`的元素，也允许插入`value`为`null`的元素；除该类未实现同步外，其余跟`Hashtable`大致相同；跟*TreeMap*不同，该容器不保证元素顺序，根据需要该容器可能会对元素重新哈希，元素的顺序也会被重新打散，因此不同时间迭代同一个*HashMap*的顺序可能会不同。\n根据对冲突的处理方式不同，哈希表有两种实现方式，一种开放地址方式（Open addressing），另一种是冲突链表方式（Separate chaining with linked lists）。**Java *HashMap*采用的是冲突链表方式**。\n<!-- more -->\n![HashMap_base](/images/hashmap/HashMap_base.png)\n\n从上图容易看出，如果选择合适的哈希函数，`put()`和`get()`方法可以在常数时间内完成。但在对*HashMap*进行迭代时，需要遍历整个table以及后面跟的冲突链表。因此对于迭代比较频繁的场景，不宜将*HashMap*的初始大小设的过大。\n\n有两个参数可以影响*HashMap*的性能：初始容量（inital capacity）和负载系数（load factor）。初始容量指定了初始`table`的大小，负载系数用来指定自动扩容的临界值。当`entry`的数量超过`capacity*load_factor`时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。\n\n将对象放入到*HashMap*或*HashSet*中时，有两个方法需要特别关心：`hashCode()`和`equals()`。**`hashCode()`方法决定了对象会被放到哪个`bucket`里，当多个对象的哈希值冲突时，`equals()`方法决定了这些对象是否是“同一个对象”**。所以，如果要将自定义的对象放入到`HashMap`或`HashSet`中，需要*@Override*`hashCode()`和`equals()`方法。\n\n# 方法剖析\n\n## get()\n\n`get(Object key)`方法根据指定的`key`值返回对应的`value`，该方法调用了`getEntry(Object key)`得到相应的`entry`，然后返回`entry.getValue()`。因此`getEntry()`是算法的核心。\n算法思想是首先通过`hash()`函数得到对应`bucket`的下标，然后依次遍历冲突链表，通过`key.equals(k)`方法来判断是否是要找的那个`entry`。\n![HashMap_getEntry](/images/hashmap/HashMap_getEntry.png)\n上图中`hash(k)&(table.length-1)`等价于`hash(k)%table.length`，原因是*HashMap*要求`table.length`必须是2的指数，因此`table.length-1`就是二进制低位全是1，跟`hash(k)`相与会将哈希值的高位全抹掉，剩下的就是余数了。\n```Java\n//getEntry()方法\nfinal Entry<K,V> getEntry(Object key) {\n\t......\n\tint hash = (key == null) ? 0 : hash(key);\n    for (Entry<K,V> e = table[hash&(table.length-1)];//得到冲突链表\n         e != null; e = e.next) {//依次遍历冲突链表中的每个entry\n        Object k;\n        //依据equals()方法判断是否相等\n        if (e.hash == hash &&\n            ((k = e.key) == key || (key != null && key.equals(k))))\n            return e;\n    }\n    return null;\n}\n```\n\n## put()\n\n`put(K key, V value)`方法是将指定的`key, value`对添加到`map`里。该方法首先会对`map`做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于`getEntry()`方法；如果没有找到，则会通过`addEntry(int hash, K key, V value, int bucketIndex)`方法插入新的`entry`，插入方式为**头插法**。\n![HashMap_addEntry](/images/hashmap/HashMap_addEntry.png)\n```Java\n//addEntry()\nvoid addEntry(int hash, K key, V value, int bucketIndex) {\n    if ((size >= threshold) && (null != table[bucketIndex])) {\n        resize(2 * table.length);//自动扩容，并重新哈希\n        hash = (null != key) ? hash(key) : 0;\n        bucketIndex = hash & (table.length-1);//hash%table.length\n    }\n    //在冲突链表头部插入新的entry\n    Entry<K,V> e = table[bucketIndex];\n    table[bucketIndex] = new Entry<>(hash, key, value, e);\n    size++;\n}\n```\n\n## remove()\n\n`remove(Object key)`的作用是删除`key`值对应的`entry`，该方法的具体逻辑是在`removeEntryForKey(Object key)`里实现的。`removeEntryForKey()`方法会首先找到`key`值对应的`entry`，然后删除该`entry`（修改链表的相应引用）。查找过程跟`getEntry()`过程类似。\n![HashMap_removeEntryForKey](/images/hashmap/HashMap_removeEntryForKey.png)\n```Java\n//removeEntryForKey()\nfinal Entry<K,V> removeEntryForKey(Object key) {\n\t......\n\tint hash = (key == null) ? 0 : hash(key);\n    int i = indexFor(hash, table.length);//hash&(table.length-1)\n    Entry<K,V> prev = table[i];//得到冲突链表\n    Entry<K,V> e = prev;\n    while (e != null) {//遍历冲突链表\n        Entry<K,V> next = e.next;\n        Object k;\n        if (e.hash == hash &&\n            ((k = e.key) == key || (key != null && key.equals(k)))) {//找到要删除的entry\n            modCount++; size--;\n            if (prev == e) table[i] = next;//删除的是冲突链表的第一个entry\n            else prev.next = next;\n            return e;\n        }\n        prev = e; e = next;\n    }\n    return e;\n}\n```\n\n\n","slug":"HashMap","published":1,"updated":"2018-02-24T08:18:23.594Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjefa5boa00046skc6qmw3y60","content":"<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p><em>HashMap</em>实现了<em>Map</em>接口，即允许放入<code>key</code>为<code>null</code>的元素，也允许插入<code>value</code>为<code>null</code>的元素；除该类未实现同步外，其余跟<code>Hashtable</code>大致相同；跟<em>TreeMap</em>不同，该容器不保证元素顺序，根据需要该容器可能会对元素重新哈希，元素的顺序也会被重新打散，因此不同时间迭代同一个<em>HashMap</em>的顺序可能会不同。<br>根据对冲突的处理方式不同，哈希表有两种实现方式，一种开放地址方式（Open addressing），另一种是冲突链表方式（Separate chaining with linked lists）。<strong>Java <em>HashMap</em>采用的是冲突链表方式</strong>。<br><a id=\"more\"></a><br><img src=\"/images/hashmap/HashMap_base.png\" alt=\"HashMap_base\"></p>\n<p>从上图容易看出，如果选择合适的哈希函数，<code>put()</code>和<code>get()</code>方法可以在常数时间内完成。但在对<em>HashMap</em>进行迭代时，需要遍历整个table以及后面跟的冲突链表。因此对于迭代比较频繁的场景，不宜将<em>HashMap</em>的初始大小设的过大。</p>\n<p>有两个参数可以影响<em>HashMap</em>的性能：初始容量（inital capacity）和负载系数（load factor）。初始容量指定了初始<code>table</code>的大小，负载系数用来指定自动扩容的临界值。当<code>entry</code>的数量超过<code>capacity*load_factor</code>时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。</p>\n<p>将对象放入到<em>HashMap</em>或<em>HashSet</em>中时，有两个方法需要特别关心：<code>hashCode()</code>和<code>equals()</code>。<strong><code>hashCode()</code>方法决定了对象会被放到哪个<code>bucket</code>里，当多个对象的哈希值冲突时，<code>equals()</code>方法决定了这些对象是否是“同一个对象”</strong>。所以，如果要将自定义的对象放入到<code>HashMap</code>或<code>HashSet</code>中，需要<em>@Override</em><code>hashCode()</code>和<code>equals()</code>方法。</p>\n<h1 id=\"方法剖析\"><a href=\"#方法剖析\" class=\"headerlink\" title=\"方法剖析\"></a>方法剖析</h1><h2 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get()\"></a>get()</h2><p><code>get(Object key)</code>方法根据指定的<code>key</code>值返回对应的<code>value</code>，该方法调用了<code>getEntry(Object key)</code>得到相应的<code>entry</code>，然后返回<code>entry.getValue()</code>。因此<code>getEntry()</code>是算法的核心。<br>算法思想是首先通过<code>hash()</code>函数得到对应<code>bucket</code>的下标，然后依次遍历冲突链表，通过<code>key.equals(k)</code>方法来判断是否是要找的那个<code>entry</code>。<br><img src=\"/images/hashmap/HashMap_getEntry.png\" alt=\"HashMap_getEntry\"><br>上图中<code>hash(k)&amp;(table.length-1)</code>等价于<code>hash(k)%table.length</code>，原因是<em>HashMap</em>要求<code>table.length</code>必须是2的指数，因此<code>table.length-1</code>就是二进制低位全是1，跟<code>hash(k)</code>相与会将哈希值的高位全抹掉，剩下的就是余数了。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//getEntry()方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Entry&lt;K,V&gt; <span class=\"title\">getEntry</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> hash = (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : hash(key);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Entry&lt;K,V&gt; e = table[hash&amp;(table.length-<span class=\"number\">1</span>)];<span class=\"comment\">//得到冲突链表</span></span><br><span class=\"line\">         e != <span class=\"keyword\">null</span>; e = e.next) &#123;<span class=\"comment\">//依次遍历冲突链表中的每个entry</span></span><br><span class=\"line\">        Object k;</span><br><span class=\"line\">        <span class=\"comment\">//依据equals()方法判断是否相等</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">            ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"put\"><a href=\"#put\" class=\"headerlink\" title=\"put()\"></a>put()</h2><p><code>put(K key, V value)</code>方法是将指定的<code>key, value</code>对添加到<code>map</code>里。该方法首先会对<code>map</code>做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于<code>getEntry()</code>方法；如果没有找到，则会通过<code>addEntry(int hash, K key, V value, int bucketIndex)</code>方法插入新的<code>entry</code>，插入方式为<strong>头插法</strong>。<br><img src=\"/images/hashmap/HashMap_addEntry.png\" alt=\"HashMap_addEntry\"><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//addEntry()</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addEntry</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">int</span> bucketIndex)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((size &gt;= threshold) &amp;&amp; (<span class=\"keyword\">null</span> != table[bucketIndex])) &#123;</span><br><span class=\"line\">        resize(<span class=\"number\">2</span> * table.length);<span class=\"comment\">//自动扩容，并重新哈希</span></span><br><span class=\"line\">        hash = (<span class=\"keyword\">null</span> != key) ? hash(key) : <span class=\"number\">0</span>;</span><br><span class=\"line\">        bucketIndex = hash &amp; (table.length-<span class=\"number\">1</span>);<span class=\"comment\">//hash%table.length</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//在冲突链表头部插入新的entry</span></span><br><span class=\"line\">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class=\"line\">    table[bucketIndex] = <span class=\"keyword\">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class=\"line\">    size++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"remove\"><a href=\"#remove\" class=\"headerlink\" title=\"remove()\"></a>remove()</h2><p><code>remove(Object key)</code>的作用是删除<code>key</code>值对应的<code>entry</code>，该方法的具体逻辑是在<code>removeEntryForKey(Object key)</code>里实现的。<code>removeEntryForKey()</code>方法会首先找到<code>key</code>值对应的<code>entry</code>，然后删除该<code>entry</code>（修改链表的相应引用）。查找过程跟<code>getEntry()</code>过程类似。<br><img src=\"/images/hashmap/HashMap_removeEntryForKey.png\" alt=\"HashMap_removeEntryForKey\"><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//removeEntryForKey()</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Entry&lt;K,V&gt; <span class=\"title\">removeEntryForKey</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> hash = (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : hash(key);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = indexFor(hash, table.length);<span class=\"comment\">//hash&amp;(table.length-1)</span></span><br><span class=\"line\">    Entry&lt;K,V&gt; prev = table[i];<span class=\"comment\">//得到冲突链表</span></span><br><span class=\"line\">    Entry&lt;K,V&gt; e = prev;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (e != <span class=\"keyword\">null</span>) &#123;<span class=\"comment\">//遍历冲突链表</span></span><br><span class=\"line\">        Entry&lt;K,V&gt; next = e.next;</span><br><span class=\"line\">        Object k;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">            ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k)))) &#123;<span class=\"comment\">//找到要删除的entry</span></span><br><span class=\"line\">            modCount++; size--;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (prev == e) table[i] = next;<span class=\"comment\">//删除的是冲突链表的第一个entry</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> prev.next = next;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        prev = e; e = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p><em>HashMap</em>实现了<em>Map</em>接口，即允许放入<code>key</code>为<code>null</code>的元素，也允许插入<code>value</code>为<code>null</code>的元素；除该类未实现同步外，其余跟<code>Hashtable</code>大致相同；跟<em>TreeMap</em>不同，该容器不保证元素顺序，根据需要该容器可能会对元素重新哈希，元素的顺序也会被重新打散，因此不同时间迭代同一个<em>HashMap</em>的顺序可能会不同。<br>根据对冲突的处理方式不同，哈希表有两种实现方式，一种开放地址方式（Open addressing），另一种是冲突链表方式（Separate chaining with linked lists）。<strong>Java <em>HashMap</em>采用的是冲突链表方式</strong>。<br>","more":"<br><img src=\"/images/hashmap/HashMap_base.png\" alt=\"HashMap_base\"></p>\n<p>从上图容易看出，如果选择合适的哈希函数，<code>put()</code>和<code>get()</code>方法可以在常数时间内完成。但在对<em>HashMap</em>进行迭代时，需要遍历整个table以及后面跟的冲突链表。因此对于迭代比较频繁的场景，不宜将<em>HashMap</em>的初始大小设的过大。</p>\n<p>有两个参数可以影响<em>HashMap</em>的性能：初始容量（inital capacity）和负载系数（load factor）。初始容量指定了初始<code>table</code>的大小，负载系数用来指定自动扩容的临界值。当<code>entry</code>的数量超过<code>capacity*load_factor</code>时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。</p>\n<p>将对象放入到<em>HashMap</em>或<em>HashSet</em>中时，有两个方法需要特别关心：<code>hashCode()</code>和<code>equals()</code>。<strong><code>hashCode()</code>方法决定了对象会被放到哪个<code>bucket</code>里，当多个对象的哈希值冲突时，<code>equals()</code>方法决定了这些对象是否是“同一个对象”</strong>。所以，如果要将自定义的对象放入到<code>HashMap</code>或<code>HashSet</code>中，需要<em>@Override</em><code>hashCode()</code>和<code>equals()</code>方法。</p>\n<h1 id=\"方法剖析\"><a href=\"#方法剖析\" class=\"headerlink\" title=\"方法剖析\"></a>方法剖析</h1><h2 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get()\"></a>get()</h2><p><code>get(Object key)</code>方法根据指定的<code>key</code>值返回对应的<code>value</code>，该方法调用了<code>getEntry(Object key)</code>得到相应的<code>entry</code>，然后返回<code>entry.getValue()</code>。因此<code>getEntry()</code>是算法的核心。<br>算法思想是首先通过<code>hash()</code>函数得到对应<code>bucket</code>的下标，然后依次遍历冲突链表，通过<code>key.equals(k)</code>方法来判断是否是要找的那个<code>entry</code>。<br><img src=\"/images/hashmap/HashMap_getEntry.png\" alt=\"HashMap_getEntry\"><br>上图中<code>hash(k)&amp;(table.length-1)</code>等价于<code>hash(k)%table.length</code>，原因是<em>HashMap</em>要求<code>table.length</code>必须是2的指数，因此<code>table.length-1</code>就是二进制低位全是1，跟<code>hash(k)</code>相与会将哈希值的高位全抹掉，剩下的就是余数了。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//getEntry()方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Entry&lt;K,V&gt; <span class=\"title\">getEntry</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> hash = (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : hash(key);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Entry&lt;K,V&gt; e = table[hash&amp;(table.length-<span class=\"number\">1</span>)];<span class=\"comment\">//得到冲突链表</span></span><br><span class=\"line\">         e != <span class=\"keyword\">null</span>; e = e.next) &#123;<span class=\"comment\">//依次遍历冲突链表中的每个entry</span></span><br><span class=\"line\">        Object k;</span><br><span class=\"line\">        <span class=\"comment\">//依据equals()方法判断是否相等</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">            ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"put\"><a href=\"#put\" class=\"headerlink\" title=\"put()\"></a>put()</h2><p><code>put(K key, V value)</code>方法是将指定的<code>key, value</code>对添加到<code>map</code>里。该方法首先会对<code>map</code>做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于<code>getEntry()</code>方法；如果没有找到，则会通过<code>addEntry(int hash, K key, V value, int bucketIndex)</code>方法插入新的<code>entry</code>，插入方式为<strong>头插法</strong>。<br><img src=\"/images/hashmap/HashMap_addEntry.png\" alt=\"HashMap_addEntry\"><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//addEntry()</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addEntry</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">int</span> bucketIndex)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((size &gt;= threshold) &amp;&amp; (<span class=\"keyword\">null</span> != table[bucketIndex])) &#123;</span><br><span class=\"line\">        resize(<span class=\"number\">2</span> * table.length);<span class=\"comment\">//自动扩容，并重新哈希</span></span><br><span class=\"line\">        hash = (<span class=\"keyword\">null</span> != key) ? hash(key) : <span class=\"number\">0</span>;</span><br><span class=\"line\">        bucketIndex = hash &amp; (table.length-<span class=\"number\">1</span>);<span class=\"comment\">//hash%table.length</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//在冲突链表头部插入新的entry</span></span><br><span class=\"line\">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class=\"line\">    table[bucketIndex] = <span class=\"keyword\">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class=\"line\">    size++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"remove\"><a href=\"#remove\" class=\"headerlink\" title=\"remove()\"></a>remove()</h2><p><code>remove(Object key)</code>的作用是删除<code>key</code>值对应的<code>entry</code>，该方法的具体逻辑是在<code>removeEntryForKey(Object key)</code>里实现的。<code>removeEntryForKey()</code>方法会首先找到<code>key</code>值对应的<code>entry</code>，然后删除该<code>entry</code>（修改链表的相应引用）。查找过程跟<code>getEntry()</code>过程类似。<br><img src=\"/images/hashmap/HashMap_removeEntryForKey.png\" alt=\"HashMap_removeEntryForKey\"><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//removeEntryForKey()</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Entry&lt;K,V&gt; <span class=\"title\">removeEntryForKey</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> hash = (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : hash(key);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = indexFor(hash, table.length);<span class=\"comment\">//hash&amp;(table.length-1)</span></span><br><span class=\"line\">    Entry&lt;K,V&gt; prev = table[i];<span class=\"comment\">//得到冲突链表</span></span><br><span class=\"line\">    Entry&lt;K,V&gt; e = prev;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (e != <span class=\"keyword\">null</span>) &#123;<span class=\"comment\">//遍历冲突链表</span></span><br><span class=\"line\">        Entry&lt;K,V&gt; next = e.next;</span><br><span class=\"line\">        Object k;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">            ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k)))) &#123;<span class=\"comment\">//找到要删除的entry</span></span><br><span class=\"line\">            modCount++; size--;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (prev == e) table[i] = next;<span class=\"comment\">//删除的是冲突链表的第一个entry</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> prev.next = next;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        prev = e; e = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>"},{"title":"LinkedList源码学习","author":"James","date":"2013-02-26T01:58:00.000Z","_content":"# LinkedList\n\n# 介绍\n\n*LinkedList*同时实现了*List*接口和*Deque*接口，也就是说它既可以看作一个顺序容器，又可以看作一个队列（*Queue*），同时又可以看作一个栈（*Stack*）。这样看来，*LinkedList*简直就是个全能冠军。当你需要使用栈或者队列时，可以考虑使用*LinkedList*，一方面是因为Java官方已经声明不建议使用*Stack*类，更遗憾的是，Java里根本没有一个叫做*Queue*的类（它是个接口名字）。关于栈或队列，现在的首选是*ArrayDeque*，它有着比*LinkedList*（当作栈或队列使用时）有着更好的性能。\n<!-- more -->\n\n![LinkedList_base](/images/linklist/LinkedList_base.png)\n\n*LinkedList*底层**通过双向链表实现**，本节将着重讲解插入和删除元素时双向链表的维护过程，也即是之间解跟*List*接口相关的函数，双向链表的每个节点用内部类*Node*表示。*LinkedList*通过`first`和`last`引用分别指向链表的第一个和最后一个元素。注意这里没有所谓的哑元，当链表为空的时候`first`和`last`都指向`null`。\n\n```Java\n//Node内部类\nprivate static class Node<E> {\n    E item;\n    Node<E> next;\n    Node<E> prev;\n    Node(Node<E> prev, E element, Node<E> next) {\n        this.item = element;\n        this.next = next;\n        this.prev = prev;\n    }\n}\n```\n\n*LinkedList*的实现方式决定了所有跟下标相关的操作都是线性时间，而在首段或者末尾删除元素只需要常数时间。为追求效率*LinkedList*没有实现同步（synchronized），如果需要多个线程并发访问，可以先采用`Collections.synchronizedList()`方法对其进行包装。\n\n# 方法剖析\n\n## add()\n\n*add()*方法有两个版本，一个是`add(E e)`，该方法在*LinkedList*的末尾插入元素，因为有`last`指向链表末尾，在末尾插入元素的花费是常数时间。只需要简单修改几个相关引用即可；另一个是`add(int index, E element)`，该方法是在指定下表处插入元素，需要先通过线性查找找到具体位置，然后修改相关引用完成插入操作。\n\n![LinkedList_add](/images/linklist/LinkedList_add.png)\n\n结合上图，可以看出`add(E e)`的逻辑非常简单。\n```Java\n//add(E e)\npublic boolean add(E e) {\n    final Node<E> l = last;\n    final Node<E> newNode = new Node<>(l, e, null);\n    last = newNode;\n    if (l == null)\n        first = newNode;//原来链表为空，这是插入的第一个元素\n    else\n        l.next = newNode;\n    size++;\n    return true;\n}\n```\n\n`add(int index, E element)`的逻辑稍显复杂，可以分成两部分，1.先根据index找到要插入的位置；2.修改引用，完成插入操作。\n\n```Java\n//add(int index, E element)\npublic void add(int index, E element) {\n\tcheckPositionIndex(index);//index >= 0 && index <= size;\n\tif (index == size)//插入位置是末尾，包括列表为空的情况\n        add(element);\n    else{\n    \tNode<E> succ = node(index);//1.先根据index找到要插入的位置\n        //2.修改引用，完成插入操作。\n        final Node<E> pred = succ.prev;\n        final Node<E> newNode = new Node<>(pred, e, succ);\n        succ.prev = newNode;\n        if (pred == null)//插入位置为0\n            first = newNode;\n        else\n            pred.next = newNode;\n        size++;\n    }\n}\n```\n\n上面代码中的`node(int index)`函数有一点小小的trick，因为链表双向的，可以从开始往后找，也可以从结尾往前找，具体朝那个方向找取决于条件`index < (size >> 1)`，也即是index是靠近前端还是后端。\n\n## remove()\n\n`remove()`方法也有两个版本，一个是删除跟指定元素相等的第一个元素`remove(Object o)`，另一个是删除指定下标处的元素`remove(int index)`。\n\n![LinkedList_remove.png](/images/linklist/LinkedList_remove.png)\n\n两个删除操作都要1.先找到要删除元素的引用，2.修改相关引用，完成删除操作。在寻找被删元素引用的时候`remove(Object o)`调用的是元素的`equals`方法，而`remove(int index)`使用的是下标计数，两种方式都是线性时间复杂度。在步骤2中，两个`revome()`方法都是通过`unlink(Node<E> x)`方法完成的。这里需要考虑删除元素是第一个或者最后一个时的边界情况。\n\n```Java\n//unlink(Node<E> x)，删除一个Node\nE unlink(Node<E> x) {\n    final E element = x.item;\n    final Node<E> next = x.next;\n    final Node<E> prev = x.prev;\n    if (prev == null) {//删除的是第一个元素\n        first = next;\n    } else {\n        prev.next = next;\n        x.prev = null;\n    }\n    if (next == null) {//删除的是最后一个元素\n        last = prev;\n    } else {\n        next.prev = prev;\n        x.next = null;\n    }\n    x.item = null;//let GC work\n    size--;\n    return element;\n}\n```\n\n# get()\n\n`get(int index)`得到指定下标处元素的引用，通过调用上文中提到的`node(int index)`方法实现。\n```Java\npublic E get(int index) {\n    checkElementIndex(index);//index >= 0 && index < size;\n    return node(index).item;\n}\n```\n\n# set()\n\n`set(int index, E element)`方法将指定下标处的元素修改成指定值，也是先通过`node(int index)`找到对应下表元素的引用，然后修改`Node`中`item`的值。\n```Java\npublic E set(int index, E element) {\n    checkElementIndex(index);\n    Node<E> x = node(index);\n    E oldVal = x.item;\n    x.item = element;//替换新值\n    return oldVal;\n}\n```","source":"_posts/LinkedList.md","raw":"title: LinkedList源码学习\nauthor: James\ntags:\n  - java\ncategories:\n  - 语言\ndate: 2013-02-26 09:58:00\n---\n# LinkedList\n\n# 介绍\n\n*LinkedList*同时实现了*List*接口和*Deque*接口，也就是说它既可以看作一个顺序容器，又可以看作一个队列（*Queue*），同时又可以看作一个栈（*Stack*）。这样看来，*LinkedList*简直就是个全能冠军。当你需要使用栈或者队列时，可以考虑使用*LinkedList*，一方面是因为Java官方已经声明不建议使用*Stack*类，更遗憾的是，Java里根本没有一个叫做*Queue*的类（它是个接口名字）。关于栈或队列，现在的首选是*ArrayDeque*，它有着比*LinkedList*（当作栈或队列使用时）有着更好的性能。\n<!-- more -->\n\n![LinkedList_base](/images/linklist/LinkedList_base.png)\n\n*LinkedList*底层**通过双向链表实现**，本节将着重讲解插入和删除元素时双向链表的维护过程，也即是之间解跟*List*接口相关的函数，双向链表的每个节点用内部类*Node*表示。*LinkedList*通过`first`和`last`引用分别指向链表的第一个和最后一个元素。注意这里没有所谓的哑元，当链表为空的时候`first`和`last`都指向`null`。\n\n```Java\n//Node内部类\nprivate static class Node<E> {\n    E item;\n    Node<E> next;\n    Node<E> prev;\n    Node(Node<E> prev, E element, Node<E> next) {\n        this.item = element;\n        this.next = next;\n        this.prev = prev;\n    }\n}\n```\n\n*LinkedList*的实现方式决定了所有跟下标相关的操作都是线性时间，而在首段或者末尾删除元素只需要常数时间。为追求效率*LinkedList*没有实现同步（synchronized），如果需要多个线程并发访问，可以先采用`Collections.synchronizedList()`方法对其进行包装。\n\n# 方法剖析\n\n## add()\n\n*add()*方法有两个版本，一个是`add(E e)`，该方法在*LinkedList*的末尾插入元素，因为有`last`指向链表末尾，在末尾插入元素的花费是常数时间。只需要简单修改几个相关引用即可；另一个是`add(int index, E element)`，该方法是在指定下表处插入元素，需要先通过线性查找找到具体位置，然后修改相关引用完成插入操作。\n\n![LinkedList_add](/images/linklist/LinkedList_add.png)\n\n结合上图，可以看出`add(E e)`的逻辑非常简单。\n```Java\n//add(E e)\npublic boolean add(E e) {\n    final Node<E> l = last;\n    final Node<E> newNode = new Node<>(l, e, null);\n    last = newNode;\n    if (l == null)\n        first = newNode;//原来链表为空，这是插入的第一个元素\n    else\n        l.next = newNode;\n    size++;\n    return true;\n}\n```\n\n`add(int index, E element)`的逻辑稍显复杂，可以分成两部分，1.先根据index找到要插入的位置；2.修改引用，完成插入操作。\n\n```Java\n//add(int index, E element)\npublic void add(int index, E element) {\n\tcheckPositionIndex(index);//index >= 0 && index <= size;\n\tif (index == size)//插入位置是末尾，包括列表为空的情况\n        add(element);\n    else{\n    \tNode<E> succ = node(index);//1.先根据index找到要插入的位置\n        //2.修改引用，完成插入操作。\n        final Node<E> pred = succ.prev;\n        final Node<E> newNode = new Node<>(pred, e, succ);\n        succ.prev = newNode;\n        if (pred == null)//插入位置为0\n            first = newNode;\n        else\n            pred.next = newNode;\n        size++;\n    }\n}\n```\n\n上面代码中的`node(int index)`函数有一点小小的trick，因为链表双向的，可以从开始往后找，也可以从结尾往前找，具体朝那个方向找取决于条件`index < (size >> 1)`，也即是index是靠近前端还是后端。\n\n## remove()\n\n`remove()`方法也有两个版本，一个是删除跟指定元素相等的第一个元素`remove(Object o)`，另一个是删除指定下标处的元素`remove(int index)`。\n\n![LinkedList_remove.png](/images/linklist/LinkedList_remove.png)\n\n两个删除操作都要1.先找到要删除元素的引用，2.修改相关引用，完成删除操作。在寻找被删元素引用的时候`remove(Object o)`调用的是元素的`equals`方法，而`remove(int index)`使用的是下标计数，两种方式都是线性时间复杂度。在步骤2中，两个`revome()`方法都是通过`unlink(Node<E> x)`方法完成的。这里需要考虑删除元素是第一个或者最后一个时的边界情况。\n\n```Java\n//unlink(Node<E> x)，删除一个Node\nE unlink(Node<E> x) {\n    final E element = x.item;\n    final Node<E> next = x.next;\n    final Node<E> prev = x.prev;\n    if (prev == null) {//删除的是第一个元素\n        first = next;\n    } else {\n        prev.next = next;\n        x.prev = null;\n    }\n    if (next == null) {//删除的是最后一个元素\n        last = prev;\n    } else {\n        next.prev = prev;\n        x.next = null;\n    }\n    x.item = null;//let GC work\n    size--;\n    return element;\n}\n```\n\n# get()\n\n`get(int index)`得到指定下标处元素的引用，通过调用上文中提到的`node(int index)`方法实现。\n```Java\npublic E get(int index) {\n    checkElementIndex(index);//index >= 0 && index < size;\n    return node(index).item;\n}\n```\n\n# set()\n\n`set(int index, E element)`方法将指定下标处的元素修改成指定值，也是先通过`node(int index)`找到对应下表元素的引用，然后修改`Node`中`item`的值。\n```Java\npublic E set(int index, E element) {\n    checkElementIndex(index);\n    Node<E> x = node(index);\n    E oldVal = x.item;\n    x.item = element;//替换新值\n    return oldVal;\n}\n```","slug":"LinkedList","published":1,"updated":"2018-02-26T02:22:28.180Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjefa5bot000a6skc44xvg46r","content":"<h1 id=\"LinkedList\"><a href=\"#LinkedList\" class=\"headerlink\" title=\"LinkedList\"></a>LinkedList</h1><h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p><em>LinkedList</em>同时实现了<em>List</em>接口和<em>Deque</em>接口，也就是说它既可以看作一个顺序容器，又可以看作一个队列（<em>Queue</em>），同时又可以看作一个栈（<em>Stack</em>）。这样看来，<em>LinkedList</em>简直就是个全能冠军。当你需要使用栈或者队列时，可以考虑使用<em>LinkedList</em>，一方面是因为Java官方已经声明不建议使用<em>Stack</em>类，更遗憾的是，Java里根本没有一个叫做<em>Queue</em>的类（它是个接口名字）。关于栈或队列，现在的首选是<em>ArrayDeque</em>，它有着比<em>LinkedList</em>（当作栈或队列使用时）有着更好的性能。<br><a id=\"more\"></a></p>\n<p><img src=\"/images/linklist/LinkedList_base.png\" alt=\"LinkedList_base\"></p>\n<p><em>LinkedList</em>底层<strong>通过双向链表实现</strong>，本节将着重讲解插入和删除元素时双向链表的维护过程，也即是之间解跟<em>List</em>接口相关的函数，双向链表的每个节点用内部类<em>Node</em>表示。<em>LinkedList</em>通过<code>first</code>和<code>last</code>引用分别指向链表的第一个和最后一个元素。注意这里没有所谓的哑元，当链表为空的时候<code>first</code>和<code>last</code>都指向<code>null</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Node内部类</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">    E item;</span><br><span class=\"line\">    Node&lt;E&gt; next;</span><br><span class=\"line\">    Node&lt;E&gt; prev;</span><br><span class=\"line\">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.item = element;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.next = next;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.prev = prev;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><em>LinkedList</em>的实现方式决定了所有跟下标相关的操作都是线性时间，而在首段或者末尾删除元素只需要常数时间。为追求效率<em>LinkedList</em>没有实现同步（synchronized），如果需要多个线程并发访问，可以先采用<code>Collections.synchronizedList()</code>方法对其进行包装。</p>\n<h1 id=\"方法剖析\"><a href=\"#方法剖析\" class=\"headerlink\" title=\"方法剖析\"></a>方法剖析</h1><h2 id=\"add\"><a href=\"#add\" class=\"headerlink\" title=\"add()\"></a>add()</h2><p><em>add()</em>方法有两个版本，一个是<code>add(E e)</code>，该方法在<em>LinkedList</em>的末尾插入元素，因为有<code>last</code>指向链表末尾，在末尾插入元素的花费是常数时间。只需要简单修改几个相关引用即可；另一个是<code>add(int index, E element)</code>，该方法是在指定下表处插入元素，需要先通过线性查找找到具体位置，然后修改相关引用完成插入操作。</p>\n<p><img src=\"/images/linklist/LinkedList_add.png\" alt=\"LinkedList_add\"></p>\n<p>结合上图，可以看出<code>add(E e)</code>的逻辑非常简单。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//add(E e)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; l = last;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; newNode = <span class=\"keyword\">new</span> Node&lt;&gt;(l, e, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    last = newNode;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        first = newNode;<span class=\"comment\">//原来链表为空，这是插入的第一个元素</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        l.next = newNode;</span><br><span class=\"line\">    size++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>add(int index, E element)</code>的逻辑稍显复杂，可以分成两部分，1.先根据index找到要插入的位置；2.修改引用，完成插入操作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//add(int index, E element)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\">\tcheckPositionIndex(index);<span class=\"comment\">//index &gt;= 0 &amp;&amp; index &lt;= size;</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (index == size)<span class=\"comment\">//插入位置是末尾，包括列表为空的情况</span></span><br><span class=\"line\">        add(element);</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    \tNode&lt;E&gt; succ = node(index);<span class=\"comment\">//1.先根据index找到要插入的位置</span></span><br><span class=\"line\">        <span class=\"comment\">//2.修改引用，完成插入操作。</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Node&lt;E&gt; newNode = <span class=\"keyword\">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class=\"line\">        succ.prev = newNode;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pred == <span class=\"keyword\">null</span>)<span class=\"comment\">//插入位置为0</span></span><br><span class=\"line\">            first = newNode;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            pred.next = newNode;</span><br><span class=\"line\">        size++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码中的<code>node(int index)</code>函数有一点小小的trick，因为链表双向的，可以从开始往后找，也可以从结尾往前找，具体朝那个方向找取决于条件<code>index &lt; (size &gt;&gt; 1)</code>，也即是index是靠近前端还是后端。</p>\n<h2 id=\"remove\"><a href=\"#remove\" class=\"headerlink\" title=\"remove()\"></a>remove()</h2><p><code>remove()</code>方法也有两个版本，一个是删除跟指定元素相等的第一个元素<code>remove(Object o)</code>，另一个是删除指定下标处的元素<code>remove(int index)</code>。</p>\n<p><img src=\"/images/linklist/LinkedList_remove.png\" alt=\"LinkedList_remove.png\"></p>\n<p>两个删除操作都要1.先找到要删除元素的引用，2.修改相关引用，完成删除操作。在寻找被删元素引用的时候<code>remove(Object o)</code>调用的是元素的<code>equals</code>方法，而<code>remove(int index)</code>使用的是下标计数，两种方式都是线性时间复杂度。在步骤2中，两个<code>revome()</code>方法都是通过<code>unlink(Node&lt;E&gt; x)</code>方法完成的。这里需要考虑删除元素是第一个或者最后一个时的边界情况。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//unlink(Node&lt;E&gt; x)，删除一个Node</span></span><br><span class=\"line\"><span class=\"function\">E <span class=\"title\">unlink</span><span class=\"params\">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> E element = x.item;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; next = x.next;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (prev == <span class=\"keyword\">null</span>) &#123;<span class=\"comment\">//删除的是第一个元素</span></span><br><span class=\"line\">        first = next;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        prev.next = next;</span><br><span class=\"line\">        x.prev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (next == <span class=\"keyword\">null</span>) &#123;<span class=\"comment\">//删除的是最后一个元素</span></span><br><span class=\"line\">        last = prev;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        next.prev = prev;</span><br><span class=\"line\">        x.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    x.item = <span class=\"keyword\">null</span>;<span class=\"comment\">//let GC work</span></span><br><span class=\"line\">    size--;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> element;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get()\"></a>get()</h1><p><code>get(int index)</code>得到指定下标处元素的引用，通过调用上文中提到的<code>node(int index)</code>方法实现。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    checkElementIndex(index);<span class=\"comment\">//index &gt;= 0 &amp;&amp; index &lt; size;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> node(index).item;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set()\"></a>set()</h1><p><code>set(int index, E element)</code>方法将指定下标处的元素修改成指定值，也是先通过<code>node(int index)</code>找到对应下表元素的引用，然后修改<code>Node</code>中<code>item</code>的值。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">set</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\">    checkElementIndex(index);</span><br><span class=\"line\">    Node&lt;E&gt; x = node(index);</span><br><span class=\"line\">    E oldVal = x.item;</span><br><span class=\"line\">    x.item = element;<span class=\"comment\">//替换新值</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> oldVal;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"LinkedList\"><a href=\"#LinkedList\" class=\"headerlink\" title=\"LinkedList\"></a>LinkedList</h1><h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p><em>LinkedList</em>同时实现了<em>List</em>接口和<em>Deque</em>接口，也就是说它既可以看作一个顺序容器，又可以看作一个队列（<em>Queue</em>），同时又可以看作一个栈（<em>Stack</em>）。这样看来，<em>LinkedList</em>简直就是个全能冠军。当你需要使用栈或者队列时，可以考虑使用<em>LinkedList</em>，一方面是因为Java官方已经声明不建议使用<em>Stack</em>类，更遗憾的是，Java里根本没有一个叫做<em>Queue</em>的类（它是个接口名字）。关于栈或队列，现在的首选是<em>ArrayDeque</em>，它有着比<em>LinkedList</em>（当作栈或队列使用时）有着更好的性能。<br>","more":"</p>\n<p><img src=\"/images/linklist/LinkedList_base.png\" alt=\"LinkedList_base\"></p>\n<p><em>LinkedList</em>底层<strong>通过双向链表实现</strong>，本节将着重讲解插入和删除元素时双向链表的维护过程，也即是之间解跟<em>List</em>接口相关的函数，双向链表的每个节点用内部类<em>Node</em>表示。<em>LinkedList</em>通过<code>first</code>和<code>last</code>引用分别指向链表的第一个和最后一个元素。注意这里没有所谓的哑元，当链表为空的时候<code>first</code>和<code>last</code>都指向<code>null</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Node内部类</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">    E item;</span><br><span class=\"line\">    Node&lt;E&gt; next;</span><br><span class=\"line\">    Node&lt;E&gt; prev;</span><br><span class=\"line\">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.item = element;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.next = next;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.prev = prev;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><em>LinkedList</em>的实现方式决定了所有跟下标相关的操作都是线性时间，而在首段或者末尾删除元素只需要常数时间。为追求效率<em>LinkedList</em>没有实现同步（synchronized），如果需要多个线程并发访问，可以先采用<code>Collections.synchronizedList()</code>方法对其进行包装。</p>\n<h1 id=\"方法剖析\"><a href=\"#方法剖析\" class=\"headerlink\" title=\"方法剖析\"></a>方法剖析</h1><h2 id=\"add\"><a href=\"#add\" class=\"headerlink\" title=\"add()\"></a>add()</h2><p><em>add()</em>方法有两个版本，一个是<code>add(E e)</code>，该方法在<em>LinkedList</em>的末尾插入元素，因为有<code>last</code>指向链表末尾，在末尾插入元素的花费是常数时间。只需要简单修改几个相关引用即可；另一个是<code>add(int index, E element)</code>，该方法是在指定下表处插入元素，需要先通过线性查找找到具体位置，然后修改相关引用完成插入操作。</p>\n<p><img src=\"/images/linklist/LinkedList_add.png\" alt=\"LinkedList_add\"></p>\n<p>结合上图，可以看出<code>add(E e)</code>的逻辑非常简单。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//add(E e)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; l = last;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; newNode = <span class=\"keyword\">new</span> Node&lt;&gt;(l, e, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    last = newNode;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        first = newNode;<span class=\"comment\">//原来链表为空，这是插入的第一个元素</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        l.next = newNode;</span><br><span class=\"line\">    size++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>add(int index, E element)</code>的逻辑稍显复杂，可以分成两部分，1.先根据index找到要插入的位置；2.修改引用，完成插入操作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//add(int index, E element)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\">\tcheckPositionIndex(index);<span class=\"comment\">//index &gt;= 0 &amp;&amp; index &lt;= size;</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (index == size)<span class=\"comment\">//插入位置是末尾，包括列表为空的情况</span></span><br><span class=\"line\">        add(element);</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    \tNode&lt;E&gt; succ = node(index);<span class=\"comment\">//1.先根据index找到要插入的位置</span></span><br><span class=\"line\">        <span class=\"comment\">//2.修改引用，完成插入操作。</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Node&lt;E&gt; newNode = <span class=\"keyword\">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class=\"line\">        succ.prev = newNode;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pred == <span class=\"keyword\">null</span>)<span class=\"comment\">//插入位置为0</span></span><br><span class=\"line\">            first = newNode;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            pred.next = newNode;</span><br><span class=\"line\">        size++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码中的<code>node(int index)</code>函数有一点小小的trick，因为链表双向的，可以从开始往后找，也可以从结尾往前找，具体朝那个方向找取决于条件<code>index &lt; (size &gt;&gt; 1)</code>，也即是index是靠近前端还是后端。</p>\n<h2 id=\"remove\"><a href=\"#remove\" class=\"headerlink\" title=\"remove()\"></a>remove()</h2><p><code>remove()</code>方法也有两个版本，一个是删除跟指定元素相等的第一个元素<code>remove(Object o)</code>，另一个是删除指定下标处的元素<code>remove(int index)</code>。</p>\n<p><img src=\"/images/linklist/LinkedList_remove.png\" alt=\"LinkedList_remove.png\"></p>\n<p>两个删除操作都要1.先找到要删除元素的引用，2.修改相关引用，完成删除操作。在寻找被删元素引用的时候<code>remove(Object o)</code>调用的是元素的<code>equals</code>方法，而<code>remove(int index)</code>使用的是下标计数，两种方式都是线性时间复杂度。在步骤2中，两个<code>revome()</code>方法都是通过<code>unlink(Node&lt;E&gt; x)</code>方法完成的。这里需要考虑删除元素是第一个或者最后一个时的边界情况。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//unlink(Node&lt;E&gt; x)，删除一个Node</span></span><br><span class=\"line\"><span class=\"function\">E <span class=\"title\">unlink</span><span class=\"params\">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> E element = x.item;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; next = x.next;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (prev == <span class=\"keyword\">null</span>) &#123;<span class=\"comment\">//删除的是第一个元素</span></span><br><span class=\"line\">        first = next;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        prev.next = next;</span><br><span class=\"line\">        x.prev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (next == <span class=\"keyword\">null</span>) &#123;<span class=\"comment\">//删除的是最后一个元素</span></span><br><span class=\"line\">        last = prev;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        next.prev = prev;</span><br><span class=\"line\">        x.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    x.item = <span class=\"keyword\">null</span>;<span class=\"comment\">//let GC work</span></span><br><span class=\"line\">    size--;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> element;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get()\"></a>get()</h1><p><code>get(int index)</code>得到指定下标处元素的引用，通过调用上文中提到的<code>node(int index)</code>方法实现。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    checkElementIndex(index);<span class=\"comment\">//index &gt;= 0 &amp;&amp; index &lt; size;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> node(index).item;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set()\"></a>set()</h1><p><code>set(int index, E element)</code>方法将指定下标处的元素修改成指定值，也是先通过<code>node(int index)</code>找到对应下表元素的引用，然后修改<code>Node</code>中<code>item</code>的值。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">set</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\">    checkElementIndex(index);</span><br><span class=\"line\">    Node&lt;E&gt; x = node(index);</span><br><span class=\"line\">    E oldVal = x.item;</span><br><span class=\"line\">    x.item = element;<span class=\"comment\">//替换新值</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> oldVal;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>"},{"title":"线程池探究","author":"James","date":"2013-07-26T06:07:00.000Z","_content":"\n# 基本概念\n\n在多线程编程的时候，为每一个任务临时分配一个线程开销很大，所以线程池应运而生，成为我们管理线程的工具。Java中提供了`Executor`接口，提供了一种标准的方法将任务的提交过程和执行过程解耦开来，并用`Runnable`表示任务。\n\n下面我们将基于JDK1.7分析下线程池框架的实现`ThreadPoolExecutor`以及用途。\n\n# 源码分析\n\n```java\npublic ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue,\n                              ThreadFactory threadFactory,\n                              RejectedExecutionHandler handler) {\n        if (corePoolSize < 0 ||\n            maximumPoolSize <= 0 ||\n            maximumPoolSize < corePoolSize ||\n            keepAliveTime < 0)\n            throw new IllegalArgumentException();\n        if (workQueue == null || threadFactory == null || handler == null)\n            throw new NullPointerException();\n        this.corePoolSize = corePoolSize;\n        this.maximumPoolSize = maximumPoolSize;\n        this.workQueue = workQueue;\n        this.keepAliveTime = unit.toNanos(keepAliveTime);\n        this.threadFactory = threadFactory;\n        this.handler = handler;\n    }\n```\n\n## 核心参数\n\n- **corePoolSize** ： 线程池中所保存的核心线程数，包括空闲线程。\n- **maximumPoolSize** ：允许的最大线程数。\n- **workQueue** ：阻塞队列，存储待执行的队列。\n  - JDK中提供如下阻塞队列：\n    1. `ArrayBlockingQueue`：基于数组结构的有界阻塞队列，按FIFO排序任务；\n    2. `LinkedBlockingQuene`：基于链表结构的阻塞队列，按FIFO排序任务\n    3. `SynchronousQuene`：一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态\n    4. `priorityBlockingQuene`：具有优先级的无界阻塞队列\n- **keepAliveTime** ：当无任务执行时，线程空闲的存活时间，时间单位由`TimeUnit`指定。\n- **threadFactory** ： 是构造Thread的方法，你可以自己去包装和传递，主要实现newThread方法。\n- **handler** ：达到`maximumPoolSize`后丢弃处理的方法，提供了几种丢弃处理的方法，当然你也可以自己实现接口：`RejectedExecutionHandler`中的方法\n  - 线程池提供了4种策略：\n    1. AbortPolicy：直接抛出异常，默认策略；\n    2. CallerRunsPolicy：用调用者所在的线程来执行任务；\n    3. DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；\n    4. DiscardPolicy：直接丢弃任务；\n\n## 执行流程\n\n当使用execute执行Runnable方法时候：\n\n```java\n\tpublic void execute(Runnable command) {\n        if (command == null)\n            throw new NullPointerException();\n        int c = ctl.get();\n    \t//当前工作线程小于corePoolSize 则启用新线程开始当前任务。\n        if (workerCountOf(c) < corePoolSize) {\n            if (addWorker(command, true))\n                return;\n            c = ctl.get();\n        }\n    \t//如果线程池处于RUNNING状态，且把提交的任务成功放入阻塞队列中\n        if (isRunning(c) && workQueue.offer(command)) {\n            int recheck = ctl.get();\n            //再次检查线程池的状态，如果线程池没有RUNNING，且成功从阻塞队列中删除任务\n            if (! isRunning(recheck) && remove(command))\n                reject(command);\n            //则执行reject方法处理任务\n            else if (workerCountOf(recheck) == 0)\n                addWorker(null, false);\n        }\n    \t//创建新的线程执行任务，如果执行失败，则执行reject方法处理任务\n        else if (!addWorker(command, false))\n            reject(command);\n\t}\n\n\tprivate boolean addWorker(Runnable firstTask, boolean core) {\n        retry:\n        for (;;) {\n            int c = ctl.get();\n            int rs = runStateOf(c);\n\n            // Check if queue empty only if necessary.\n            if (rs >= SHUTDOWN &&\n                ! (rs == SHUTDOWN &&\n                   firstTask == null &&\n                   ! workQueue.isEmpty()))\n                return false;\n\n            for (;;) {\n                int wc = workerCountOf(c);\n                if (wc >= CAPACITY ||\n                    //判断当前需要创建的线程是否为核心线程\n                    wc >= (core ? corePoolSize : maximumPoolSize))\n                    return false;\n                if (compareAndIncrementWorkerCount(c))\n                    break retry;\n                c = ctl.get();  // Re-read ctl\n                if (runStateOf(c) != rs)\n                    continue retry;\n                // else CAS failed due to workerCount change; retry inner loop\n            }\n        }\n\t\t//开始创建新的线程\n        boolean workerStarted = false;\n        boolean workerAdded = false;\n        Worker w = null;\n        try {\n            final ReentrantLock mainLock = this.mainLock;\n            //work内会通过factory创建一个线程   Work是个关键地方后面会分析。\n            w = new Worker(firstTask);\n            final Thread t = w.thread;\n            if (t != null) {\n                mainLock.lock();\n                try {\n                    int c = ctl.get();\n                    int rs = runStateOf(c);\n\n                    if (rs < SHUTDOWN ||\n                        (rs == SHUTDOWN && firstTask == null)) {\n                        if (t.isAlive()) // precheck that t is startable\n                            throw new IllegalThreadStateException();\n                        //把Woker实例插入到HashSet\n                        workers.add(w);\n                        int s = workers.size();\n                        if (s > largestPoolSize)\n                            largestPoolSize = s;\n                        workerAdded = true;\n                    }\n                } finally {\n                    mainLock.unlock();\n                }\n                if (workerAdded) {\n                    t.start();//并启动Woker中的线程\n                    workerStarted = true;\n                }\n            }\n        } finally {\n            if (! workerStarted)\n                addWorkerFailed(w);\n        }\n        return workerStarted;\n \t}\n```\n\n\n\n1. 如果线程池中的线程数量**小于**corePoolSize，即使线程池中有空闲线程，也会创建一个新的线程来执行新添加的任务。\n2. 如果线程池中的线程数量**大于等于** corePoolSize\n   1. 缓冲队列workQueue未满，则将新添加的任务放到workQueue中，按照FIFO的原则依次等待执行（线程池中有线程空闲出来后依次将缓冲队列中的任务交付给空闲的线程执行）。\n   2. 缓冲队列workQueue已满\n      1. 但线程池中的线程数量小于maximumPoolSize，则会创建新的线程来处理被添加的任务。\n      2. 如果线程池中的线程数量等于了maximumPoolSize，执行丢弃处理。\n\n**小结**:当有新的任务要处理时，先判断线程池中的线程数量是否大于`corePoolSize`，再看缓冲队列`workQueue`是否满，最后看线程池中的线程数量是否大于`maximumPoolSize`。\n\n![工作流程](/images/threadpool/工作流程.jpg)\n\n下面一起看下核心方法**runWorker **具体的执行流程是怎么样的。 \n\n```java\nfinal void runWorker(Worker w) {\n        Thread wt = Thread.currentThread();\n        //获取第一个任务firstTask\n        Runnable task = w.firstTask;\n        w.firstTask = null;\n    \t//通过unlock方法释放锁\n        w.unlock(); // allow interrupts\n        boolean completedAbruptly = true;\n        try {\n            //如果第一个任务firstTask为空，则从阻塞队列中获取等待的任务\n            while (task != null || (task = getTask()) != null) {\n                w.lock();\n                if ((runStateAtLeast(ctl.get(), STOP) ||\n                     (Thread.interrupted() &&\n                      runStateAtLeast(ctl.get(), STOP))) &&\n                    !wt.isInterrupted())\n                    wt.interrupt();\n                try {\n                    beforeExecute(wt, task);\n                    Throwable thrown = null;\n                    try {\n                        //执行任务的run方法\n                        task.run();\n                    } catch (RuntimeException x) {\n                        thrown = x; throw x;\n                    } finally {\n                        afterExecute(task, thrown);\n                    }\n                } finally {\n                    task = null;\n                    w.completedTasks++;\n                    w.unlock();\n                }\n            }\n            completedAbruptly = false;\n        } finally {\n            processWorkerExit(w, completedAbruptly);\n        }\n    }\n```\n\n从阻塞队列中获取等待的任务**getTask**方法\n\n```java\nprivate Runnable getTask() {\n        boolean timedOut = false; // Did the last poll() time out?\n        retry:\n        for (;;) {\n            int c = ctl.get();\n            int rs = runStateOf(c);\n            // 队列为空则直接返回null\n            if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {\n                decrementWorkerCount();\n                return null;\n            }\n            boolean timed;      // Are workers subject to culling?\n            for (;;) {\n                int wc = workerCountOf(c);\n                timed = allowCoreThreadTimeOut || wc > corePoolSize;\n                if (wc <= maximumPoolSize && ! (timedOut && timed))\n                    break;\n                if (compareAndDecrementWorkerCount(c))\n                    return null;\n                c = ctl.get();  // Re-read ctl\n                if (runStateOf(c) != rs)\n                    continue retry;\n                // else CAS failed due to workerCount change; retry inner loop\n            }\n            try {\n                //根据timed在阻塞队列上超时等待或者阻塞等待任务\n                Runnable r = timed ?\n                    //如果在keepAliveTime时间内，阻塞队列还是没有任务，则返回null\n                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :\n                    workQueue.take();\n                if (r != null)\n                    return r;\n                timedOut = true;\n            } catch (InterruptedException retry) {\n                timedOut = false;\n            }\n        }\n    }\n```\n\n\n\n# 使用方法\n\n## 创建\n\n```java\nthreadsPool = new ThreadPoolExecutor(corePoolSize, maximumPoolSize,\n\tkeepAliveTime, milliseconds,runnableTaskQueue, threadFactory,handler);\n```\n\n`Exectors`工厂类提供了线程池的初始化接口，主要有如下几种：\n\n-  `newFixedThreadPool`：初始化一个指定线程数的线程池，其中corePoolSize == maximumPoolSize\n-  `newCachedThreadPool`：初始化一个可以缓存线程的线程池，默认缓存60s，线程池的线程数可达到Integer.MAX_VALUE，即2147483647，内部使用SynchronousQueue作为阻塞队列\n-  `newSingleThreadExecutor`：初始化的线程池中只有一个线程，如果该线程异常结束，会重新创建一个新的线程继续执行任务，唯一的线程可以保证所提交任务的顺序执行\n-  `newScheduledThreadPool`：初始化的线程池可以在指定的时间内周期性的执行所提交的任务，在实际的业务场景中可以使用该线程池定期的同步数据。\n\n## 提交任务\n\n通过`execute`提交任务\n\n```JAVA\nthreadsPool.execute(new Runnable() {\n\tpublic void run() {\n\t\t// TODO Auto-generated method stub\n\t}\n});\n```\n\n使用`submit` 方法来提交任务，它会返回一个`future`,那么我们可以通过这个future来判断任务是否执行成功\n\n```java\ntry {\n\tObject s = future.get();\n} catch (InterruptedException e) {\n    \n} catch (ExecutionException e) {\n    \n} finally {\n\t// 关闭线程池\n    executor.shutdown();\n}\n```\n\n## 线程池的关闭\n\n我们可以通过调用线程池的`shutdown`或者`shutdownNow`方法来关闭线程池。他们之间的不同\n\n`shutdown`：只是将线程池的状态设置成 *SHUTDOWN* 状态，然后中断所有没有正在执行任务的线程。\n\n`shutdownNow`：遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。\n\n# 实战相关问题\n\n## 线程池大小的估算\n\n合理的配置线程池，就必须首先分析任务特性，可以从以下几个角度来进行分析：\n\n1. 任务的性质: CPU密集型任务，IO密集型任务和混合型任务。\n2. 任务执行时间的长短：长，中和短。\n3. 任务的优先级：高，中和低。\n\nCPU密集型任务配置尽可能少的线程数量，如配置Ncpu+1个线程的线程池。\n\nIO密集型任务则由于需要等待IO操作，线程并不是一直在执行任务，则配置尽可能多的线程，如2*Ncpu。\n\n**线程等待时间所占比例越高，需要越多线程。线程CPU时间所占比例越高，需要越少线程。**\n\n\n\n","source":"_posts/threadpool.md","raw":"title: 线程池探究\nauthor: James\ntags:\n  - threadpool\ncategories:\n  - 实战\ndate: 2013-07-26 14:07:00\n---\n\n# 基本概念\n\n在多线程编程的时候，为每一个任务临时分配一个线程开销很大，所以线程池应运而生，成为我们管理线程的工具。Java中提供了`Executor`接口，提供了一种标准的方法将任务的提交过程和执行过程解耦开来，并用`Runnable`表示任务。\n\n下面我们将基于JDK1.7分析下线程池框架的实现`ThreadPoolExecutor`以及用途。\n\n# 源码分析\n\n```java\npublic ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue,\n                              ThreadFactory threadFactory,\n                              RejectedExecutionHandler handler) {\n        if (corePoolSize < 0 ||\n            maximumPoolSize <= 0 ||\n            maximumPoolSize < corePoolSize ||\n            keepAliveTime < 0)\n            throw new IllegalArgumentException();\n        if (workQueue == null || threadFactory == null || handler == null)\n            throw new NullPointerException();\n        this.corePoolSize = corePoolSize;\n        this.maximumPoolSize = maximumPoolSize;\n        this.workQueue = workQueue;\n        this.keepAliveTime = unit.toNanos(keepAliveTime);\n        this.threadFactory = threadFactory;\n        this.handler = handler;\n    }\n```\n\n## 核心参数\n\n- **corePoolSize** ： 线程池中所保存的核心线程数，包括空闲线程。\n- **maximumPoolSize** ：允许的最大线程数。\n- **workQueue** ：阻塞队列，存储待执行的队列。\n  - JDK中提供如下阻塞队列：\n    1. `ArrayBlockingQueue`：基于数组结构的有界阻塞队列，按FIFO排序任务；\n    2. `LinkedBlockingQuene`：基于链表结构的阻塞队列，按FIFO排序任务\n    3. `SynchronousQuene`：一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态\n    4. `priorityBlockingQuene`：具有优先级的无界阻塞队列\n- **keepAliveTime** ：当无任务执行时，线程空闲的存活时间，时间单位由`TimeUnit`指定。\n- **threadFactory** ： 是构造Thread的方法，你可以自己去包装和传递，主要实现newThread方法。\n- **handler** ：达到`maximumPoolSize`后丢弃处理的方法，提供了几种丢弃处理的方法，当然你也可以自己实现接口：`RejectedExecutionHandler`中的方法\n  - 线程池提供了4种策略：\n    1. AbortPolicy：直接抛出异常，默认策略；\n    2. CallerRunsPolicy：用调用者所在的线程来执行任务；\n    3. DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；\n    4. DiscardPolicy：直接丢弃任务；\n\n## 执行流程\n\n当使用execute执行Runnable方法时候：\n\n```java\n\tpublic void execute(Runnable command) {\n        if (command == null)\n            throw new NullPointerException();\n        int c = ctl.get();\n    \t//当前工作线程小于corePoolSize 则启用新线程开始当前任务。\n        if (workerCountOf(c) < corePoolSize) {\n            if (addWorker(command, true))\n                return;\n            c = ctl.get();\n        }\n    \t//如果线程池处于RUNNING状态，且把提交的任务成功放入阻塞队列中\n        if (isRunning(c) && workQueue.offer(command)) {\n            int recheck = ctl.get();\n            //再次检查线程池的状态，如果线程池没有RUNNING，且成功从阻塞队列中删除任务\n            if (! isRunning(recheck) && remove(command))\n                reject(command);\n            //则执行reject方法处理任务\n            else if (workerCountOf(recheck) == 0)\n                addWorker(null, false);\n        }\n    \t//创建新的线程执行任务，如果执行失败，则执行reject方法处理任务\n        else if (!addWorker(command, false))\n            reject(command);\n\t}\n\n\tprivate boolean addWorker(Runnable firstTask, boolean core) {\n        retry:\n        for (;;) {\n            int c = ctl.get();\n            int rs = runStateOf(c);\n\n            // Check if queue empty only if necessary.\n            if (rs >= SHUTDOWN &&\n                ! (rs == SHUTDOWN &&\n                   firstTask == null &&\n                   ! workQueue.isEmpty()))\n                return false;\n\n            for (;;) {\n                int wc = workerCountOf(c);\n                if (wc >= CAPACITY ||\n                    //判断当前需要创建的线程是否为核心线程\n                    wc >= (core ? corePoolSize : maximumPoolSize))\n                    return false;\n                if (compareAndIncrementWorkerCount(c))\n                    break retry;\n                c = ctl.get();  // Re-read ctl\n                if (runStateOf(c) != rs)\n                    continue retry;\n                // else CAS failed due to workerCount change; retry inner loop\n            }\n        }\n\t\t//开始创建新的线程\n        boolean workerStarted = false;\n        boolean workerAdded = false;\n        Worker w = null;\n        try {\n            final ReentrantLock mainLock = this.mainLock;\n            //work内会通过factory创建一个线程   Work是个关键地方后面会分析。\n            w = new Worker(firstTask);\n            final Thread t = w.thread;\n            if (t != null) {\n                mainLock.lock();\n                try {\n                    int c = ctl.get();\n                    int rs = runStateOf(c);\n\n                    if (rs < SHUTDOWN ||\n                        (rs == SHUTDOWN && firstTask == null)) {\n                        if (t.isAlive()) // precheck that t is startable\n                            throw new IllegalThreadStateException();\n                        //把Woker实例插入到HashSet\n                        workers.add(w);\n                        int s = workers.size();\n                        if (s > largestPoolSize)\n                            largestPoolSize = s;\n                        workerAdded = true;\n                    }\n                } finally {\n                    mainLock.unlock();\n                }\n                if (workerAdded) {\n                    t.start();//并启动Woker中的线程\n                    workerStarted = true;\n                }\n            }\n        } finally {\n            if (! workerStarted)\n                addWorkerFailed(w);\n        }\n        return workerStarted;\n \t}\n```\n\n\n\n1. 如果线程池中的线程数量**小于**corePoolSize，即使线程池中有空闲线程，也会创建一个新的线程来执行新添加的任务。\n2. 如果线程池中的线程数量**大于等于** corePoolSize\n   1. 缓冲队列workQueue未满，则将新添加的任务放到workQueue中，按照FIFO的原则依次等待执行（线程池中有线程空闲出来后依次将缓冲队列中的任务交付给空闲的线程执行）。\n   2. 缓冲队列workQueue已满\n      1. 但线程池中的线程数量小于maximumPoolSize，则会创建新的线程来处理被添加的任务。\n      2. 如果线程池中的线程数量等于了maximumPoolSize，执行丢弃处理。\n\n**小结**:当有新的任务要处理时，先判断线程池中的线程数量是否大于`corePoolSize`，再看缓冲队列`workQueue`是否满，最后看线程池中的线程数量是否大于`maximumPoolSize`。\n\n![工作流程](/images/threadpool/工作流程.jpg)\n\n下面一起看下核心方法**runWorker **具体的执行流程是怎么样的。 \n\n```java\nfinal void runWorker(Worker w) {\n        Thread wt = Thread.currentThread();\n        //获取第一个任务firstTask\n        Runnable task = w.firstTask;\n        w.firstTask = null;\n    \t//通过unlock方法释放锁\n        w.unlock(); // allow interrupts\n        boolean completedAbruptly = true;\n        try {\n            //如果第一个任务firstTask为空，则从阻塞队列中获取等待的任务\n            while (task != null || (task = getTask()) != null) {\n                w.lock();\n                if ((runStateAtLeast(ctl.get(), STOP) ||\n                     (Thread.interrupted() &&\n                      runStateAtLeast(ctl.get(), STOP))) &&\n                    !wt.isInterrupted())\n                    wt.interrupt();\n                try {\n                    beforeExecute(wt, task);\n                    Throwable thrown = null;\n                    try {\n                        //执行任务的run方法\n                        task.run();\n                    } catch (RuntimeException x) {\n                        thrown = x; throw x;\n                    } finally {\n                        afterExecute(task, thrown);\n                    }\n                } finally {\n                    task = null;\n                    w.completedTasks++;\n                    w.unlock();\n                }\n            }\n            completedAbruptly = false;\n        } finally {\n            processWorkerExit(w, completedAbruptly);\n        }\n    }\n```\n\n从阻塞队列中获取等待的任务**getTask**方法\n\n```java\nprivate Runnable getTask() {\n        boolean timedOut = false; // Did the last poll() time out?\n        retry:\n        for (;;) {\n            int c = ctl.get();\n            int rs = runStateOf(c);\n            // 队列为空则直接返回null\n            if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {\n                decrementWorkerCount();\n                return null;\n            }\n            boolean timed;      // Are workers subject to culling?\n            for (;;) {\n                int wc = workerCountOf(c);\n                timed = allowCoreThreadTimeOut || wc > corePoolSize;\n                if (wc <= maximumPoolSize && ! (timedOut && timed))\n                    break;\n                if (compareAndDecrementWorkerCount(c))\n                    return null;\n                c = ctl.get();  // Re-read ctl\n                if (runStateOf(c) != rs)\n                    continue retry;\n                // else CAS failed due to workerCount change; retry inner loop\n            }\n            try {\n                //根据timed在阻塞队列上超时等待或者阻塞等待任务\n                Runnable r = timed ?\n                    //如果在keepAliveTime时间内，阻塞队列还是没有任务，则返回null\n                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :\n                    workQueue.take();\n                if (r != null)\n                    return r;\n                timedOut = true;\n            } catch (InterruptedException retry) {\n                timedOut = false;\n            }\n        }\n    }\n```\n\n\n\n# 使用方法\n\n## 创建\n\n```java\nthreadsPool = new ThreadPoolExecutor(corePoolSize, maximumPoolSize,\n\tkeepAliveTime, milliseconds,runnableTaskQueue, threadFactory,handler);\n```\n\n`Exectors`工厂类提供了线程池的初始化接口，主要有如下几种：\n\n-  `newFixedThreadPool`：初始化一个指定线程数的线程池，其中corePoolSize == maximumPoolSize\n-  `newCachedThreadPool`：初始化一个可以缓存线程的线程池，默认缓存60s，线程池的线程数可达到Integer.MAX_VALUE，即2147483647，内部使用SynchronousQueue作为阻塞队列\n-  `newSingleThreadExecutor`：初始化的线程池中只有一个线程，如果该线程异常结束，会重新创建一个新的线程继续执行任务，唯一的线程可以保证所提交任务的顺序执行\n-  `newScheduledThreadPool`：初始化的线程池可以在指定的时间内周期性的执行所提交的任务，在实际的业务场景中可以使用该线程池定期的同步数据。\n\n## 提交任务\n\n通过`execute`提交任务\n\n```JAVA\nthreadsPool.execute(new Runnable() {\n\tpublic void run() {\n\t\t// TODO Auto-generated method stub\n\t}\n});\n```\n\n使用`submit` 方法来提交任务，它会返回一个`future`,那么我们可以通过这个future来判断任务是否执行成功\n\n```java\ntry {\n\tObject s = future.get();\n} catch (InterruptedException e) {\n    \n} catch (ExecutionException e) {\n    \n} finally {\n\t// 关闭线程池\n    executor.shutdown();\n}\n```\n\n## 线程池的关闭\n\n我们可以通过调用线程池的`shutdown`或者`shutdownNow`方法来关闭线程池。他们之间的不同\n\n`shutdown`：只是将线程池的状态设置成 *SHUTDOWN* 状态，然后中断所有没有正在执行任务的线程。\n\n`shutdownNow`：遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。\n\n# 实战相关问题\n\n## 线程池大小的估算\n\n合理的配置线程池，就必须首先分析任务特性，可以从以下几个角度来进行分析：\n\n1. 任务的性质: CPU密集型任务，IO密集型任务和混合型任务。\n2. 任务执行时间的长短：长，中和短。\n3. 任务的优先级：高，中和低。\n\nCPU密集型任务配置尽可能少的线程数量，如配置Ncpu+1个线程的线程池。\n\nIO密集型任务则由于需要等待IO操作，线程并不是一直在执行任务，则配置尽可能多的线程，如2*Ncpu。\n\n**线程等待时间所占比例越高，需要越多线程。线程CPU时间所占比例越高，需要越少线程。**\n\n\n\n","slug":"threadpool","published":1,"updated":"2018-02-27T06:26:07.449Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjefa5bp3000b6skcds3fuch6","content":"<h1 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h1><p>在多线程编程的时候，为每一个任务临时分配一个线程开销很大，所以线程池应运而生，成为我们管理线程的工具。Java中提供了<code>Executor</code>接口，提供了一种标准的方法将任务的提交过程和执行过程解耦开来，并用<code>Runnable</code>表示任务。</p>\n<p>下面我们将基于JDK1.7分析下线程池框架的实现<code>ThreadPoolExecutor</code>以及用途。</p>\n<h1 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ThreadPoolExecutor</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              <span class=\"keyword\">int</span> maximumPoolSize,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              <span class=\"keyword\">long</span> keepAliveTime,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              TimeUnit unit,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              ThreadFactory threadFactory,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (corePoolSize &lt; <span class=\"number\">0</span> ||</span><br><span class=\"line\">            maximumPoolSize &lt;= <span class=\"number\">0</span> ||</span><br><span class=\"line\">            maximumPoolSize &lt; corePoolSize ||</span><br><span class=\"line\">            keepAliveTime &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (workQueue == <span class=\"keyword\">null</span> || threadFactory == <span class=\"keyword\">null</span> || handler == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.corePoolSize = corePoolSize;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.workQueue = workQueue;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.threadFactory = threadFactory;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.handler = handler;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"核心参数\"><a href=\"#核心参数\" class=\"headerlink\" title=\"核心参数\"></a>核心参数</h2><ul>\n<li><strong>corePoolSize</strong> ： 线程池中所保存的核心线程数，包括空闲线程。</li>\n<li><strong>maximumPoolSize</strong> ：允许的最大线程数。</li>\n<li><strong>workQueue</strong> ：阻塞队列，存储待执行的队列。<ul>\n<li>JDK中提供如下阻塞队列：<ol>\n<li><code>ArrayBlockingQueue</code>：基于数组结构的有界阻塞队列，按FIFO排序任务；</li>\n<li><code>LinkedBlockingQuene</code>：基于链表结构的阻塞队列，按FIFO排序任务</li>\n<li><code>SynchronousQuene</code>：一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态</li>\n<li><code>priorityBlockingQuene</code>：具有优先级的无界阻塞队列</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><strong>keepAliveTime</strong> ：当无任务执行时，线程空闲的存活时间，时间单位由<code>TimeUnit</code>指定。</li>\n<li><strong>threadFactory</strong> ： 是构造Thread的方法，你可以自己去包装和传递，主要实现newThread方法。</li>\n<li><strong>handler</strong> ：达到<code>maximumPoolSize</code>后丢弃处理的方法，提供了几种丢弃处理的方法，当然你也可以自己实现接口：<code>RejectedExecutionHandler</code>中的方法<ul>\n<li>线程池提供了4种策略：<ol>\n<li>AbortPolicy：直接抛出异常，默认策略；</li>\n<li>CallerRunsPolicy：用调用者所在的线程来执行任务；</li>\n<li>DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；</li>\n<li>DiscardPolicy：直接丢弃任务；</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"执行流程\"><a href=\"#执行流程\" class=\"headerlink\" title=\"执行流程\"></a>执行流程</h2><p>当使用execute执行Runnable方法时候：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable command)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (command == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">           <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">       <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">   \t<span class=\"comment\">//当前工作线程小于corePoolSize 则启用新线程开始当前任务。</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (addWorker(command, <span class=\"keyword\">true</span>))</span><br><span class=\"line\">               <span class=\"keyword\">return</span>;</span><br><span class=\"line\">           c = ctl.get();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   \t<span class=\"comment\">//如果线程池处于RUNNING状态，且把提交的任务成功放入阻塞队列中</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">int</span> recheck = ctl.get();</span><br><span class=\"line\">           <span class=\"comment\">//再次检查线程池的状态，如果线程池没有RUNNING，且成功从阻塞队列中删除任务</span></span><br><span class=\"line\">           <span class=\"keyword\">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class=\"line\">               reject(command);</span><br><span class=\"line\">           <span class=\"comment\">//则执行reject方法处理任务</span></span><br><span class=\"line\">           <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (workerCountOf(recheck) == <span class=\"number\">0</span>)</span><br><span class=\"line\">               addWorker(<span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   \t<span class=\"comment\">//创建新的线程执行任务，如果执行失败，则执行reject方法处理任务</span></span><br><span class=\"line\">       <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!addWorker(command, <span class=\"keyword\">false</span>))</span><br><span class=\"line\">           reject(command);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addWorker</span><span class=\"params\">(Runnable firstTask, <span class=\"keyword\">boolean</span> core)</span> </span>&#123;</span><br><span class=\"line\">       retry:</span><br><span class=\"line\">       <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">           <span class=\"keyword\">int</span> rs = runStateOf(c);</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"comment\">// Check if queue empty only if necessary.</span></span><br><span class=\"line\">           <span class=\"keyword\">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class=\"line\">               ! (rs == SHUTDOWN &amp;&amp;</span><br><span class=\"line\">                  firstTask == <span class=\"keyword\">null</span> &amp;&amp;</span><br><span class=\"line\">                  ! workQueue.isEmpty()))</span><br><span class=\"line\">               <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">               <span class=\"keyword\">int</span> wc = workerCountOf(c);</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (wc &gt;= CAPACITY ||</span><br><span class=\"line\">                   <span class=\"comment\">//判断当前需要创建的线程是否为核心线程</span></span><br><span class=\"line\">                   wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class=\"line\">                   <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class=\"line\">                   <span class=\"keyword\">break</span> retry;</span><br><span class=\"line\">               c = ctl.get();  <span class=\"comment\">// Re-read ctl</span></span><br><span class=\"line\">               <span class=\"keyword\">if</span> (runStateOf(c) != rs)</span><br><span class=\"line\">                   <span class=\"keyword\">continue</span> retry;</span><br><span class=\"line\">               <span class=\"comment\">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">\t<span class=\"comment\">//开始创建新的线程</span></span><br><span class=\"line\">       <span class=\"keyword\">boolean</span> workerStarted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">       <span class=\"keyword\">boolean</span> workerAdded = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">       Worker w = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">       <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">           <span class=\"keyword\">final</span> ReentrantLock mainLock = <span class=\"keyword\">this</span>.mainLock;</span><br><span class=\"line\">           <span class=\"comment\">//work内会通过factory创建一个线程   Work是个关键地方后面会分析。</span></span><br><span class=\"line\">           w = <span class=\"keyword\">new</span> Worker(firstTask);</span><br><span class=\"line\">           <span class=\"keyword\">final</span> Thread t = w.thread;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (t != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">               mainLock.lock();</span><br><span class=\"line\">               <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                   <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">                   <span class=\"keyword\">int</span> rs = runStateOf(c);</span><br><span class=\"line\"></span><br><span class=\"line\">                   <span class=\"keyword\">if</span> (rs &lt; SHUTDOWN ||</span><br><span class=\"line\">                       (rs == SHUTDOWN &amp;&amp; firstTask == <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">                       <span class=\"keyword\">if</span> (t.isAlive()) <span class=\"comment\">// precheck that t is startable</span></span><br><span class=\"line\">                           <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalThreadStateException();</span><br><span class=\"line\">                       <span class=\"comment\">//把Woker实例插入到HashSet</span></span><br><span class=\"line\">                       workers.add(w);</span><br><span class=\"line\">                       <span class=\"keyword\">int</span> s = workers.size();</span><br><span class=\"line\">                       <span class=\"keyword\">if</span> (s &gt; largestPoolSize)</span><br><span class=\"line\">                           largestPoolSize = s;</span><br><span class=\"line\">                       workerAdded = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                   &#125;</span><br><span class=\"line\">               &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                   mainLock.unlock();</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (workerAdded) &#123;</span><br><span class=\"line\">                   t.start();<span class=\"comment\">//并启动Woker中的线程</span></span><br><span class=\"line\">                   workerStarted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (! workerStarted)</span><br><span class=\"line\">               addWorkerFailed(w);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> workerStarted;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>如果线程池中的线程数量<strong>小于</strong>corePoolSize，即使线程池中有空闲线程，也会创建一个新的线程来执行新添加的任务。</li>\n<li>如果线程池中的线程数量<strong>大于等于</strong> corePoolSize<ol>\n<li>缓冲队列workQueue未满，则将新添加的任务放到workQueue中，按照FIFO的原则依次等待执行（线程池中有线程空闲出来后依次将缓冲队列中的任务交付给空闲的线程执行）。</li>\n<li>缓冲队列workQueue已满<ol>\n<li>但线程池中的线程数量小于maximumPoolSize，则会创建新的线程来处理被添加的任务。</li>\n<li>如果线程池中的线程数量等于了maximumPoolSize，执行丢弃处理。</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<p><strong>小结</strong>:当有新的任务要处理时，先判断线程池中的线程数量是否大于<code>corePoolSize</code>，再看缓冲队列<code>workQueue</code>是否满，最后看线程池中的线程数量是否大于<code>maximumPoolSize</code>。</p>\n<p><img src=\"/images/threadpool/工作流程.jpg\" alt=\"工作流程\"></p>\n<p>下面一起看下核心方法<strong>runWorker </strong>具体的执行流程是怎么样的。 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">runWorker</span><span class=\"params\">(Worker w)</span> </span>&#123;</span><br><span class=\"line\">        Thread wt = Thread.currentThread();</span><br><span class=\"line\">        <span class=\"comment\">//获取第一个任务firstTask</span></span><br><span class=\"line\">        Runnable task = w.firstTask;</span><br><span class=\"line\">        w.firstTask = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    \t<span class=\"comment\">//通过unlock方法释放锁</span></span><br><span class=\"line\">        w.unlock(); <span class=\"comment\">// allow interrupts</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> completedAbruptly = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果第一个任务firstTask为空，则从阻塞队列中获取等待的任务</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (task != <span class=\"keyword\">null</span> || (task = getTask()) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                w.lock();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class=\"line\">                     (Thread.interrupted() &amp;&amp;</span><br><span class=\"line\">                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class=\"line\">                    !wt.isInterrupted())</span><br><span class=\"line\">                    wt.interrupt();</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    beforeExecute(wt, task);</span><br><span class=\"line\">                    Throwable thrown = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">//执行任务的run方法</span></span><br><span class=\"line\">                        task.run();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (RuntimeException x) &#123;</span><br><span class=\"line\">                        thrown = x; <span class=\"keyword\">throw</span> x;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                        afterExecute(task, thrown);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    task = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    w.completedTasks++;</span><br><span class=\"line\">                    w.unlock();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            completedAbruptly = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            processWorkerExit(w, completedAbruptly);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>从阻塞队列中获取等待的任务<strong>getTask</strong>方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Runnable <span class=\"title\">getTask</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> timedOut = <span class=\"keyword\">false</span>; <span class=\"comment\">// Did the last poll() time out?</span></span><br><span class=\"line\">        retry:</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> rs = runStateOf(c);</span><br><span class=\"line\">            <span class=\"comment\">// 队列为空则直接返回null</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class=\"line\">                decrementWorkerCount();</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> timed;      <span class=\"comment\">// Are workers subject to culling?</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> wc = workerCountOf(c);</span><br><span class=\"line\">                timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (wc &lt;= maximumPoolSize &amp;&amp; ! (timedOut &amp;&amp; timed))</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                c = ctl.get();  <span class=\"comment\">// Re-read ctl</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (runStateOf(c) != rs)</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span> retry;</span><br><span class=\"line\">                <span class=\"comment\">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//根据timed在阻塞队列上超时等待或者阻塞等待任务</span></span><br><span class=\"line\">                Runnable r = timed ?</span><br><span class=\"line\">                    <span class=\"comment\">//如果在keepAliveTime时间内，阻塞队列还是没有任务，则返回null</span></span><br><span class=\"line\">                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class=\"line\">                    workQueue.take();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (r != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">                timedOut = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException retry) &#123;</span><br><span class=\"line\">                timedOut = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h1><h2 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">threadsPool = <span class=\"keyword\">new</span> ThreadPoolExecutor(corePoolSize, maximumPoolSize,</span><br><span class=\"line\">\tkeepAliveTime, milliseconds,runnableTaskQueue, threadFactory,handler);</span><br></pre></td></tr></table></figure>\n<p><code>Exectors</code>工厂类提供了线程池的初始化接口，主要有如下几种：</p>\n<ul>\n<li><code>newFixedThreadPool</code>：初始化一个指定线程数的线程池，其中corePoolSize == maximumPoolSize</li>\n<li><code>newCachedThreadPool</code>：初始化一个可以缓存线程的线程池，默认缓存60s，线程池的线程数可达到Integer.MAX_VALUE，即2147483647，内部使用SynchronousQueue作为阻塞队列</li>\n<li><code>newSingleThreadExecutor</code>：初始化的线程池中只有一个线程，如果该线程异常结束，会重新创建一个新的线程继续执行任务，唯一的线程可以保证所提交任务的顺序执行</li>\n<li><code>newScheduledThreadPool</code>：初始化的线程池可以在指定的时间内周期性的执行所提交的任务，在实际的业务场景中可以使用该线程池定期的同步数据。</li>\n</ul>\n<h2 id=\"提交任务\"><a href=\"#提交任务\" class=\"headerlink\" title=\"提交任务\"></a>提交任务</h2><p>通过<code>execute</code>提交任务</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">threadsPool.execute(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>使用<code>submit</code> 方法来提交任务，它会返回一个<code>future</code>,那么我们可以通过这个future来判断任务是否执行成功</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\tObject s = future.get();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (ExecutionException e) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 关闭线程池</span></span><br><span class=\"line\">    executor.shutdown();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"线程池的关闭\"><a href=\"#线程池的关闭\" class=\"headerlink\" title=\"线程池的关闭\"></a>线程池的关闭</h2><p>我们可以通过调用线程池的<code>shutdown</code>或者<code>shutdownNow</code>方法来关闭线程池。他们之间的不同</p>\n<p><code>shutdown</code>：只是将线程池的状态设置成 <em>SHUTDOWN</em> 状态，然后中断所有没有正在执行任务的线程。</p>\n<p><code>shutdownNow</code>：遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。</p>\n<h1 id=\"实战相关问题\"><a href=\"#实战相关问题\" class=\"headerlink\" title=\"实战相关问题\"></a>实战相关问题</h1><h2 id=\"线程池大小的估算\"><a href=\"#线程池大小的估算\" class=\"headerlink\" title=\"线程池大小的估算\"></a>线程池大小的估算</h2><p>合理的配置线程池，就必须首先分析任务特性，可以从以下几个角度来进行分析：</p>\n<ol>\n<li>任务的性质: CPU密集型任务，IO密集型任务和混合型任务。</li>\n<li>任务执行时间的长短：长，中和短。</li>\n<li>任务的优先级：高，中和低。</li>\n</ol>\n<p>CPU密集型任务配置尽可能少的线程数量，如配置Ncpu+1个线程的线程池。</p>\n<p>IO密集型任务则由于需要等待IO操作，线程并不是一直在执行任务，则配置尽可能多的线程，如2*Ncpu。</p>\n<p><strong>线程等待时间所占比例越高，需要越多线程。线程CPU时间所占比例越高，需要越少线程。</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h1><p>在多线程编程的时候，为每一个任务临时分配一个线程开销很大，所以线程池应运而生，成为我们管理线程的工具。Java中提供了<code>Executor</code>接口，提供了一种标准的方法将任务的提交过程和执行过程解耦开来，并用<code>Runnable</code>表示任务。</p>\n<p>下面我们将基于JDK1.7分析下线程池框架的实现<code>ThreadPoolExecutor</code>以及用途。</p>\n<h1 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ThreadPoolExecutor</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              <span class=\"keyword\">int</span> maximumPoolSize,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              <span class=\"keyword\">long</span> keepAliveTime,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              TimeUnit unit,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              ThreadFactory threadFactory,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (corePoolSize &lt; <span class=\"number\">0</span> ||</span><br><span class=\"line\">            maximumPoolSize &lt;= <span class=\"number\">0</span> ||</span><br><span class=\"line\">            maximumPoolSize &lt; corePoolSize ||</span><br><span class=\"line\">            keepAliveTime &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (workQueue == <span class=\"keyword\">null</span> || threadFactory == <span class=\"keyword\">null</span> || handler == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.corePoolSize = corePoolSize;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.workQueue = workQueue;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.threadFactory = threadFactory;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.handler = handler;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"核心参数\"><a href=\"#核心参数\" class=\"headerlink\" title=\"核心参数\"></a>核心参数</h2><ul>\n<li><strong>corePoolSize</strong> ： 线程池中所保存的核心线程数，包括空闲线程。</li>\n<li><strong>maximumPoolSize</strong> ：允许的最大线程数。</li>\n<li><strong>workQueue</strong> ：阻塞队列，存储待执行的队列。<ul>\n<li>JDK中提供如下阻塞队列：<ol>\n<li><code>ArrayBlockingQueue</code>：基于数组结构的有界阻塞队列，按FIFO排序任务；</li>\n<li><code>LinkedBlockingQuene</code>：基于链表结构的阻塞队列，按FIFO排序任务</li>\n<li><code>SynchronousQuene</code>：一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态</li>\n<li><code>priorityBlockingQuene</code>：具有优先级的无界阻塞队列</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><strong>keepAliveTime</strong> ：当无任务执行时，线程空闲的存活时间，时间单位由<code>TimeUnit</code>指定。</li>\n<li><strong>threadFactory</strong> ： 是构造Thread的方法，你可以自己去包装和传递，主要实现newThread方法。</li>\n<li><strong>handler</strong> ：达到<code>maximumPoolSize</code>后丢弃处理的方法，提供了几种丢弃处理的方法，当然你也可以自己实现接口：<code>RejectedExecutionHandler</code>中的方法<ul>\n<li>线程池提供了4种策略：<ol>\n<li>AbortPolicy：直接抛出异常，默认策略；</li>\n<li>CallerRunsPolicy：用调用者所在的线程来执行任务；</li>\n<li>DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；</li>\n<li>DiscardPolicy：直接丢弃任务；</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"执行流程\"><a href=\"#执行流程\" class=\"headerlink\" title=\"执行流程\"></a>执行流程</h2><p>当使用execute执行Runnable方法时候：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable command)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (command == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">           <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">       <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">   \t<span class=\"comment\">//当前工作线程小于corePoolSize 则启用新线程开始当前任务。</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (addWorker(command, <span class=\"keyword\">true</span>))</span><br><span class=\"line\">               <span class=\"keyword\">return</span>;</span><br><span class=\"line\">           c = ctl.get();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   \t<span class=\"comment\">//如果线程池处于RUNNING状态，且把提交的任务成功放入阻塞队列中</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">int</span> recheck = ctl.get();</span><br><span class=\"line\">           <span class=\"comment\">//再次检查线程池的状态，如果线程池没有RUNNING，且成功从阻塞队列中删除任务</span></span><br><span class=\"line\">           <span class=\"keyword\">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class=\"line\">               reject(command);</span><br><span class=\"line\">           <span class=\"comment\">//则执行reject方法处理任务</span></span><br><span class=\"line\">           <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (workerCountOf(recheck) == <span class=\"number\">0</span>)</span><br><span class=\"line\">               addWorker(<span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   \t<span class=\"comment\">//创建新的线程执行任务，如果执行失败，则执行reject方法处理任务</span></span><br><span class=\"line\">       <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!addWorker(command, <span class=\"keyword\">false</span>))</span><br><span class=\"line\">           reject(command);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addWorker</span><span class=\"params\">(Runnable firstTask, <span class=\"keyword\">boolean</span> core)</span> </span>&#123;</span><br><span class=\"line\">       retry:</span><br><span class=\"line\">       <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">           <span class=\"keyword\">int</span> rs = runStateOf(c);</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"comment\">// Check if queue empty only if necessary.</span></span><br><span class=\"line\">           <span class=\"keyword\">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class=\"line\">               ! (rs == SHUTDOWN &amp;&amp;</span><br><span class=\"line\">                  firstTask == <span class=\"keyword\">null</span> &amp;&amp;</span><br><span class=\"line\">                  ! workQueue.isEmpty()))</span><br><span class=\"line\">               <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">               <span class=\"keyword\">int</span> wc = workerCountOf(c);</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (wc &gt;= CAPACITY ||</span><br><span class=\"line\">                   <span class=\"comment\">//判断当前需要创建的线程是否为核心线程</span></span><br><span class=\"line\">                   wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class=\"line\">                   <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class=\"line\">                   <span class=\"keyword\">break</span> retry;</span><br><span class=\"line\">               c = ctl.get();  <span class=\"comment\">// Re-read ctl</span></span><br><span class=\"line\">               <span class=\"keyword\">if</span> (runStateOf(c) != rs)</span><br><span class=\"line\">                   <span class=\"keyword\">continue</span> retry;</span><br><span class=\"line\">               <span class=\"comment\">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">\t<span class=\"comment\">//开始创建新的线程</span></span><br><span class=\"line\">       <span class=\"keyword\">boolean</span> workerStarted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">       <span class=\"keyword\">boolean</span> workerAdded = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">       Worker w = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">       <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">           <span class=\"keyword\">final</span> ReentrantLock mainLock = <span class=\"keyword\">this</span>.mainLock;</span><br><span class=\"line\">           <span class=\"comment\">//work内会通过factory创建一个线程   Work是个关键地方后面会分析。</span></span><br><span class=\"line\">           w = <span class=\"keyword\">new</span> Worker(firstTask);</span><br><span class=\"line\">           <span class=\"keyword\">final</span> Thread t = w.thread;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (t != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">               mainLock.lock();</span><br><span class=\"line\">               <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                   <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">                   <span class=\"keyword\">int</span> rs = runStateOf(c);</span><br><span class=\"line\"></span><br><span class=\"line\">                   <span class=\"keyword\">if</span> (rs &lt; SHUTDOWN ||</span><br><span class=\"line\">                       (rs == SHUTDOWN &amp;&amp; firstTask == <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">                       <span class=\"keyword\">if</span> (t.isAlive()) <span class=\"comment\">// precheck that t is startable</span></span><br><span class=\"line\">                           <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalThreadStateException();</span><br><span class=\"line\">                       <span class=\"comment\">//把Woker实例插入到HashSet</span></span><br><span class=\"line\">                       workers.add(w);</span><br><span class=\"line\">                       <span class=\"keyword\">int</span> s = workers.size();</span><br><span class=\"line\">                       <span class=\"keyword\">if</span> (s &gt; largestPoolSize)</span><br><span class=\"line\">                           largestPoolSize = s;</span><br><span class=\"line\">                       workerAdded = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                   &#125;</span><br><span class=\"line\">               &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                   mainLock.unlock();</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (workerAdded) &#123;</span><br><span class=\"line\">                   t.start();<span class=\"comment\">//并启动Woker中的线程</span></span><br><span class=\"line\">                   workerStarted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (! workerStarted)</span><br><span class=\"line\">               addWorkerFailed(w);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> workerStarted;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>如果线程池中的线程数量<strong>小于</strong>corePoolSize，即使线程池中有空闲线程，也会创建一个新的线程来执行新添加的任务。</li>\n<li>如果线程池中的线程数量<strong>大于等于</strong> corePoolSize<ol>\n<li>缓冲队列workQueue未满，则将新添加的任务放到workQueue中，按照FIFO的原则依次等待执行（线程池中有线程空闲出来后依次将缓冲队列中的任务交付给空闲的线程执行）。</li>\n<li>缓冲队列workQueue已满<ol>\n<li>但线程池中的线程数量小于maximumPoolSize，则会创建新的线程来处理被添加的任务。</li>\n<li>如果线程池中的线程数量等于了maximumPoolSize，执行丢弃处理。</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<p><strong>小结</strong>:当有新的任务要处理时，先判断线程池中的线程数量是否大于<code>corePoolSize</code>，再看缓冲队列<code>workQueue</code>是否满，最后看线程池中的线程数量是否大于<code>maximumPoolSize</code>。</p>\n<p><img src=\"/images/threadpool/工作流程.jpg\" alt=\"工作流程\"></p>\n<p>下面一起看下核心方法<strong>runWorker </strong>具体的执行流程是怎么样的。 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">runWorker</span><span class=\"params\">(Worker w)</span> </span>&#123;</span><br><span class=\"line\">        Thread wt = Thread.currentThread();</span><br><span class=\"line\">        <span class=\"comment\">//获取第一个任务firstTask</span></span><br><span class=\"line\">        Runnable task = w.firstTask;</span><br><span class=\"line\">        w.firstTask = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    \t<span class=\"comment\">//通过unlock方法释放锁</span></span><br><span class=\"line\">        w.unlock(); <span class=\"comment\">// allow interrupts</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> completedAbruptly = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果第一个任务firstTask为空，则从阻塞队列中获取等待的任务</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (task != <span class=\"keyword\">null</span> || (task = getTask()) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                w.lock();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class=\"line\">                     (Thread.interrupted() &amp;&amp;</span><br><span class=\"line\">                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class=\"line\">                    !wt.isInterrupted())</span><br><span class=\"line\">                    wt.interrupt();</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    beforeExecute(wt, task);</span><br><span class=\"line\">                    Throwable thrown = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">//执行任务的run方法</span></span><br><span class=\"line\">                        task.run();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (RuntimeException x) &#123;</span><br><span class=\"line\">                        thrown = x; <span class=\"keyword\">throw</span> x;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                        afterExecute(task, thrown);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    task = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    w.completedTasks++;</span><br><span class=\"line\">                    w.unlock();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            completedAbruptly = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            processWorkerExit(w, completedAbruptly);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>从阻塞队列中获取等待的任务<strong>getTask</strong>方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Runnable <span class=\"title\">getTask</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> timedOut = <span class=\"keyword\">false</span>; <span class=\"comment\">// Did the last poll() time out?</span></span><br><span class=\"line\">        retry:</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> rs = runStateOf(c);</span><br><span class=\"line\">            <span class=\"comment\">// 队列为空则直接返回null</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class=\"line\">                decrementWorkerCount();</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> timed;      <span class=\"comment\">// Are workers subject to culling?</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> wc = workerCountOf(c);</span><br><span class=\"line\">                timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (wc &lt;= maximumPoolSize &amp;&amp; ! (timedOut &amp;&amp; timed))</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                c = ctl.get();  <span class=\"comment\">// Re-read ctl</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (runStateOf(c) != rs)</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span> retry;</span><br><span class=\"line\">                <span class=\"comment\">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//根据timed在阻塞队列上超时等待或者阻塞等待任务</span></span><br><span class=\"line\">                Runnable r = timed ?</span><br><span class=\"line\">                    <span class=\"comment\">//如果在keepAliveTime时间内，阻塞队列还是没有任务，则返回null</span></span><br><span class=\"line\">                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class=\"line\">                    workQueue.take();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (r != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">                timedOut = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException retry) &#123;</span><br><span class=\"line\">                timedOut = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h1><h2 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">threadsPool = <span class=\"keyword\">new</span> ThreadPoolExecutor(corePoolSize, maximumPoolSize,</span><br><span class=\"line\">\tkeepAliveTime, milliseconds,runnableTaskQueue, threadFactory,handler);</span><br></pre></td></tr></table></figure>\n<p><code>Exectors</code>工厂类提供了线程池的初始化接口，主要有如下几种：</p>\n<ul>\n<li><code>newFixedThreadPool</code>：初始化一个指定线程数的线程池，其中corePoolSize == maximumPoolSize</li>\n<li><code>newCachedThreadPool</code>：初始化一个可以缓存线程的线程池，默认缓存60s，线程池的线程数可达到Integer.MAX_VALUE，即2147483647，内部使用SynchronousQueue作为阻塞队列</li>\n<li><code>newSingleThreadExecutor</code>：初始化的线程池中只有一个线程，如果该线程异常结束，会重新创建一个新的线程继续执行任务，唯一的线程可以保证所提交任务的顺序执行</li>\n<li><code>newScheduledThreadPool</code>：初始化的线程池可以在指定的时间内周期性的执行所提交的任务，在实际的业务场景中可以使用该线程池定期的同步数据。</li>\n</ul>\n<h2 id=\"提交任务\"><a href=\"#提交任务\" class=\"headerlink\" title=\"提交任务\"></a>提交任务</h2><p>通过<code>execute</code>提交任务</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">threadsPool.execute(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>使用<code>submit</code> 方法来提交任务，它会返回一个<code>future</code>,那么我们可以通过这个future来判断任务是否执行成功</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\tObject s = future.get();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (ExecutionException e) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 关闭线程池</span></span><br><span class=\"line\">    executor.shutdown();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"线程池的关闭\"><a href=\"#线程池的关闭\" class=\"headerlink\" title=\"线程池的关闭\"></a>线程池的关闭</h2><p>我们可以通过调用线程池的<code>shutdown</code>或者<code>shutdownNow</code>方法来关闭线程池。他们之间的不同</p>\n<p><code>shutdown</code>：只是将线程池的状态设置成 <em>SHUTDOWN</em> 状态，然后中断所有没有正在执行任务的线程。</p>\n<p><code>shutdownNow</code>：遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。</p>\n<h1 id=\"实战相关问题\"><a href=\"#实战相关问题\" class=\"headerlink\" title=\"实战相关问题\"></a>实战相关问题</h1><h2 id=\"线程池大小的估算\"><a href=\"#线程池大小的估算\" class=\"headerlink\" title=\"线程池大小的估算\"></a>线程池大小的估算</h2><p>合理的配置线程池，就必须首先分析任务特性，可以从以下几个角度来进行分析：</p>\n<ol>\n<li>任务的性质: CPU密集型任务，IO密集型任务和混合型任务。</li>\n<li>任务执行时间的长短：长，中和短。</li>\n<li>任务的优先级：高，中和低。</li>\n</ol>\n<p>CPU密集型任务配置尽可能少的线程数量，如配置Ncpu+1个线程的线程池。</p>\n<p>IO密集型任务则由于需要等待IO操作，线程并不是一直在执行任务，则配置尽可能多的线程，如2*Ncpu。</p>\n<p><strong>线程等待时间所占比例越高，需要越多线程。线程CPU时间所占比例越高，需要越少线程。</strong></p>\n"},{"title":"ArrayList源码学习","date":"2013-06-16T00:09:00.000Z","_content":"# Introduction\n\n本文是学习ArrayList源码的学习总结，组织结构如下：\n\n- 总体介绍\n- 核心方法剖析\n\n# 总体介绍\n\n*ArrayList*实现了*List*接口，是顺序容器，即元素存放的数据与放进去的顺序相同，允许放入`null`元素，底层通过**数组实现**。除该类未实现同步外，其余跟*Vector*大致相同。每个*ArrayList*都有一个容量（capacity），表示底层数组的实际大小，容器内存储元素的个数不能多于当前容量。当向容器中添加元素时，如果容量不足，容器会自动增大底层数组的大小。前面已经提过，Java泛型只是编译器提供的语法糖，所以这里的数组是一个Object数组，以便能够容纳任何类型的对象。\n\n<!-- more -->\n\n![ArrayList_base](/images/arraylist/ArrayList_base.png)\n\nsize(), isEmpty(), get(), set()方法均能在常数时间内完成，add()方法的时间开销跟插入位置有关，addAll()方法的时间开销跟添加元素的个数成正比。其余方法大都是线性时间。\n\n为追求效率，ArrayList没有实现同步（synchronized），如果需要多个线程并发访问，用户可以手动同步，也可使用Vector替代。\n\n# 方法剖析\n\n### set()\n\n既然底层是一个数组*ArrayList*的`set()`方法也就变得非常简单，直接对数组的指定位置赋值即可。\n```java\npublic E set(int index, E element) {\n    rangeCheck(index);//下标越界检查\n    E oldValue = elementData(index);\n    elementData[index] = element;//赋值到指定位置，复制的仅仅是引用\n    return oldValue;\n}\n```\n\n### get()\n\n`get()`方法同样很简单，唯一要注意的是由于底层数组是Object[]，得到元素后需要进行类型转换。\n```java\npublic E get(int index) {\n    rangeCheck(index);\n    return (E) elementData[index];//注意类型转换\n}\n```\n\n### add()\n\n跟C++ 的*vector*不同，*ArrayList*没有`push_back()`方法，对应的方法是`add(E e)`，*ArrayList*也没有`insert()`方法，对应的方法是`add(int index, E e)`。这两个方法都是向容器中添加新元素，这可能会导致*capacity*不足，因此在添加元素之前，都需要进行剩余空间检查，如果需要则自动扩容。扩容操作最终是通过`grow()`方法完成的。\n```java\nprivate void grow(int minCapacity) {\n    int oldCapacity = elementData.length;\n    int newCapacity = oldCapacity + (oldCapacity >> 1);//原来的1.5倍\n    if (newCapacity - minCapacity < 0)\n        newCapacity = minCapacity;\n    if (newCapacity - MAX_ARRAY_SIZE > 0)\n        newCapacity = hugeCapacity(minCapacity);\n    elementData = Arrays.copyOf(elementData, newCapacity);//扩展空间并复制\n}\n```\n由于Java GC自动管理了内存，这里也就不需要考虑源数组释放的问题。\n\n![ArrayList_grow](/images/arraylist/ArrayList_grow.png)\n\n空间的问题解决后，插入过程就显得非常简单。\n\n![ArrayList_add](/images/arraylist/ArrayList_add.png)\n\n`add(int index, E e)`需要先对元素进行移动，然后完成插入操作，也就意味着该方法有着线性的时间复杂度。\n\n### addAll()\n\n`addAll()`方法能够一次添加多个元素，根据位置不同也有两个版本，一个是在末尾添加的`addAll(Collection<? extends E> c)`方法，一个是从指定位置开始插入的`addAll(int index, Collection<? extends E> c)`方法。跟`add()`方法类似，在插入之前也需要进行空间检查，如果需要则自动扩容；如果从指定位置插入，也会存在移动元素的情况。\n`addAll()`的时间复杂度不仅跟插入元素的多少有关，也跟插入的位置相关。\n\n### remove()\n\n`remove()`方法也有两个版本，一个是`remove(int index)`删除指定位置的元素，另一个是`remove(Object o)`删除第一个满足`o.equals(elementData[index])`的元素。删除操作是`add()`操作的逆过程，需要将删除点之后的元素向前移动一个位置。需要注意的是为了让GC起作用，必须显式的为最后一个位置赋`null`值。\n```java\npublic E remove(int index) {\n    rangeCheck(index);\n    modCount++;\n    E oldValue = elementData(index);\n    int numMoved = size - index - 1;\n    if (numMoved > 0)\n        System.arraycopy(elementData, index+1, elementData, index, numMoved);\n    elementData[--size] = null; //清除该位置的引用，让GC起作用\n    return oldValue;\n}\n```","source":"_posts/arraylist.md","raw":"title: ArrayList源码学习\ncategories:\n  - 语言\ntags:\n  - Java\ndate: 2013-06-16 08:09:00\n---\n# Introduction\n\n本文是学习ArrayList源码的学习总结，组织结构如下：\n\n- 总体介绍\n- 核心方法剖析\n\n# 总体介绍\n\n*ArrayList*实现了*List*接口，是顺序容器，即元素存放的数据与放进去的顺序相同，允许放入`null`元素，底层通过**数组实现**。除该类未实现同步外，其余跟*Vector*大致相同。每个*ArrayList*都有一个容量（capacity），表示底层数组的实际大小，容器内存储元素的个数不能多于当前容量。当向容器中添加元素时，如果容量不足，容器会自动增大底层数组的大小。前面已经提过，Java泛型只是编译器提供的语法糖，所以这里的数组是一个Object数组，以便能够容纳任何类型的对象。\n\n<!-- more -->\n\n![ArrayList_base](/images/arraylist/ArrayList_base.png)\n\nsize(), isEmpty(), get(), set()方法均能在常数时间内完成，add()方法的时间开销跟插入位置有关，addAll()方法的时间开销跟添加元素的个数成正比。其余方法大都是线性时间。\n\n为追求效率，ArrayList没有实现同步（synchronized），如果需要多个线程并发访问，用户可以手动同步，也可使用Vector替代。\n\n# 方法剖析\n\n### set()\n\n既然底层是一个数组*ArrayList*的`set()`方法也就变得非常简单，直接对数组的指定位置赋值即可。\n```java\npublic E set(int index, E element) {\n    rangeCheck(index);//下标越界检查\n    E oldValue = elementData(index);\n    elementData[index] = element;//赋值到指定位置，复制的仅仅是引用\n    return oldValue;\n}\n```\n\n### get()\n\n`get()`方法同样很简单，唯一要注意的是由于底层数组是Object[]，得到元素后需要进行类型转换。\n```java\npublic E get(int index) {\n    rangeCheck(index);\n    return (E) elementData[index];//注意类型转换\n}\n```\n\n### add()\n\n跟C++ 的*vector*不同，*ArrayList*没有`push_back()`方法，对应的方法是`add(E e)`，*ArrayList*也没有`insert()`方法，对应的方法是`add(int index, E e)`。这两个方法都是向容器中添加新元素，这可能会导致*capacity*不足，因此在添加元素之前，都需要进行剩余空间检查，如果需要则自动扩容。扩容操作最终是通过`grow()`方法完成的。\n```java\nprivate void grow(int minCapacity) {\n    int oldCapacity = elementData.length;\n    int newCapacity = oldCapacity + (oldCapacity >> 1);//原来的1.5倍\n    if (newCapacity - minCapacity < 0)\n        newCapacity = minCapacity;\n    if (newCapacity - MAX_ARRAY_SIZE > 0)\n        newCapacity = hugeCapacity(minCapacity);\n    elementData = Arrays.copyOf(elementData, newCapacity);//扩展空间并复制\n}\n```\n由于Java GC自动管理了内存，这里也就不需要考虑源数组释放的问题。\n\n![ArrayList_grow](/images/arraylist/ArrayList_grow.png)\n\n空间的问题解决后，插入过程就显得非常简单。\n\n![ArrayList_add](/images/arraylist/ArrayList_add.png)\n\n`add(int index, E e)`需要先对元素进行移动，然后完成插入操作，也就意味着该方法有着线性的时间复杂度。\n\n### addAll()\n\n`addAll()`方法能够一次添加多个元素，根据位置不同也有两个版本，一个是在末尾添加的`addAll(Collection<? extends E> c)`方法，一个是从指定位置开始插入的`addAll(int index, Collection<? extends E> c)`方法。跟`add()`方法类似，在插入之前也需要进行空间检查，如果需要则自动扩容；如果从指定位置插入，也会存在移动元素的情况。\n`addAll()`的时间复杂度不仅跟插入元素的多少有关，也跟插入的位置相关。\n\n### remove()\n\n`remove()`方法也有两个版本，一个是`remove(int index)`删除指定位置的元素，另一个是`remove(Object o)`删除第一个满足`o.equals(elementData[index])`的元素。删除操作是`add()`操作的逆过程，需要将删除点之后的元素向前移动一个位置。需要注意的是为了让GC起作用，必须显式的为最后一个位置赋`null`值。\n```java\npublic E remove(int index) {\n    rangeCheck(index);\n    modCount++;\n    E oldValue = elementData(index);\n    int numMoved = size - index - 1;\n    if (numMoved > 0)\n        System.arraycopy(elementData, index+1, elementData, index, numMoved);\n    elementData[--size] = null; //清除该位置的引用，让GC起作用\n    return oldValue;\n}\n```","slug":"arraylist","published":1,"updated":"2018-02-24T08:06:52.023Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjefa5bp9000e6skck12h91o0","content":"<h1 id=\"Introduction\"><a href=\"#Introduction\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h1><p>本文是学习ArrayList源码的学习总结，组织结构如下：</p>\n<ul>\n<li>总体介绍</li>\n<li>核心方法剖析</li>\n</ul>\n<h1 id=\"总体介绍\"><a href=\"#总体介绍\" class=\"headerlink\" title=\"总体介绍\"></a>总体介绍</h1><p><em>ArrayList</em>实现了<em>List</em>接口，是顺序容器，即元素存放的数据与放进去的顺序相同，允许放入<code>null</code>元素，底层通过<strong>数组实现</strong>。除该类未实现同步外，其余跟<em>Vector</em>大致相同。每个<em>ArrayList</em>都有一个容量（capacity），表示底层数组的实际大小，容器内存储元素的个数不能多于当前容量。当向容器中添加元素时，如果容量不足，容器会自动增大底层数组的大小。前面已经提过，Java泛型只是编译器提供的语法糖，所以这里的数组是一个Object数组，以便能够容纳任何类型的对象。</p>\n<a id=\"more\"></a>\n<p><img src=\"/images/arraylist/ArrayList_base.png\" alt=\"ArrayList_base\"></p>\n<p>size(), isEmpty(), get(), set()方法均能在常数时间内完成，add()方法的时间开销跟插入位置有关，addAll()方法的时间开销跟添加元素的个数成正比。其余方法大都是线性时间。</p>\n<p>为追求效率，ArrayList没有实现同步（synchronized），如果需要多个线程并发访问，用户可以手动同步，也可使用Vector替代。</p>\n<h1 id=\"方法剖析\"><a href=\"#方法剖析\" class=\"headerlink\" title=\"方法剖析\"></a>方法剖析</h1><h3 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set()\"></a>set()</h3><p>既然底层是一个数组<em>ArrayList</em>的<code>set()</code>方法也就变得非常简单，直接对数组的指定位置赋值即可。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">set</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\">    rangeCheck(index);<span class=\"comment\">//下标越界检查</span></span><br><span class=\"line\">    E oldValue = elementData(index);</span><br><span class=\"line\">    elementData[index] = element;<span class=\"comment\">//赋值到指定位置，复制的仅仅是引用</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get()\"></a>get()</h3><p><code>get()</code>方法同样很简单，唯一要注意的是由于底层数组是Object[]，得到元素后需要进行类型转换。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    rangeCheck(index);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (E) elementData[index];<span class=\"comment\">//注意类型转换</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"add\"><a href=\"#add\" class=\"headerlink\" title=\"add()\"></a>add()</h3><p>跟C++ 的<em>vector</em>不同，<em>ArrayList</em>没有<code>push_back()</code>方法，对应的方法是<code>add(E e)</code>，<em>ArrayList</em>也没有<code>insert()</code>方法，对应的方法是<code>add(int index, E e)</code>。这两个方法都是向容器中添加新元素，这可能会导致<em>capacity</em>不足，因此在添加元素之前，都需要进行剩余空间检查，如果需要则自动扩容。扩容操作最终是通过<code>grow()</code>方法完成的。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">grow</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCapacity = elementData.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class=\"number\">1</span>);<span class=\"comment\">//原来的1.5倍</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = minCapacity;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">    elementData = Arrays.copyOf(elementData, newCapacity);<span class=\"comment\">//扩展空间并复制</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>由于Java GC自动管理了内存，这里也就不需要考虑源数组释放的问题。</p>\n<p><img src=\"/images/arraylist/ArrayList_grow.png\" alt=\"ArrayList_grow\"></p>\n<p>空间的问题解决后，插入过程就显得非常简单。</p>\n<p><img src=\"/images/arraylist/ArrayList_add.png\" alt=\"ArrayList_add\"></p>\n<p><code>add(int index, E e)</code>需要先对元素进行移动，然后完成插入操作，也就意味着该方法有着线性的时间复杂度。</p>\n<h3 id=\"addAll\"><a href=\"#addAll\" class=\"headerlink\" title=\"addAll()\"></a>addAll()</h3><p><code>addAll()</code>方法能够一次添加多个元素，根据位置不同也有两个版本，一个是在末尾添加的<code>addAll(Collection&lt;? extends E&gt; c)</code>方法，一个是从指定位置开始插入的<code>addAll(int index, Collection&lt;? extends E&gt; c)</code>方法。跟<code>add()</code>方法类似，在插入之前也需要进行空间检查，如果需要则自动扩容；如果从指定位置插入，也会存在移动元素的情况。<br><code>addAll()</code>的时间复杂度不仅跟插入元素的多少有关，也跟插入的位置相关。</p>\n<h3 id=\"remove\"><a href=\"#remove\" class=\"headerlink\" title=\"remove()\"></a>remove()</h3><p><code>remove()</code>方法也有两个版本，一个是<code>remove(int index)</code>删除指定位置的元素，另一个是<code>remove(Object o)</code>删除第一个满足<code>o.equals(elementData[index])</code>的元素。删除操作是<code>add()</code>操作的逆过程，需要将删除点之后的元素向前移动一个位置。需要注意的是为了让GC起作用，必须显式的为最后一个位置赋<code>null</code>值。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">remove</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    rangeCheck(index);</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">    E oldValue = elementData(index);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> numMoved = size - index - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (numMoved &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        System.arraycopy(elementData, index+<span class=\"number\">1</span>, elementData, index, numMoved);</span><br><span class=\"line\">    elementData[--size] = <span class=\"keyword\">null</span>; <span class=\"comment\">//清除该位置的引用，让GC起作用</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Introduction\"><a href=\"#Introduction\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h1><p>本文是学习ArrayList源码的学习总结，组织结构如下：</p>\n<ul>\n<li>总体介绍</li>\n<li>核心方法剖析</li>\n</ul>\n<h1 id=\"总体介绍\"><a href=\"#总体介绍\" class=\"headerlink\" title=\"总体介绍\"></a>总体介绍</h1><p><em>ArrayList</em>实现了<em>List</em>接口，是顺序容器，即元素存放的数据与放进去的顺序相同，允许放入<code>null</code>元素，底层通过<strong>数组实现</strong>。除该类未实现同步外，其余跟<em>Vector</em>大致相同。每个<em>ArrayList</em>都有一个容量（capacity），表示底层数组的实际大小，容器内存储元素的个数不能多于当前容量。当向容器中添加元素时，如果容量不足，容器会自动增大底层数组的大小。前面已经提过，Java泛型只是编译器提供的语法糖，所以这里的数组是一个Object数组，以便能够容纳任何类型的对象。</p>","more":"<p><img src=\"/images/arraylist/ArrayList_base.png\" alt=\"ArrayList_base\"></p>\n<p>size(), isEmpty(), get(), set()方法均能在常数时间内完成，add()方法的时间开销跟插入位置有关，addAll()方法的时间开销跟添加元素的个数成正比。其余方法大都是线性时间。</p>\n<p>为追求效率，ArrayList没有实现同步（synchronized），如果需要多个线程并发访问，用户可以手动同步，也可使用Vector替代。</p>\n<h1 id=\"方法剖析\"><a href=\"#方法剖析\" class=\"headerlink\" title=\"方法剖析\"></a>方法剖析</h1><h3 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set()\"></a>set()</h3><p>既然底层是一个数组<em>ArrayList</em>的<code>set()</code>方法也就变得非常简单，直接对数组的指定位置赋值即可。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">set</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\">    rangeCheck(index);<span class=\"comment\">//下标越界检查</span></span><br><span class=\"line\">    E oldValue = elementData(index);</span><br><span class=\"line\">    elementData[index] = element;<span class=\"comment\">//赋值到指定位置，复制的仅仅是引用</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get()\"></a>get()</h3><p><code>get()</code>方法同样很简单，唯一要注意的是由于底层数组是Object[]，得到元素后需要进行类型转换。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    rangeCheck(index);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (E) elementData[index];<span class=\"comment\">//注意类型转换</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"add\"><a href=\"#add\" class=\"headerlink\" title=\"add()\"></a>add()</h3><p>跟C++ 的<em>vector</em>不同，<em>ArrayList</em>没有<code>push_back()</code>方法，对应的方法是<code>add(E e)</code>，<em>ArrayList</em>也没有<code>insert()</code>方法，对应的方法是<code>add(int index, E e)</code>。这两个方法都是向容器中添加新元素，这可能会导致<em>capacity</em>不足，因此在添加元素之前，都需要进行剩余空间检查，如果需要则自动扩容。扩容操作最终是通过<code>grow()</code>方法完成的。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">grow</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCapacity = elementData.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class=\"number\">1</span>);<span class=\"comment\">//原来的1.5倍</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = minCapacity;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">    elementData = Arrays.copyOf(elementData, newCapacity);<span class=\"comment\">//扩展空间并复制</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>由于Java GC自动管理了内存，这里也就不需要考虑源数组释放的问题。</p>\n<p><img src=\"/images/arraylist/ArrayList_grow.png\" alt=\"ArrayList_grow\"></p>\n<p>空间的问题解决后，插入过程就显得非常简单。</p>\n<p><img src=\"/images/arraylist/ArrayList_add.png\" alt=\"ArrayList_add\"></p>\n<p><code>add(int index, E e)</code>需要先对元素进行移动，然后完成插入操作，也就意味着该方法有着线性的时间复杂度。</p>\n<h3 id=\"addAll\"><a href=\"#addAll\" class=\"headerlink\" title=\"addAll()\"></a>addAll()</h3><p><code>addAll()</code>方法能够一次添加多个元素，根据位置不同也有两个版本，一个是在末尾添加的<code>addAll(Collection&lt;? extends E&gt; c)</code>方法，一个是从指定位置开始插入的<code>addAll(int index, Collection&lt;? extends E&gt; c)</code>方法。跟<code>add()</code>方法类似，在插入之前也需要进行空间检查，如果需要则自动扩容；如果从指定位置插入，也会存在移动元素的情况。<br><code>addAll()</code>的时间复杂度不仅跟插入元素的多少有关，也跟插入的位置相关。</p>\n<h3 id=\"remove\"><a href=\"#remove\" class=\"headerlink\" title=\"remove()\"></a>remove()</h3><p><code>remove()</code>方法也有两个版本，一个是<code>remove(int index)</code>删除指定位置的元素，另一个是<code>remove(Object o)</code>删除第一个满足<code>o.equals(elementData[index])</code>的元素。删除操作是<code>add()</code>操作的逆过程，需要将删除点之后的元素向前移动一个位置。需要注意的是为了让GC起作用，必须显式的为最后一个位置赋<code>null</code>值。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">remove</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    rangeCheck(index);</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">    E oldValue = elementData(index);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> numMoved = size - index - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (numMoved &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        System.arraycopy(elementData, index+<span class=\"number\">1</span>, elementData, index, numMoved);</span><br><span class=\"line\">    elementData[--size] = <span class=\"keyword\">null</span>; <span class=\"comment\">//清除该位置的引用，让GC起作用</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>"},{"title":"JVM内存分析","author":"James","date":"2013-05-27T08:13:00.000Z","_content":"# 概要\n\n开发人员编写Java代码(.java文件)，然后将之编译成字节码(.class文件)。最后字节码被装入内存，一旦字节码进入虚拟机，它就会被解释器解释执行，或者是被即时代码发生器有选择的转换成机器码执行。在Java平台的结构中, 可以看出，Java虚拟机(JVM) 处在核心的位置，是程序与底层操作系统和硬件无关的关键。它的下方是移植接口，移植接口由两部分组成：适配器和Java操作系统, 其中依赖于平台的部分称为适配器；JVM 通过移植接口在具体的平台和操作系统上实现；在JVM 的上方是Java的基本类库和扩展类库以及它们的API， 利用Java API编写的应用程序(application) 和小程序(Java applet) 可以在任何Java平台上运行而无需考虑底层平台, 就是因为有Java虚拟机(JVM)实现了程序与操作系统的分离，从而实现了Java 的平台无关性。\n\n<!-- more -->\n\n![jvm_struct2](/images/jvm/jvm_struct2.jpg)\n\n\n\n# 详细介绍\n\n## 程序计数器\n\n程序计数器，可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作就是通过改变程序计数器的值来选择下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都要依赖这个计数器来完成。\n\n多线程中，为了让线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间互不影响、独立存储，因此这块内存是 线程私有 的。\n\n当线程正在执行的是一个Java方法，这个计数器记录的是在正在执行的虚拟机字节码指令的地址；当执行的是Native方法，这个计数器值为空。\n\n此内存区域是唯一一个没有规定任何OutOfMemoryError情况的区域 。\n\n##  Java虚拟机栈\n\nJava虚拟机栈也是线程私有的 ，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储**局部变量表**、**操作数栈**、**动态链表**、方法出口信息等。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。\n\n**局部变量表**中存放了编译器可知的各种**基本数据类型**(boolean、byte、char、short、int、float、long、double)、对象引用（reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。\n\n如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。\n\n## Java堆\n\nJava堆是所有线程共享的一块内存区域，在虚拟机启动时创建，此内存区域的唯一目的就是存放**对象实例 **。\n\nJava堆是垃圾收集器管理的主要区域。由于现在收集器基本采用分代回收算法，所以Java堆还可细分为：新生代和老年代。从内存分配的角度来看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区(TLAB)。\n\nJava堆可以处于物理上不连续的内存空间，只要逻辑上连续的即可。在实现上，既可以实现固定大小的，也可以是扩展的。\n\n如果堆中没有内存完成实例分配，并且堆也无法完成扩展时，将会抛出OutOfMemoryError异常。\n\n![jvm_heap](/images/jvm/jvm_heap.jpg)\n\n## 方法区\n\n方法区是各个线程共享的内存区域，它用于存储已被虚拟机加载的*类信息*、*常量*、*静态变量*、即时编译器编译后的代码等数据 。\n\n相对而言，垃圾收集行为在这个区域比较少出现，但并非数据进了方法区就永久的存在了，这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，\n\n运行时常量池：用于存放编译期生成的各种字面量和符号引用。\n\n当方法区无法满足内存分配需要时，将抛出OutOfMemoryError异常。\n\n## 直接内存\n\n直接内存不是虚拟机运行时数据区的一部分，在NIO类中引入一种基于通道与缓冲区的IO方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。\n\n直接内存的分配不会受到Java堆大小的限制，但是会受到本机内存大小的限制，所有也可能会抛OutOfMemoryError异常。\n\n## 本地方法栈\n\n本地方法栈与虚拟机的作用相似，不同之处在于虚拟机栈为虚拟机执行的Java方法服务，而本地方法栈则为虚拟机使用到的Native方法服务。有的虚拟机直接把本地方法栈和虚拟机栈合二为一。\n\n会抛出stackOverflowError和OutOfMemoryError异常。\n\n一个数组的在堆中的简单表示:\n\n![array](/images/jvm/array.jpg)\n\n\n\n# 设置参数\n\n| 设置                       | 说明                                                         |\n| -------------------------- | ------------------------------------------------------------ |\n| -Xms512m                   | 表示JVM初始分配的堆内存大小为512m（JVM Heap(堆内存)最小尺寸，初始分配） |\n| -Xmx1024m                  | JVM最大允许分配的堆内存大小为1024m，按需分配（JVM Heap(堆内存)最大允许的尺寸，按需分配） |\n| -XX:PermSize=512M          | JVM初始分配的非堆内存                                        |\n| -XX:MaxPermSize=1024M      | JVM最大允许分配的非堆内存，按需分配                          |\n| -XX:NewSize/-XX:MaxNewSize | 定义YOUNG段的尺寸，NewSize为JVM启动时YOUNG的内存大小； MaxNewSize为最大可占用的YOUNG内存大小。 |\n| -XX:SurvivorRatio          | 设置YOUNG代中Survivor空间和Eden空间的比例                    |\n\n## 说明\n\n- -Xmx不指定或者指定偏小，应用可能会导致java.lang.OutOfMemory错误\n- PermSize和MaxPermSize指明虚拟机为java永久生成对象（Permanate generation）如，class对象、方法对象这些可反射（reflective）对象分配内存限制\n- -XX:MaxPermSize分配过小会导致：java.lang.OutOfMemoryError: PermGen space\n\n# 内存监控方法\n\njmap -heap 查看java 堆（heap）使用情况\n\n参数配置：内存溢出自动dump内存快照\n\n-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/home/logs\n\njmap -dump:format=b,file=heap.bin <pid>  \n\nformat=b的含义是，dump出来的文件时二进制格式。\n\nfile-heap.bin的含义是，dump出来的文件名是heap.bin。\n\n <pid>就是JVM的进程号。\n\n （在linux下）先执行ps aux | grep java，找到JVM的pid；然后再执行jmap -dump:format=b,file=heap.bin <pid>，得到heap dump文件。\n\n或者可以使用 jps -lv 查看java pid","source":"_posts/jvm_memory.md","raw":"title: JVM内存分析\nauthor: James\ntags:\n  - jvm\n  - java\ncategories:\n  - 语言\ndate: 2013-05-27 16:13:00\n---\n# 概要\n\n开发人员编写Java代码(.java文件)，然后将之编译成字节码(.class文件)。最后字节码被装入内存，一旦字节码进入虚拟机，它就会被解释器解释执行，或者是被即时代码发生器有选择的转换成机器码执行。在Java平台的结构中, 可以看出，Java虚拟机(JVM) 处在核心的位置，是程序与底层操作系统和硬件无关的关键。它的下方是移植接口，移植接口由两部分组成：适配器和Java操作系统, 其中依赖于平台的部分称为适配器；JVM 通过移植接口在具体的平台和操作系统上实现；在JVM 的上方是Java的基本类库和扩展类库以及它们的API， 利用Java API编写的应用程序(application) 和小程序(Java applet) 可以在任何Java平台上运行而无需考虑底层平台, 就是因为有Java虚拟机(JVM)实现了程序与操作系统的分离，从而实现了Java 的平台无关性。\n\n<!-- more -->\n\n![jvm_struct2](/images/jvm/jvm_struct2.jpg)\n\n\n\n# 详细介绍\n\n## 程序计数器\n\n程序计数器，可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作就是通过改变程序计数器的值来选择下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都要依赖这个计数器来完成。\n\n多线程中，为了让线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间互不影响、独立存储，因此这块内存是 线程私有 的。\n\n当线程正在执行的是一个Java方法，这个计数器记录的是在正在执行的虚拟机字节码指令的地址；当执行的是Native方法，这个计数器值为空。\n\n此内存区域是唯一一个没有规定任何OutOfMemoryError情况的区域 。\n\n##  Java虚拟机栈\n\nJava虚拟机栈也是线程私有的 ，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储**局部变量表**、**操作数栈**、**动态链表**、方法出口信息等。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。\n\n**局部变量表**中存放了编译器可知的各种**基本数据类型**(boolean、byte、char、short、int、float、long、double)、对象引用（reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。\n\n如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。\n\n## Java堆\n\nJava堆是所有线程共享的一块内存区域，在虚拟机启动时创建，此内存区域的唯一目的就是存放**对象实例 **。\n\nJava堆是垃圾收集器管理的主要区域。由于现在收集器基本采用分代回收算法，所以Java堆还可细分为：新生代和老年代。从内存分配的角度来看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区(TLAB)。\n\nJava堆可以处于物理上不连续的内存空间，只要逻辑上连续的即可。在实现上，既可以实现固定大小的，也可以是扩展的。\n\n如果堆中没有内存完成实例分配，并且堆也无法完成扩展时，将会抛出OutOfMemoryError异常。\n\n![jvm_heap](/images/jvm/jvm_heap.jpg)\n\n## 方法区\n\n方法区是各个线程共享的内存区域，它用于存储已被虚拟机加载的*类信息*、*常量*、*静态变量*、即时编译器编译后的代码等数据 。\n\n相对而言，垃圾收集行为在这个区域比较少出现，但并非数据进了方法区就永久的存在了，这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，\n\n运行时常量池：用于存放编译期生成的各种字面量和符号引用。\n\n当方法区无法满足内存分配需要时，将抛出OutOfMemoryError异常。\n\n## 直接内存\n\n直接内存不是虚拟机运行时数据区的一部分，在NIO类中引入一种基于通道与缓冲区的IO方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。\n\n直接内存的分配不会受到Java堆大小的限制，但是会受到本机内存大小的限制，所有也可能会抛OutOfMemoryError异常。\n\n## 本地方法栈\n\n本地方法栈与虚拟机的作用相似，不同之处在于虚拟机栈为虚拟机执行的Java方法服务，而本地方法栈则为虚拟机使用到的Native方法服务。有的虚拟机直接把本地方法栈和虚拟机栈合二为一。\n\n会抛出stackOverflowError和OutOfMemoryError异常。\n\n一个数组的在堆中的简单表示:\n\n![array](/images/jvm/array.jpg)\n\n\n\n# 设置参数\n\n| 设置                       | 说明                                                         |\n| -------------------------- | ------------------------------------------------------------ |\n| -Xms512m                   | 表示JVM初始分配的堆内存大小为512m（JVM Heap(堆内存)最小尺寸，初始分配） |\n| -Xmx1024m                  | JVM最大允许分配的堆内存大小为1024m，按需分配（JVM Heap(堆内存)最大允许的尺寸，按需分配） |\n| -XX:PermSize=512M          | JVM初始分配的非堆内存                                        |\n| -XX:MaxPermSize=1024M      | JVM最大允许分配的非堆内存，按需分配                          |\n| -XX:NewSize/-XX:MaxNewSize | 定义YOUNG段的尺寸，NewSize为JVM启动时YOUNG的内存大小； MaxNewSize为最大可占用的YOUNG内存大小。 |\n| -XX:SurvivorRatio          | 设置YOUNG代中Survivor空间和Eden空间的比例                    |\n\n## 说明\n\n- -Xmx不指定或者指定偏小，应用可能会导致java.lang.OutOfMemory错误\n- PermSize和MaxPermSize指明虚拟机为java永久生成对象（Permanate generation）如，class对象、方法对象这些可反射（reflective）对象分配内存限制\n- -XX:MaxPermSize分配过小会导致：java.lang.OutOfMemoryError: PermGen space\n\n# 内存监控方法\n\njmap -heap 查看java 堆（heap）使用情况\n\n参数配置：内存溢出自动dump内存快照\n\n-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/home/logs\n\njmap -dump:format=b,file=heap.bin <pid>  \n\nformat=b的含义是，dump出来的文件时二进制格式。\n\nfile-heap.bin的含义是，dump出来的文件名是heap.bin。\n\n <pid>就是JVM的进程号。\n\n （在linux下）先执行ps aux | grep java，找到JVM的pid；然后再执行jmap -dump:format=b,file=heap.bin <pid>，得到heap dump文件。\n\n或者可以使用 jps -lv 查看java pid","slug":"jvm_memory","published":1,"updated":"2018-03-01T01:36:49.979Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjefa5bpc000f6skc0u681bhw","content":"<h1 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h1><p>开发人员编写Java代码(.java文件)，然后将之编译成字节码(.class文件)。最后字节码被装入内存，一旦字节码进入虚拟机，它就会被解释器解释执行，或者是被即时代码发生器有选择的转换成机器码执行。在Java平台的结构中, 可以看出，Java虚拟机(JVM) 处在核心的位置，是程序与底层操作系统和硬件无关的关键。它的下方是移植接口，移植接口由两部分组成：适配器和Java操作系统, 其中依赖于平台的部分称为适配器；JVM 通过移植接口在具体的平台和操作系统上实现；在JVM 的上方是Java的基本类库和扩展类库以及它们的API， 利用Java API编写的应用程序(application) 和小程序(Java applet) 可以在任何Java平台上运行而无需考虑底层平台, 就是因为有Java虚拟机(JVM)实现了程序与操作系统的分离，从而实现了Java 的平台无关性。</p>\n<a id=\"more\"></a>\n<p><img src=\"/images/jvm/jvm_struct2.jpg\" alt=\"jvm_struct2\"></p>\n<h1 id=\"详细介绍\"><a href=\"#详细介绍\" class=\"headerlink\" title=\"详细介绍\"></a>详细介绍</h1><h2 id=\"程序计数器\"><a href=\"#程序计数器\" class=\"headerlink\" title=\"程序计数器\"></a>程序计数器</h2><p>程序计数器，可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作就是通过改变程序计数器的值来选择下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都要依赖这个计数器来完成。</p>\n<p>多线程中，为了让线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间互不影响、独立存储，因此这块内存是 线程私有 的。</p>\n<p>当线程正在执行的是一个Java方法，这个计数器记录的是在正在执行的虚拟机字节码指令的地址；当执行的是Native方法，这个计数器值为空。</p>\n<p>此内存区域是唯一一个没有规定任何OutOfMemoryError情况的区域 。</p>\n<h2 id=\"Java虚拟机栈\"><a href=\"#Java虚拟机栈\" class=\"headerlink\" title=\"Java虚拟机栈\"></a>Java虚拟机栈</h2><p>Java虚拟机栈也是线程私有的 ，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储<strong>局部变量表</strong>、<strong>操作数栈</strong>、<strong>动态链表</strong>、方法出口信息等。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p>\n<p><strong>局部变量表</strong>中存放了编译器可知的各种<strong>基本数据类型</strong>(boolean、byte、char、short、int、float、long、double)、对象引用（reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。</p>\n<p>如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。</p>\n<h2 id=\"Java堆\"><a href=\"#Java堆\" class=\"headerlink\" title=\"Java堆\"></a>Java堆</h2><p>Java堆是所有线程共享的一块内存区域，在虚拟机启动时创建，此内存区域的唯一目的就是存放<strong>对象实例 </strong>。</p>\n<p>Java堆是垃圾收集器管理的主要区域。由于现在收集器基本采用分代回收算法，所以Java堆还可细分为：新生代和老年代。从内存分配的角度来看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区(TLAB)。</p>\n<p>Java堆可以处于物理上不连续的内存空间，只要逻辑上连续的即可。在实现上，既可以实现固定大小的，也可以是扩展的。</p>\n<p>如果堆中没有内存完成实例分配，并且堆也无法完成扩展时，将会抛出OutOfMemoryError异常。</p>\n<p><img src=\"/images/jvm/jvm_heap.jpg\" alt=\"jvm_heap\"></p>\n<h2 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区\"></a>方法区</h2><p>方法区是各个线程共享的内存区域，它用于存储已被虚拟机加载的<em>类信息</em>、<em>常量</em>、<em>静态变量</em>、即时编译器编译后的代码等数据 。</p>\n<p>相对而言，垃圾收集行为在这个区域比较少出现，但并非数据进了方法区就永久的存在了，这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，</p>\n<p>运行时常量池：用于存放编译期生成的各种字面量和符号引用。</p>\n<p>当方法区无法满足内存分配需要时，将抛出OutOfMemoryError异常。</p>\n<h2 id=\"直接内存\"><a href=\"#直接内存\" class=\"headerlink\" title=\"直接内存\"></a>直接内存</h2><p>直接内存不是虚拟机运行时数据区的一部分，在NIO类中引入一种基于通道与缓冲区的IO方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。</p>\n<p>直接内存的分配不会受到Java堆大小的限制，但是会受到本机内存大小的限制，所有也可能会抛OutOfMemoryError异常。</p>\n<h2 id=\"本地方法栈\"><a href=\"#本地方法栈\" class=\"headerlink\" title=\"本地方法栈\"></a>本地方法栈</h2><p>本地方法栈与虚拟机的作用相似，不同之处在于虚拟机栈为虚拟机执行的Java方法服务，而本地方法栈则为虚拟机使用到的Native方法服务。有的虚拟机直接把本地方法栈和虚拟机栈合二为一。</p>\n<p>会抛出stackOverflowError和OutOfMemoryError异常。</p>\n<p>一个数组的在堆中的简单表示:</p>\n<p><img src=\"/images/jvm/array.jpg\" alt=\"array\"></p>\n<h1 id=\"设置参数\"><a href=\"#设置参数\" class=\"headerlink\" title=\"设置参数\"></a>设置参数</h1><table>\n<thead>\n<tr>\n<th>设置</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-Xms512m</td>\n<td>表示JVM初始分配的堆内存大小为512m（JVM Heap(堆内存)最小尺寸，初始分配）</td>\n</tr>\n<tr>\n<td>-Xmx1024m</td>\n<td>JVM最大允许分配的堆内存大小为1024m，按需分配（JVM Heap(堆内存)最大允许的尺寸，按需分配）</td>\n</tr>\n<tr>\n<td>-XX:PermSize=512M</td>\n<td>JVM初始分配的非堆内存</td>\n</tr>\n<tr>\n<td>-XX:MaxPermSize=1024M</td>\n<td>JVM最大允许分配的非堆内存，按需分配</td>\n</tr>\n<tr>\n<td>-XX:NewSize/-XX:MaxNewSize</td>\n<td>定义YOUNG段的尺寸，NewSize为JVM启动时YOUNG的内存大小； MaxNewSize为最大可占用的YOUNG内存大小。</td>\n</tr>\n<tr>\n<td>-XX:SurvivorRatio</td>\n<td>设置YOUNG代中Survivor空间和Eden空间的比例</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><ul>\n<li>-Xmx不指定或者指定偏小，应用可能会导致java.lang.OutOfMemory错误</li>\n<li>PermSize和MaxPermSize指明虚拟机为java永久生成对象（Permanate generation）如，class对象、方法对象这些可反射（reflective）对象分配内存限制</li>\n<li>-XX:MaxPermSize分配过小会导致：java.lang.OutOfMemoryError: PermGen space</li>\n</ul>\n<h1 id=\"内存监控方法\"><a href=\"#内存监控方法\" class=\"headerlink\" title=\"内存监控方法\"></a>内存监控方法</h1><p>jmap -heap 查看java 堆（heap）使用情况</p>\n<p>参数配置：内存溢出自动dump内存快照</p>\n<p>-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/home/logs</p>\n<p>jmap -dump:format=b,file=heap.bin <pid>  </pid></p>\n<p>format=b的含义是，dump出来的文件时二进制格式。</p>\n<p>file-heap.bin的含义是，dump出来的文件名是heap.bin。</p>\n<p> <pid>就是JVM的进程号。</pid></p>\n<p> （在linux下）先执行ps aux | grep java，找到JVM的pid；然后再执行jmap -dump:format=b,file=heap.bin <pid>，得到heap dump文件。</pid></p>\n<p>或者可以使用 jps -lv 查看java pid</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h1><p>开发人员编写Java代码(.java文件)，然后将之编译成字节码(.class文件)。最后字节码被装入内存，一旦字节码进入虚拟机，它就会被解释器解释执行，或者是被即时代码发生器有选择的转换成机器码执行。在Java平台的结构中, 可以看出，Java虚拟机(JVM) 处在核心的位置，是程序与底层操作系统和硬件无关的关键。它的下方是移植接口，移植接口由两部分组成：适配器和Java操作系统, 其中依赖于平台的部分称为适配器；JVM 通过移植接口在具体的平台和操作系统上实现；在JVM 的上方是Java的基本类库和扩展类库以及它们的API， 利用Java API编写的应用程序(application) 和小程序(Java applet) 可以在任何Java平台上运行而无需考虑底层平台, 就是因为有Java虚拟机(JVM)实现了程序与操作系统的分离，从而实现了Java 的平台无关性。</p>","more":"<p><img src=\"/images/jvm/jvm_struct2.jpg\" alt=\"jvm_struct2\"></p>\n<h1 id=\"详细介绍\"><a href=\"#详细介绍\" class=\"headerlink\" title=\"详细介绍\"></a>详细介绍</h1><h2 id=\"程序计数器\"><a href=\"#程序计数器\" class=\"headerlink\" title=\"程序计数器\"></a>程序计数器</h2><p>程序计数器，可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作就是通过改变程序计数器的值来选择下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都要依赖这个计数器来完成。</p>\n<p>多线程中，为了让线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间互不影响、独立存储，因此这块内存是 线程私有 的。</p>\n<p>当线程正在执行的是一个Java方法，这个计数器记录的是在正在执行的虚拟机字节码指令的地址；当执行的是Native方法，这个计数器值为空。</p>\n<p>此内存区域是唯一一个没有规定任何OutOfMemoryError情况的区域 。</p>\n<h2 id=\"Java虚拟机栈\"><a href=\"#Java虚拟机栈\" class=\"headerlink\" title=\"Java虚拟机栈\"></a>Java虚拟机栈</h2><p>Java虚拟机栈也是线程私有的 ，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储<strong>局部变量表</strong>、<strong>操作数栈</strong>、<strong>动态链表</strong>、方法出口信息等。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p>\n<p><strong>局部变量表</strong>中存放了编译器可知的各种<strong>基本数据类型</strong>(boolean、byte、char、short、int、float、long、double)、对象引用（reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。</p>\n<p>如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。</p>\n<h2 id=\"Java堆\"><a href=\"#Java堆\" class=\"headerlink\" title=\"Java堆\"></a>Java堆</h2><p>Java堆是所有线程共享的一块内存区域，在虚拟机启动时创建，此内存区域的唯一目的就是存放<strong>对象实例 </strong>。</p>\n<p>Java堆是垃圾收集器管理的主要区域。由于现在收集器基本采用分代回收算法，所以Java堆还可细分为：新生代和老年代。从内存分配的角度来看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区(TLAB)。</p>\n<p>Java堆可以处于物理上不连续的内存空间，只要逻辑上连续的即可。在实现上，既可以实现固定大小的，也可以是扩展的。</p>\n<p>如果堆中没有内存完成实例分配，并且堆也无法完成扩展时，将会抛出OutOfMemoryError异常。</p>\n<p><img src=\"/images/jvm/jvm_heap.jpg\" alt=\"jvm_heap\"></p>\n<h2 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区\"></a>方法区</h2><p>方法区是各个线程共享的内存区域，它用于存储已被虚拟机加载的<em>类信息</em>、<em>常量</em>、<em>静态变量</em>、即时编译器编译后的代码等数据 。</p>\n<p>相对而言，垃圾收集行为在这个区域比较少出现，但并非数据进了方法区就永久的存在了，这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，</p>\n<p>运行时常量池：用于存放编译期生成的各种字面量和符号引用。</p>\n<p>当方法区无法满足内存分配需要时，将抛出OutOfMemoryError异常。</p>\n<h2 id=\"直接内存\"><a href=\"#直接内存\" class=\"headerlink\" title=\"直接内存\"></a>直接内存</h2><p>直接内存不是虚拟机运行时数据区的一部分，在NIO类中引入一种基于通道与缓冲区的IO方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。</p>\n<p>直接内存的分配不会受到Java堆大小的限制，但是会受到本机内存大小的限制，所有也可能会抛OutOfMemoryError异常。</p>\n<h2 id=\"本地方法栈\"><a href=\"#本地方法栈\" class=\"headerlink\" title=\"本地方法栈\"></a>本地方法栈</h2><p>本地方法栈与虚拟机的作用相似，不同之处在于虚拟机栈为虚拟机执行的Java方法服务，而本地方法栈则为虚拟机使用到的Native方法服务。有的虚拟机直接把本地方法栈和虚拟机栈合二为一。</p>\n<p>会抛出stackOverflowError和OutOfMemoryError异常。</p>\n<p>一个数组的在堆中的简单表示:</p>\n<p><img src=\"/images/jvm/array.jpg\" alt=\"array\"></p>\n<h1 id=\"设置参数\"><a href=\"#设置参数\" class=\"headerlink\" title=\"设置参数\"></a>设置参数</h1><table>\n<thead>\n<tr>\n<th>设置</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-Xms512m</td>\n<td>表示JVM初始分配的堆内存大小为512m（JVM Heap(堆内存)最小尺寸，初始分配）</td>\n</tr>\n<tr>\n<td>-Xmx1024m</td>\n<td>JVM最大允许分配的堆内存大小为1024m，按需分配（JVM Heap(堆内存)最大允许的尺寸，按需分配）</td>\n</tr>\n<tr>\n<td>-XX:PermSize=512M</td>\n<td>JVM初始分配的非堆内存</td>\n</tr>\n<tr>\n<td>-XX:MaxPermSize=1024M</td>\n<td>JVM最大允许分配的非堆内存，按需分配</td>\n</tr>\n<tr>\n<td>-XX:NewSize/-XX:MaxNewSize</td>\n<td>定义YOUNG段的尺寸，NewSize为JVM启动时YOUNG的内存大小； MaxNewSize为最大可占用的YOUNG内存大小。</td>\n</tr>\n<tr>\n<td>-XX:SurvivorRatio</td>\n<td>设置YOUNG代中Survivor空间和Eden空间的比例</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><ul>\n<li>-Xmx不指定或者指定偏小，应用可能会导致java.lang.OutOfMemory错误</li>\n<li>PermSize和MaxPermSize指明虚拟机为java永久生成对象（Permanate generation）如，class对象、方法对象这些可反射（reflective）对象分配内存限制</li>\n<li>-XX:MaxPermSize分配过小会导致：java.lang.OutOfMemoryError: PermGen space</li>\n</ul>\n<h1 id=\"内存监控方法\"><a href=\"#内存监控方法\" class=\"headerlink\" title=\"内存监控方法\"></a>内存监控方法</h1><p>jmap -heap 查看java 堆（heap）使用情况</p>\n<p>参数配置：内存溢出自动dump内存快照</p>\n<p>-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/home/logs</p>\n<p>jmap -dump:format=b,file=heap.bin <pid>  </pid></p>\n<p>format=b的含义是，dump出来的文件时二进制格式。</p>\n<p>file-heap.bin的含义是，dump出来的文件名是heap.bin。</p>\n<p> <pid>就是JVM的进程号。</pid></p>\n<p> （在linux下）先执行ps aux | grep java，找到JVM的pid；然后再执行jmap -dump:format=b,file=heap.bin <pid>，得到heap dump文件。</pid></p>\n<p>或者可以使用 jps -lv 查看java pid</p>"},{"title":"synchronized的故事","author":"James","date":"2013-07-01T03:30:00.000Z","_content":"\n# 前言\n\n并发编程几乎是每个程序员都必须要掌握的技能，但是也是比较难理解和熟练掌握，使用过程中也很容易出现问题；本文将从java Synchronized的关键字入手，着重讲解其应用方式和实现原理。\n\n<!-- more -->\n\n# 为什么需要它\n\n##  共享性\n\n数据共享性是线程安全的主要原因之一。如果所有的数据只是在线程内有效，那就不存在线程安全性问题，这也是我们在编程的时候经常不需要考虑线程安全的主要原因之一。但是，在多线程编程中，数据共享是不可避免的。对共享变量操作，在多线程环境下很容易出现各种意想不到的的结果。\n\n## 互斥性\n\n资源互斥是指同时只允许一个访问者对其进行访问，具有唯一性和排它性。我们通常允许多个线程同时对数据进行读操作，但同一时间内只允许一个线程对数据进行写操作。\n\n## 可见性\n\n要理解可见性，需要先对JVM的内存模型有一定的了解,如下图:\n\n图中每个线程都有一个自己的工作内存，对于共享变量，线程每次读取的是工作内存中共享变量的副本，写入的时候也直接修改工作内存中副本的值，然后在某个时间点上再将工作内存与主内存中的值进行同步。这样导致的问题是，如果线程1对某个变量进行了修改，线程2却有可能看不到线程1对共享变量所做的修改。\n\n![线程内存共享图](/images/synchronized/thread.png)\n\n## 重排序\n\n为了提高性能，编译器和处理器可能会对指令做重排序。重排序可以分为以下几种：\n\n1. 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。\n2. 指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。\n3. 内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。\n\n# 应用方式\n\nsynchronized关键字最主要有以下3种应用方式:\n\n- 修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁。*注意*：一个对象只有一把锁，当一个线程获取了该对象的锁之后，其他线程无法获取该对象的锁，所以无法访问该对象的其他synchronized实例方法\n- 修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁。\n- 修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。\n\n# 实现原理\n\n先从下面一段代码来看看Synchronized是如何实现对代码块同步的\n\n```java\npackage com.paddx.test.concurrent;\n\npublic class Test {\n    public void method() {\n        synchronized (this) {\n            System.out.println(\"Method...\");\n        }\n    }\n}\n```\n\n然后我们反编译下面的代码来看看\n\n![反编译代码](/images/synchronized/syn_class.png)\n\n红框的两条指令是关键：\n\n`monitorenter` ：每个对象有一个监视器锁`monitor`。当`monitor`被占用时就会处于锁定状态，线程执行`monitorenter`指令时尝试获取`monitor`的所有权，过程如下：\n\n​\t1. 如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。\n\n​\t2. 如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1.\n\n​\t3. 如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。\n\n`monitorexit`：执行`monitorexit`的线程必须是`objectref`所对应的`monitor`的所有者。\n\n​\t指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是\n\n​\t这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权.\n\n​\t从上图字节码中也可以看出多了一个monitorexit指令，它是异常结束时被执行的释放monitor 的指令。\n\n# JDK 实现机制\n\n首先需要了解对象内存的布局：\n\n1. 对象头：标记字（32位虚拟机4B，64位虚拟机8B） + 类型指针（32位虚拟机4B，64位虚拟机8B）+ [数组长（对于数据对象才需要此部分信息）]\n2. 实例数据\n3. 对齐填充：对于64位虚拟机来说，对象大小必须是8B的整数倍，不够的话需要占位填充\n\n![反编译代码](/images/synchronized/object.png)\n\n**Mark Word** 用于存储对象自身的运行时数据，它是实现轻量级锁和偏向锁的关键，所以下面将重点阐述。，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程 \nID、偏向时间戳等等。Java对象头一般占有两个机器码（在32位虚拟机中，1个机器码等于4字节，也就是32bit），但是如果对象是数组类型，则需要三个机器码，因为JVM虚拟机可以通过Java对象的元数据信息确定Java对象的大小，但是无法从数组的元数据来确认数组的大小，所以用一块来记录数组长度。\n![锁存储状态](/images/synchronized/lockstatus.png)\n\n## 几种锁类型\n\n　锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级）。JDK\n 1.6中默认是开启偏向锁和轻量级锁的，我们也可以通过-XX:-UseBiasedLocking来禁用偏向锁。\n\n### 轻量级锁\n\n1. 在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝。\n2. 拷贝对象头中的Mark Word复制到锁记录中。\n3. 拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock record里的owner指针指向object mark word。\n4. 如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，即表示此对象处于轻量级锁定状态。\n5. 如果这个更新操作失败了，虚拟机首先会检查对象的Mark \n   Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。否则说明多个线程竞争锁，轻量级锁就要膨胀为重量级锁，锁标志的状态值变为“10”，Mark\n    Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。 \n   而当前线程便尝试使用自旋来获取锁，自旋就是为了不让线程阻塞，而采用循环去获取锁的过程。\n\n### 偏向锁\n\n引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗必须小于节省下来的CAS原子指令的性能消耗）。上面说过，轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能。\n\n1. 访问Mark Word中偏向锁的标识是否设置成1，锁标志位是否为01——确认为可偏向状态。\n2. 如果为可偏向状态，则测试线程ID是否指向当前线程，如果是，进入步骤5，否则进入步骤3。\n3. 如果线程ID并未指向当前线程，则通过CAS操作竞争锁。如果竞争成功，则将Mark Word中线程ID设置为当前线程ID，然后执行步骤5；如果竞争失败，执行步骤4。\n4. 如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点（safepoint）时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。\n5. 执行同步代码。\n\n\n### 重量级锁\n\n重量级锁通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。\n\n\n**总结** : JDk中采用轻量级锁和偏向锁等对Synchronized的优化，但是这两种锁也不是完全没缺点的，比如竞争比较激烈的时候，不但无法提升效率，反而会降低效率，因为多了一个锁升级的过程\n\n| 锁       | 优点                                                         | 缺点                                             | 适用场景                             |\n| -------- | ------------------------------------------------------------ | ------------------------------------------------ | ------------------------------------ |\n| 偏向锁   | 加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。 | 如果线程间存在锁竞争，会带来额外的锁撤销的消耗。 | 适用于只有一个线程访问同步块场景。   |\n| 轻量级锁 | 竞争的线程不会阻塞，提高了程序的响应速度。                   | 如果始终得不到锁竞争的线程使用自旋会消耗CPU。    | 追求响应时间。同步块执行速度非常快。 |\n| 重量级锁 | 线程竞争不使用自旋，不会消耗CPU。                            | 线程阻塞，响应时间缓慢。                         | 追求吞吐量。同步块执行速度较长。     |\n\n### 锁消除\n\n消除锁是虚拟机另外一种锁的优化，这种优化更彻底，Java虚拟机在JIT编译时(可以简单理解为当某段代码即将第一次被执行时进行编译，又称即时编译)，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间，如下StringBuffer的append是一个同步方法，但是在add方法中的StringBuffer属于一个局部变量，并且不会被其他线程所使用，因此StringBuffer不可能存在共享资源竞争的情景，JVM会自动将其锁消除。\n","source":"_posts/synchronized.md","raw":"title: synchronized的故事\nauthor: James\ntags:\n  - synchronized\n  - lock\ncategories:\n  - 语言\ndate: 2013-07-01 11:30:00\n---\n\n# 前言\n\n并发编程几乎是每个程序员都必须要掌握的技能，但是也是比较难理解和熟练掌握，使用过程中也很容易出现问题；本文将从java Synchronized的关键字入手，着重讲解其应用方式和实现原理。\n\n<!-- more -->\n\n# 为什么需要它\n\n##  共享性\n\n数据共享性是线程安全的主要原因之一。如果所有的数据只是在线程内有效，那就不存在线程安全性问题，这也是我们在编程的时候经常不需要考虑线程安全的主要原因之一。但是，在多线程编程中，数据共享是不可避免的。对共享变量操作，在多线程环境下很容易出现各种意想不到的的结果。\n\n## 互斥性\n\n资源互斥是指同时只允许一个访问者对其进行访问，具有唯一性和排它性。我们通常允许多个线程同时对数据进行读操作，但同一时间内只允许一个线程对数据进行写操作。\n\n## 可见性\n\n要理解可见性，需要先对JVM的内存模型有一定的了解,如下图:\n\n图中每个线程都有一个自己的工作内存，对于共享变量，线程每次读取的是工作内存中共享变量的副本，写入的时候也直接修改工作内存中副本的值，然后在某个时间点上再将工作内存与主内存中的值进行同步。这样导致的问题是，如果线程1对某个变量进行了修改，线程2却有可能看不到线程1对共享变量所做的修改。\n\n![线程内存共享图](/images/synchronized/thread.png)\n\n## 重排序\n\n为了提高性能，编译器和处理器可能会对指令做重排序。重排序可以分为以下几种：\n\n1. 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。\n2. 指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。\n3. 内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。\n\n# 应用方式\n\nsynchronized关键字最主要有以下3种应用方式:\n\n- 修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁。*注意*：一个对象只有一把锁，当一个线程获取了该对象的锁之后，其他线程无法获取该对象的锁，所以无法访问该对象的其他synchronized实例方法\n- 修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁。\n- 修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。\n\n# 实现原理\n\n先从下面一段代码来看看Synchronized是如何实现对代码块同步的\n\n```java\npackage com.paddx.test.concurrent;\n\npublic class Test {\n    public void method() {\n        synchronized (this) {\n            System.out.println(\"Method...\");\n        }\n    }\n}\n```\n\n然后我们反编译下面的代码来看看\n\n![反编译代码](/images/synchronized/syn_class.png)\n\n红框的两条指令是关键：\n\n`monitorenter` ：每个对象有一个监视器锁`monitor`。当`monitor`被占用时就会处于锁定状态，线程执行`monitorenter`指令时尝试获取`monitor`的所有权，过程如下：\n\n​\t1. 如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。\n\n​\t2. 如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1.\n\n​\t3. 如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。\n\n`monitorexit`：执行`monitorexit`的线程必须是`objectref`所对应的`monitor`的所有者。\n\n​\t指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是\n\n​\t这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权.\n\n​\t从上图字节码中也可以看出多了一个monitorexit指令，它是异常结束时被执行的释放monitor 的指令。\n\n# JDK 实现机制\n\n首先需要了解对象内存的布局：\n\n1. 对象头：标记字（32位虚拟机4B，64位虚拟机8B） + 类型指针（32位虚拟机4B，64位虚拟机8B）+ [数组长（对于数据对象才需要此部分信息）]\n2. 实例数据\n3. 对齐填充：对于64位虚拟机来说，对象大小必须是8B的整数倍，不够的话需要占位填充\n\n![反编译代码](/images/synchronized/object.png)\n\n**Mark Word** 用于存储对象自身的运行时数据，它是实现轻量级锁和偏向锁的关键，所以下面将重点阐述。，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程 \nID、偏向时间戳等等。Java对象头一般占有两个机器码（在32位虚拟机中，1个机器码等于4字节，也就是32bit），但是如果对象是数组类型，则需要三个机器码，因为JVM虚拟机可以通过Java对象的元数据信息确定Java对象的大小，但是无法从数组的元数据来确认数组的大小，所以用一块来记录数组长度。\n![锁存储状态](/images/synchronized/lockstatus.png)\n\n## 几种锁类型\n\n　锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级）。JDK\n 1.6中默认是开启偏向锁和轻量级锁的，我们也可以通过-XX:-UseBiasedLocking来禁用偏向锁。\n\n### 轻量级锁\n\n1. 在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝。\n2. 拷贝对象头中的Mark Word复制到锁记录中。\n3. 拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock record里的owner指针指向object mark word。\n4. 如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，即表示此对象处于轻量级锁定状态。\n5. 如果这个更新操作失败了，虚拟机首先会检查对象的Mark \n   Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。否则说明多个线程竞争锁，轻量级锁就要膨胀为重量级锁，锁标志的状态值变为“10”，Mark\n    Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。 \n   而当前线程便尝试使用自旋来获取锁，自旋就是为了不让线程阻塞，而采用循环去获取锁的过程。\n\n### 偏向锁\n\n引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗必须小于节省下来的CAS原子指令的性能消耗）。上面说过，轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能。\n\n1. 访问Mark Word中偏向锁的标识是否设置成1，锁标志位是否为01——确认为可偏向状态。\n2. 如果为可偏向状态，则测试线程ID是否指向当前线程，如果是，进入步骤5，否则进入步骤3。\n3. 如果线程ID并未指向当前线程，则通过CAS操作竞争锁。如果竞争成功，则将Mark Word中线程ID设置为当前线程ID，然后执行步骤5；如果竞争失败，执行步骤4。\n4. 如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点（safepoint）时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。\n5. 执行同步代码。\n\n\n### 重量级锁\n\n重量级锁通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。\n\n\n**总结** : JDk中采用轻量级锁和偏向锁等对Synchronized的优化，但是这两种锁也不是完全没缺点的，比如竞争比较激烈的时候，不但无法提升效率，反而会降低效率，因为多了一个锁升级的过程\n\n| 锁       | 优点                                                         | 缺点                                             | 适用场景                             |\n| -------- | ------------------------------------------------------------ | ------------------------------------------------ | ------------------------------------ |\n| 偏向锁   | 加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。 | 如果线程间存在锁竞争，会带来额外的锁撤销的消耗。 | 适用于只有一个线程访问同步块场景。   |\n| 轻量级锁 | 竞争的线程不会阻塞，提高了程序的响应速度。                   | 如果始终得不到锁竞争的线程使用自旋会消耗CPU。    | 追求响应时间。同步块执行速度非常快。 |\n| 重量级锁 | 线程竞争不使用自旋，不会消耗CPU。                            | 线程阻塞，响应时间缓慢。                         | 追求吞吐量。同步块执行速度较长。     |\n\n### 锁消除\n\n消除锁是虚拟机另外一种锁的优化，这种优化更彻底，Java虚拟机在JIT编译时(可以简单理解为当某段代码即将第一次被执行时进行编译，又称即时编译)，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间，如下StringBuffer的append是一个同步方法，但是在add方法中的StringBuffer属于一个局部变量，并且不会被其他线程所使用，因此StringBuffer不可能存在共享资源竞争的情景，JVM会自动将其锁消除。\n","slug":"synchronized","published":1,"updated":"2018-03-15T06:41:11.291Z","_id":"cjehtoy8e0000dskcy7b2r8bt","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>并发编程几乎是每个程序员都必须要掌握的技能，但是也是比较难理解和熟练掌握，使用过程中也很容易出现问题；本文将从java Synchronized的关键字入手，着重讲解其应用方式和实现原理。</p>\n<a id=\"more\"></a>\n<h1 id=\"为什么需要它\"><a href=\"#为什么需要它\" class=\"headerlink\" title=\"为什么需要它\"></a>为什么需要它</h1><h2 id=\"共享性\"><a href=\"#共享性\" class=\"headerlink\" title=\"共享性\"></a>共享性</h2><p>数据共享性是线程安全的主要原因之一。如果所有的数据只是在线程内有效，那就不存在线程安全性问题，这也是我们在编程的时候经常不需要考虑线程安全的主要原因之一。但是，在多线程编程中，数据共享是不可避免的。对共享变量操作，在多线程环境下很容易出现各种意想不到的的结果。</p>\n<h2 id=\"互斥性\"><a href=\"#互斥性\" class=\"headerlink\" title=\"互斥性\"></a>互斥性</h2><p>资源互斥是指同时只允许一个访问者对其进行访问，具有唯一性和排它性。我们通常允许多个线程同时对数据进行读操作，但同一时间内只允许一个线程对数据进行写操作。</p>\n<h2 id=\"可见性\"><a href=\"#可见性\" class=\"headerlink\" title=\"可见性\"></a>可见性</h2><p>要理解可见性，需要先对JVM的内存模型有一定的了解,如下图:</p>\n<p>图中每个线程都有一个自己的工作内存，对于共享变量，线程每次读取的是工作内存中共享变量的副本，写入的时候也直接修改工作内存中副本的值，然后在某个时间点上再将工作内存与主内存中的值进行同步。这样导致的问题是，如果线程1对某个变量进行了修改，线程2却有可能看不到线程1对共享变量所做的修改。</p>\n<p><img src=\"/images/synchronized/thread.png\" alt=\"线程内存共享图\"></p>\n<h2 id=\"重排序\"><a href=\"#重排序\" class=\"headerlink\" title=\"重排序\"></a>重排序</h2><p>为了提高性能，编译器和处理器可能会对指令做重排序。重排序可以分为以下几种：</p>\n<ol>\n<li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li>\n<li>指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>\n<li>内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li>\n</ol>\n<h1 id=\"应用方式\"><a href=\"#应用方式\" class=\"headerlink\" title=\"应用方式\"></a>应用方式</h1><p>synchronized关键字最主要有以下3种应用方式:</p>\n<ul>\n<li>修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁。<em>注意</em>：一个对象只有一把锁，当一个线程获取了该对象的锁之后，其他线程无法获取该对象的锁，所以无法访问该对象的其他synchronized实例方法</li>\n<li>修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁。</li>\n<li>修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</li>\n</ul>\n<h1 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h1><p>先从下面一段代码来看看Synchronized是如何实现对代码块同步的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.paddx.test.concurrent;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"Method...\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后我们反编译下面的代码来看看</p>\n<p><img src=\"/images/synchronized/syn_class.png\" alt=\"反编译代码\"></p>\n<p>红框的两条指令是关键：</p>\n<p><code>monitorenter</code> ：每个对象有一个监视器锁<code>monitor</code>。当<code>monitor</code>被占用时就会处于锁定状态，线程执行<code>monitorenter</code>指令时尝试获取<code>monitor</code>的所有权，过程如下：</p>\n<p>​    1. 如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。</p>\n<p>​    2. 如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1.</p>\n<p>​    3. 如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。</p>\n<p><code>monitorexit</code>：执行<code>monitorexit</code>的线程必须是<code>objectref</code>所对应的<code>monitor</code>的所有者。</p>\n<p>​    指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是</p>\n<p>​    这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权.</p>\n<p>​    从上图字节码中也可以看出多了一个monitorexit指令，它是异常结束时被执行的释放monitor 的指令。</p>\n<h1 id=\"JDK-实现机制\"><a href=\"#JDK-实现机制\" class=\"headerlink\" title=\"JDK 实现机制\"></a>JDK 实现机制</h1><p>首先需要了解对象内存的布局：</p>\n<ol>\n<li>对象头：标记字（32位虚拟机4B，64位虚拟机8B） + 类型指针（32位虚拟机4B，64位虚拟机8B）+ [数组长（对于数据对象才需要此部分信息）]</li>\n<li>实例数据</li>\n<li>对齐填充：对于64位虚拟机来说，对象大小必须是8B的整数倍，不够的话需要占位填充</li>\n</ol>\n<p><img src=\"/images/synchronized/object.png\" alt=\"反编译代码\"></p>\n<p><strong>Mark Word</strong> 用于存储对象自身的运行时数据，它是实现轻量级锁和偏向锁的关键，所以下面将重点阐述。，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程<br>ID、偏向时间戳等等。Java对象头一般占有两个机器码（在32位虚拟机中，1个机器码等于4字节，也就是32bit），但是如果对象是数组类型，则需要三个机器码，因为JVM虚拟机可以通过Java对象的元数据信息确定Java对象的大小，但是无法从数组的元数据来确认数组的大小，所以用一块来记录数组长度。<br><img src=\"/images/synchronized/lockstatus.png\" alt=\"锁存储状态\"></p>\n<h2 id=\"几种锁类型\"><a href=\"#几种锁类型\" class=\"headerlink\" title=\"几种锁类型\"></a>几种锁类型</h2><p>　锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级）。JDK<br> 1.6中默认是开启偏向锁和轻量级锁的，我们也可以通过-XX:-UseBiasedLocking来禁用偏向锁。</p>\n<h3 id=\"轻量级锁\"><a href=\"#轻量级锁\" class=\"headerlink\" title=\"轻量级锁\"></a>轻量级锁</h3><ol>\n<li>在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝。</li>\n<li>拷贝对象头中的Mark Word复制到锁记录中。</li>\n<li>拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock record里的owner指针指向object mark word。</li>\n<li>如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，即表示此对象处于轻量级锁定状态。</li>\n<li>如果这个更新操作失败了，虚拟机首先会检查对象的Mark<br>Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。否则说明多个线程竞争锁，轻量级锁就要膨胀为重量级锁，锁标志的状态值变为“10”，Mark<br> Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。<br>而当前线程便尝试使用自旋来获取锁，自旋就是为了不让线程阻塞，而采用循环去获取锁的过程。</li>\n</ol>\n<h3 id=\"偏向锁\"><a href=\"#偏向锁\" class=\"headerlink\" title=\"偏向锁\"></a>偏向锁</h3><p>引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗必须小于节省下来的CAS原子指令的性能消耗）。上面说过，轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能。</p>\n<ol>\n<li>访问Mark Word中偏向锁的标识是否设置成1，锁标志位是否为01——确认为可偏向状态。</li>\n<li>如果为可偏向状态，则测试线程ID是否指向当前线程，如果是，进入步骤5，否则进入步骤3。</li>\n<li>如果线程ID并未指向当前线程，则通过CAS操作竞争锁。如果竞争成功，则将Mark Word中线程ID设置为当前线程ID，然后执行步骤5；如果竞争失败，执行步骤4。</li>\n<li>如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点（safepoint）时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。</li>\n<li>执行同步代码。</li>\n</ol>\n<h3 id=\"重量级锁\"><a href=\"#重量级锁\" class=\"headerlink\" title=\"重量级锁\"></a>重量级锁</h3><p>重量级锁通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。</p>\n<p><strong>总结</strong> : JDk中采用轻量级锁和偏向锁等对Synchronized的优化，但是这两种锁也不是完全没缺点的，比如竞争比较激烈的时候，不但无法提升效率，反而会降低效率，因为多了一个锁升级的过程</p>\n<table>\n<thead>\n<tr>\n<th>锁</th>\n<th>优点</th>\n<th>缺点</th>\n<th>适用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>偏向锁</td>\n<td>加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。</td>\n<td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗。</td>\n<td>适用于只有一个线程访问同步块场景。</td>\n</tr>\n<tr>\n<td>轻量级锁</td>\n<td>竞争的线程不会阻塞，提高了程序的响应速度。</td>\n<td>如果始终得不到锁竞争的线程使用自旋会消耗CPU。</td>\n<td>追求响应时间。同步块执行速度非常快。</td>\n</tr>\n<tr>\n<td>重量级锁</td>\n<td>线程竞争不使用自旋，不会消耗CPU。</td>\n<td>线程阻塞，响应时间缓慢。</td>\n<td>追求吞吐量。同步块执行速度较长。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"锁消除\"><a href=\"#锁消除\" class=\"headerlink\" title=\"锁消除\"></a>锁消除</h3><p>消除锁是虚拟机另外一种锁的优化，这种优化更彻底，Java虚拟机在JIT编译时(可以简单理解为当某段代码即将第一次被执行时进行编译，又称即时编译)，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间，如下StringBuffer的append是一个同步方法，但是在add方法中的StringBuffer属于一个局部变量，并且不会被其他线程所使用，因此StringBuffer不可能存在共享资源竞争的情景，JVM会自动将其锁消除。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>并发编程几乎是每个程序员都必须要掌握的技能，但是也是比较难理解和熟练掌握，使用过程中也很容易出现问题；本文将从java Synchronized的关键字入手，着重讲解其应用方式和实现原理。</p>","more":"<h1 id=\"为什么需要它\"><a href=\"#为什么需要它\" class=\"headerlink\" title=\"为什么需要它\"></a>为什么需要它</h1><h2 id=\"共享性\"><a href=\"#共享性\" class=\"headerlink\" title=\"共享性\"></a>共享性</h2><p>数据共享性是线程安全的主要原因之一。如果所有的数据只是在线程内有效，那就不存在线程安全性问题，这也是我们在编程的时候经常不需要考虑线程安全的主要原因之一。但是，在多线程编程中，数据共享是不可避免的。对共享变量操作，在多线程环境下很容易出现各种意想不到的的结果。</p>\n<h2 id=\"互斥性\"><a href=\"#互斥性\" class=\"headerlink\" title=\"互斥性\"></a>互斥性</h2><p>资源互斥是指同时只允许一个访问者对其进行访问，具有唯一性和排它性。我们通常允许多个线程同时对数据进行读操作，但同一时间内只允许一个线程对数据进行写操作。</p>\n<h2 id=\"可见性\"><a href=\"#可见性\" class=\"headerlink\" title=\"可见性\"></a>可见性</h2><p>要理解可见性，需要先对JVM的内存模型有一定的了解,如下图:</p>\n<p>图中每个线程都有一个自己的工作内存，对于共享变量，线程每次读取的是工作内存中共享变量的副本，写入的时候也直接修改工作内存中副本的值，然后在某个时间点上再将工作内存与主内存中的值进行同步。这样导致的问题是，如果线程1对某个变量进行了修改，线程2却有可能看不到线程1对共享变量所做的修改。</p>\n<p><img src=\"/images/synchronized/thread.png\" alt=\"线程内存共享图\"></p>\n<h2 id=\"重排序\"><a href=\"#重排序\" class=\"headerlink\" title=\"重排序\"></a>重排序</h2><p>为了提高性能，编译器和处理器可能会对指令做重排序。重排序可以分为以下几种：</p>\n<ol>\n<li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li>\n<li>指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>\n<li>内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li>\n</ol>\n<h1 id=\"应用方式\"><a href=\"#应用方式\" class=\"headerlink\" title=\"应用方式\"></a>应用方式</h1><p>synchronized关键字最主要有以下3种应用方式:</p>\n<ul>\n<li>修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁。<em>注意</em>：一个对象只有一把锁，当一个线程获取了该对象的锁之后，其他线程无法获取该对象的锁，所以无法访问该对象的其他synchronized实例方法</li>\n<li>修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁。</li>\n<li>修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</li>\n</ul>\n<h1 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h1><p>先从下面一段代码来看看Synchronized是如何实现对代码块同步的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.paddx.test.concurrent;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"Method...\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后我们反编译下面的代码来看看</p>\n<p><img src=\"/images/synchronized/syn_class.png\" alt=\"反编译代码\"></p>\n<p>红框的两条指令是关键：</p>\n<p><code>monitorenter</code> ：每个对象有一个监视器锁<code>monitor</code>。当<code>monitor</code>被占用时就会处于锁定状态，线程执行<code>monitorenter</code>指令时尝试获取<code>monitor</code>的所有权，过程如下：</p>\n<p>​    1. 如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。</p>\n<p>​    2. 如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1.</p>\n<p>​    3. 如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。</p>\n<p><code>monitorexit</code>：执行<code>monitorexit</code>的线程必须是<code>objectref</code>所对应的<code>monitor</code>的所有者。</p>\n<p>​    指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是</p>\n<p>​    这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权.</p>\n<p>​    从上图字节码中也可以看出多了一个monitorexit指令，它是异常结束时被执行的释放monitor 的指令。</p>\n<h1 id=\"JDK-实现机制\"><a href=\"#JDK-实现机制\" class=\"headerlink\" title=\"JDK 实现机制\"></a>JDK 实现机制</h1><p>首先需要了解对象内存的布局：</p>\n<ol>\n<li>对象头：标记字（32位虚拟机4B，64位虚拟机8B） + 类型指针（32位虚拟机4B，64位虚拟机8B）+ [数组长（对于数据对象才需要此部分信息）]</li>\n<li>实例数据</li>\n<li>对齐填充：对于64位虚拟机来说，对象大小必须是8B的整数倍，不够的话需要占位填充</li>\n</ol>\n<p><img src=\"/images/synchronized/object.png\" alt=\"反编译代码\"></p>\n<p><strong>Mark Word</strong> 用于存储对象自身的运行时数据，它是实现轻量级锁和偏向锁的关键，所以下面将重点阐述。，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程<br>ID、偏向时间戳等等。Java对象头一般占有两个机器码（在32位虚拟机中，1个机器码等于4字节，也就是32bit），但是如果对象是数组类型，则需要三个机器码，因为JVM虚拟机可以通过Java对象的元数据信息确定Java对象的大小，但是无法从数组的元数据来确认数组的大小，所以用一块来记录数组长度。<br><img src=\"/images/synchronized/lockstatus.png\" alt=\"锁存储状态\"></p>\n<h2 id=\"几种锁类型\"><a href=\"#几种锁类型\" class=\"headerlink\" title=\"几种锁类型\"></a>几种锁类型</h2><p>　锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级）。JDK<br> 1.6中默认是开启偏向锁和轻量级锁的，我们也可以通过-XX:-UseBiasedLocking来禁用偏向锁。</p>\n<h3 id=\"轻量级锁\"><a href=\"#轻量级锁\" class=\"headerlink\" title=\"轻量级锁\"></a>轻量级锁</h3><ol>\n<li>在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝。</li>\n<li>拷贝对象头中的Mark Word复制到锁记录中。</li>\n<li>拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock record里的owner指针指向object mark word。</li>\n<li>如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，即表示此对象处于轻量级锁定状态。</li>\n<li>如果这个更新操作失败了，虚拟机首先会检查对象的Mark<br>Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。否则说明多个线程竞争锁，轻量级锁就要膨胀为重量级锁，锁标志的状态值变为“10”，Mark<br> Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。<br>而当前线程便尝试使用自旋来获取锁，自旋就是为了不让线程阻塞，而采用循环去获取锁的过程。</li>\n</ol>\n<h3 id=\"偏向锁\"><a href=\"#偏向锁\" class=\"headerlink\" title=\"偏向锁\"></a>偏向锁</h3><p>引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗必须小于节省下来的CAS原子指令的性能消耗）。上面说过，轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能。</p>\n<ol>\n<li>访问Mark Word中偏向锁的标识是否设置成1，锁标志位是否为01——确认为可偏向状态。</li>\n<li>如果为可偏向状态，则测试线程ID是否指向当前线程，如果是，进入步骤5，否则进入步骤3。</li>\n<li>如果线程ID并未指向当前线程，则通过CAS操作竞争锁。如果竞争成功，则将Mark Word中线程ID设置为当前线程ID，然后执行步骤5；如果竞争失败，执行步骤4。</li>\n<li>如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点（safepoint）时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。</li>\n<li>执行同步代码。</li>\n</ol>\n<h3 id=\"重量级锁\"><a href=\"#重量级锁\" class=\"headerlink\" title=\"重量级锁\"></a>重量级锁</h3><p>重量级锁通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。</p>\n<p><strong>总结</strong> : JDk中采用轻量级锁和偏向锁等对Synchronized的优化，但是这两种锁也不是完全没缺点的，比如竞争比较激烈的时候，不但无法提升效率，反而会降低效率，因为多了一个锁升级的过程</p>\n<table>\n<thead>\n<tr>\n<th>锁</th>\n<th>优点</th>\n<th>缺点</th>\n<th>适用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>偏向锁</td>\n<td>加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。</td>\n<td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗。</td>\n<td>适用于只有一个线程访问同步块场景。</td>\n</tr>\n<tr>\n<td>轻量级锁</td>\n<td>竞争的线程不会阻塞，提高了程序的响应速度。</td>\n<td>如果始终得不到锁竞争的线程使用自旋会消耗CPU。</td>\n<td>追求响应时间。同步块执行速度非常快。</td>\n</tr>\n<tr>\n<td>重量级锁</td>\n<td>线程竞争不使用自旋，不会消耗CPU。</td>\n<td>线程阻塞，响应时间缓慢。</td>\n<td>追求吞吐量。同步块执行速度较长。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"锁消除\"><a href=\"#锁消除\" class=\"headerlink\" title=\"锁消除\"></a>锁消除</h3><p>消除锁是虚拟机另外一种锁的优化，这种优化更彻底，Java虚拟机在JIT编译时(可以简单理解为当某段代码即将第一次被执行时进行编译，又称即时编译)，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间，如下StringBuffer的append是一个同步方法，但是在add方法中的StringBuffer属于一个局部变量，并且不会被其他线程所使用，因此StringBuffer不可能存在共享资源竞争的情景，JVM会自动将其锁消除。</p>"},{"title":"Docker学习","author":"James","date":"2017-03-20T08:10:00.000Z","_content":"# Docker是什么\nDocker 是 Docker 公司的开源项目，使用 Google 公司推出的 Go 语言开发的,并于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 GitHub 上进行维护。\n\nDocker是一个虚拟环境容器，可以将你的开发环境、代码、配置文件等一并打包到这个容器中，并发布和应用到任意平台中。比如，你在本地用Python开发网站后台，开发测试完成后，就可以将Python3及其依赖包、Flask及其各种插件、Mysql、Nginx等打包到一个容器中，然后部署到任意你想部署到的环境。\n\n<!-- more -->\n\n![HashMap_base](/images/docker/docker_struct.png)\n\n# 为什么使用 Docker\n\nDocker 跟传统的虚拟化方式相比具有以下优势:\n\n## 更高效的利用系统资源\n\n由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。\n\n## 更快速的启动时间\n\n传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。\n\n## 一致的运行环境\n\n开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 “这段代码在我机器上没问题啊” 这类问题。\n\n## 持续交付和部署\n\n对开发和运维人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。\n\n使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 Dockerfile 来进行镜像构建，并结合 持续集成系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合持续部署系统进行自动部署。\n\n而且使用 Dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。\n\n## 更轻松的迁移\n\n由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。\n\n## 更轻松的维护和扩展\n\nDocker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。\n\n# 三个重要概念\n\n1. **镜像（Image）**：类似于虚拟机中的镜像，是一个包含有文件系统的面向Docker引擎的只读模板。任何应用程序运行都需要环境，而镜像就是用来提供这种运行环境的。例如一个Ubuntu镜像就是一个包含Ubuntu操作系统环境的模板，同理在该镜像上装上Apache软件，就可以称为Apache镜像。\n2. **容器（Container）**：类似于一个轻量级的沙盒，可以将其看作一个极简的Linux系统环境（包括root权限、进程空间、用户空间和网络空间等），以及运行在其中的应用程序。Docker引擎利用容器来运行、隔离各个应用。容器是镜像创建的应用实例，可以创建、启动、停止、删除容器，各个容器之间是是相互隔离的，互不影响。注意：镜像本身是只读的，容器从镜像启动时，Docker在镜像的上层创建一个可写层，镜像本身不变。\n3. **仓库（Repository）**：类似于代码仓库，这里是镜像仓库，是Docker用来集中存放镜像文件的地方。注意与注册服务器（Registry）的区别：注册服务器是存放仓库的地方，一般会有多个仓库；而仓库是存放镜像的地方，一般每个仓库存放一类镜像，每个镜像利用tag进行区分，比如Ubuntu仓库存放有多个版本（12.04、14.04等）的Ubuntu镜像。\n\n\n## 安装\n\nDocker可以安装在Windows、Linux、Mac等各个平台上。具体可以查看文档[Install Docker](https%3A//docs.docker.com/engine/installation/)。安装完成之后，可以查看Docker的版本信息：\n\n```bash\n[root@xxx ~]# docker  version\nClient:\n Version:       18.02.0-ce\n API version:   1.35 (downgraded from 1.36)\n Go version:    go1.9.4\n Git commit:    fc4de447b5\n Built: Mon Feb 12 19:03:38 2018\n OS/Arch:       windows/amd64\n Experimental:  false\n Orchestrator:  swarm\n\nServer:\n Engine:\n  Version:      17.12.1-ce\n  API version:  1.35 (minimum version 1.12)\n  Go version:   go1.9.4\n  Git commit:   7390fc6\n  Built:        Tue Feb 27 22:20:43 2018\n  OS/Arch:      linux/amd64\n  Experimental: false\n```\n\n## 镜像\n\n安装完Docker引擎之后，就可以对镜像进行基本的操作了。\n\n我们从官方注册服务器（[https://hub.docker.com](https://link.zhihu.com/?target=https%3A//hub.docker.com)）的仓库中pull下CentOS的镜像，前边说过，每个仓库会有多个镜像，用tag标示，如果不加tag，默认使用latest镜像：\n\n```bash\n[root@xxx ~]# docker search centos    # 查看centos镜像是否存在\n[root@xxx ~]# docker pull centos    # 利用pull命令获取镜像\nUsing default tag: latest\nlatest: Pulling from library/centos\n08d48e6f1cff: Pull complete\nDigest: sha256:b2f9d1c0ff5f87a4743104d099a3d561002ac500db1b9bfa02a783a46e0d366c\nStatus: Downloaded newer image for centos:latest\n\n[root@xxx ~]# docker images    # 查看当前系统中的images信息\nREPOSITORY      TAG            IMAGE ID       CREATED        SIZE\ncentos          latest         0584b3d2cf6d   9 days ago     196.5 MB\n```\n\n### 创建自定义镜像\n\n#### commit的方式\n\n1.启动一个容器后进行修改 ==> 利用commit提交更新后的副本\n\n```bash\n[root@xxx ~]# docker run -it centos:latest /bin/bash    # 启动一个容器\n[root@72f1a8a0e394 /]#    # 这里命令行形式变了，表示已经进入了一个新环境\n[root@72f1a8a0e394 /]# git --version    # 此时的容器中没有git\nbash: git: command not found\n[root@72f1a8a0e394 /]# yum install git    # 利用yum安装git\n......\n[root@72f1a8a0e394 /]# git --version   # 此时的容器中已经装有git了\ngit version 1.8.3.1\n```\n\n2.退出该容器，然后查看docker中运行的容器：\n\n```bash\n[root@xxx ~]# docker ps -a\nCONTAINER ID  IMAGE    COMMAND      CREATED   STATUS   PORTS    NAMES\n72f1a8a0e394  centos:latest \"/bin/bash\"  9 minutes ago   Exited (0) 3 minutes ago  \n```\n\n3.将容器转化为一个镜像，即执行commit操作(不推荐)\n\n```bash\n[root@xxx ~]# docker commit -m \"centos with git\" -a \"james\" 72f1a8a0e394 xianhu/centos:git\n\n[root@xxx ~]# docker images\nREPOSITORY       TAG    IMAGE ID         CREATED             SIZE\njames/centos    git    52166e4475ed     5 seconds ago       358.1 MB\ncentos           latest 0584b3d2cf6d     9 days ago          196.5 MB\n```\n\n`-m`指定说明信息；`-a`指定用户信息；72f1a8a0e394代表容器的id；james/centos:git指定目标镜像的用户名、仓库名和 tag 信息。\n\n4.此时Docker引擎中就有了我们新建的镜像james/centos:git，此镜像和原有的CentOS镜像区别在于多了个Git工具。此时我们利用新镜像创建的容器，本身就自带git了。\n\n```bash\n[root@xxx ~]# docker run -it james/centos:git /bin/bash\n[root@520afc596c51 /]# git --version\ngit version 1.8.3.1\n```\n\n#### Dockerfile方式\n\nDockerfile可以理解为一种配置文件，用来告诉docker build命令应该执行哪些操作。一个简易的Dockerfile文件如下所示，官方说明：[Dockerfile reference](https%3A//docs.docker.com/engine/reference/builder/)：\n\n```ini\n# 说明该镜像以哪个镜像为基础\nFROM centos:latest\n\n# 构建者的基本信息\nMAINTAINER james\n\n# 在build这个镜像时执行的操作\nRUN yum update\nRUN yum install -y git\n\n# 拷贝本地文件到镜像中\nCOPY ./* /usr/share/gitdir/\n```\n\n用build命令构建镜像了：\n\n```bash\n$ docker build -t nginx:v3 .\ndocker build [选项] <上下文路径/URL/->\n```\n\n## 容器\n\n镜像和容器的关系，就像是面向对象程序设计中的`类`和`实例`一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。\n\n每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为**容器存储层**。\n\n容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。\n\n按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 [数据卷（Volume）](https://docs.docker.com/engine/tutorials/dockervolumes/)、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主(或网络存储)发生读写，其性能和稳定性更高。\n\n数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器可以随意删除、重新 `run`，数据却不会丢失。\n\n### 启动\n\n启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（stopped）的容器重新启动。\n\n命令主要为 `docker run`。\n\n### 查看\n\n利用 `docker ps -a` 命令可以查看所有容器   \n\n### 终止\n\n可以使用 `docker stop` 命令和上面使用的 `docker ps -a` 查看到的 `CONTAINER ID`或 `NAMES`，来终止一个运行中的容器。\n\n### 删除\n\n可以使用 `docker rm` 来删除一个处于终止状态的容器。\n\n## 仓库\n\n仓库（`Repository`）是集中存放镜像的地方，镜像构建完成后，可以很容易的在当前宿主上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，[Docker Registry](https://docs.docker.com/registry/) 就是这样的服务。\n\n一个容易混淆的概念是注册服务器（`Registry`）。实际上注册服务器是管理仓库的具体服务器，每个服务器上可以有多个仓库，而每个仓库下面有多个镜像。从这方面来说，仓库可以被认为是一个具体的项目或目录。例如对于仓库地址 `dl.dockerpool.com/ubuntu` 来说，`dl.dockerpool.com` 是注册服务器地址，`ubuntu` 是仓库名。","source":"_posts/Docker.md","raw":"title: Docker学习\nauthor: James\ntags:\n  - docker\ncategories:\n  - 实战\ndate: 2017-03-20 16:10:00\n---\n# Docker是什么\nDocker 是 Docker 公司的开源项目，使用 Google 公司推出的 Go 语言开发的,并于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 GitHub 上进行维护。\n\nDocker是一个虚拟环境容器，可以将你的开发环境、代码、配置文件等一并打包到这个容器中，并发布和应用到任意平台中。比如，你在本地用Python开发网站后台，开发测试完成后，就可以将Python3及其依赖包、Flask及其各种插件、Mysql、Nginx等打包到一个容器中，然后部署到任意你想部署到的环境。\n\n<!-- more -->\n\n![HashMap_base](/images/docker/docker_struct.png)\n\n# 为什么使用 Docker\n\nDocker 跟传统的虚拟化方式相比具有以下优势:\n\n## 更高效的利用系统资源\n\n由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。\n\n## 更快速的启动时间\n\n传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。\n\n## 一致的运行环境\n\n开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 “这段代码在我机器上没问题啊” 这类问题。\n\n## 持续交付和部署\n\n对开发和运维人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。\n\n使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 Dockerfile 来进行镜像构建，并结合 持续集成系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合持续部署系统进行自动部署。\n\n而且使用 Dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。\n\n## 更轻松的迁移\n\n由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。\n\n## 更轻松的维护和扩展\n\nDocker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。\n\n# 三个重要概念\n\n1. **镜像（Image）**：类似于虚拟机中的镜像，是一个包含有文件系统的面向Docker引擎的只读模板。任何应用程序运行都需要环境，而镜像就是用来提供这种运行环境的。例如一个Ubuntu镜像就是一个包含Ubuntu操作系统环境的模板，同理在该镜像上装上Apache软件，就可以称为Apache镜像。\n2. **容器（Container）**：类似于一个轻量级的沙盒，可以将其看作一个极简的Linux系统环境（包括root权限、进程空间、用户空间和网络空间等），以及运行在其中的应用程序。Docker引擎利用容器来运行、隔离各个应用。容器是镜像创建的应用实例，可以创建、启动、停止、删除容器，各个容器之间是是相互隔离的，互不影响。注意：镜像本身是只读的，容器从镜像启动时，Docker在镜像的上层创建一个可写层，镜像本身不变。\n3. **仓库（Repository）**：类似于代码仓库，这里是镜像仓库，是Docker用来集中存放镜像文件的地方。注意与注册服务器（Registry）的区别：注册服务器是存放仓库的地方，一般会有多个仓库；而仓库是存放镜像的地方，一般每个仓库存放一类镜像，每个镜像利用tag进行区分，比如Ubuntu仓库存放有多个版本（12.04、14.04等）的Ubuntu镜像。\n\n\n## 安装\n\nDocker可以安装在Windows、Linux、Mac等各个平台上。具体可以查看文档[Install Docker](https%3A//docs.docker.com/engine/installation/)。安装完成之后，可以查看Docker的版本信息：\n\n```bash\n[root@xxx ~]# docker  version\nClient:\n Version:       18.02.0-ce\n API version:   1.35 (downgraded from 1.36)\n Go version:    go1.9.4\n Git commit:    fc4de447b5\n Built: Mon Feb 12 19:03:38 2018\n OS/Arch:       windows/amd64\n Experimental:  false\n Orchestrator:  swarm\n\nServer:\n Engine:\n  Version:      17.12.1-ce\n  API version:  1.35 (minimum version 1.12)\n  Go version:   go1.9.4\n  Git commit:   7390fc6\n  Built:        Tue Feb 27 22:20:43 2018\n  OS/Arch:      linux/amd64\n  Experimental: false\n```\n\n## 镜像\n\n安装完Docker引擎之后，就可以对镜像进行基本的操作了。\n\n我们从官方注册服务器（[https://hub.docker.com](https://link.zhihu.com/?target=https%3A//hub.docker.com)）的仓库中pull下CentOS的镜像，前边说过，每个仓库会有多个镜像，用tag标示，如果不加tag，默认使用latest镜像：\n\n```bash\n[root@xxx ~]# docker search centos    # 查看centos镜像是否存在\n[root@xxx ~]# docker pull centos    # 利用pull命令获取镜像\nUsing default tag: latest\nlatest: Pulling from library/centos\n08d48e6f1cff: Pull complete\nDigest: sha256:b2f9d1c0ff5f87a4743104d099a3d561002ac500db1b9bfa02a783a46e0d366c\nStatus: Downloaded newer image for centos:latest\n\n[root@xxx ~]# docker images    # 查看当前系统中的images信息\nREPOSITORY      TAG            IMAGE ID       CREATED        SIZE\ncentos          latest         0584b3d2cf6d   9 days ago     196.5 MB\n```\n\n### 创建自定义镜像\n\n#### commit的方式\n\n1.启动一个容器后进行修改 ==> 利用commit提交更新后的副本\n\n```bash\n[root@xxx ~]# docker run -it centos:latest /bin/bash    # 启动一个容器\n[root@72f1a8a0e394 /]#    # 这里命令行形式变了，表示已经进入了一个新环境\n[root@72f1a8a0e394 /]# git --version    # 此时的容器中没有git\nbash: git: command not found\n[root@72f1a8a0e394 /]# yum install git    # 利用yum安装git\n......\n[root@72f1a8a0e394 /]# git --version   # 此时的容器中已经装有git了\ngit version 1.8.3.1\n```\n\n2.退出该容器，然后查看docker中运行的容器：\n\n```bash\n[root@xxx ~]# docker ps -a\nCONTAINER ID  IMAGE    COMMAND      CREATED   STATUS   PORTS    NAMES\n72f1a8a0e394  centos:latest \"/bin/bash\"  9 minutes ago   Exited (0) 3 minutes ago  \n```\n\n3.将容器转化为一个镜像，即执行commit操作(不推荐)\n\n```bash\n[root@xxx ~]# docker commit -m \"centos with git\" -a \"james\" 72f1a8a0e394 xianhu/centos:git\n\n[root@xxx ~]# docker images\nREPOSITORY       TAG    IMAGE ID         CREATED             SIZE\njames/centos    git    52166e4475ed     5 seconds ago       358.1 MB\ncentos           latest 0584b3d2cf6d     9 days ago          196.5 MB\n```\n\n`-m`指定说明信息；`-a`指定用户信息；72f1a8a0e394代表容器的id；james/centos:git指定目标镜像的用户名、仓库名和 tag 信息。\n\n4.此时Docker引擎中就有了我们新建的镜像james/centos:git，此镜像和原有的CentOS镜像区别在于多了个Git工具。此时我们利用新镜像创建的容器，本身就自带git了。\n\n```bash\n[root@xxx ~]# docker run -it james/centos:git /bin/bash\n[root@520afc596c51 /]# git --version\ngit version 1.8.3.1\n```\n\n#### Dockerfile方式\n\nDockerfile可以理解为一种配置文件，用来告诉docker build命令应该执行哪些操作。一个简易的Dockerfile文件如下所示，官方说明：[Dockerfile reference](https%3A//docs.docker.com/engine/reference/builder/)：\n\n```ini\n# 说明该镜像以哪个镜像为基础\nFROM centos:latest\n\n# 构建者的基本信息\nMAINTAINER james\n\n# 在build这个镜像时执行的操作\nRUN yum update\nRUN yum install -y git\n\n# 拷贝本地文件到镜像中\nCOPY ./* /usr/share/gitdir/\n```\n\n用build命令构建镜像了：\n\n```bash\n$ docker build -t nginx:v3 .\ndocker build [选项] <上下文路径/URL/->\n```\n\n## 容器\n\n镜像和容器的关系，就像是面向对象程序设计中的`类`和`实例`一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。\n\n每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为**容器存储层**。\n\n容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。\n\n按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 [数据卷（Volume）](https://docs.docker.com/engine/tutorials/dockervolumes/)、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主(或网络存储)发生读写，其性能和稳定性更高。\n\n数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器可以随意删除、重新 `run`，数据却不会丢失。\n\n### 启动\n\n启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（stopped）的容器重新启动。\n\n命令主要为 `docker run`。\n\n### 查看\n\n利用 `docker ps -a` 命令可以查看所有容器   \n\n### 终止\n\n可以使用 `docker stop` 命令和上面使用的 `docker ps -a` 查看到的 `CONTAINER ID`或 `NAMES`，来终止一个运行中的容器。\n\n### 删除\n\n可以使用 `docker rm` 来删除一个处于终止状态的容器。\n\n## 仓库\n\n仓库（`Repository`）是集中存放镜像的地方，镜像构建完成后，可以很容易的在当前宿主上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，[Docker Registry](https://docs.docker.com/registry/) 就是这样的服务。\n\n一个容易混淆的概念是注册服务器（`Registry`）。实际上注册服务器是管理仓库的具体服务器，每个服务器上可以有多个仓库，而每个仓库下面有多个镜像。从这方面来说，仓库可以被认为是一个具体的项目或目录。例如对于仓库地址 `dl.dockerpool.com/ubuntu` 来说，`dl.dockerpool.com` 是注册服务器地址，`ubuntu` 是仓库名。","slug":"Docker","published":1,"updated":"2018-03-22T07:13:16.585Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf26kpq40000mokcup8o4tke","content":"<h1 id=\"Docker是什么\"><a href=\"#Docker是什么\" class=\"headerlink\" title=\"Docker是什么\"></a>Docker是什么</h1><p>Docker 是 Docker 公司的开源项目，使用 Google 公司推出的 Go 语言开发的,并于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 GitHub 上进行维护。</p>\n<p>Docker是一个虚拟环境容器，可以将你的开发环境、代码、配置文件等一并打包到这个容器中，并发布和应用到任意平台中。比如，你在本地用Python开发网站后台，开发测试完成后，就可以将Python3及其依赖包、Flask及其各种插件、Mysql、Nginx等打包到一个容器中，然后部署到任意你想部署到的环境。</p>\n<a id=\"more\"></a>\n<p><img src=\"/images/docker/docker_struct.png\" alt=\"HashMap_base\"></p>\n<h1 id=\"为什么使用-Docker\"><a href=\"#为什么使用-Docker\" class=\"headerlink\" title=\"为什么使用 Docker\"></a>为什么使用 Docker</h1><p>Docker 跟传统的虚拟化方式相比具有以下优势:</p>\n<h2 id=\"更高效的利用系统资源\"><a href=\"#更高效的利用系统资源\" class=\"headerlink\" title=\"更高效的利用系统资源\"></a>更高效的利用系统资源</h2><p>由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。</p>\n<h2 id=\"更快速的启动时间\"><a href=\"#更快速的启动时间\" class=\"headerlink\" title=\"更快速的启动时间\"></a>更快速的启动时间</h2><p>传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。</p>\n<h2 id=\"一致的运行环境\"><a href=\"#一致的运行环境\" class=\"headerlink\" title=\"一致的运行环境\"></a>一致的运行环境</h2><p>开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 “这段代码在我机器上没问题啊” 这类问题。</p>\n<h2 id=\"持续交付和部署\"><a href=\"#持续交付和部署\" class=\"headerlink\" title=\"持续交付和部署\"></a>持续交付和部署</h2><p>对开发和运维人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。</p>\n<p>使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 Dockerfile 来进行镜像构建，并结合 持续集成系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合持续部署系统进行自动部署。</p>\n<p>而且使用 Dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。</p>\n<h2 id=\"更轻松的迁移\"><a href=\"#更轻松的迁移\" class=\"headerlink\" title=\"更轻松的迁移\"></a>更轻松的迁移</h2><p>由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</p>\n<h2 id=\"更轻松的维护和扩展\"><a href=\"#更轻松的维护和扩展\" class=\"headerlink\" title=\"更轻松的维护和扩展\"></a>更轻松的维护和扩展</h2><p>Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。</p>\n<h1 id=\"三个重要概念\"><a href=\"#三个重要概念\" class=\"headerlink\" title=\"三个重要概念\"></a>三个重要概念</h1><ol>\n<li><strong>镜像（Image）</strong>：类似于虚拟机中的镜像，是一个包含有文件系统的面向Docker引擎的只读模板。任何应用程序运行都需要环境，而镜像就是用来提供这种运行环境的。例如一个Ubuntu镜像就是一个包含Ubuntu操作系统环境的模板，同理在该镜像上装上Apache软件，就可以称为Apache镜像。</li>\n<li><strong>容器（Container）</strong>：类似于一个轻量级的沙盒，可以将其看作一个极简的Linux系统环境（包括root权限、进程空间、用户空间和网络空间等），以及运行在其中的应用程序。Docker引擎利用容器来运行、隔离各个应用。容器是镜像创建的应用实例，可以创建、启动、停止、删除容器，各个容器之间是是相互隔离的，互不影响。注意：镜像本身是只读的，容器从镜像启动时，Docker在镜像的上层创建一个可写层，镜像本身不变。</li>\n<li><strong>仓库（Repository）</strong>：类似于代码仓库，这里是镜像仓库，是Docker用来集中存放镜像文件的地方。注意与注册服务器（Registry）的区别：注册服务器是存放仓库的地方，一般会有多个仓库；而仓库是存放镜像的地方，一般每个仓库存放一类镜像，每个镜像利用tag进行区分，比如Ubuntu仓库存放有多个版本（12.04、14.04等）的Ubuntu镜像。</li>\n</ol>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>Docker可以安装在Windows、Linux、Mac等各个平台上。具体可以查看文档<a href=\"https%3A//docs.docker.com/engine/installation/\">Install Docker</a>。安装完成之后，可以查看Docker的版本信息：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@xxx ~]<span class=\"comment\"># docker  version</span></span><br><span class=\"line\">Client:</span><br><span class=\"line\"> Version:       18.02.0-ce</span><br><span class=\"line\"> API version:   1.35 (downgraded from 1.36)</span><br><span class=\"line\"> Go version:    go1.9.4</span><br><span class=\"line\"> Git commit:    fc4de447b5</span><br><span class=\"line\"> Built: Mon Feb 12 19:03:38 2018</span><br><span class=\"line\"> OS/Arch:       windows/amd64</span><br><span class=\"line\"> Experimental:  <span class=\"literal\">false</span></span><br><span class=\"line\"> Orchestrator:  swarm</span><br><span class=\"line\"></span><br><span class=\"line\">Server:</span><br><span class=\"line\"> Engine:</span><br><span class=\"line\">  Version:      17.12.1-ce</span><br><span class=\"line\">  API version:  1.35 (minimum version 1.12)</span><br><span class=\"line\">  Go version:   go1.9.4</span><br><span class=\"line\">  Git commit:   7390fc6</span><br><span class=\"line\">  Built:        Tue Feb 27 22:20:43 2018</span><br><span class=\"line\">  OS/Arch:      linux/amd64</span><br><span class=\"line\">  Experimental: <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"镜像\"><a href=\"#镜像\" class=\"headerlink\" title=\"镜像\"></a>镜像</h2><p>安装完Docker引擎之后，就可以对镜像进行基本的操作了。</p>\n<p>我们从官方注册服务器（<a href=\"https://link.zhihu.com/?target=https%3A//hub.docker.com\" target=\"_blank\" rel=\"noopener\">https://hub.docker.com</a>）的仓库中pull下CentOS的镜像，前边说过，每个仓库会有多个镜像，用tag标示，如果不加tag，默认使用latest镜像：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@xxx ~]<span class=\"comment\"># docker search centos    # 查看centos镜像是否存在</span></span><br><span class=\"line\">[root@xxx ~]<span class=\"comment\"># docker pull centos    # 利用pull命令获取镜像</span></span><br><span class=\"line\">Using default tag: latest</span><br><span class=\"line\">latest: Pulling from library/centos</span><br><span class=\"line\">08d48e6f1cff: Pull complete</span><br><span class=\"line\">Digest: sha256:b2f9d1c0ff5f87a4743104d099a3d561002ac500db1b9bfa02a783a46e0d366c</span><br><span class=\"line\">Status: Downloaded newer image <span class=\"keyword\">for</span> centos:latest</span><br><span class=\"line\"></span><br><span class=\"line\">[root@xxx ~]<span class=\"comment\"># docker images    # 查看当前系统中的images信息</span></span><br><span class=\"line\">REPOSITORY      TAG            IMAGE ID       CREATED        SIZE</span><br><span class=\"line\">centos          latest         0584b3d2cf6d   9 days ago     196.5 MB</span><br></pre></td></tr></table></figure>\n<h3 id=\"创建自定义镜像\"><a href=\"#创建自定义镜像\" class=\"headerlink\" title=\"创建自定义镜像\"></a>创建自定义镜像</h3><h4 id=\"commit的方式\"><a href=\"#commit的方式\" class=\"headerlink\" title=\"commit的方式\"></a>commit的方式</h4><p>1.启动一个容器后进行修改 ==&gt; 利用commit提交更新后的副本</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@xxx ~]<span class=\"comment\"># docker run -it centos:latest /bin/bash    # 启动一个容器</span></span><br><span class=\"line\">[root@72f1a8a0e394 /]<span class=\"comment\">#    # 这里命令行形式变了，表示已经进入了一个新环境</span></span><br><span class=\"line\">[root@72f1a8a0e394 /]<span class=\"comment\"># git --version    # 此时的容器中没有git</span></span><br><span class=\"line\">bash: git: <span class=\"built_in\">command</span> not found</span><br><span class=\"line\">[root@72f1a8a0e394 /]<span class=\"comment\"># yum install git    # 利用yum安装git</span></span><br><span class=\"line\">......</span><br><span class=\"line\">[root@72f1a8a0e394 /]<span class=\"comment\"># git --version   # 此时的容器中已经装有git了</span></span><br><span class=\"line\">git version 1.8.3.1</span><br></pre></td></tr></table></figure>\n<p>2.退出该容器，然后查看docker中运行的容器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@xxx ~]<span class=\"comment\"># docker ps -a</span></span><br><span class=\"line\">CONTAINER ID  IMAGE    COMMAND      CREATED   STATUS   PORTS    NAMES</span><br><span class=\"line\">72f1a8a0e394  centos:latest <span class=\"string\">\"/bin/bash\"</span>  9 minutes ago   Exited (0) 3 minutes ago</span><br></pre></td></tr></table></figure>\n<p>3.将容器转化为一个镜像，即执行commit操作(不推荐)</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@xxx ~]<span class=\"comment\"># docker commit -m \"centos with git\" -a \"james\" 72f1a8a0e394 xianhu/centos:git</span></span><br><span class=\"line\"></span><br><span class=\"line\">[root@xxx ~]<span class=\"comment\"># docker images</span></span><br><span class=\"line\">REPOSITORY       TAG    IMAGE ID         CREATED             SIZE</span><br><span class=\"line\">james/centos    git    52166e4475ed     5 seconds ago       358.1 MB</span><br><span class=\"line\">centos           latest 0584b3d2cf6d     9 days ago          196.5 MB</span><br></pre></td></tr></table></figure>\n<p><code>-m</code>指定说明信息；<code>-a</code>指定用户信息；72f1a8a0e394代表容器的id；james/centos:git指定目标镜像的用户名、仓库名和 tag 信息。</p>\n<p>4.此时Docker引擎中就有了我们新建的镜像james/centos:git，此镜像和原有的CentOS镜像区别在于多了个Git工具。此时我们利用新镜像创建的容器，本身就自带git了。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@xxx ~]<span class=\"comment\"># docker run -it james/centos:git /bin/bash</span></span><br><span class=\"line\">[root@520afc596c51 /]<span class=\"comment\"># git --version</span></span><br><span class=\"line\">git version 1.8.3.1</span><br></pre></td></tr></table></figure>\n<h4 id=\"Dockerfile方式\"><a href=\"#Dockerfile方式\" class=\"headerlink\" title=\"Dockerfile方式\"></a>Dockerfile方式</h4><p>Dockerfile可以理解为一种配置文件，用来告诉docker build命令应该执行哪些操作。一个简易的Dockerfile文件如下所示，官方说明：<a href=\"https%3A//docs.docker.com/engine/reference/builder/\">Dockerfile reference</a>：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 说明该镜像以哪个镜像为基础</span></span><br><span class=\"line\">FROM centos:latest</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 构建者的基本信息</span></span><br><span class=\"line\">MAINTAINER james</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在build这个镜像时执行的操作</span></span><br><span class=\"line\">RUN yum update</span><br><span class=\"line\">RUN yum install -y git</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 拷贝本地文件到镜像中</span></span><br><span class=\"line\">COPY ./* /usr/share/gitdir/</span><br></pre></td></tr></table></figure>\n<p>用build命令构建镜像了：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker build -t nginx:v3 .</span><br><span class=\"line\">docker build [选项] &lt;上下文路径/URL/-&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"容器\"><a href=\"#容器\" class=\"headerlink\" title=\"容器\"></a>容器</h2><p>镜像和容器的关系，就像是面向对象程序设计中的<code>类</code>和<code>实例</code>一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p>\n<p>每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为<strong>容器存储层</strong>。</p>\n<p>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p>\n<p>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 <a href=\"https://docs.docker.com/engine/tutorials/dockervolumes/\" target=\"_blank\" rel=\"noopener\">数据卷（Volume）</a>、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主(或网络存储)发生读写，其性能和稳定性更高。</p>\n<p>数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器可以随意删除、重新 <code>run</code>，数据却不会丢失。</p>\n<h3 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h3><p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（stopped）的容器重新启动。</p>\n<p>命令主要为 <code>docker run</code>。</p>\n<h3 id=\"查看\"><a href=\"#查看\" class=\"headerlink\" title=\"查看\"></a>查看</h3><p>利用 <code>docker ps -a</code> 命令可以查看所有容器   </p>\n<h3 id=\"终止\"><a href=\"#终止\" class=\"headerlink\" title=\"终止\"></a>终止</h3><p>可以使用 <code>docker stop</code> 命令和上面使用的 <code>docker ps -a</code> 查看到的 <code>CONTAINER ID</code>或 <code>NAMES</code>，来终止一个运行中的容器。</p>\n<h3 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h3><p>可以使用 <code>docker rm</code> 来删除一个处于终止状态的容器。</p>\n<h2 id=\"仓库\"><a href=\"#仓库\" class=\"headerlink\" title=\"仓库\"></a>仓库</h2><p>仓库（<code>Repository</code>）是集中存放镜像的地方，镜像构建完成后，可以很容易的在当前宿主上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，<a href=\"https://docs.docker.com/registry/\" target=\"_blank\" rel=\"noopener\">Docker Registry</a> 就是这样的服务。</p>\n<p>一个容易混淆的概念是注册服务器（<code>Registry</code>）。实际上注册服务器是管理仓库的具体服务器，每个服务器上可以有多个仓库，而每个仓库下面有多个镜像。从这方面来说，仓库可以被认为是一个具体的项目或目录。例如对于仓库地址 <code>dl.dockerpool.com/ubuntu</code> 来说，<code>dl.dockerpool.com</code> 是注册服务器地址，<code>ubuntu</code> 是仓库名。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Docker是什么\"><a href=\"#Docker是什么\" class=\"headerlink\" title=\"Docker是什么\"></a>Docker是什么</h1><p>Docker 是 Docker 公司的开源项目，使用 Google 公司推出的 Go 语言开发的,并于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 GitHub 上进行维护。</p>\n<p>Docker是一个虚拟环境容器，可以将你的开发环境、代码、配置文件等一并打包到这个容器中，并发布和应用到任意平台中。比如，你在本地用Python开发网站后台，开发测试完成后，就可以将Python3及其依赖包、Flask及其各种插件、Mysql、Nginx等打包到一个容器中，然后部署到任意你想部署到的环境。</p>","more":"<p><img src=\"/images/docker/docker_struct.png\" alt=\"HashMap_base\"></p>\n<h1 id=\"为什么使用-Docker\"><a href=\"#为什么使用-Docker\" class=\"headerlink\" title=\"为什么使用 Docker\"></a>为什么使用 Docker</h1><p>Docker 跟传统的虚拟化方式相比具有以下优势:</p>\n<h2 id=\"更高效的利用系统资源\"><a href=\"#更高效的利用系统资源\" class=\"headerlink\" title=\"更高效的利用系统资源\"></a>更高效的利用系统资源</h2><p>由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。</p>\n<h2 id=\"更快速的启动时间\"><a href=\"#更快速的启动时间\" class=\"headerlink\" title=\"更快速的启动时间\"></a>更快速的启动时间</h2><p>传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。</p>\n<h2 id=\"一致的运行环境\"><a href=\"#一致的运行环境\" class=\"headerlink\" title=\"一致的运行环境\"></a>一致的运行环境</h2><p>开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 “这段代码在我机器上没问题啊” 这类问题。</p>\n<h2 id=\"持续交付和部署\"><a href=\"#持续交付和部署\" class=\"headerlink\" title=\"持续交付和部署\"></a>持续交付和部署</h2><p>对开发和运维人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。</p>\n<p>使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 Dockerfile 来进行镜像构建，并结合 持续集成系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合持续部署系统进行自动部署。</p>\n<p>而且使用 Dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。</p>\n<h2 id=\"更轻松的迁移\"><a href=\"#更轻松的迁移\" class=\"headerlink\" title=\"更轻松的迁移\"></a>更轻松的迁移</h2><p>由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</p>\n<h2 id=\"更轻松的维护和扩展\"><a href=\"#更轻松的维护和扩展\" class=\"headerlink\" title=\"更轻松的维护和扩展\"></a>更轻松的维护和扩展</h2><p>Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。</p>\n<h1 id=\"三个重要概念\"><a href=\"#三个重要概念\" class=\"headerlink\" title=\"三个重要概念\"></a>三个重要概念</h1><ol>\n<li><strong>镜像（Image）</strong>：类似于虚拟机中的镜像，是一个包含有文件系统的面向Docker引擎的只读模板。任何应用程序运行都需要环境，而镜像就是用来提供这种运行环境的。例如一个Ubuntu镜像就是一个包含Ubuntu操作系统环境的模板，同理在该镜像上装上Apache软件，就可以称为Apache镜像。</li>\n<li><strong>容器（Container）</strong>：类似于一个轻量级的沙盒，可以将其看作一个极简的Linux系统环境（包括root权限、进程空间、用户空间和网络空间等），以及运行在其中的应用程序。Docker引擎利用容器来运行、隔离各个应用。容器是镜像创建的应用实例，可以创建、启动、停止、删除容器，各个容器之间是是相互隔离的，互不影响。注意：镜像本身是只读的，容器从镜像启动时，Docker在镜像的上层创建一个可写层，镜像本身不变。</li>\n<li><strong>仓库（Repository）</strong>：类似于代码仓库，这里是镜像仓库，是Docker用来集中存放镜像文件的地方。注意与注册服务器（Registry）的区别：注册服务器是存放仓库的地方，一般会有多个仓库；而仓库是存放镜像的地方，一般每个仓库存放一类镜像，每个镜像利用tag进行区分，比如Ubuntu仓库存放有多个版本（12.04、14.04等）的Ubuntu镜像。</li>\n</ol>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>Docker可以安装在Windows、Linux、Mac等各个平台上。具体可以查看文档<a href=\"https%3A//docs.docker.com/engine/installation/\">Install Docker</a>。安装完成之后，可以查看Docker的版本信息：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@xxx ~]<span class=\"comment\"># docker  version</span></span><br><span class=\"line\">Client:</span><br><span class=\"line\"> Version:       18.02.0-ce</span><br><span class=\"line\"> API version:   1.35 (downgraded from 1.36)</span><br><span class=\"line\"> Go version:    go1.9.4</span><br><span class=\"line\"> Git commit:    fc4de447b5</span><br><span class=\"line\"> Built: Mon Feb 12 19:03:38 2018</span><br><span class=\"line\"> OS/Arch:       windows/amd64</span><br><span class=\"line\"> Experimental:  <span class=\"literal\">false</span></span><br><span class=\"line\"> Orchestrator:  swarm</span><br><span class=\"line\"></span><br><span class=\"line\">Server:</span><br><span class=\"line\"> Engine:</span><br><span class=\"line\">  Version:      17.12.1-ce</span><br><span class=\"line\">  API version:  1.35 (minimum version 1.12)</span><br><span class=\"line\">  Go version:   go1.9.4</span><br><span class=\"line\">  Git commit:   7390fc6</span><br><span class=\"line\">  Built:        Tue Feb 27 22:20:43 2018</span><br><span class=\"line\">  OS/Arch:      linux/amd64</span><br><span class=\"line\">  Experimental: <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"镜像\"><a href=\"#镜像\" class=\"headerlink\" title=\"镜像\"></a>镜像</h2><p>安装完Docker引擎之后，就可以对镜像进行基本的操作了。</p>\n<p>我们从官方注册服务器（<a href=\"https://link.zhihu.com/?target=https%3A//hub.docker.com\" target=\"_blank\" rel=\"noopener\">https://hub.docker.com</a>）的仓库中pull下CentOS的镜像，前边说过，每个仓库会有多个镜像，用tag标示，如果不加tag，默认使用latest镜像：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@xxx ~]<span class=\"comment\"># docker search centos    # 查看centos镜像是否存在</span></span><br><span class=\"line\">[root@xxx ~]<span class=\"comment\"># docker pull centos    # 利用pull命令获取镜像</span></span><br><span class=\"line\">Using default tag: latest</span><br><span class=\"line\">latest: Pulling from library/centos</span><br><span class=\"line\">08d48e6f1cff: Pull complete</span><br><span class=\"line\">Digest: sha256:b2f9d1c0ff5f87a4743104d099a3d561002ac500db1b9bfa02a783a46e0d366c</span><br><span class=\"line\">Status: Downloaded newer image <span class=\"keyword\">for</span> centos:latest</span><br><span class=\"line\"></span><br><span class=\"line\">[root@xxx ~]<span class=\"comment\"># docker images    # 查看当前系统中的images信息</span></span><br><span class=\"line\">REPOSITORY      TAG            IMAGE ID       CREATED        SIZE</span><br><span class=\"line\">centos          latest         0584b3d2cf6d   9 days ago     196.5 MB</span><br></pre></td></tr></table></figure>\n<h3 id=\"创建自定义镜像\"><a href=\"#创建自定义镜像\" class=\"headerlink\" title=\"创建自定义镜像\"></a>创建自定义镜像</h3><h4 id=\"commit的方式\"><a href=\"#commit的方式\" class=\"headerlink\" title=\"commit的方式\"></a>commit的方式</h4><p>1.启动一个容器后进行修改 ==&gt; 利用commit提交更新后的副本</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@xxx ~]<span class=\"comment\"># docker run -it centos:latest /bin/bash    # 启动一个容器</span></span><br><span class=\"line\">[root@72f1a8a0e394 /]<span class=\"comment\">#    # 这里命令行形式变了，表示已经进入了一个新环境</span></span><br><span class=\"line\">[root@72f1a8a0e394 /]<span class=\"comment\"># git --version    # 此时的容器中没有git</span></span><br><span class=\"line\">bash: git: <span class=\"built_in\">command</span> not found</span><br><span class=\"line\">[root@72f1a8a0e394 /]<span class=\"comment\"># yum install git    # 利用yum安装git</span></span><br><span class=\"line\">......</span><br><span class=\"line\">[root@72f1a8a0e394 /]<span class=\"comment\"># git --version   # 此时的容器中已经装有git了</span></span><br><span class=\"line\">git version 1.8.3.1</span><br></pre></td></tr></table></figure>\n<p>2.退出该容器，然后查看docker中运行的容器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@xxx ~]<span class=\"comment\"># docker ps -a</span></span><br><span class=\"line\">CONTAINER ID  IMAGE    COMMAND      CREATED   STATUS   PORTS    NAMES</span><br><span class=\"line\">72f1a8a0e394  centos:latest <span class=\"string\">\"/bin/bash\"</span>  9 minutes ago   Exited (0) 3 minutes ago</span><br></pre></td></tr></table></figure>\n<p>3.将容器转化为一个镜像，即执行commit操作(不推荐)</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@xxx ~]<span class=\"comment\"># docker commit -m \"centos with git\" -a \"james\" 72f1a8a0e394 xianhu/centos:git</span></span><br><span class=\"line\"></span><br><span class=\"line\">[root@xxx ~]<span class=\"comment\"># docker images</span></span><br><span class=\"line\">REPOSITORY       TAG    IMAGE ID         CREATED             SIZE</span><br><span class=\"line\">james/centos    git    52166e4475ed     5 seconds ago       358.1 MB</span><br><span class=\"line\">centos           latest 0584b3d2cf6d     9 days ago          196.5 MB</span><br></pre></td></tr></table></figure>\n<p><code>-m</code>指定说明信息；<code>-a</code>指定用户信息；72f1a8a0e394代表容器的id；james/centos:git指定目标镜像的用户名、仓库名和 tag 信息。</p>\n<p>4.此时Docker引擎中就有了我们新建的镜像james/centos:git，此镜像和原有的CentOS镜像区别在于多了个Git工具。此时我们利用新镜像创建的容器，本身就自带git了。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@xxx ~]<span class=\"comment\"># docker run -it james/centos:git /bin/bash</span></span><br><span class=\"line\">[root@520afc596c51 /]<span class=\"comment\"># git --version</span></span><br><span class=\"line\">git version 1.8.3.1</span><br></pre></td></tr></table></figure>\n<h4 id=\"Dockerfile方式\"><a href=\"#Dockerfile方式\" class=\"headerlink\" title=\"Dockerfile方式\"></a>Dockerfile方式</h4><p>Dockerfile可以理解为一种配置文件，用来告诉docker build命令应该执行哪些操作。一个简易的Dockerfile文件如下所示，官方说明：<a href=\"https%3A//docs.docker.com/engine/reference/builder/\">Dockerfile reference</a>：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 说明该镜像以哪个镜像为基础</span></span><br><span class=\"line\">FROM centos:latest</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 构建者的基本信息</span></span><br><span class=\"line\">MAINTAINER james</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在build这个镜像时执行的操作</span></span><br><span class=\"line\">RUN yum update</span><br><span class=\"line\">RUN yum install -y git</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 拷贝本地文件到镜像中</span></span><br><span class=\"line\">COPY ./* /usr/share/gitdir/</span><br></pre></td></tr></table></figure>\n<p>用build命令构建镜像了：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker build -t nginx:v3 .</span><br><span class=\"line\">docker build [选项] &lt;上下文路径/URL/-&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"容器\"><a href=\"#容器\" class=\"headerlink\" title=\"容器\"></a>容器</h2><p>镜像和容器的关系，就像是面向对象程序设计中的<code>类</code>和<code>实例</code>一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p>\n<p>每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为<strong>容器存储层</strong>。</p>\n<p>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p>\n<p>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 <a href=\"https://docs.docker.com/engine/tutorials/dockervolumes/\" target=\"_blank\" rel=\"noopener\">数据卷（Volume）</a>、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主(或网络存储)发生读写，其性能和稳定性更高。</p>\n<p>数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器可以随意删除、重新 <code>run</code>，数据却不会丢失。</p>\n<h3 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h3><p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（stopped）的容器重新启动。</p>\n<p>命令主要为 <code>docker run</code>。</p>\n<h3 id=\"查看\"><a href=\"#查看\" class=\"headerlink\" title=\"查看\"></a>查看</h3><p>利用 <code>docker ps -a</code> 命令可以查看所有容器   </p>\n<h3 id=\"终止\"><a href=\"#终止\" class=\"headerlink\" title=\"终止\"></a>终止</h3><p>可以使用 <code>docker stop</code> 命令和上面使用的 <code>docker ps -a</code> 查看到的 <code>CONTAINER ID</code>或 <code>NAMES</code>，来终止一个运行中的容器。</p>\n<h3 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h3><p>可以使用 <code>docker rm</code> 来删除一个处于终止状态的容器。</p>\n<h2 id=\"仓库\"><a href=\"#仓库\" class=\"headerlink\" title=\"仓库\"></a>仓库</h2><p>仓库（<code>Repository</code>）是集中存放镜像的地方，镜像构建完成后，可以很容易的在当前宿主上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，<a href=\"https://docs.docker.com/registry/\" target=\"_blank\" rel=\"noopener\">Docker Registry</a> 就是这样的服务。</p>\n<p>一个容易混淆的概念是注册服务器（<code>Registry</code>）。实际上注册服务器是管理仓库的具体服务器，每个服务器上可以有多个仓库，而每个仓库下面有多个镜像。从这方面来说，仓库可以被认为是一个具体的项目或目录。例如对于仓库地址 <code>dl.dockerpool.com/ubuntu</code> 来说，<code>dl.dockerpool.com</code> 是注册服务器地址，<code>ubuntu</code> 是仓库名。</p>"},{"title":"区块链解谜","author":"James","date":"2017-12-29T03:58:00.000Z","_content":"\n# 什么是区块链\n\n区块链是一个分布式的，去中心化的，点对点的，不可篡改的，共享账本系统。\n\n<!-- more -->\n\n![jvm_struct2](/images/blockchain/blockchain.png)\n\n#  区块链架构\n\n区块链整体架构上划分为网络层、共识层、数据层、智能合约层和应用层。共识层和数据层之间的联系比较密切，需要“通力合作”完成数据的存取。\n\n- 网络层，几乎都是基于P2P的网络，它主要完成节点之间的交互和数据块的传输。\n- 共识层，提供在不可信、分布式环境中的共识协议，通过它保证节点之间的数据一致性。\n- 数据层，提供数据保存的数据结构，它要承担防篡改的任务，所以技术上用了区块链表、Hash、Merkle Tree来实现。\n- 智能合约层，相当于数据访问接口，对区块链上的数据读写都是通过智能合约进行的，任何人的数据读写动作都是被明确定义的。\n- 应用层，各种各样的应用程序。\n\n\n![jvm_struct2](/images/blockchain/arch.png)\n\n\n# 区块链和比特币的关系\n\n每个区块数据由谁来记录或者说打包，是可以设置一个游戏规则的，比如说掷骰子，大家约定谁能连续3次掷出6，那就让他来记这个数据，为了补偿 一下他的劳动投入，奖励给他一些收益， \n比特币正是使用了这样的原理来不断的发行新的比特币出来，奖励给打包的那个人的比特币就是新发行的比特币。\n\n# 挖矿和区块链\n\n作为一个“数据库应用”比特币必须要“做点什么”。于是它就设计了一个小游戏环节——挖矿。游戏设计师中本聪在他大作《比特币：一种点对点式的电子现金系统》详细讲述的设计内幕和游戏方法。\n\n# 区块链的技术组合\n\n## 公开密钥算法\n\n属于计算机密码学里传统的技术，公开密钥算法是一种不对称的加密算法，拥有两个密钥，可以互相加解密，通常其中的一个密钥是公开的称之为公钥，另外一个密钥是保密的称之为私钥\n\n## 哈希算法\n\n也是属于计算机密码学中传统的技术，应用就更广泛了，主要用来对一段数据进行计算，得出一个摘要信息，通俗点说就是给一段数据生成1个身份证号；不同的消息生成的摘要数据是不一样的（某些抗碰撞能力弱的哈希算法可能在这里面会有些问题，但是使用广泛的一些知名的哈希算法，发生碰撞的概率很低），相当于给⼀段数据生成了一个身份证号这么个意思，在区块链系统中，哈希算法的使用很多，例如如区块与区块之间，就是通过区块头的哈希关联起来的，在区块中的每一笔交易事务也都会生成一个哈希值作为交易易数据的ID，通过这些身份证号可以方便的检索或者关联区块，也能方便的指定某一笔交易事务。 \n\n## 网络共识算法\n\n在很久前就有计算机科学家研究过，并且提出过一些模型，如拜占庭容错算法之类，比特币、以太坊这些使用的是一种工作量证明算法，其它的一些区块链系统有使用其他各种衍生的算法，算法的原理都很简单，就是约一个规则，通过共同执行这个规则，让每个分布式的节点数据都保持最终一致；\n\n## 梅克尔数据证明\n\n这是利用哈希算法将一组数据创建为一棵哈希树结构，用于验证数据完整性的一种结构，同时也应用在了轻量级钱包中。不同的区块链系统对梅克尔树的应用不尽相同，比特币中是二叉梅克尔树，比较简单，通过交易事务的哈希值两两配合生成一棵树，以太坊这种就复杂的多了，称之为梅克尔.帕特里夏树，这里暂时不赘述。\n\n## 可编程脚本合约\n\n什么叫合约？就是一组约定的规则，例如银行的结算系统，小明转账100给小王，在这个过程中，银系统就会根据一组规则自动执行，规则包含如检测小明的密码是否正确，余额是否足够，小王的账号是否正确，检测通过则分别更改两者的账户余额并写入事务日志。是的，这就是合约的意思了，当然，如果范围再广泛些，各种商业合约也都是这么个意思，因此可编程脚本合约也没什么好稀奇的，如果将这种编程合约放到区块链的环境中，比较有趣了，看两个特点：\n\n第一个，区块链系统是无中新的分布式网络，没有边界\n\n第二个，区块链系统通过一系列的技术实现了可信任网络\n\n加起来，就是无边界的可信任网络，在这样的网络中执行既定的合约，成本低而且安全，比特币在本质上也是属于这种脚本合约，只不过在比特币软件中，合约中处理的事情是比特币的转账","source":"_posts/blockchain.md","raw":"title: 区块链解谜\nauthor: James\ntags:\n  - 区块链\ncategories:\n  - 区块链\ndate: 2017-12-29 11:58:00\n---\n\n# 什么是区块链\n\n区块链是一个分布式的，去中心化的，点对点的，不可篡改的，共享账本系统。\n\n<!-- more -->\n\n![jvm_struct2](/images/blockchain/blockchain.png)\n\n#  区块链架构\n\n区块链整体架构上划分为网络层、共识层、数据层、智能合约层和应用层。共识层和数据层之间的联系比较密切，需要“通力合作”完成数据的存取。\n\n- 网络层，几乎都是基于P2P的网络，它主要完成节点之间的交互和数据块的传输。\n- 共识层，提供在不可信、分布式环境中的共识协议，通过它保证节点之间的数据一致性。\n- 数据层，提供数据保存的数据结构，它要承担防篡改的任务，所以技术上用了区块链表、Hash、Merkle Tree来实现。\n- 智能合约层，相当于数据访问接口，对区块链上的数据读写都是通过智能合约进行的，任何人的数据读写动作都是被明确定义的。\n- 应用层，各种各样的应用程序。\n\n\n![jvm_struct2](/images/blockchain/arch.png)\n\n\n# 区块链和比特币的关系\n\n每个区块数据由谁来记录或者说打包，是可以设置一个游戏规则的，比如说掷骰子，大家约定谁能连续3次掷出6，那就让他来记这个数据，为了补偿 一下他的劳动投入，奖励给他一些收益， \n比特币正是使用了这样的原理来不断的发行新的比特币出来，奖励给打包的那个人的比特币就是新发行的比特币。\n\n# 挖矿和区块链\n\n作为一个“数据库应用”比特币必须要“做点什么”。于是它就设计了一个小游戏环节——挖矿。游戏设计师中本聪在他大作《比特币：一种点对点式的电子现金系统》详细讲述的设计内幕和游戏方法。\n\n# 区块链的技术组合\n\n## 公开密钥算法\n\n属于计算机密码学里传统的技术，公开密钥算法是一种不对称的加密算法，拥有两个密钥，可以互相加解密，通常其中的一个密钥是公开的称之为公钥，另外一个密钥是保密的称之为私钥\n\n## 哈希算法\n\n也是属于计算机密码学中传统的技术，应用就更广泛了，主要用来对一段数据进行计算，得出一个摘要信息，通俗点说就是给一段数据生成1个身份证号；不同的消息生成的摘要数据是不一样的（某些抗碰撞能力弱的哈希算法可能在这里面会有些问题，但是使用广泛的一些知名的哈希算法，发生碰撞的概率很低），相当于给⼀段数据生成了一个身份证号这么个意思，在区块链系统中，哈希算法的使用很多，例如如区块与区块之间，就是通过区块头的哈希关联起来的，在区块中的每一笔交易事务也都会生成一个哈希值作为交易易数据的ID，通过这些身份证号可以方便的检索或者关联区块，也能方便的指定某一笔交易事务。 \n\n## 网络共识算法\n\n在很久前就有计算机科学家研究过，并且提出过一些模型，如拜占庭容错算法之类，比特币、以太坊这些使用的是一种工作量证明算法，其它的一些区块链系统有使用其他各种衍生的算法，算法的原理都很简单，就是约一个规则，通过共同执行这个规则，让每个分布式的节点数据都保持最终一致；\n\n## 梅克尔数据证明\n\n这是利用哈希算法将一组数据创建为一棵哈希树结构，用于验证数据完整性的一种结构，同时也应用在了轻量级钱包中。不同的区块链系统对梅克尔树的应用不尽相同，比特币中是二叉梅克尔树，比较简单，通过交易事务的哈希值两两配合生成一棵树，以太坊这种就复杂的多了，称之为梅克尔.帕特里夏树，这里暂时不赘述。\n\n## 可编程脚本合约\n\n什么叫合约？就是一组约定的规则，例如银行的结算系统，小明转账100给小王，在这个过程中，银系统就会根据一组规则自动执行，规则包含如检测小明的密码是否正确，余额是否足够，小王的账号是否正确，检测通过则分别更改两者的账户余额并写入事务日志。是的，这就是合约的意思了，当然，如果范围再广泛些，各种商业合约也都是这么个意思，因此可编程脚本合约也没什么好稀奇的，如果将这种编程合约放到区块链的环境中，比较有趣了，看两个特点：\n\n第一个，区块链系统是无中新的分布式网络，没有边界\n\n第二个，区块链系统通过一系列的技术实现了可信任网络\n\n加起来，就是无边界的可信任网络，在这样的网络中执行既定的合约，成本低而且安全，比特币在本质上也是属于这种脚本合约，只不过在比特币软件中，合约中处理的事情是比特币的转账","slug":"blockchain","published":1,"updated":"2018-04-04T08:30:35.237Z","_id":"cjfktbq2f0000w0kc4cs6a9ev","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"什么是区块链\"><a href=\"#什么是区块链\" class=\"headerlink\" title=\"什么是区块链\"></a>什么是区块链</h1><p>区块链是一个分布式的，去中心化的，点对点的，不可篡改的，共享账本系统。</p>\n<a id=\"more\"></a>\n<p><img src=\"/images/blockchain/blockchain.png\" alt=\"jvm_struct2\"></p>\n<h1 id=\"区块链架构\"><a href=\"#区块链架构\" class=\"headerlink\" title=\"区块链架构\"></a>区块链架构</h1><p>区块链整体架构上划分为网络层、共识层、数据层、智能合约层和应用层。共识层和数据层之间的联系比较密切，需要“通力合作”完成数据的存取。</p>\n<ul>\n<li>网络层，几乎都是基于P2P的网络，它主要完成节点之间的交互和数据块的传输。</li>\n<li>共识层，提供在不可信、分布式环境中的共识协议，通过它保证节点之间的数据一致性。</li>\n<li>数据层，提供数据保存的数据结构，它要承担防篡改的任务，所以技术上用了区块链表、Hash、Merkle Tree来实现。</li>\n<li>智能合约层，相当于数据访问接口，对区块链上的数据读写都是通过智能合约进行的，任何人的数据读写动作都是被明确定义的。</li>\n<li>应用层，各种各样的应用程序。</li>\n</ul>\n<p><img src=\"/images/blockchain/arch.png\" alt=\"jvm_struct2\"></p>\n<h1 id=\"区块链和比特币的关系\"><a href=\"#区块链和比特币的关系\" class=\"headerlink\" title=\"区块链和比特币的关系\"></a>区块链和比特币的关系</h1><p>每个区块数据由谁来记录或者说打包，是可以设置一个游戏规则的，比如说掷骰子，大家约定谁能连续3次掷出6，那就让他来记这个数据，为了补偿 一下他的劳动投入，奖励给他一些收益，<br>比特币正是使用了这样的原理来不断的发行新的比特币出来，奖励给打包的那个人的比特币就是新发行的比特币。</p>\n<h1 id=\"挖矿和区块链\"><a href=\"#挖矿和区块链\" class=\"headerlink\" title=\"挖矿和区块链\"></a>挖矿和区块链</h1><p>作为一个“数据库应用”比特币必须要“做点什么”。于是它就设计了一个小游戏环节——挖矿。游戏设计师中本聪在他大作《比特币：一种点对点式的电子现金系统》详细讲述的设计内幕和游戏方法。</p>\n<h1 id=\"区块链的技术组合\"><a href=\"#区块链的技术组合\" class=\"headerlink\" title=\"区块链的技术组合\"></a>区块链的技术组合</h1><h2 id=\"公开密钥算法\"><a href=\"#公开密钥算法\" class=\"headerlink\" title=\"公开密钥算法\"></a>公开密钥算法</h2><p>属于计算机密码学里传统的技术，公开密钥算法是一种不对称的加密算法，拥有两个密钥，可以互相加解密，通常其中的一个密钥是公开的称之为公钥，另外一个密钥是保密的称之为私钥</p>\n<h2 id=\"哈希算法\"><a href=\"#哈希算法\" class=\"headerlink\" title=\"哈希算法\"></a>哈希算法</h2><p>也是属于计算机密码学中传统的技术，应用就更广泛了，主要用来对一段数据进行计算，得出一个摘要信息，通俗点说就是给一段数据生成1个身份证号；不同的消息生成的摘要数据是不一样的（某些抗碰撞能力弱的哈希算法可能在这里面会有些问题，但是使用广泛的一些知名的哈希算法，发生碰撞的概率很低），相当于给⼀段数据生成了一个身份证号这么个意思，在区块链系统中，哈希算法的使用很多，例如如区块与区块之间，就是通过区块头的哈希关联起来的，在区块中的每一笔交易事务也都会生成一个哈希值作为交易易数据的ID，通过这些身份证号可以方便的检索或者关联区块，也能方便的指定某一笔交易事务。 </p>\n<h2 id=\"网络共识算法\"><a href=\"#网络共识算法\" class=\"headerlink\" title=\"网络共识算法\"></a>网络共识算法</h2><p>在很久前就有计算机科学家研究过，并且提出过一些模型，如拜占庭容错算法之类，比特币、以太坊这些使用的是一种工作量证明算法，其它的一些区块链系统有使用其他各种衍生的算法，算法的原理都很简单，就是约一个规则，通过共同执行这个规则，让每个分布式的节点数据都保持最终一致；</p>\n<h2 id=\"梅克尔数据证明\"><a href=\"#梅克尔数据证明\" class=\"headerlink\" title=\"梅克尔数据证明\"></a>梅克尔数据证明</h2><p>这是利用哈希算法将一组数据创建为一棵哈希树结构，用于验证数据完整性的一种结构，同时也应用在了轻量级钱包中。不同的区块链系统对梅克尔树的应用不尽相同，比特币中是二叉梅克尔树，比较简单，通过交易事务的哈希值两两配合生成一棵树，以太坊这种就复杂的多了，称之为梅克尔.帕特里夏树，这里暂时不赘述。</p>\n<h2 id=\"可编程脚本合约\"><a href=\"#可编程脚本合约\" class=\"headerlink\" title=\"可编程脚本合约\"></a>可编程脚本合约</h2><p>什么叫合约？就是一组约定的规则，例如银行的结算系统，小明转账100给小王，在这个过程中，银系统就会根据一组规则自动执行，规则包含如检测小明的密码是否正确，余额是否足够，小王的账号是否正确，检测通过则分别更改两者的账户余额并写入事务日志。是的，这就是合约的意思了，当然，如果范围再广泛些，各种商业合约也都是这么个意思，因此可编程脚本合约也没什么好稀奇的，如果将这种编程合约放到区块链的环境中，比较有趣了，看两个特点：</p>\n<p>第一个，区块链系统是无中新的分布式网络，没有边界</p>\n<p>第二个，区块链系统通过一系列的技术实现了可信任网络</p>\n<p>加起来，就是无边界的可信任网络，在这样的网络中执行既定的合约，成本低而且安全，比特币在本质上也是属于这种脚本合约，只不过在比特币软件中，合约中处理的事情是比特币的转账</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"什么是区块链\"><a href=\"#什么是区块链\" class=\"headerlink\" title=\"什么是区块链\"></a>什么是区块链</h1><p>区块链是一个分布式的，去中心化的，点对点的，不可篡改的，共享账本系统。</p>","more":"<p><img src=\"/images/blockchain/blockchain.png\" alt=\"jvm_struct2\"></p>\n<h1 id=\"区块链架构\"><a href=\"#区块链架构\" class=\"headerlink\" title=\"区块链架构\"></a>区块链架构</h1><p>区块链整体架构上划分为网络层、共识层、数据层、智能合约层和应用层。共识层和数据层之间的联系比较密切，需要“通力合作”完成数据的存取。</p>\n<ul>\n<li>网络层，几乎都是基于P2P的网络，它主要完成节点之间的交互和数据块的传输。</li>\n<li>共识层，提供在不可信、分布式环境中的共识协议，通过它保证节点之间的数据一致性。</li>\n<li>数据层，提供数据保存的数据结构，它要承担防篡改的任务，所以技术上用了区块链表、Hash、Merkle Tree来实现。</li>\n<li>智能合约层，相当于数据访问接口，对区块链上的数据读写都是通过智能合约进行的，任何人的数据读写动作都是被明确定义的。</li>\n<li>应用层，各种各样的应用程序。</li>\n</ul>\n<p><img src=\"/images/blockchain/arch.png\" alt=\"jvm_struct2\"></p>\n<h1 id=\"区块链和比特币的关系\"><a href=\"#区块链和比特币的关系\" class=\"headerlink\" title=\"区块链和比特币的关系\"></a>区块链和比特币的关系</h1><p>每个区块数据由谁来记录或者说打包，是可以设置一个游戏规则的，比如说掷骰子，大家约定谁能连续3次掷出6，那就让他来记这个数据，为了补偿 一下他的劳动投入，奖励给他一些收益，<br>比特币正是使用了这样的原理来不断的发行新的比特币出来，奖励给打包的那个人的比特币就是新发行的比特币。</p>\n<h1 id=\"挖矿和区块链\"><a href=\"#挖矿和区块链\" class=\"headerlink\" title=\"挖矿和区块链\"></a>挖矿和区块链</h1><p>作为一个“数据库应用”比特币必须要“做点什么”。于是它就设计了一个小游戏环节——挖矿。游戏设计师中本聪在他大作《比特币：一种点对点式的电子现金系统》详细讲述的设计内幕和游戏方法。</p>\n<h1 id=\"区块链的技术组合\"><a href=\"#区块链的技术组合\" class=\"headerlink\" title=\"区块链的技术组合\"></a>区块链的技术组合</h1><h2 id=\"公开密钥算法\"><a href=\"#公开密钥算法\" class=\"headerlink\" title=\"公开密钥算法\"></a>公开密钥算法</h2><p>属于计算机密码学里传统的技术，公开密钥算法是一种不对称的加密算法，拥有两个密钥，可以互相加解密，通常其中的一个密钥是公开的称之为公钥，另外一个密钥是保密的称之为私钥</p>\n<h2 id=\"哈希算法\"><a href=\"#哈希算法\" class=\"headerlink\" title=\"哈希算法\"></a>哈希算法</h2><p>也是属于计算机密码学中传统的技术，应用就更广泛了，主要用来对一段数据进行计算，得出一个摘要信息，通俗点说就是给一段数据生成1个身份证号；不同的消息生成的摘要数据是不一样的（某些抗碰撞能力弱的哈希算法可能在这里面会有些问题，但是使用广泛的一些知名的哈希算法，发生碰撞的概率很低），相当于给⼀段数据生成了一个身份证号这么个意思，在区块链系统中，哈希算法的使用很多，例如如区块与区块之间，就是通过区块头的哈希关联起来的，在区块中的每一笔交易事务也都会生成一个哈希值作为交易易数据的ID，通过这些身份证号可以方便的检索或者关联区块，也能方便的指定某一笔交易事务。 </p>\n<h2 id=\"网络共识算法\"><a href=\"#网络共识算法\" class=\"headerlink\" title=\"网络共识算法\"></a>网络共识算法</h2><p>在很久前就有计算机科学家研究过，并且提出过一些模型，如拜占庭容错算法之类，比特币、以太坊这些使用的是一种工作量证明算法，其它的一些区块链系统有使用其他各种衍生的算法，算法的原理都很简单，就是约一个规则，通过共同执行这个规则，让每个分布式的节点数据都保持最终一致；</p>\n<h2 id=\"梅克尔数据证明\"><a href=\"#梅克尔数据证明\" class=\"headerlink\" title=\"梅克尔数据证明\"></a>梅克尔数据证明</h2><p>这是利用哈希算法将一组数据创建为一棵哈希树结构，用于验证数据完整性的一种结构，同时也应用在了轻量级钱包中。不同的区块链系统对梅克尔树的应用不尽相同，比特币中是二叉梅克尔树，比较简单，通过交易事务的哈希值两两配合生成一棵树，以太坊这种就复杂的多了，称之为梅克尔.帕特里夏树，这里暂时不赘述。</p>\n<h2 id=\"可编程脚本合约\"><a href=\"#可编程脚本合约\" class=\"headerlink\" title=\"可编程脚本合约\"></a>可编程脚本合约</h2><p>什么叫合约？就是一组约定的规则，例如银行的结算系统，小明转账100给小王，在这个过程中，银系统就会根据一组规则自动执行，规则包含如检测小明的密码是否正确，余额是否足够，小王的账号是否正确，检测通过则分别更改两者的账户余额并写入事务日志。是的，这就是合约的意思了，当然，如果范围再广泛些，各种商业合约也都是这么个意思，因此可编程脚本合约也没什么好稀奇的，如果将这种编程合约放到区块链的环境中，比较有趣了，看两个特点：</p>\n<p>第一个，区块链系统是无中新的分布式网络，没有边界</p>\n<p>第二个，区块链系统通过一系列的技术实现了可信任网络</p>\n<p>加起来，就是无边界的可信任网络，在这样的网络中执行既定的合约，成本低而且安全，比特币在本质上也是属于这种脚本合约，只不过在比特币软件中，合约中处理的事情是比特币的转账</p>"},{"title":"二分查找真的不简单","author":"James","date":"2015-04-09T07:19:00.000Z","_content":"\n# 简介\n\n二分查找法： 在一个有序数组中，取数组中的中间值和要找的值进行比较，当要查找的值大于中间值，则在右边的区间继续取一个中间值和要比较的数进行比较。当找查找的值小于中间值时则反之，直至最后要查找的值和中间值相同，则说明找到该值。\n\n一般而言，对于包含n个元素的有序列表，用二分查找最多需要`㏒₂n`步，而简单查找最多需要n步。\n\n# 问题 \n\n编写二分查找法的代码看似简单，其实是很容易出错的，你必须注意各种边界条件的处理，例如数组是空的，或者数组只有一个元素等等。别说你会出错，很多正规出版的算法书在讲解二分查找法时，他们给出的代码也是有错误的，据统计在美国出版的二十多本不同的讲算法的书中，只有五本对二分查找的代码实现是正确的。\n\n\n\n# show code\n\n## 递归二分查找\n\n```java\nInteger binarySearch(Integer[] arrs, Integer val, Integer lo, Integer hi) {\n        if(lo > hi) return -1;\n        Integer mid = (hi + lo) / 2;\n        if (val > arrs[mid]) return binarySearch(arrs, val, mid + 1, hi);\n        else if (val < arrs[mid]) return binarySearch(arrs, val, lo, mid - 1);\n        return mid;\n}\n```\n\n## 非递归\n\n```java\nInteger binarySearchV1(Integer[] arrs, Integer val, Integer lo, Integer hi) {\n        while(hi >= lo){\n            //low + high 是会溢出的。只要这个数组我们开的足够大\n            //Integer mid = (hi + lo) / 2;\n            Integer mid = ((hi - lo) >> 2) + lo;\n            if (val > arrs[mid]) lo = mid + 1;\n            else if (val < arrs[mid]) hi = mid - 1;\n            else return mid;\n        }\n        return -1;\n}\n```\n\n# 易错点\n\n- *死循环*: 在做的是整数运算，整除2了之后，对于奇数和偶数的行为还不一样，很有可能有些情况下我们并没有减小取值范围，而形成死循环\n- 退出条件。到底什么时候我们才觉得我们找不到呢\n- 差1错误。我们的左端点应该是当前可能区间的最小范围，那么右端点是最大范围呢，还是最大范围+1呢。我们取了中间值之后，在缩小区间时，有没有保持左右端点的这个假设的一致性呢？\n\n# 扩展思考\n\n## 二分查找还有改进的空间吗?\n\n可以细微的评定下上面非递归版本的比较次数,假设以7个有序数列为例，图中能够清晰的看到查找一个元素成功或者失败需要比较次数。\n\n![binary](/images/binarysearch/example1.png)\n\n\n\n先看成功的情况：分别为所有次数相加除以元素个数 :(2+3+4+4+5+5+6)29/7≈4+\n\n再看失败的情况:上图中虚线框中为失败的比较次数:(3+4+4+5+4+5+5+6)36/8=4.5\n\n故而可以得出平均查找长度均大致为O(1.5·㏒₂n)。\n\n可以发现向左和向右分支前的比较次数不想等。向左分支前只需要比较一次，而向右分支则需要比较两次；由此可以发现虽然递归深度是均衡的，但是转向成本不均衡。\n\n是不是可以通过调整递归深度的不均衡，对转向成本的不均衡进行补偿呢。\n\n### Fibonacci查找\n\n先看一段代码\n\n```java\nInteger fibSearch(Integer[] arrs, Integer val, Integer lo, Integer hi) {\n    \tFib fibs = Fib.create(hi - lo) //创建一个Fib数列 logn(hi-lo)\n        while(hi >= lo){\n            while( hi - lo < fib.get() ) fib.prev();//通过向前的顺序查找确定轴点\n            //Integer mid = (hi + lo) / 2;\n            Integer mid = lo + fib.get() - 1 //黄金比例切分\n            if (val > arrs[mid]) lo = mid + 1;\n            else if (val < arrs[mid]) hi = mid - 1;\n            else return mid;\n        }\n        return -1;\n}\n```\n\n还是以7个有序数列为例，看看FIb查找元素的比较次数\n\n![binary](/images/binarysearch/example2.png)\n\n平均成功查找比较次数=(2+3+4+4+5+5+5) / 7 = 28 / 7 = 4.00\n\n平均失败查找比较次数=(4+5+4+4+5+4+5+4) / 8 = 35 / 8 = 4.38\n\n跟上面的比较次数想比是不是有所优化。\n\n普通二分查找和FIb数列查找的不同其实就是选择轴点， 二分对应轴点=0.5;FIb查找对应抽点=0.6180399...所谓的黄金分割。\n\n### 二分查找再优化\n\n既然之前二分查找版本左右分支的转向代价是不平衡的，那么有办法能够做成平衡的吗?\n\n比如只做一次比较，所有分支只有2个方向，而不是3个方向。\n\n```java\nInteger binarySearchV1(Integer[] arrs, Integer val, Integer lo, Integer hi) {\n        while(1 < hi - lo ){//查找宽度缩短至1时，算法才会终止\n            Integer mid = ((hi - lo) >> 2) + lo;//还是以中点为轴点\n            val < arrs[mid] ? hi = mi : lo = mi//每次比较都只有2个方向\n        }\n        return (val == arrs[lo]) ? lo : -1;\n}\n```\n\n但是相对于之前的版本，由于无论如何都需要比较完所有转向，所以最好的情况下更坏（例如第一次就能比配到需要查找的元素，之前版本是O(1)， 而优化的版本需要O(logn)），但是更坏的情况变好(之前的版本需要 1.5*logn，而优化版本只需要logn)。\n\n","source":"_posts/binarysearch.md","raw":"title: 二分查找真的不简单\nauthor: James\ntags:\n  - 二分查找\ncategories:\n  - 算法\ndate: 2015-04-09 15:19:00\n---\n\n# 简介\n\n二分查找法： 在一个有序数组中，取数组中的中间值和要找的值进行比较，当要查找的值大于中间值，则在右边的区间继续取一个中间值和要比较的数进行比较。当找查找的值小于中间值时则反之，直至最后要查找的值和中间值相同，则说明找到该值。\n\n一般而言，对于包含n个元素的有序列表，用二分查找最多需要`㏒₂n`步，而简单查找最多需要n步。\n\n# 问题 \n\n编写二分查找法的代码看似简单，其实是很容易出错的，你必须注意各种边界条件的处理，例如数组是空的，或者数组只有一个元素等等。别说你会出错，很多正规出版的算法书在讲解二分查找法时，他们给出的代码也是有错误的，据统计在美国出版的二十多本不同的讲算法的书中，只有五本对二分查找的代码实现是正确的。\n\n\n\n# show code\n\n## 递归二分查找\n\n```java\nInteger binarySearch(Integer[] arrs, Integer val, Integer lo, Integer hi) {\n        if(lo > hi) return -1;\n        Integer mid = (hi + lo) / 2;\n        if (val > arrs[mid]) return binarySearch(arrs, val, mid + 1, hi);\n        else if (val < arrs[mid]) return binarySearch(arrs, val, lo, mid - 1);\n        return mid;\n}\n```\n\n## 非递归\n\n```java\nInteger binarySearchV1(Integer[] arrs, Integer val, Integer lo, Integer hi) {\n        while(hi >= lo){\n            //low + high 是会溢出的。只要这个数组我们开的足够大\n            //Integer mid = (hi + lo) / 2;\n            Integer mid = ((hi - lo) >> 2) + lo;\n            if (val > arrs[mid]) lo = mid + 1;\n            else if (val < arrs[mid]) hi = mid - 1;\n            else return mid;\n        }\n        return -1;\n}\n```\n\n# 易错点\n\n- *死循环*: 在做的是整数运算，整除2了之后，对于奇数和偶数的行为还不一样，很有可能有些情况下我们并没有减小取值范围，而形成死循环\n- 退出条件。到底什么时候我们才觉得我们找不到呢\n- 差1错误。我们的左端点应该是当前可能区间的最小范围，那么右端点是最大范围呢，还是最大范围+1呢。我们取了中间值之后，在缩小区间时，有没有保持左右端点的这个假设的一致性呢？\n\n# 扩展思考\n\n## 二分查找还有改进的空间吗?\n\n可以细微的评定下上面非递归版本的比较次数,假设以7个有序数列为例，图中能够清晰的看到查找一个元素成功或者失败需要比较次数。\n\n![binary](/images/binarysearch/example1.png)\n\n\n\n先看成功的情况：分别为所有次数相加除以元素个数 :(2+3+4+4+5+5+6)29/7≈4+\n\n再看失败的情况:上图中虚线框中为失败的比较次数:(3+4+4+5+4+5+5+6)36/8=4.5\n\n故而可以得出平均查找长度均大致为O(1.5·㏒₂n)。\n\n可以发现向左和向右分支前的比较次数不想等。向左分支前只需要比较一次，而向右分支则需要比较两次；由此可以发现虽然递归深度是均衡的，但是转向成本不均衡。\n\n是不是可以通过调整递归深度的不均衡，对转向成本的不均衡进行补偿呢。\n\n### Fibonacci查找\n\n先看一段代码\n\n```java\nInteger fibSearch(Integer[] arrs, Integer val, Integer lo, Integer hi) {\n    \tFib fibs = Fib.create(hi - lo) //创建一个Fib数列 logn(hi-lo)\n        while(hi >= lo){\n            while( hi - lo < fib.get() ) fib.prev();//通过向前的顺序查找确定轴点\n            //Integer mid = (hi + lo) / 2;\n            Integer mid = lo + fib.get() - 1 //黄金比例切分\n            if (val > arrs[mid]) lo = mid + 1;\n            else if (val < arrs[mid]) hi = mid - 1;\n            else return mid;\n        }\n        return -1;\n}\n```\n\n还是以7个有序数列为例，看看FIb查找元素的比较次数\n\n![binary](/images/binarysearch/example2.png)\n\n平均成功查找比较次数=(2+3+4+4+5+5+5) / 7 = 28 / 7 = 4.00\n\n平均失败查找比较次数=(4+5+4+4+5+4+5+4) / 8 = 35 / 8 = 4.38\n\n跟上面的比较次数想比是不是有所优化。\n\n普通二分查找和FIb数列查找的不同其实就是选择轴点， 二分对应轴点=0.5;FIb查找对应抽点=0.6180399...所谓的黄金分割。\n\n### 二分查找再优化\n\n既然之前二分查找版本左右分支的转向代价是不平衡的，那么有办法能够做成平衡的吗?\n\n比如只做一次比较，所有分支只有2个方向，而不是3个方向。\n\n```java\nInteger binarySearchV1(Integer[] arrs, Integer val, Integer lo, Integer hi) {\n        while(1 < hi - lo ){//查找宽度缩短至1时，算法才会终止\n            Integer mid = ((hi - lo) >> 2) + lo;//还是以中点为轴点\n            val < arrs[mid] ? hi = mi : lo = mi//每次比较都只有2个方向\n        }\n        return (val == arrs[lo]) ? lo : -1;\n}\n```\n\n但是相对于之前的版本，由于无论如何都需要比较完所有转向，所以最好的情况下更坏（例如第一次就能比配到需要查找的元素，之前版本是O(1)， 而优化的版本需要O(logn)），但是更坏的情况变好(之前的版本需要 1.5*logn，而优化版本只需要logn)。\n\n","slug":"binarysearch","published":1,"updated":"2018-04-18T09:27:41.501Z","_id":"cjfrwqk1s0000wckcf06oqq6q","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>二分查找法： 在一个有序数组中，取数组中的中间值和要找的值进行比较，当要查找的值大于中间值，则在右边的区间继续取一个中间值和要比较的数进行比较。当找查找的值小于中间值时则反之，直至最后要查找的值和中间值相同，则说明找到该值。</p>\n<p>一般而言，对于包含n个元素的有序列表，用二分查找最多需要<code>㏒₂n</code>步，而简单查找最多需要n步。</p>\n<h1 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h1><p>编写二分查找法的代码看似简单，其实是很容易出错的，你必须注意各种边界条件的处理，例如数组是空的，或者数组只有一个元素等等。别说你会出错，很多正规出版的算法书在讲解二分查找法时，他们给出的代码也是有错误的，据统计在美国出版的二十多本不同的讲算法的书中，只有五本对二分查找的代码实现是正确的。</p>\n<h1 id=\"show-code\"><a href=\"#show-code\" class=\"headerlink\" title=\"show code\"></a>show code</h1><h2 id=\"递归二分查找\"><a href=\"#递归二分查找\" class=\"headerlink\" title=\"递归二分查找\"></a>递归二分查找</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Integer <span class=\"title\">binarySearch</span><span class=\"params\">(Integer[] arrs, Integer val, Integer lo, Integer hi)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(lo &gt; hi) <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">        Integer mid = (hi + lo) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (val &gt; arrs[mid]) <span class=\"keyword\">return</span> binarySearch(arrs, val, mid + <span class=\"number\">1</span>, hi);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (val &lt; arrs[mid]) <span class=\"keyword\">return</span> binarySearch(arrs, val, lo, mid - <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"非递归\"><a href=\"#非递归\" class=\"headerlink\" title=\"非递归\"></a>非递归</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Integer <span class=\"title\">binarySearchV1</span><span class=\"params\">(Integer[] arrs, Integer val, Integer lo, Integer hi)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(hi &gt;= lo)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//low + high 是会溢出的。只要这个数组我们开的足够大</span></span><br><span class=\"line\">            <span class=\"comment\">//Integer mid = (hi + lo) / 2;</span></span><br><span class=\"line\">            Integer mid = ((hi - lo) &gt;&gt; <span class=\"number\">2</span>) + lo;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (val &gt; arrs[mid]) lo = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (val &lt; arrs[mid]) hi = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"易错点\"><a href=\"#易错点\" class=\"headerlink\" title=\"易错点\"></a>易错点</h1><ul>\n<li><em>死循环</em>: 在做的是整数运算，整除2了之后，对于奇数和偶数的行为还不一样，很有可能有些情况下我们并没有减小取值范围，而形成死循环</li>\n<li>退出条件。到底什么时候我们才觉得我们找不到呢</li>\n<li>差1错误。我们的左端点应该是当前可能区间的最小范围，那么右端点是最大范围呢，还是最大范围+1呢。我们取了中间值之后，在缩小区间时，有没有保持左右端点的这个假设的一致性呢？</li>\n</ul>\n<h1 id=\"扩展思考\"><a href=\"#扩展思考\" class=\"headerlink\" title=\"扩展思考\"></a>扩展思考</h1><h2 id=\"二分查找还有改进的空间吗\"><a href=\"#二分查找还有改进的空间吗\" class=\"headerlink\" title=\"二分查找还有改进的空间吗?\"></a>二分查找还有改进的空间吗?</h2><p>可以细微的评定下上面非递归版本的比较次数,假设以7个有序数列为例，图中能够清晰的看到查找一个元素成功或者失败需要比较次数。</p>\n<p><img src=\"/images/binarysearch/example1.png\" alt=\"binary\"></p>\n<p>先看成功的情况：分别为所有次数相加除以元素个数 :(2+3+4+4+5+5+6)29/7≈4+</p>\n<p>再看失败的情况:上图中虚线框中为失败的比较次数:(3+4+4+5+4+5+5+6)36/8=4.5</p>\n<p>故而可以得出平均查找长度均大致为O(1.5·㏒₂n)。</p>\n<p>可以发现向左和向右分支前的比较次数不想等。向左分支前只需要比较一次，而向右分支则需要比较两次；由此可以发现虽然递归深度是均衡的，但是转向成本不均衡。</p>\n<p>是不是可以通过调整递归深度的不均衡，对转向成本的不均衡进行补偿呢。</p>\n<h3 id=\"Fibonacci查找\"><a href=\"#Fibonacci查找\" class=\"headerlink\" title=\"Fibonacci查找\"></a>Fibonacci查找</h3><p>先看一段代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Integer <span class=\"title\">fibSearch</span><span class=\"params\">(Integer[] arrs, Integer val, Integer lo, Integer hi)</span> </span>&#123;</span><br><span class=\"line\">    \tFib fibs = Fib.create(hi - lo) <span class=\"comment\">//创建一个Fib数列 logn(hi-lo)</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(hi &gt;= lo)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>( hi - lo &lt; fib.get() ) fib.prev();<span class=\"comment\">//通过向前的顺序查找确定轴点</span></span><br><span class=\"line\">            <span class=\"comment\">//Integer mid = (hi + lo) / 2;</span></span><br><span class=\"line\">            Integer mid = lo + fib.get() - <span class=\"number\">1</span> <span class=\"comment\">//黄金比例切分</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (val &gt; arrs[mid]) lo = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (val &lt; arrs[mid]) hi = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>还是以7个有序数列为例，看看FIb查找元素的比较次数</p>\n<p><img src=\"/images/binarysearch/example2.png\" alt=\"binary\"></p>\n<p>平均成功查找比较次数=(2+3+4+4+5+5+5) / 7 = 28 / 7 = 4.00</p>\n<p>平均失败查找比较次数=(4+5+4+4+5+4+5+4) / 8 = 35 / 8 = 4.38</p>\n<p>跟上面的比较次数想比是不是有所优化。</p>\n<p>普通二分查找和FIb数列查找的不同其实就是选择轴点， 二分对应轴点=0.5;FIb查找对应抽点=0.6180399…所谓的黄金分割。</p>\n<h3 id=\"二分查找再优化\"><a href=\"#二分查找再优化\" class=\"headerlink\" title=\"二分查找再优化\"></a>二分查找再优化</h3><p>既然之前二分查找版本左右分支的转向代价是不平衡的，那么有办法能够做成平衡的吗?</p>\n<p>比如只做一次比较，所有分支只有2个方向，而不是3个方向。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Integer <span class=\"title\">binarySearchV1</span><span class=\"params\">(Integer[] arrs, Integer val, Integer lo, Integer hi)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"number\">1</span> &lt; hi - lo )&#123;<span class=\"comment\">//查找宽度缩短至1时，算法才会终止</span></span><br><span class=\"line\">            Integer mid = ((hi - lo) &gt;&gt; <span class=\"number\">2</span>) + lo;<span class=\"comment\">//还是以中点为轴点</span></span><br><span class=\"line\">            val &lt; arrs[mid] ? hi = mi : lo = mi<span class=\"comment\">//每次比较都只有2个方向</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (val == arrs[lo]) ? lo : -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是相对于之前的版本，由于无论如何都需要比较完所有转向，所以最好的情况下更坏（例如第一次就能比配到需要查找的元素，之前版本是O(1)， 而优化的版本需要O(logn)），但是更坏的情况变好(之前的版本需要 1.5*logn，而优化版本只需要logn)。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>二分查找法： 在一个有序数组中，取数组中的中间值和要找的值进行比较，当要查找的值大于中间值，则在右边的区间继续取一个中间值和要比较的数进行比较。当找查找的值小于中间值时则反之，直至最后要查找的值和中间值相同，则说明找到该值。</p>\n<p>一般而言，对于包含n个元素的有序列表，用二分查找最多需要<code>㏒₂n</code>步，而简单查找最多需要n步。</p>\n<h1 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h1><p>编写二分查找法的代码看似简单，其实是很容易出错的，你必须注意各种边界条件的处理，例如数组是空的，或者数组只有一个元素等等。别说你会出错，很多正规出版的算法书在讲解二分查找法时，他们给出的代码也是有错误的，据统计在美国出版的二十多本不同的讲算法的书中，只有五本对二分查找的代码实现是正确的。</p>\n<h1 id=\"show-code\"><a href=\"#show-code\" class=\"headerlink\" title=\"show code\"></a>show code</h1><h2 id=\"递归二分查找\"><a href=\"#递归二分查找\" class=\"headerlink\" title=\"递归二分查找\"></a>递归二分查找</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Integer <span class=\"title\">binarySearch</span><span class=\"params\">(Integer[] arrs, Integer val, Integer lo, Integer hi)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(lo &gt; hi) <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">        Integer mid = (hi + lo) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (val &gt; arrs[mid]) <span class=\"keyword\">return</span> binarySearch(arrs, val, mid + <span class=\"number\">1</span>, hi);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (val &lt; arrs[mid]) <span class=\"keyword\">return</span> binarySearch(arrs, val, lo, mid - <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"非递归\"><a href=\"#非递归\" class=\"headerlink\" title=\"非递归\"></a>非递归</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Integer <span class=\"title\">binarySearchV1</span><span class=\"params\">(Integer[] arrs, Integer val, Integer lo, Integer hi)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(hi &gt;= lo)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//low + high 是会溢出的。只要这个数组我们开的足够大</span></span><br><span class=\"line\">            <span class=\"comment\">//Integer mid = (hi + lo) / 2;</span></span><br><span class=\"line\">            Integer mid = ((hi - lo) &gt;&gt; <span class=\"number\">2</span>) + lo;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (val &gt; arrs[mid]) lo = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (val &lt; arrs[mid]) hi = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"易错点\"><a href=\"#易错点\" class=\"headerlink\" title=\"易错点\"></a>易错点</h1><ul>\n<li><em>死循环</em>: 在做的是整数运算，整除2了之后，对于奇数和偶数的行为还不一样，很有可能有些情况下我们并没有减小取值范围，而形成死循环</li>\n<li>退出条件。到底什么时候我们才觉得我们找不到呢</li>\n<li>差1错误。我们的左端点应该是当前可能区间的最小范围，那么右端点是最大范围呢，还是最大范围+1呢。我们取了中间值之后，在缩小区间时，有没有保持左右端点的这个假设的一致性呢？</li>\n</ul>\n<h1 id=\"扩展思考\"><a href=\"#扩展思考\" class=\"headerlink\" title=\"扩展思考\"></a>扩展思考</h1><h2 id=\"二分查找还有改进的空间吗\"><a href=\"#二分查找还有改进的空间吗\" class=\"headerlink\" title=\"二分查找还有改进的空间吗?\"></a>二分查找还有改进的空间吗?</h2><p>可以细微的评定下上面非递归版本的比较次数,假设以7个有序数列为例，图中能够清晰的看到查找一个元素成功或者失败需要比较次数。</p>\n<p><img src=\"/images/binarysearch/example1.png\" alt=\"binary\"></p>\n<p>先看成功的情况：分别为所有次数相加除以元素个数 :(2+3+4+4+5+5+6)29/7≈4+</p>\n<p>再看失败的情况:上图中虚线框中为失败的比较次数:(3+4+4+5+4+5+5+6)36/8=4.5</p>\n<p>故而可以得出平均查找长度均大致为O(1.5·㏒₂n)。</p>\n<p>可以发现向左和向右分支前的比较次数不想等。向左分支前只需要比较一次，而向右分支则需要比较两次；由此可以发现虽然递归深度是均衡的，但是转向成本不均衡。</p>\n<p>是不是可以通过调整递归深度的不均衡，对转向成本的不均衡进行补偿呢。</p>\n<h3 id=\"Fibonacci查找\"><a href=\"#Fibonacci查找\" class=\"headerlink\" title=\"Fibonacci查找\"></a>Fibonacci查找</h3><p>先看一段代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Integer <span class=\"title\">fibSearch</span><span class=\"params\">(Integer[] arrs, Integer val, Integer lo, Integer hi)</span> </span>&#123;</span><br><span class=\"line\">    \tFib fibs = Fib.create(hi - lo) <span class=\"comment\">//创建一个Fib数列 logn(hi-lo)</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(hi &gt;= lo)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>( hi - lo &lt; fib.get() ) fib.prev();<span class=\"comment\">//通过向前的顺序查找确定轴点</span></span><br><span class=\"line\">            <span class=\"comment\">//Integer mid = (hi + lo) / 2;</span></span><br><span class=\"line\">            Integer mid = lo + fib.get() - <span class=\"number\">1</span> <span class=\"comment\">//黄金比例切分</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (val &gt; arrs[mid]) lo = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (val &lt; arrs[mid]) hi = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>还是以7个有序数列为例，看看FIb查找元素的比较次数</p>\n<p><img src=\"/images/binarysearch/example2.png\" alt=\"binary\"></p>\n<p>平均成功查找比较次数=(2+3+4+4+5+5+5) / 7 = 28 / 7 = 4.00</p>\n<p>平均失败查找比较次数=(4+5+4+4+5+4+5+4) / 8 = 35 / 8 = 4.38</p>\n<p>跟上面的比较次数想比是不是有所优化。</p>\n<p>普通二分查找和FIb数列查找的不同其实就是选择轴点， 二分对应轴点=0.5;FIb查找对应抽点=0.6180399…所谓的黄金分割。</p>\n<h3 id=\"二分查找再优化\"><a href=\"#二分查找再优化\" class=\"headerlink\" title=\"二分查找再优化\"></a>二分查找再优化</h3><p>既然之前二分查找版本左右分支的转向代价是不平衡的，那么有办法能够做成平衡的吗?</p>\n<p>比如只做一次比较，所有分支只有2个方向，而不是3个方向。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Integer <span class=\"title\">binarySearchV1</span><span class=\"params\">(Integer[] arrs, Integer val, Integer lo, Integer hi)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"number\">1</span> &lt; hi - lo )&#123;<span class=\"comment\">//查找宽度缩短至1时，算法才会终止</span></span><br><span class=\"line\">            Integer mid = ((hi - lo) &gt;&gt; <span class=\"number\">2</span>) + lo;<span class=\"comment\">//还是以中点为轴点</span></span><br><span class=\"line\">            val &lt; arrs[mid] ? hi = mi : lo = mi<span class=\"comment\">//每次比较都只有2个方向</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (val == arrs[lo]) ? lo : -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是相对于之前的版本，由于无论如何都需要比较完所有转向，所以最好的情况下更坏（例如第一次就能比配到需要查找的元素，之前版本是O(1)， 而优化的版本需要O(logn)），但是更坏的情况变好(之前的版本需要 1.5*logn，而优化版本只需要logn)。</p>\n"},{"title":"探索 ConcurrentHashMap","author":"James","date":"2013-08-20T09:06:00.000Z","_content":"\n# 简介\n\nConcurrentHashMap 是 util.concurrent 包的重要成员。本文将结合 Java 内存模型，分析 JDK 源代码，探索 ConcurrentHashMap 高并发的具体实现机制。\n\n<!-- more -->\n\n# 结构分析\n\nConcurrentHashMap 类中包含两个静态内部类 HashEntry 和 Segment。HashEntry 用来封装映射表的键 / 值对；Segment 用来充当锁的角色，每个 Segment 对象守护整个散列映射表的若干个桶。每个桶是由若干个 HashEntry 对象链接起来的链表。一个 ConcurrentHashMap 实例中包含由若干个 Segment 对象组成的数组。*声明*: 以下源码是针对 `JDK 1.6`\n\n## ConcurrentHashMap 类\n\nConcurrentHashMap 在默认并发级别会创建包含 16 个 Segment 对象的数组。每个 Segment 的成员对象 table 包含若干个散列表的桶。每个桶是由 HashEntry 链接起来的一个链表。如果键能均匀散列，每个 Segment 大约守护整个散列表中桶总数的 1/16。\n\n```java\npublic class ConcurrentHashMap<K, V> extends AbstractMap<K, V> \n       implements ConcurrentMap<K, V>, Serializable { \n \n   /** \n    * 散列映射表的默认初始容量为 16，即初始默认为 16 个桶\n    * 在构造函数中没有指定这个参数时，使用本参数\n    */ \n   static final     int DEFAULT_INITIAL_CAPACITY= 16; \n \n   /** \n    * 散列映射表的默认装载因子为 0.75，该值是 table 中包含的 HashEntry 元素的个数与\n* table 数组长度的比值\n    * 当 table 中包含的 HashEntry 元素的个数超过了 table 数组的长度与装载因子的乘积时，\n* 将触发 再散列\n    * 在构造函数中没有指定这个参数时，使用本参数\n    */ \n   static final float DEFAULT_LOAD_FACTOR= 0.75f; \n \n   /** \n    * 散列表的默认并发级别为 16。该值表示当前更新线程的估计数\n    * 在构造函数中没有指定这个参数时，使用本参数\n    */ \n   static final int DEFAULT_CONCURRENCY_LEVEL= 16; \n \n   /** \n    * segments 的掩码值\n    * key 的散列码的高位用来选择具体的 segment \n    */ \n   final int segmentMask; \n \n   /** \n    * 偏移量\n    */ \n   final int segmentShift; \n \n   /** \n    * 由 Segment 对象组成的数组\n    */ \n   final Segment<K,V>[] segments; \n \n   /** \n    * 创建一个带有指定初始容量、加载因子和并发级别的新的空映射。\n    */ \n   public ConcurrentHashMap(int initialCapacity, \n                            float loadFactor, int concurrencyLevel) { \n       if(!(loadFactor > 0) || initialCapacity < 0 || \nconcurrencyLevel <= 0) \n           throw new IllegalArgumentException(); \n \n       if(concurrencyLevel > MAX_SEGMENTS) \n           concurrencyLevel = MAX_SEGMENTS; \n \n       // 寻找最佳匹配参数（不小于给定参数的最接近的 2 次幂） \n       int sshift = 0; \n       int ssize = 1; \n       while(ssize < concurrencyLevel) { \n           ++sshift; \n           ssize <<= 1; \n       } \n       segmentShift = 32 - sshift;       // 偏移量值\n       segmentMask = ssize - 1;           // 掩码值 \n       this.segments = Segment.newArray(ssize);   // 创建数组\n \n       if (initialCapacity > MAXIMUM_CAPACITY) \n           initialCapacity = MAXIMUM_CAPACITY; \n       int c = initialCapacity / ssize; \n       if(c * ssize < initialCapacity) \n           ++c; \n       int cap = 1; \n       while(cap < c) \n           cap <<= 1; \n \n       // 依次遍历每个数组元素\n       for(int i = 0; i < this.segments.length; ++i) \n           // 初始化每个数组元素引用的 Segment 对象\nthis.segments[i] = new Segment<K,V>(cap, loadFactor); \n   } \n \n   /** \n    * 创建一个带有默认初始容量 (16)、默认加载因子 (0.75) 和 默认并发级别 (16) \n * 的空散列映射表。\n    */ \n   public ConcurrentHashMap() { \n       // 使用三个默认参数，调用上面重载的构造函数来创建空散列映射表\nthis(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL); \n}\n```\n\n结构示意图：\n\n![ConcurrentHashMap](/images/concurrentHashMap/image005.jpg)\n\n## HashEntry 类\n\nHashEntry 用来封装散列映射表中的键值对。在 HashEntry 类中，key，hash 和 next 域都被声明为 final 型，value 域被声明为 volatile 型。\n\n```java\nstatic final class HashEntry<K,V> { \n       final K key;                       // 声明 key 为 final 型\n       final int hash;                   // 声明 hash 值为 final 型 \n       volatile V value;                 // 声明 value 为 volatile 型\n       final HashEntry<K,V> next;      // 声明 next 为 final 型 \n \n       HashEntry(K key, int hash, HashEntry<K,V> next, V value) { \n           this.key = key; \n           this.hash = hash; \n           this.next = next; \n           this.value = value; \n       } \n}\n```\n\n在 ConcurrentHashMap 中，在散列时如果产生“碰撞”，将采用“分离链接法”来处理“碰撞”：把“碰撞”的 HashEntry 对象链接成一个链表。由于 HashEntry 的 next 域为 final 型，所以新节点只能在链表的表头处插入。\n\n## Segment 类\n\nSegment 类继承于 ReentrantLock 类，从而使得 Segment 对象能充当锁的角色。每个 Segment 对象用来守护其（成员对象 table 中）包含的若干个桶。\n\ntable 是一个由 HashEntry 对象组成的数组。table 数组的每一个数组成员就是散列映射表的一个桶。\n\ncount 变量是一个计数器，它表示每个 Segment 对象管理的 table 数组（若干个 HashEntry 组成的链表）包含的 HashEntry 对象的个数。每一个 Segment 对象都有一个 count 对象来表示本 Segment 中包含的 HashEntry 对象的总数。注意，之所以在每个 Segment 对象中包含一个计数器，而不是在 `ConcurrentHashMap 中使用全局的计数器，是为了避免出现“热点域”而影响 ConcurrentHashMap 的并发性。`\n\n```java\nstatic final class Segment<K,V> extends ReentrantLock implements Serializable { \n       /** \n        * 在本 segment 范围内，包含的 HashEntry 元素的个数\n        * 该变量被声明为 volatile 型\n        */ \n       transient volatile int count; \n \n       /** \n        * table 被更新的次数\n        */ \n       transient int modCount; \n \n       /** \n        * 当 table 中包含的 HashEntry 元素的个数超过本变量值时，触发 table 的再散列\n        */ \n       transient int threshold; \n \n       /** \n        * table 是由 HashEntry 对象组成的数组\n        * 如果散列时发生碰撞，碰撞的 HashEntry 对象就以链表的形式链接成一个链表\n        * table 数组的数组成员代表散列映射表的一个桶\n        * 每个 table 守护整个 ConcurrentHashMap 包含桶总数的一部分\n        * 如果并发级别为 16，table 则守护 ConcurrentHashMap 包含的桶总数的 1/16 \n        */ \n       transient volatile HashEntry<K,V>[] table; \n \n       /** \n        * 装载因子\n        */ \n       final float loadFactor; \n \n       Segment(int initialCapacity, float lf) { \n           loadFactor = lf; \n           setTable(HashEntry.<K,V>newArray(initialCapacity)); \n       } \n \n       /** \n        * 设置 table 引用到这个新生成的 HashEntry 数组\n        * 只能在持有锁或构造函数中调用本方法\n        */ \n       void setTable(HashEntry<K,V>[] newTable) { \n           // 计算临界阀值为新数组的长度与装载因子的乘积\n           threshold = (int)(newTable.length * loadFactor); \n           table = newTable; \n       } \n \n       /** \n        * 根据 key 的散列值，找到 table 中对应的那个桶（table 数组的某个数组成员）\n        */ \n       HashEntry<K,V> getFirst(int hash) { \n           HashEntry<K,V>[] tab = table; \n           // 把散列值与 table 数组长度减 1 的值相“与”，\n// 得到散列值对应的 table 数组的下标\n           // 然后返回 table 数组中此下标对应的 HashEntry 元素\n           return tab[hash & (tab.length - 1)]; \n       } \n}\n```\n\n插入三个节点后 Segment 的结构示意图：\n\n![Segment](/images/concurrentHashMap/image004.jpg)\n\n## Put 方法的实现\n\n1.根据 key 计算出对应的 hash 值：\n\n```java\npublic V put(K key, V value) { \n       if (value == null)          //ConcurrentHashMap 中不允许用 null 作为映射值\n           throw new NullPointerException(); \n       int hash = hash(key.hashCode());        // 计算键对应的散列码\n       // 根据散列码找到对应的 Segment \n       return segmentFor(hash).put(key, hash, value, false); \n}\n```\n\n2.根据 hash 值找到对应的 Segment:\n\n```java\n/** \n    * 使用 key 的散列码来得到 segments 数组中对应的 Segment \n    */ \nfinal Segment<K,V> segmentFor(int hash) { \n   // 将散列值右移 segmentShift 个位，并在高位填充 0 \n   // 然后把得到的值与 segmentMask 相“与”\n// 从而得到 hash 值对应的 segments 数组的下标值\n// 最后根据下标值返回散列码对应的 Segment 对象\n       return segments[(hash >>> segmentShift) & segmentMask]; \n}\n```\n\n3.在 Segment 中执行具体的 put 操作\n\n```java\nV put(K key, int hash, V value, boolean onlyIfAbsent) { \n           lock();  // 加锁，这里是锁定某个 Segment 对象而非整个 ConcurrentHashMap \n           try { \n               int c = count; \n \n               if (c++ > threshold)     // 如果超过再散列的阈值\n                   rehash();              // 执行再散列，table 数组的长度将扩充一倍\n \n               HashEntry<K,V>[] tab = table; \n               // 把散列码值与 table 数组的长度减 1 的值相“与”\n               // 得到该散列码对应的 table 数组的下标值\n               int index = hash & (tab.length - 1); \n               // 找到散列码对应的具体的那个桶\n               HashEntry<K,V> first = tab[index]; \n \n               HashEntry<K,V> e = first; \n               while (e != null && (e.hash != hash || !key.equals(e.key))) \n                   e = e.next; \n \n               V oldValue; \n               if (e != null) {            // 如果键 / 值对以经存在\n                   oldValue = e.value; \n                   if (!onlyIfAbsent) \n                       e.value = value;    // 设置 value 值\n               } \n               else {                        // 键 / 值对不存在 \n                   oldValue = null; \n                   ++modCount;         // 要添加新节点到链表中，所以 modCont 要加 1  \n                   // 创建新节点，并添加到链表的头部 \n                   tab[index] = new HashEntry<K,V>(key, hash, first, value); \n                   count = c;               // 写 count 变量\n               } \n               return oldValue; \n           } finally { \n               unlock();                     // 解锁\n           } \n       }\n```\n\n加锁操作是针对（键的 hash 值对应的）某个具体的 Segment，锁定的是该 Segment 而不是整个 ConcurrentHashMap`。因为插入键 / 值对操作只是在这个 Segment 包含的某个桶中完成，不需要锁定整个`ConcurrentHashMap。`此时，其他写线程对另外 15 个`Segment 的加锁并不会因为当前线程对这个 Segment 的加锁而阻塞。同时，所有读线程几乎不会因本线程的加锁而阻塞（除非读线程刚好读到这个 Segment 中某个 `HashEntry 的 value 域的值为 null，此时需要加锁后重新读取该值`）。\n\n相比较于 `HashTable 和由同步包装器包装的 HashMap``每次只能有一个线程执行读或写操作，`ConcurrentHashMap 在并发访问性能上有了质的提高。*在理想状态下*，ConcurrentHashMap 可以支持 16 个线程执行并发写操作（如果并发级别设置为 16），及任意数量线程的读操作。\n\n# 总结\n\nConcurrentHashMap 是一个并发散列映射表的实现，它允许完全并发的读取，并且支持给定数量的并发更新。相比于 `HashTable 和`用同步包装器包装的 HashMap（Collections.synchronizedMap(new HashMap())），ConcurrentHashMap 拥有更高的并发性。在 `HashTable 和由同步包装器包装的 HashMap 中，使用一个全局的锁来同步不同线程间的并发访问。同一时间点，只能有一个线程持有锁，也就是说在同一时间点，只能有一个线程能访问容器。这虽然保证多线程间的安全并发访问，但同时也导致对容器的访问变成``*串行化*``的了。`\n\n在使用锁来协调多线程间并发访问的模式下，减小对锁的竞争可以有效提高并发性。有两种方式可以减小对锁的竞争：\n\n1. 减小请求 同一个锁的 频率。\n2. 减少持有锁的 时间。\n\nConcurrentHashMap 的高并发性主要来自于三个方面：\n\n1. 用分离锁实现多个线程间的更深层次的共享访问。\n2. 用 HashEntery 对象的不变性来降低执行读操作的线程在遍历链表期间对加锁的需求。\n3. 通过对同一个 Volatile 变量的写 / 读访问，协调不同线程间读 / 写操作的内存可见性。\n\n使用分离锁，减小了请求 *同一个锁*的频率。\n\n通过 HashEntery 对象的不变性及对同一个 Volatile 变量的读 / 写来协调内存可见性，使得 读操作大多数时候不需要加锁就能成功获取到需要的值。由于散列映射表在实际应用中大多数操作都是成功的 读操作，所以 2 和 3 既可以减少请求同一个锁的频率，也可以有效减少持有锁的时间。\n\n通过减小请求同一个锁的频率和尽量减少持有锁的时间 `，使得 ConcurrentHashMap 的并发性相对于 HashTable 和`用同步包装器包装的 HashMap`有了质的提高。`\n\n","source":"_posts/ConcurrentHashMap.md","raw":"title: 探索 ConcurrentHashMap\nauthor: James\ntags:\n  - ConcurrentHashMap\ncategories:\n  - 语言\ndate: 2013-08-20 17:06:00\n---\n\n# 简介\n\nConcurrentHashMap 是 util.concurrent 包的重要成员。本文将结合 Java 内存模型，分析 JDK 源代码，探索 ConcurrentHashMap 高并发的具体实现机制。\n\n<!-- more -->\n\n# 结构分析\n\nConcurrentHashMap 类中包含两个静态内部类 HashEntry 和 Segment。HashEntry 用来封装映射表的键 / 值对；Segment 用来充当锁的角色，每个 Segment 对象守护整个散列映射表的若干个桶。每个桶是由若干个 HashEntry 对象链接起来的链表。一个 ConcurrentHashMap 实例中包含由若干个 Segment 对象组成的数组。*声明*: 以下源码是针对 `JDK 1.6`\n\n## ConcurrentHashMap 类\n\nConcurrentHashMap 在默认并发级别会创建包含 16 个 Segment 对象的数组。每个 Segment 的成员对象 table 包含若干个散列表的桶。每个桶是由 HashEntry 链接起来的一个链表。如果键能均匀散列，每个 Segment 大约守护整个散列表中桶总数的 1/16。\n\n```java\npublic class ConcurrentHashMap<K, V> extends AbstractMap<K, V> \n       implements ConcurrentMap<K, V>, Serializable { \n \n   /** \n    * 散列映射表的默认初始容量为 16，即初始默认为 16 个桶\n    * 在构造函数中没有指定这个参数时，使用本参数\n    */ \n   static final     int DEFAULT_INITIAL_CAPACITY= 16; \n \n   /** \n    * 散列映射表的默认装载因子为 0.75，该值是 table 中包含的 HashEntry 元素的个数与\n* table 数组长度的比值\n    * 当 table 中包含的 HashEntry 元素的个数超过了 table 数组的长度与装载因子的乘积时，\n* 将触发 再散列\n    * 在构造函数中没有指定这个参数时，使用本参数\n    */ \n   static final float DEFAULT_LOAD_FACTOR= 0.75f; \n \n   /** \n    * 散列表的默认并发级别为 16。该值表示当前更新线程的估计数\n    * 在构造函数中没有指定这个参数时，使用本参数\n    */ \n   static final int DEFAULT_CONCURRENCY_LEVEL= 16; \n \n   /** \n    * segments 的掩码值\n    * key 的散列码的高位用来选择具体的 segment \n    */ \n   final int segmentMask; \n \n   /** \n    * 偏移量\n    */ \n   final int segmentShift; \n \n   /** \n    * 由 Segment 对象组成的数组\n    */ \n   final Segment<K,V>[] segments; \n \n   /** \n    * 创建一个带有指定初始容量、加载因子和并发级别的新的空映射。\n    */ \n   public ConcurrentHashMap(int initialCapacity, \n                            float loadFactor, int concurrencyLevel) { \n       if(!(loadFactor > 0) || initialCapacity < 0 || \nconcurrencyLevel <= 0) \n           throw new IllegalArgumentException(); \n \n       if(concurrencyLevel > MAX_SEGMENTS) \n           concurrencyLevel = MAX_SEGMENTS; \n \n       // 寻找最佳匹配参数（不小于给定参数的最接近的 2 次幂） \n       int sshift = 0; \n       int ssize = 1; \n       while(ssize < concurrencyLevel) { \n           ++sshift; \n           ssize <<= 1; \n       } \n       segmentShift = 32 - sshift;       // 偏移量值\n       segmentMask = ssize - 1;           // 掩码值 \n       this.segments = Segment.newArray(ssize);   // 创建数组\n \n       if (initialCapacity > MAXIMUM_CAPACITY) \n           initialCapacity = MAXIMUM_CAPACITY; \n       int c = initialCapacity / ssize; \n       if(c * ssize < initialCapacity) \n           ++c; \n       int cap = 1; \n       while(cap < c) \n           cap <<= 1; \n \n       // 依次遍历每个数组元素\n       for(int i = 0; i < this.segments.length; ++i) \n           // 初始化每个数组元素引用的 Segment 对象\nthis.segments[i] = new Segment<K,V>(cap, loadFactor); \n   } \n \n   /** \n    * 创建一个带有默认初始容量 (16)、默认加载因子 (0.75) 和 默认并发级别 (16) \n * 的空散列映射表。\n    */ \n   public ConcurrentHashMap() { \n       // 使用三个默认参数，调用上面重载的构造函数来创建空散列映射表\nthis(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL); \n}\n```\n\n结构示意图：\n\n![ConcurrentHashMap](/images/concurrentHashMap/image005.jpg)\n\n## HashEntry 类\n\nHashEntry 用来封装散列映射表中的键值对。在 HashEntry 类中，key，hash 和 next 域都被声明为 final 型，value 域被声明为 volatile 型。\n\n```java\nstatic final class HashEntry<K,V> { \n       final K key;                       // 声明 key 为 final 型\n       final int hash;                   // 声明 hash 值为 final 型 \n       volatile V value;                 // 声明 value 为 volatile 型\n       final HashEntry<K,V> next;      // 声明 next 为 final 型 \n \n       HashEntry(K key, int hash, HashEntry<K,V> next, V value) { \n           this.key = key; \n           this.hash = hash; \n           this.next = next; \n           this.value = value; \n       } \n}\n```\n\n在 ConcurrentHashMap 中，在散列时如果产生“碰撞”，将采用“分离链接法”来处理“碰撞”：把“碰撞”的 HashEntry 对象链接成一个链表。由于 HashEntry 的 next 域为 final 型，所以新节点只能在链表的表头处插入。\n\n## Segment 类\n\nSegment 类继承于 ReentrantLock 类，从而使得 Segment 对象能充当锁的角色。每个 Segment 对象用来守护其（成员对象 table 中）包含的若干个桶。\n\ntable 是一个由 HashEntry 对象组成的数组。table 数组的每一个数组成员就是散列映射表的一个桶。\n\ncount 变量是一个计数器，它表示每个 Segment 对象管理的 table 数组（若干个 HashEntry 组成的链表）包含的 HashEntry 对象的个数。每一个 Segment 对象都有一个 count 对象来表示本 Segment 中包含的 HashEntry 对象的总数。注意，之所以在每个 Segment 对象中包含一个计数器，而不是在 `ConcurrentHashMap 中使用全局的计数器，是为了避免出现“热点域”而影响 ConcurrentHashMap 的并发性。`\n\n```java\nstatic final class Segment<K,V> extends ReentrantLock implements Serializable { \n       /** \n        * 在本 segment 范围内，包含的 HashEntry 元素的个数\n        * 该变量被声明为 volatile 型\n        */ \n       transient volatile int count; \n \n       /** \n        * table 被更新的次数\n        */ \n       transient int modCount; \n \n       /** \n        * 当 table 中包含的 HashEntry 元素的个数超过本变量值时，触发 table 的再散列\n        */ \n       transient int threshold; \n \n       /** \n        * table 是由 HashEntry 对象组成的数组\n        * 如果散列时发生碰撞，碰撞的 HashEntry 对象就以链表的形式链接成一个链表\n        * table 数组的数组成员代表散列映射表的一个桶\n        * 每个 table 守护整个 ConcurrentHashMap 包含桶总数的一部分\n        * 如果并发级别为 16，table 则守护 ConcurrentHashMap 包含的桶总数的 1/16 \n        */ \n       transient volatile HashEntry<K,V>[] table; \n \n       /** \n        * 装载因子\n        */ \n       final float loadFactor; \n \n       Segment(int initialCapacity, float lf) { \n           loadFactor = lf; \n           setTable(HashEntry.<K,V>newArray(initialCapacity)); \n       } \n \n       /** \n        * 设置 table 引用到这个新生成的 HashEntry 数组\n        * 只能在持有锁或构造函数中调用本方法\n        */ \n       void setTable(HashEntry<K,V>[] newTable) { \n           // 计算临界阀值为新数组的长度与装载因子的乘积\n           threshold = (int)(newTable.length * loadFactor); \n           table = newTable; \n       } \n \n       /** \n        * 根据 key 的散列值，找到 table 中对应的那个桶（table 数组的某个数组成员）\n        */ \n       HashEntry<K,V> getFirst(int hash) { \n           HashEntry<K,V>[] tab = table; \n           // 把散列值与 table 数组长度减 1 的值相“与”，\n// 得到散列值对应的 table 数组的下标\n           // 然后返回 table 数组中此下标对应的 HashEntry 元素\n           return tab[hash & (tab.length - 1)]; \n       } \n}\n```\n\n插入三个节点后 Segment 的结构示意图：\n\n![Segment](/images/concurrentHashMap/image004.jpg)\n\n## Put 方法的实现\n\n1.根据 key 计算出对应的 hash 值：\n\n```java\npublic V put(K key, V value) { \n       if (value == null)          //ConcurrentHashMap 中不允许用 null 作为映射值\n           throw new NullPointerException(); \n       int hash = hash(key.hashCode());        // 计算键对应的散列码\n       // 根据散列码找到对应的 Segment \n       return segmentFor(hash).put(key, hash, value, false); \n}\n```\n\n2.根据 hash 值找到对应的 Segment:\n\n```java\n/** \n    * 使用 key 的散列码来得到 segments 数组中对应的 Segment \n    */ \nfinal Segment<K,V> segmentFor(int hash) { \n   // 将散列值右移 segmentShift 个位，并在高位填充 0 \n   // 然后把得到的值与 segmentMask 相“与”\n// 从而得到 hash 值对应的 segments 数组的下标值\n// 最后根据下标值返回散列码对应的 Segment 对象\n       return segments[(hash >>> segmentShift) & segmentMask]; \n}\n```\n\n3.在 Segment 中执行具体的 put 操作\n\n```java\nV put(K key, int hash, V value, boolean onlyIfAbsent) { \n           lock();  // 加锁，这里是锁定某个 Segment 对象而非整个 ConcurrentHashMap \n           try { \n               int c = count; \n \n               if (c++ > threshold)     // 如果超过再散列的阈值\n                   rehash();              // 执行再散列，table 数组的长度将扩充一倍\n \n               HashEntry<K,V>[] tab = table; \n               // 把散列码值与 table 数组的长度减 1 的值相“与”\n               // 得到该散列码对应的 table 数组的下标值\n               int index = hash & (tab.length - 1); \n               // 找到散列码对应的具体的那个桶\n               HashEntry<K,V> first = tab[index]; \n \n               HashEntry<K,V> e = first; \n               while (e != null && (e.hash != hash || !key.equals(e.key))) \n                   e = e.next; \n \n               V oldValue; \n               if (e != null) {            // 如果键 / 值对以经存在\n                   oldValue = e.value; \n                   if (!onlyIfAbsent) \n                       e.value = value;    // 设置 value 值\n               } \n               else {                        // 键 / 值对不存在 \n                   oldValue = null; \n                   ++modCount;         // 要添加新节点到链表中，所以 modCont 要加 1  \n                   // 创建新节点，并添加到链表的头部 \n                   tab[index] = new HashEntry<K,V>(key, hash, first, value); \n                   count = c;               // 写 count 变量\n               } \n               return oldValue; \n           } finally { \n               unlock();                     // 解锁\n           } \n       }\n```\n\n加锁操作是针对（键的 hash 值对应的）某个具体的 Segment，锁定的是该 Segment 而不是整个 ConcurrentHashMap`。因为插入键 / 值对操作只是在这个 Segment 包含的某个桶中完成，不需要锁定整个`ConcurrentHashMap。`此时，其他写线程对另外 15 个`Segment 的加锁并不会因为当前线程对这个 Segment 的加锁而阻塞。同时，所有读线程几乎不会因本线程的加锁而阻塞（除非读线程刚好读到这个 Segment 中某个 `HashEntry 的 value 域的值为 null，此时需要加锁后重新读取该值`）。\n\n相比较于 `HashTable 和由同步包装器包装的 HashMap``每次只能有一个线程执行读或写操作，`ConcurrentHashMap 在并发访问性能上有了质的提高。*在理想状态下*，ConcurrentHashMap 可以支持 16 个线程执行并发写操作（如果并发级别设置为 16），及任意数量线程的读操作。\n\n# 总结\n\nConcurrentHashMap 是一个并发散列映射表的实现，它允许完全并发的读取，并且支持给定数量的并发更新。相比于 `HashTable 和`用同步包装器包装的 HashMap（Collections.synchronizedMap(new HashMap())），ConcurrentHashMap 拥有更高的并发性。在 `HashTable 和由同步包装器包装的 HashMap 中，使用一个全局的锁来同步不同线程间的并发访问。同一时间点，只能有一个线程持有锁，也就是说在同一时间点，只能有一个线程能访问容器。这虽然保证多线程间的安全并发访问，但同时也导致对容器的访问变成``*串行化*``的了。`\n\n在使用锁来协调多线程间并发访问的模式下，减小对锁的竞争可以有效提高并发性。有两种方式可以减小对锁的竞争：\n\n1. 减小请求 同一个锁的 频率。\n2. 减少持有锁的 时间。\n\nConcurrentHashMap 的高并发性主要来自于三个方面：\n\n1. 用分离锁实现多个线程间的更深层次的共享访问。\n2. 用 HashEntery 对象的不变性来降低执行读操作的线程在遍历链表期间对加锁的需求。\n3. 通过对同一个 Volatile 变量的写 / 读访问，协调不同线程间读 / 写操作的内存可见性。\n\n使用分离锁，减小了请求 *同一个锁*的频率。\n\n通过 HashEntery 对象的不变性及对同一个 Volatile 变量的读 / 写来协调内存可见性，使得 读操作大多数时候不需要加锁就能成功获取到需要的值。由于散列映射表在实际应用中大多数操作都是成功的 读操作，所以 2 和 3 既可以减少请求同一个锁的频率，也可以有效减少持有锁的时间。\n\n通过减小请求同一个锁的频率和尽量减少持有锁的时间 `，使得 ConcurrentHashMap 的并发性相对于 HashTable 和`用同步包装器包装的 HashMap`有了质的提高。`\n\n","slug":"ConcurrentHashMap","published":1,"updated":"2018-04-20T10:18:31.417Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgiyu41q000048kc7hmxes7v","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>ConcurrentHashMap 是 util.concurrent 包的重要成员。本文将结合 Java 内存模型，分析 JDK 源代码，探索 ConcurrentHashMap 高并发的具体实现机制。</p>\n<a id=\"more\"></a>\n<h1 id=\"结构分析\"><a href=\"#结构分析\" class=\"headerlink\" title=\"结构分析\"></a>结构分析</h1><p>ConcurrentHashMap 类中包含两个静态内部类 HashEntry 和 Segment。HashEntry 用来封装映射表的键 / 值对；Segment 用来充当锁的角色，每个 Segment 对象守护整个散列映射表的若干个桶。每个桶是由若干个 HashEntry 对象链接起来的链表。一个 ConcurrentHashMap 实例中包含由若干个 Segment 对象组成的数组。<em>声明</em>: 以下源码是针对 <code>JDK 1.6</code></p>\n<h2 id=\"ConcurrentHashMap-类\"><a href=\"#ConcurrentHashMap-类\" class=\"headerlink\" title=\"ConcurrentHashMap 类\"></a>ConcurrentHashMap 类</h2><p>ConcurrentHashMap 在默认并发级别会创建包含 16 个 Segment 对象的数组。每个 Segment 的成员对象 table 包含若干个散列表的桶。每个桶是由 HashEntry 链接起来的一个链表。如果键能均匀散列，每个 Segment 大约守护整个散列表中桶总数的 1/16。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcurrentHashMap</span>&lt;<span class=\"title\">K</span>, <span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AbstractMap</span>&lt;<span class=\"title\">K</span>, <span class=\"title\">V</span>&gt; </span></span><br><span class=\"line\"><span class=\"class\">       <span class=\"keyword\">implements</span> <span class=\"title\">ConcurrentMap</span>&lt;<span class=\"title\">K</span>, <span class=\"title\">V</span>&gt;, <span class=\"title\">Serializable</span> </span>&#123; </span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * 散列映射表的默认初始容量为 16，即初始默认为 16 个桶</span></span><br><span class=\"line\"><span class=\"comment\">    * 在构造函数中没有指定这个参数时，使用本参数</span></span><br><span class=\"line\"><span class=\"comment\">    */</span> </span><br><span class=\"line\">   <span class=\"keyword\">static</span> <span class=\"keyword\">final</span>     <span class=\"keyword\">int</span> DEFAULT_INITIAL_CAPACITY= <span class=\"number\">16</span>; </span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * 散列映射表的默认装载因子为 0.75，该值是 table 中包含的 HashEntry 元素的个数与</span></span><br><span class=\"line\"><span class=\"comment\">* table 数组长度的比值</span></span><br><span class=\"line\"><span class=\"comment\">    * 当 table 中包含的 HashEntry 元素的个数超过了 table 数组的长度与装载因子的乘积时，</span></span><br><span class=\"line\"><span class=\"comment\">* 将触发 再散列</span></span><br><span class=\"line\"><span class=\"comment\">    * 在构造函数中没有指定这个参数时，使用本参数</span></span><br><span class=\"line\"><span class=\"comment\">    */</span> </span><br><span class=\"line\">   <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> DEFAULT_LOAD_FACTOR= <span class=\"number\">0.75f</span>; </span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * 散列表的默认并发级别为 16。该值表示当前更新线程的估计数</span></span><br><span class=\"line\"><span class=\"comment\">    * 在构造函数中没有指定这个参数时，使用本参数</span></span><br><span class=\"line\"><span class=\"comment\">    */</span> </span><br><span class=\"line\">   <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_CONCURRENCY_LEVEL= <span class=\"number\">16</span>; </span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * segments 的掩码值</span></span><br><span class=\"line\"><span class=\"comment\">    * key 的散列码的高位用来选择具体的 segment </span></span><br><span class=\"line\"><span class=\"comment\">    */</span> </span><br><span class=\"line\">   <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> segmentMask; </span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * 偏移量</span></span><br><span class=\"line\"><span class=\"comment\">    */</span> </span><br><span class=\"line\">   <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> segmentShift; </span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * 由 Segment 对象组成的数组</span></span><br><span class=\"line\"><span class=\"comment\">    */</span> </span><br><span class=\"line\">   <span class=\"keyword\">final</span> Segment&lt;K,V&gt;[] segments; </span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * 创建一个带有指定初始容量、加载因子和并发级别的新的空映射。</span></span><br><span class=\"line\"><span class=\"comment\">    */</span> </span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ConcurrentHashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                            <span class=\"keyword\">float</span> loadFactor, <span class=\"keyword\">int</span> concurrencyLevel)</span> </span>&#123; </span><br><span class=\"line\">       <span class=\"keyword\">if</span>(!(loadFactor &gt; <span class=\"number\">0</span>) || initialCapacity &lt; <span class=\"number\">0</span> || </span><br><span class=\"line\">concurrencyLevel &lt;= <span class=\"number\">0</span>) </span><br><span class=\"line\">           <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(); </span><br><span class=\"line\"> </span><br><span class=\"line\">       <span class=\"keyword\">if</span>(concurrencyLevel &gt; MAX_SEGMENTS) </span><br><span class=\"line\">           concurrencyLevel = MAX_SEGMENTS; </span><br><span class=\"line\"> </span><br><span class=\"line\">       <span class=\"comment\">// 寻找最佳匹配参数（不小于给定参数的最接近的 2 次幂） </span></span><br><span class=\"line\">       <span class=\"keyword\">int</span> sshift = <span class=\"number\">0</span>; </span><br><span class=\"line\">       <span class=\"keyword\">int</span> ssize = <span class=\"number\">1</span>; </span><br><span class=\"line\">       <span class=\"keyword\">while</span>(ssize &lt; concurrencyLevel) &#123; </span><br><span class=\"line\">           ++sshift; </span><br><span class=\"line\">           ssize &lt;&lt;= <span class=\"number\">1</span>; </span><br><span class=\"line\">       &#125; </span><br><span class=\"line\">       segmentShift = <span class=\"number\">32</span> - sshift;       <span class=\"comment\">// 偏移量值</span></span><br><span class=\"line\">       segmentMask = ssize - <span class=\"number\">1</span>;           <span class=\"comment\">// 掩码值 </span></span><br><span class=\"line\">       <span class=\"keyword\">this</span>.segments = Segment.newArray(ssize);   <span class=\"comment\">// 创建数组</span></span><br><span class=\"line\"> </span><br><span class=\"line\">       <span class=\"keyword\">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY) </span><br><span class=\"line\">           initialCapacity = MAXIMUM_CAPACITY; </span><br><span class=\"line\">       <span class=\"keyword\">int</span> c = initialCapacity / ssize; </span><br><span class=\"line\">       <span class=\"keyword\">if</span>(c * ssize &lt; initialCapacity) </span><br><span class=\"line\">           ++c; </span><br><span class=\"line\">       <span class=\"keyword\">int</span> cap = <span class=\"number\">1</span>; </span><br><span class=\"line\">       <span class=\"keyword\">while</span>(cap &lt; c) </span><br><span class=\"line\">           cap &lt;&lt;= <span class=\"number\">1</span>; </span><br><span class=\"line\"> </span><br><span class=\"line\">       <span class=\"comment\">// 依次遍历每个数组元素</span></span><br><span class=\"line\">       <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">this</span>.segments.length; ++i) </span><br><span class=\"line\">           <span class=\"comment\">// 初始化每个数组元素引用的 Segment 对象</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.segments[i] = <span class=\"keyword\">new</span> Segment&lt;K,V&gt;(cap, loadFactor); </span><br><span class=\"line\">   &#125; </span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * 创建一个带有默认初始容量 (16)、默认加载因子 (0.75) 和 默认并发级别 (16) </span></span><br><span class=\"line\"><span class=\"comment\"> * 的空散列映射表。</span></span><br><span class=\"line\"><span class=\"comment\">    */</span> </span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ConcurrentHashMap</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">       <span class=\"comment\">// 使用三个默认参数，调用上面重载的构造函数来创建空散列映射表</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结构示意图：</p>\n<p><img src=\"/images/concurrentHashMap/image005.jpg\" alt=\"ConcurrentHashMap\"></p>\n<h2 id=\"HashEntry-类\"><a href=\"#HashEntry-类\" class=\"headerlink\" title=\"HashEntry 类\"></a>HashEntry 类</h2><p>HashEntry 用来封装散列映射表中的键值对。在 HashEntry 类中，key，hash 和 next 域都被声明为 final 型，value 域被声明为 volatile 型。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashEntry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123; </span><br><span class=\"line\">       <span class=\"keyword\">final</span> K key;                       <span class=\"comment\">// 声明 key 为 final 型</span></span><br><span class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> hash;                   <span class=\"comment\">// 声明 hash 值为 final 型 </span></span><br><span class=\"line\">       <span class=\"keyword\">volatile</span> V value;                 <span class=\"comment\">// 声明 value 为 volatile 型</span></span><br><span class=\"line\">       <span class=\"keyword\">final</span> HashEntry&lt;K,V&gt; next;      <span class=\"comment\">// 声明 next 为 final 型 </span></span><br><span class=\"line\"> </span><br><span class=\"line\">       HashEntry(K key, <span class=\"keyword\">int</span> hash, HashEntry&lt;K,V&gt; next, V value) &#123; </span><br><span class=\"line\">           <span class=\"keyword\">this</span>.key = key; </span><br><span class=\"line\">           <span class=\"keyword\">this</span>.hash = hash; </span><br><span class=\"line\">           <span class=\"keyword\">this</span>.next = next; </span><br><span class=\"line\">           <span class=\"keyword\">this</span>.value = value; </span><br><span class=\"line\">       &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 ConcurrentHashMap 中，在散列时如果产生“碰撞”，将采用“分离链接法”来处理“碰撞”：把“碰撞”的 HashEntry 对象链接成一个链表。由于 HashEntry 的 next 域为 final 型，所以新节点只能在链表的表头处插入。</p>\n<h2 id=\"Segment-类\"><a href=\"#Segment-类\" class=\"headerlink\" title=\"Segment 类\"></a>Segment 类</h2><p>Segment 类继承于 ReentrantLock 类，从而使得 Segment 对象能充当锁的角色。每个 Segment 对象用来守护其（成员对象 table 中）包含的若干个桶。</p>\n<p>table 是一个由 HashEntry 对象组成的数组。table 数组的每一个数组成员就是散列映射表的一个桶。</p>\n<p>count 变量是一个计数器，它表示每个 Segment 对象管理的 table 数组（若干个 HashEntry 组成的链表）包含的 HashEntry 对象的个数。每一个 Segment 对象都有一个 count 对象来表示本 Segment 中包含的 HashEntry 对象的总数。注意，之所以在每个 Segment 对象中包含一个计数器，而不是在 <code>ConcurrentHashMap 中使用全局的计数器，是为了避免出现“热点域”而影响 ConcurrentHashMap 的并发性。</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Segment</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">ReentrantLock</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span> </span>&#123; </span><br><span class=\"line\">       <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">        * 在本 segment 范围内，包含的 HashEntry 元素的个数</span></span><br><span class=\"line\"><span class=\"comment\">        * 该变量被声明为 volatile 型</span></span><br><span class=\"line\"><span class=\"comment\">        */</span> </span><br><span class=\"line\">       <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> count; </span><br><span class=\"line\"> </span><br><span class=\"line\">       <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">        * table 被更新的次数</span></span><br><span class=\"line\"><span class=\"comment\">        */</span> </span><br><span class=\"line\">       <span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> modCount; </span><br><span class=\"line\"> </span><br><span class=\"line\">       <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">        * 当 table 中包含的 HashEntry 元素的个数超过本变量值时，触发 table 的再散列</span></span><br><span class=\"line\"><span class=\"comment\">        */</span> </span><br><span class=\"line\">       <span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> threshold; </span><br><span class=\"line\"> </span><br><span class=\"line\">       <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">        * table 是由 HashEntry 对象组成的数组</span></span><br><span class=\"line\"><span class=\"comment\">        * 如果散列时发生碰撞，碰撞的 HashEntry 对象就以链表的形式链接成一个链表</span></span><br><span class=\"line\"><span class=\"comment\">        * table 数组的数组成员代表散列映射表的一个桶</span></span><br><span class=\"line\"><span class=\"comment\">        * 每个 table 守护整个 ConcurrentHashMap 包含桶总数的一部分</span></span><br><span class=\"line\"><span class=\"comment\">        * 如果并发级别为 16，table 则守护 ConcurrentHashMap 包含的桶总数的 1/16 </span></span><br><span class=\"line\"><span class=\"comment\">        */</span> </span><br><span class=\"line\">       <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> HashEntry&lt;K,V&gt;[] table; </span><br><span class=\"line\"> </span><br><span class=\"line\">       <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">        * 装载因子</span></span><br><span class=\"line\"><span class=\"comment\">        */</span> </span><br><span class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> loadFactor; </span><br><span class=\"line\"> </span><br><span class=\"line\">       Segment(<span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">float</span> lf) &#123; </span><br><span class=\"line\">           loadFactor = lf; </span><br><span class=\"line\">           setTable(HashEntry.&lt;K,V&gt;newArray(initialCapacity)); </span><br><span class=\"line\">       &#125; </span><br><span class=\"line\"> </span><br><span class=\"line\">       <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">        * 设置 table 引用到这个新生成的 HashEntry 数组</span></span><br><span class=\"line\"><span class=\"comment\">        * 只能在持有锁或构造函数中调用本方法</span></span><br><span class=\"line\"><span class=\"comment\">        */</span> </span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setTable</span><span class=\"params\">(HashEntry&lt;K,V&gt;[] newTable)</span> </span>&#123; </span><br><span class=\"line\">           <span class=\"comment\">// 计算临界阀值为新数组的长度与装载因子的乘积</span></span><br><span class=\"line\">           threshold = (<span class=\"keyword\">int</span>)(newTable.length * loadFactor); </span><br><span class=\"line\">           table = newTable; </span><br><span class=\"line\">       &#125; </span><br><span class=\"line\"> </span><br><span class=\"line\">       <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">        * 根据 key 的散列值，找到 table 中对应的那个桶（table 数组的某个数组成员）</span></span><br><span class=\"line\"><span class=\"comment\">        */</span> </span><br><span class=\"line\">       <span class=\"function\">HashEntry&lt;K,V&gt; <span class=\"title\">getFirst</span><span class=\"params\">(<span class=\"keyword\">int</span> hash)</span> </span>&#123; </span><br><span class=\"line\">           HashEntry&lt;K,V&gt;[] tab = table; </span><br><span class=\"line\">           <span class=\"comment\">// 把散列值与 table 数组长度减 1 的值相“与”，</span></span><br><span class=\"line\"><span class=\"comment\">// 得到散列值对应的 table 数组的下标</span></span><br><span class=\"line\">           <span class=\"comment\">// 然后返回 table 数组中此下标对应的 HashEntry 元素</span></span><br><span class=\"line\">           <span class=\"keyword\">return</span> tab[hash &amp; (tab.length - <span class=\"number\">1</span>)]; </span><br><span class=\"line\">       &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>插入三个节点后 Segment 的结构示意图：</p>\n<p><img src=\"/images/concurrentHashMap/image004.jpg\" alt=\"Segment\"></p>\n<h2 id=\"Put-方法的实现\"><a href=\"#Put-方法的实现\" class=\"headerlink\" title=\"Put 方法的实现\"></a>Put 方法的实现</h2><p>1.根据 key 计算出对应的 hash 值：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123; </span><br><span class=\"line\">       <span class=\"keyword\">if</span> (value == <span class=\"keyword\">null</span>)          <span class=\"comment\">//ConcurrentHashMap 中不允许用 null 作为映射值</span></span><br><span class=\"line\">           <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(); </span><br><span class=\"line\">       <span class=\"keyword\">int</span> hash = hash(key.hashCode());        <span class=\"comment\">// 计算键对应的散列码</span></span><br><span class=\"line\">       <span class=\"comment\">// 根据散列码找到对应的 Segment </span></span><br><span class=\"line\">       <span class=\"keyword\">return</span> segmentFor(hash).put(key, hash, value, <span class=\"keyword\">false</span>); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2.根据 hash 值找到对应的 Segment:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * 使用 key 的散列码来得到 segments 数组中对应的 Segment </span></span><br><span class=\"line\"><span class=\"comment\">    */</span> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Segment&lt;K,V&gt; <span class=\"title\">segmentFor</span><span class=\"params\">(<span class=\"keyword\">int</span> hash)</span> </span>&#123; </span><br><span class=\"line\">   <span class=\"comment\">// 将散列值右移 segmentShift 个位，并在高位填充 0 </span></span><br><span class=\"line\">   <span class=\"comment\">// 然后把得到的值与 segmentMask 相“与”</span></span><br><span class=\"line\"><span class=\"comment\">// 从而得到 hash 值对应的 segments 数组的下标值</span></span><br><span class=\"line\"><span class=\"comment\">// 最后根据下标值返回散列码对应的 Segment 对象</span></span><br><span class=\"line\">       <span class=\"keyword\">return</span> segments[(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask]; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>3.在 Segment 中执行具体的 put 操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">V <span class=\"title\">put</span><span class=\"params\">(K key, <span class=\"keyword\">int</span> hash, V value, <span class=\"keyword\">boolean</span> onlyIfAbsent)</span> </span>&#123; </span><br><span class=\"line\">           lock();  <span class=\"comment\">// 加锁，这里是锁定某个 Segment 对象而非整个 ConcurrentHashMap </span></span><br><span class=\"line\">           <span class=\"keyword\">try</span> &#123; </span><br><span class=\"line\">               <span class=\"keyword\">int</span> c = count; </span><br><span class=\"line\"> </span><br><span class=\"line\">               <span class=\"keyword\">if</span> (c++ &gt; threshold)     <span class=\"comment\">// 如果超过再散列的阈值</span></span><br><span class=\"line\">                   rehash();              <span class=\"comment\">// 执行再散列，table 数组的长度将扩充一倍</span></span><br><span class=\"line\"> </span><br><span class=\"line\">               HashEntry&lt;K,V&gt;[] tab = table; </span><br><span class=\"line\">               <span class=\"comment\">// 把散列码值与 table 数组的长度减 1 的值相“与”</span></span><br><span class=\"line\">               <span class=\"comment\">// 得到该散列码对应的 table 数组的下标值</span></span><br><span class=\"line\">               <span class=\"keyword\">int</span> index = hash &amp; (tab.length - <span class=\"number\">1</span>); </span><br><span class=\"line\">               <span class=\"comment\">// 找到散列码对应的具体的那个桶</span></span><br><span class=\"line\">               HashEntry&lt;K,V&gt; first = tab[index]; </span><br><span class=\"line\"> </span><br><span class=\"line\">               HashEntry&lt;K,V&gt; e = first; </span><br><span class=\"line\">               <span class=\"keyword\">while</span> (e != <span class=\"keyword\">null</span> &amp;&amp; (e.hash != hash || !key.equals(e.key))) </span><br><span class=\"line\">                   e = e.next; </span><br><span class=\"line\"> </span><br><span class=\"line\">               V oldValue; </span><br><span class=\"line\">               <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123;            <span class=\"comment\">// 如果键 / 值对以经存在</span></span><br><span class=\"line\">                   oldValue = e.value; </span><br><span class=\"line\">                   <span class=\"keyword\">if</span> (!onlyIfAbsent) </span><br><span class=\"line\">                       e.value = value;    <span class=\"comment\">// 设置 value 值</span></span><br><span class=\"line\">               &#125; </span><br><span class=\"line\">               <span class=\"keyword\">else</span> &#123;                        <span class=\"comment\">// 键 / 值对不存在 </span></span><br><span class=\"line\">                   oldValue = <span class=\"keyword\">null</span>; </span><br><span class=\"line\">                   ++modCount;         <span class=\"comment\">// 要添加新节点到链表中，所以 modCont 要加 1  </span></span><br><span class=\"line\">                   <span class=\"comment\">// 创建新节点，并添加到链表的头部 </span></span><br><span class=\"line\">                   tab[index] = <span class=\"keyword\">new</span> HashEntry&lt;K,V&gt;(key, hash, first, value); </span><br><span class=\"line\">                   count = c;               <span class=\"comment\">// 写 count 变量</span></span><br><span class=\"line\">               &#125; </span><br><span class=\"line\">               <span class=\"keyword\">return</span> oldValue; </span><br><span class=\"line\">           &#125; <span class=\"keyword\">finally</span> &#123; </span><br><span class=\"line\">               unlock();                     <span class=\"comment\">// 解锁</span></span><br><span class=\"line\">           &#125; </span><br><span class=\"line\">       &#125;</span><br></pre></td></tr></table></figure>\n<p>加锁操作是针对（键的 hash 值对应的）某个具体的 Segment，锁定的是该 Segment 而不是整个 ConcurrentHashMap<code>。因为插入键 / 值对操作只是在这个 Segment 包含的某个桶中完成，不需要锁定整个</code>ConcurrentHashMap。<code>此时，其他写线程对另外 15 个</code>Segment 的加锁并不会因为当前线程对这个 Segment 的加锁而阻塞。同时，所有读线程几乎不会因本线程的加锁而阻塞（除非读线程刚好读到这个 Segment 中某个 <code>HashEntry 的 value 域的值为 null，此时需要加锁后重新读取该值</code>）。</p>\n<p>相比较于 <code>HashTable 和由同步包装器包装的 HashMap`</code>每次只能有一个线程执行读或写操作，`ConcurrentHashMap 在并发访问性能上有了质的提高。<em>在理想状态下</em>，ConcurrentHashMap 可以支持 16 个线程执行并发写操作（如果并发级别设置为 16），及任意数量线程的读操作。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>ConcurrentHashMap 是一个并发散列映射表的实现，它允许完全并发的读取，并且支持给定数量的并发更新。相比于 <code>HashTable 和</code>用同步包装器包装的 HashMap（Collections.synchronizedMap(new HashMap())），ConcurrentHashMap 拥有更高的并发性。在 <code>HashTable 和由同步包装器包装的 HashMap 中，使用一个全局的锁来同步不同线程间的并发访问。同一时间点，只能有一个线程持有锁，也就是说在同一时间点，只能有一个线程能访问容器。这虽然保证多线程间的安全并发访问，但同时也导致对容器的访问变成`</code><em>串行化</em><code></code>的了。`</p>\n<p>在使用锁来协调多线程间并发访问的模式下，减小对锁的竞争可以有效提高并发性。有两种方式可以减小对锁的竞争：</p>\n<ol>\n<li>减小请求 同一个锁的 频率。</li>\n<li>减少持有锁的 时间。</li>\n</ol>\n<p>ConcurrentHashMap 的高并发性主要来自于三个方面：</p>\n<ol>\n<li>用分离锁实现多个线程间的更深层次的共享访问。</li>\n<li>用 HashEntery 对象的不变性来降低执行读操作的线程在遍历链表期间对加锁的需求。</li>\n<li>通过对同一个 Volatile 变量的写 / 读访问，协调不同线程间读 / 写操作的内存可见性。</li>\n</ol>\n<p>使用分离锁，减小了请求 <em>同一个锁</em>的频率。</p>\n<p>通过 HashEntery 对象的不变性及对同一个 Volatile 变量的读 / 写来协调内存可见性，使得 读操作大多数时候不需要加锁就能成功获取到需要的值。由于散列映射表在实际应用中大多数操作都是成功的 读操作，所以 2 和 3 既可以减少请求同一个锁的频率，也可以有效减少持有锁的时间。</p>\n<p>通过减小请求同一个锁的频率和尽量减少持有锁的时间 <code>，使得 ConcurrentHashMap 的并发性相对于 HashTable 和</code>用同步包装器包装的 HashMap<code>有了质的提高。</code></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>ConcurrentHashMap 是 util.concurrent 包的重要成员。本文将结合 Java 内存模型，分析 JDK 源代码，探索 ConcurrentHashMap 高并发的具体实现机制。</p>","more":"<h1 id=\"结构分析\"><a href=\"#结构分析\" class=\"headerlink\" title=\"结构分析\"></a>结构分析</h1><p>ConcurrentHashMap 类中包含两个静态内部类 HashEntry 和 Segment。HashEntry 用来封装映射表的键 / 值对；Segment 用来充当锁的角色，每个 Segment 对象守护整个散列映射表的若干个桶。每个桶是由若干个 HashEntry 对象链接起来的链表。一个 ConcurrentHashMap 实例中包含由若干个 Segment 对象组成的数组。<em>声明</em>: 以下源码是针对 <code>JDK 1.6</code></p>\n<h2 id=\"ConcurrentHashMap-类\"><a href=\"#ConcurrentHashMap-类\" class=\"headerlink\" title=\"ConcurrentHashMap 类\"></a>ConcurrentHashMap 类</h2><p>ConcurrentHashMap 在默认并发级别会创建包含 16 个 Segment 对象的数组。每个 Segment 的成员对象 table 包含若干个散列表的桶。每个桶是由 HashEntry 链接起来的一个链表。如果键能均匀散列，每个 Segment 大约守护整个散列表中桶总数的 1/16。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcurrentHashMap</span>&lt;<span class=\"title\">K</span>, <span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AbstractMap</span>&lt;<span class=\"title\">K</span>, <span class=\"title\">V</span>&gt; </span></span><br><span class=\"line\"><span class=\"class\">       <span class=\"keyword\">implements</span> <span class=\"title\">ConcurrentMap</span>&lt;<span class=\"title\">K</span>, <span class=\"title\">V</span>&gt;, <span class=\"title\">Serializable</span> </span>&#123; </span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * 散列映射表的默认初始容量为 16，即初始默认为 16 个桶</span></span><br><span class=\"line\"><span class=\"comment\">    * 在构造函数中没有指定这个参数时，使用本参数</span></span><br><span class=\"line\"><span class=\"comment\">    */</span> </span><br><span class=\"line\">   <span class=\"keyword\">static</span> <span class=\"keyword\">final</span>     <span class=\"keyword\">int</span> DEFAULT_INITIAL_CAPACITY= <span class=\"number\">16</span>; </span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * 散列映射表的默认装载因子为 0.75，该值是 table 中包含的 HashEntry 元素的个数与</span></span><br><span class=\"line\"><span class=\"comment\">* table 数组长度的比值</span></span><br><span class=\"line\"><span class=\"comment\">    * 当 table 中包含的 HashEntry 元素的个数超过了 table 数组的长度与装载因子的乘积时，</span></span><br><span class=\"line\"><span class=\"comment\">* 将触发 再散列</span></span><br><span class=\"line\"><span class=\"comment\">    * 在构造函数中没有指定这个参数时，使用本参数</span></span><br><span class=\"line\"><span class=\"comment\">    */</span> </span><br><span class=\"line\">   <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> DEFAULT_LOAD_FACTOR= <span class=\"number\">0.75f</span>; </span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * 散列表的默认并发级别为 16。该值表示当前更新线程的估计数</span></span><br><span class=\"line\"><span class=\"comment\">    * 在构造函数中没有指定这个参数时，使用本参数</span></span><br><span class=\"line\"><span class=\"comment\">    */</span> </span><br><span class=\"line\">   <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_CONCURRENCY_LEVEL= <span class=\"number\">16</span>; </span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * segments 的掩码值</span></span><br><span class=\"line\"><span class=\"comment\">    * key 的散列码的高位用来选择具体的 segment </span></span><br><span class=\"line\"><span class=\"comment\">    */</span> </span><br><span class=\"line\">   <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> segmentMask; </span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * 偏移量</span></span><br><span class=\"line\"><span class=\"comment\">    */</span> </span><br><span class=\"line\">   <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> segmentShift; </span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * 由 Segment 对象组成的数组</span></span><br><span class=\"line\"><span class=\"comment\">    */</span> </span><br><span class=\"line\">   <span class=\"keyword\">final</span> Segment&lt;K,V&gt;[] segments; </span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * 创建一个带有指定初始容量、加载因子和并发级别的新的空映射。</span></span><br><span class=\"line\"><span class=\"comment\">    */</span> </span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ConcurrentHashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                            <span class=\"keyword\">float</span> loadFactor, <span class=\"keyword\">int</span> concurrencyLevel)</span> </span>&#123; </span><br><span class=\"line\">       <span class=\"keyword\">if</span>(!(loadFactor &gt; <span class=\"number\">0</span>) || initialCapacity &lt; <span class=\"number\">0</span> || </span><br><span class=\"line\">concurrencyLevel &lt;= <span class=\"number\">0</span>) </span><br><span class=\"line\">           <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(); </span><br><span class=\"line\"> </span><br><span class=\"line\">       <span class=\"keyword\">if</span>(concurrencyLevel &gt; MAX_SEGMENTS) </span><br><span class=\"line\">           concurrencyLevel = MAX_SEGMENTS; </span><br><span class=\"line\"> </span><br><span class=\"line\">       <span class=\"comment\">// 寻找最佳匹配参数（不小于给定参数的最接近的 2 次幂） </span></span><br><span class=\"line\">       <span class=\"keyword\">int</span> sshift = <span class=\"number\">0</span>; </span><br><span class=\"line\">       <span class=\"keyword\">int</span> ssize = <span class=\"number\">1</span>; </span><br><span class=\"line\">       <span class=\"keyword\">while</span>(ssize &lt; concurrencyLevel) &#123; </span><br><span class=\"line\">           ++sshift; </span><br><span class=\"line\">           ssize &lt;&lt;= <span class=\"number\">1</span>; </span><br><span class=\"line\">       &#125; </span><br><span class=\"line\">       segmentShift = <span class=\"number\">32</span> - sshift;       <span class=\"comment\">// 偏移量值</span></span><br><span class=\"line\">       segmentMask = ssize - <span class=\"number\">1</span>;           <span class=\"comment\">// 掩码值 </span></span><br><span class=\"line\">       <span class=\"keyword\">this</span>.segments = Segment.newArray(ssize);   <span class=\"comment\">// 创建数组</span></span><br><span class=\"line\"> </span><br><span class=\"line\">       <span class=\"keyword\">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY) </span><br><span class=\"line\">           initialCapacity = MAXIMUM_CAPACITY; </span><br><span class=\"line\">       <span class=\"keyword\">int</span> c = initialCapacity / ssize; </span><br><span class=\"line\">       <span class=\"keyword\">if</span>(c * ssize &lt; initialCapacity) </span><br><span class=\"line\">           ++c; </span><br><span class=\"line\">       <span class=\"keyword\">int</span> cap = <span class=\"number\">1</span>; </span><br><span class=\"line\">       <span class=\"keyword\">while</span>(cap &lt; c) </span><br><span class=\"line\">           cap &lt;&lt;= <span class=\"number\">1</span>; </span><br><span class=\"line\"> </span><br><span class=\"line\">       <span class=\"comment\">// 依次遍历每个数组元素</span></span><br><span class=\"line\">       <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">this</span>.segments.length; ++i) </span><br><span class=\"line\">           <span class=\"comment\">// 初始化每个数组元素引用的 Segment 对象</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.segments[i] = <span class=\"keyword\">new</span> Segment&lt;K,V&gt;(cap, loadFactor); </span><br><span class=\"line\">   &#125; </span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * 创建一个带有默认初始容量 (16)、默认加载因子 (0.75) 和 默认并发级别 (16) </span></span><br><span class=\"line\"><span class=\"comment\"> * 的空散列映射表。</span></span><br><span class=\"line\"><span class=\"comment\">    */</span> </span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ConcurrentHashMap</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">       <span class=\"comment\">// 使用三个默认参数，调用上面重载的构造函数来创建空散列映射表</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结构示意图：</p>\n<p><img src=\"/images/concurrentHashMap/image005.jpg\" alt=\"ConcurrentHashMap\"></p>\n<h2 id=\"HashEntry-类\"><a href=\"#HashEntry-类\" class=\"headerlink\" title=\"HashEntry 类\"></a>HashEntry 类</h2><p>HashEntry 用来封装散列映射表中的键值对。在 HashEntry 类中，key，hash 和 next 域都被声明为 final 型，value 域被声明为 volatile 型。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashEntry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123; </span><br><span class=\"line\">       <span class=\"keyword\">final</span> K key;                       <span class=\"comment\">// 声明 key 为 final 型</span></span><br><span class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> hash;                   <span class=\"comment\">// 声明 hash 值为 final 型 </span></span><br><span class=\"line\">       <span class=\"keyword\">volatile</span> V value;                 <span class=\"comment\">// 声明 value 为 volatile 型</span></span><br><span class=\"line\">       <span class=\"keyword\">final</span> HashEntry&lt;K,V&gt; next;      <span class=\"comment\">// 声明 next 为 final 型 </span></span><br><span class=\"line\"> </span><br><span class=\"line\">       HashEntry(K key, <span class=\"keyword\">int</span> hash, HashEntry&lt;K,V&gt; next, V value) &#123; </span><br><span class=\"line\">           <span class=\"keyword\">this</span>.key = key; </span><br><span class=\"line\">           <span class=\"keyword\">this</span>.hash = hash; </span><br><span class=\"line\">           <span class=\"keyword\">this</span>.next = next; </span><br><span class=\"line\">           <span class=\"keyword\">this</span>.value = value; </span><br><span class=\"line\">       &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 ConcurrentHashMap 中，在散列时如果产生“碰撞”，将采用“分离链接法”来处理“碰撞”：把“碰撞”的 HashEntry 对象链接成一个链表。由于 HashEntry 的 next 域为 final 型，所以新节点只能在链表的表头处插入。</p>\n<h2 id=\"Segment-类\"><a href=\"#Segment-类\" class=\"headerlink\" title=\"Segment 类\"></a>Segment 类</h2><p>Segment 类继承于 ReentrantLock 类，从而使得 Segment 对象能充当锁的角色。每个 Segment 对象用来守护其（成员对象 table 中）包含的若干个桶。</p>\n<p>table 是一个由 HashEntry 对象组成的数组。table 数组的每一个数组成员就是散列映射表的一个桶。</p>\n<p>count 变量是一个计数器，它表示每个 Segment 对象管理的 table 数组（若干个 HashEntry 组成的链表）包含的 HashEntry 对象的个数。每一个 Segment 对象都有一个 count 对象来表示本 Segment 中包含的 HashEntry 对象的总数。注意，之所以在每个 Segment 对象中包含一个计数器，而不是在 <code>ConcurrentHashMap 中使用全局的计数器，是为了避免出现“热点域”而影响 ConcurrentHashMap 的并发性。</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Segment</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">ReentrantLock</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span> </span>&#123; </span><br><span class=\"line\">       <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">        * 在本 segment 范围内，包含的 HashEntry 元素的个数</span></span><br><span class=\"line\"><span class=\"comment\">        * 该变量被声明为 volatile 型</span></span><br><span class=\"line\"><span class=\"comment\">        */</span> </span><br><span class=\"line\">       <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> count; </span><br><span class=\"line\"> </span><br><span class=\"line\">       <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">        * table 被更新的次数</span></span><br><span class=\"line\"><span class=\"comment\">        */</span> </span><br><span class=\"line\">       <span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> modCount; </span><br><span class=\"line\"> </span><br><span class=\"line\">       <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">        * 当 table 中包含的 HashEntry 元素的个数超过本变量值时，触发 table 的再散列</span></span><br><span class=\"line\"><span class=\"comment\">        */</span> </span><br><span class=\"line\">       <span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> threshold; </span><br><span class=\"line\"> </span><br><span class=\"line\">       <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">        * table 是由 HashEntry 对象组成的数组</span></span><br><span class=\"line\"><span class=\"comment\">        * 如果散列时发生碰撞，碰撞的 HashEntry 对象就以链表的形式链接成一个链表</span></span><br><span class=\"line\"><span class=\"comment\">        * table 数组的数组成员代表散列映射表的一个桶</span></span><br><span class=\"line\"><span class=\"comment\">        * 每个 table 守护整个 ConcurrentHashMap 包含桶总数的一部分</span></span><br><span class=\"line\"><span class=\"comment\">        * 如果并发级别为 16，table 则守护 ConcurrentHashMap 包含的桶总数的 1/16 </span></span><br><span class=\"line\"><span class=\"comment\">        */</span> </span><br><span class=\"line\">       <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> HashEntry&lt;K,V&gt;[] table; </span><br><span class=\"line\"> </span><br><span class=\"line\">       <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">        * 装载因子</span></span><br><span class=\"line\"><span class=\"comment\">        */</span> </span><br><span class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> loadFactor; </span><br><span class=\"line\"> </span><br><span class=\"line\">       Segment(<span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">float</span> lf) &#123; </span><br><span class=\"line\">           loadFactor = lf; </span><br><span class=\"line\">           setTable(HashEntry.&lt;K,V&gt;newArray(initialCapacity)); </span><br><span class=\"line\">       &#125; </span><br><span class=\"line\"> </span><br><span class=\"line\">       <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">        * 设置 table 引用到这个新生成的 HashEntry 数组</span></span><br><span class=\"line\"><span class=\"comment\">        * 只能在持有锁或构造函数中调用本方法</span></span><br><span class=\"line\"><span class=\"comment\">        */</span> </span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setTable</span><span class=\"params\">(HashEntry&lt;K,V&gt;[] newTable)</span> </span>&#123; </span><br><span class=\"line\">           <span class=\"comment\">// 计算临界阀值为新数组的长度与装载因子的乘积</span></span><br><span class=\"line\">           threshold = (<span class=\"keyword\">int</span>)(newTable.length * loadFactor); </span><br><span class=\"line\">           table = newTable; </span><br><span class=\"line\">       &#125; </span><br><span class=\"line\"> </span><br><span class=\"line\">       <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">        * 根据 key 的散列值，找到 table 中对应的那个桶（table 数组的某个数组成员）</span></span><br><span class=\"line\"><span class=\"comment\">        */</span> </span><br><span class=\"line\">       <span class=\"function\">HashEntry&lt;K,V&gt; <span class=\"title\">getFirst</span><span class=\"params\">(<span class=\"keyword\">int</span> hash)</span> </span>&#123; </span><br><span class=\"line\">           HashEntry&lt;K,V&gt;[] tab = table; </span><br><span class=\"line\">           <span class=\"comment\">// 把散列值与 table 数组长度减 1 的值相“与”，</span></span><br><span class=\"line\"><span class=\"comment\">// 得到散列值对应的 table 数组的下标</span></span><br><span class=\"line\">           <span class=\"comment\">// 然后返回 table 数组中此下标对应的 HashEntry 元素</span></span><br><span class=\"line\">           <span class=\"keyword\">return</span> tab[hash &amp; (tab.length - <span class=\"number\">1</span>)]; </span><br><span class=\"line\">       &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>插入三个节点后 Segment 的结构示意图：</p>\n<p><img src=\"/images/concurrentHashMap/image004.jpg\" alt=\"Segment\"></p>\n<h2 id=\"Put-方法的实现\"><a href=\"#Put-方法的实现\" class=\"headerlink\" title=\"Put 方法的实现\"></a>Put 方法的实现</h2><p>1.根据 key 计算出对应的 hash 值：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123; </span><br><span class=\"line\">       <span class=\"keyword\">if</span> (value == <span class=\"keyword\">null</span>)          <span class=\"comment\">//ConcurrentHashMap 中不允许用 null 作为映射值</span></span><br><span class=\"line\">           <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(); </span><br><span class=\"line\">       <span class=\"keyword\">int</span> hash = hash(key.hashCode());        <span class=\"comment\">// 计算键对应的散列码</span></span><br><span class=\"line\">       <span class=\"comment\">// 根据散列码找到对应的 Segment </span></span><br><span class=\"line\">       <span class=\"keyword\">return</span> segmentFor(hash).put(key, hash, value, <span class=\"keyword\">false</span>); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2.根据 hash 值找到对应的 Segment:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * 使用 key 的散列码来得到 segments 数组中对应的 Segment </span></span><br><span class=\"line\"><span class=\"comment\">    */</span> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Segment&lt;K,V&gt; <span class=\"title\">segmentFor</span><span class=\"params\">(<span class=\"keyword\">int</span> hash)</span> </span>&#123; </span><br><span class=\"line\">   <span class=\"comment\">// 将散列值右移 segmentShift 个位，并在高位填充 0 </span></span><br><span class=\"line\">   <span class=\"comment\">// 然后把得到的值与 segmentMask 相“与”</span></span><br><span class=\"line\"><span class=\"comment\">// 从而得到 hash 值对应的 segments 数组的下标值</span></span><br><span class=\"line\"><span class=\"comment\">// 最后根据下标值返回散列码对应的 Segment 对象</span></span><br><span class=\"line\">       <span class=\"keyword\">return</span> segments[(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask]; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>3.在 Segment 中执行具体的 put 操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">V <span class=\"title\">put</span><span class=\"params\">(K key, <span class=\"keyword\">int</span> hash, V value, <span class=\"keyword\">boolean</span> onlyIfAbsent)</span> </span>&#123; </span><br><span class=\"line\">           lock();  <span class=\"comment\">// 加锁，这里是锁定某个 Segment 对象而非整个 ConcurrentHashMap </span></span><br><span class=\"line\">           <span class=\"keyword\">try</span> &#123; </span><br><span class=\"line\">               <span class=\"keyword\">int</span> c = count; </span><br><span class=\"line\"> </span><br><span class=\"line\">               <span class=\"keyword\">if</span> (c++ &gt; threshold)     <span class=\"comment\">// 如果超过再散列的阈值</span></span><br><span class=\"line\">                   rehash();              <span class=\"comment\">// 执行再散列，table 数组的长度将扩充一倍</span></span><br><span class=\"line\"> </span><br><span class=\"line\">               HashEntry&lt;K,V&gt;[] tab = table; </span><br><span class=\"line\">               <span class=\"comment\">// 把散列码值与 table 数组的长度减 1 的值相“与”</span></span><br><span class=\"line\">               <span class=\"comment\">// 得到该散列码对应的 table 数组的下标值</span></span><br><span class=\"line\">               <span class=\"keyword\">int</span> index = hash &amp; (tab.length - <span class=\"number\">1</span>); </span><br><span class=\"line\">               <span class=\"comment\">// 找到散列码对应的具体的那个桶</span></span><br><span class=\"line\">               HashEntry&lt;K,V&gt; first = tab[index]; </span><br><span class=\"line\"> </span><br><span class=\"line\">               HashEntry&lt;K,V&gt; e = first; </span><br><span class=\"line\">               <span class=\"keyword\">while</span> (e != <span class=\"keyword\">null</span> &amp;&amp; (e.hash != hash || !key.equals(e.key))) </span><br><span class=\"line\">                   e = e.next; </span><br><span class=\"line\"> </span><br><span class=\"line\">               V oldValue; </span><br><span class=\"line\">               <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123;            <span class=\"comment\">// 如果键 / 值对以经存在</span></span><br><span class=\"line\">                   oldValue = e.value; </span><br><span class=\"line\">                   <span class=\"keyword\">if</span> (!onlyIfAbsent) </span><br><span class=\"line\">                       e.value = value;    <span class=\"comment\">// 设置 value 值</span></span><br><span class=\"line\">               &#125; </span><br><span class=\"line\">               <span class=\"keyword\">else</span> &#123;                        <span class=\"comment\">// 键 / 值对不存在 </span></span><br><span class=\"line\">                   oldValue = <span class=\"keyword\">null</span>; </span><br><span class=\"line\">                   ++modCount;         <span class=\"comment\">// 要添加新节点到链表中，所以 modCont 要加 1  </span></span><br><span class=\"line\">                   <span class=\"comment\">// 创建新节点，并添加到链表的头部 </span></span><br><span class=\"line\">                   tab[index] = <span class=\"keyword\">new</span> HashEntry&lt;K,V&gt;(key, hash, first, value); </span><br><span class=\"line\">                   count = c;               <span class=\"comment\">// 写 count 变量</span></span><br><span class=\"line\">               &#125; </span><br><span class=\"line\">               <span class=\"keyword\">return</span> oldValue; </span><br><span class=\"line\">           &#125; <span class=\"keyword\">finally</span> &#123; </span><br><span class=\"line\">               unlock();                     <span class=\"comment\">// 解锁</span></span><br><span class=\"line\">           &#125; </span><br><span class=\"line\">       &#125;</span><br></pre></td></tr></table></figure>\n<p>加锁操作是针对（键的 hash 值对应的）某个具体的 Segment，锁定的是该 Segment 而不是整个 ConcurrentHashMap<code>。因为插入键 / 值对操作只是在这个 Segment 包含的某个桶中完成，不需要锁定整个</code>ConcurrentHashMap。<code>此时，其他写线程对另外 15 个</code>Segment 的加锁并不会因为当前线程对这个 Segment 的加锁而阻塞。同时，所有读线程几乎不会因本线程的加锁而阻塞（除非读线程刚好读到这个 Segment 中某个 <code>HashEntry 的 value 域的值为 null，此时需要加锁后重新读取该值</code>）。</p>\n<p>相比较于 <code>HashTable 和由同步包装器包装的 HashMap`</code>每次只能有一个线程执行读或写操作，`ConcurrentHashMap 在并发访问性能上有了质的提高。<em>在理想状态下</em>，ConcurrentHashMap 可以支持 16 个线程执行并发写操作（如果并发级别设置为 16），及任意数量线程的读操作。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>ConcurrentHashMap 是一个并发散列映射表的实现，它允许完全并发的读取，并且支持给定数量的并发更新。相比于 <code>HashTable 和</code>用同步包装器包装的 HashMap（Collections.synchronizedMap(new HashMap())），ConcurrentHashMap 拥有更高的并发性。在 <code>HashTable 和由同步包装器包装的 HashMap 中，使用一个全局的锁来同步不同线程间的并发访问。同一时间点，只能有一个线程持有锁，也就是说在同一时间点，只能有一个线程能访问容器。这虽然保证多线程间的安全并发访问，但同时也导致对容器的访问变成`</code><em>串行化</em><code></code>的了。`</p>\n<p>在使用锁来协调多线程间并发访问的模式下，减小对锁的竞争可以有效提高并发性。有两种方式可以减小对锁的竞争：</p>\n<ol>\n<li>减小请求 同一个锁的 频率。</li>\n<li>减少持有锁的 时间。</li>\n</ol>\n<p>ConcurrentHashMap 的高并发性主要来自于三个方面：</p>\n<ol>\n<li>用分离锁实现多个线程间的更深层次的共享访问。</li>\n<li>用 HashEntery 对象的不变性来降低执行读操作的线程在遍历链表期间对加锁的需求。</li>\n<li>通过对同一个 Volatile 变量的写 / 读访问，协调不同线程间读 / 写操作的内存可见性。</li>\n</ol>\n<p>使用分离锁，减小了请求 <em>同一个锁</em>的频率。</p>\n<p>通过 HashEntery 对象的不变性及对同一个 Volatile 变量的读 / 写来协调内存可见性，使得 读操作大多数时候不需要加锁就能成功获取到需要的值。由于散列映射表在实际应用中大多数操作都是成功的 读操作，所以 2 和 3 既可以减少请求同一个锁的频率，也可以有效减少持有锁的时间。</p>\n<p>通过减小请求同一个锁的频率和尽量减少持有锁的时间 <code>，使得 ConcurrentHashMap 的并发性相对于 HashTable 和</code>用同步包装器包装的 HashMap<code>有了质的提高。</code></p>"},{"title":"基于Redis分布式锁","author":"James","date":"2017-05-08T02:21:00.000Z","_content":"\n# 关于分布式锁\n\n分布式环境下，数据一致性问题一直是一个比较重要的话题，而又不同于单进程的情况。分布式与单机情况下最大的不同在于其不是多线程而是多进程。多线程由于可以共享堆内存，因此可以简单的采取内存作为标记存储位置。而进程之间甚至可能都不在同一台物理机上，因此需要将标记存储在一个所有进程都能看到的地方。\n\n<!-- more -->\n\n## 常见分布式锁方案\n\n- 基于数据库实现分布式锁  \n- 基于缓存的锁实现方案，如 redis\n- 基于Zookeeper实现分布式锁 \n\n本文将讨论第二种方式，基于Redis实现分布式锁。 \n\n# 基于Redis的实现\n\n## 可靠性\n\n1. **排他性**：任意时刻只能一个客户端自有其锁\n2. **避免死锁** ：如果某个持有锁的客户端发生异常，而不能主动释放锁，其他客户端也能获得锁\n3. **容错性**：大部分节点能够正常运行，就能保证加锁和释放 \n\n\n\n## 思路\n\n使用redis的SETNX实现分布式锁，多个进程执行以下Redis命令： \n\n```bash\nSETNX lock.id <current Unix time + lock timeout + 1>\n```\n\nSETNX是将 key 的值设为 value，当且仅当 key 不存在。若给定的 key 已经存在，则 SETNX 不做任何动作。   \n\n- 返回1，说明该进程获得锁，SETNX将键 lock.id 的值设置为锁的超时时间，当前时间 +加上锁的有效时间。 \n- 返回0，说明其他进程已经获得了锁，进程不能进入临界区。进程可以在一个循环中不断地尝试 SETNX 操作，以获得锁。\n\n\n\n## 实现方式1\n\n获得锁\n\n```java\n    public void lock(Integer sec) throws Exception{\n        Boolean lock = Boolean.FALSE;\n        Long curr = System.currentTimeMillis();//TODO 需要每个实例自己生成过期时间，要求多个客户端之间需要时间同步\n        Long timeout = sec * LOCK_TIME_MILLIS;\n        Long timestamp = curr + timeout;\n        Long blockTime = timeout;\n        while(!lock){\n            // SETNX方式尝试获得锁\n            lock = mainRedis.opsForValue().setIfAbsent(lock_key, timestamp.toString());\n            if(lock){\n                //设置失效时间\n                mainRedis.expire(lock_key, timeout, TimeUnit.MILLISECONDS);//设置超时\n                lock_value = timestamp.toString();\n                return;\n            }\n            //超过重试次数unlock 此步骤避免超时设置失败导致异常\n            blockTime -= WAIT_TIME_MILLIS;\n            if( blockTime <= 0 ){\n                String lock_value = mainRedis.opsForValue().get(lock_key);\n                if(lock_value != null && Long.valueOf(lock_value) < curr)//TODO 时间不同步，可能导致误解锁\n                    mainRedis.delete(lock_key);//TODO 非原子操作，可能导致误解锁.需借鉴lua脚本执行的方式\n            }\n            Thread.sleep(WAIT_TIME_MILLIS);\"+blockTime);\n        }\n    }\n```\n\n- lock_key来当锁。\n- timestamp作为value,在解锁的时候能有依据。\n- SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作。\n-  timeout 为过期时间，超时判断\n- blockTime  避免超时设置失败导致异常,当重试获得锁次数达到时候解锁\n\n释放锁\n\n```java\n  public void unlock(){\n        mainRedis.execute(new RedisCallback<Boolean>() {\n            @Override\n            public Boolean doInRedis(RedisConnection connection) throws DataAccessException {\n                connection.watch(lock_key_bytes);//redis事务,防止此时key超时，其他实例获得新锁被误删除\n                String alive_lock_value = KeyUtils.decode(connection.get(lock_key_bytes));\n                connection.multi();\n                //对比value是否为当前线程\n                if (alive_lock_value != null && lock_value.equals(alive_lock_value)){\n                    connection.del(lock_key_bytes);\n                }\n                return connection.exec() != null;\n            }\n        });\n    }\n```\n\n\n最新版本jedis 解决获取锁设置失效时间原子问题，下面代码仅供参考:\n\n```java\npublic boolean lock(String key, String request, int blockTime) throws InterruptedException {\n\n        while (blockTime >= 0) {\n\n            String result = this.jedis.set(lockPrefix + key, request, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, 10 * TIME);\n            if (LOCK_MSG.equals(result)) {\n                return true;\n            }\n            blockTime -= sleepTime;\n\n            Thread.sleep(sleepTime);\n        }\n        return false;\n}\n```\n\n\n\n# 总结\n\n至此一个基于 Redis 的分布式锁完成，但是依然有些问题。\n\n- 需要每个实例自己生成过期时间，要求多个客户端之间需要时间同步。\n- 设置key超时时候可以用lua脚本达到原子操作。或者用新版本jedis包。\n- 就算 Redis 是集群部署的，如果每个节点都只是 master 没有 slave，那么 master 宕机时该节点上的所有 key  在那一时刻都相当于是释放锁了，这样也会出现并发问题。就算是有 slave 节点，但如果在数据同步到 salve 之前 master  宕机也是会出现上面的问题。\n\n感兴趣的朋友还可以参考 [Redisson](https://github.com/redisson/redisson) 的实现。","source":"_posts/RedisLock.md","raw":"title: 基于Redis分布式锁\nauthor: James\ntags:\n  - redis\n  - lock\ncategories:\n  - 架构\ndate: 2017-05-08 10:21:00\n---\n\n# 关于分布式锁\n\n分布式环境下，数据一致性问题一直是一个比较重要的话题，而又不同于单进程的情况。分布式与单机情况下最大的不同在于其不是多线程而是多进程。多线程由于可以共享堆内存，因此可以简单的采取内存作为标记存储位置。而进程之间甚至可能都不在同一台物理机上，因此需要将标记存储在一个所有进程都能看到的地方。\n\n<!-- more -->\n\n## 常见分布式锁方案\n\n- 基于数据库实现分布式锁  \n- 基于缓存的锁实现方案，如 redis\n- 基于Zookeeper实现分布式锁 \n\n本文将讨论第二种方式，基于Redis实现分布式锁。 \n\n# 基于Redis的实现\n\n## 可靠性\n\n1. **排他性**：任意时刻只能一个客户端自有其锁\n2. **避免死锁** ：如果某个持有锁的客户端发生异常，而不能主动释放锁，其他客户端也能获得锁\n3. **容错性**：大部分节点能够正常运行，就能保证加锁和释放 \n\n\n\n## 思路\n\n使用redis的SETNX实现分布式锁，多个进程执行以下Redis命令： \n\n```bash\nSETNX lock.id <current Unix time + lock timeout + 1>\n```\n\nSETNX是将 key 的值设为 value，当且仅当 key 不存在。若给定的 key 已经存在，则 SETNX 不做任何动作。   \n\n- 返回1，说明该进程获得锁，SETNX将键 lock.id 的值设置为锁的超时时间，当前时间 +加上锁的有效时间。 \n- 返回0，说明其他进程已经获得了锁，进程不能进入临界区。进程可以在一个循环中不断地尝试 SETNX 操作，以获得锁。\n\n\n\n## 实现方式1\n\n获得锁\n\n```java\n    public void lock(Integer sec) throws Exception{\n        Boolean lock = Boolean.FALSE;\n        Long curr = System.currentTimeMillis();//TODO 需要每个实例自己生成过期时间，要求多个客户端之间需要时间同步\n        Long timeout = sec * LOCK_TIME_MILLIS;\n        Long timestamp = curr + timeout;\n        Long blockTime = timeout;\n        while(!lock){\n            // SETNX方式尝试获得锁\n            lock = mainRedis.opsForValue().setIfAbsent(lock_key, timestamp.toString());\n            if(lock){\n                //设置失效时间\n                mainRedis.expire(lock_key, timeout, TimeUnit.MILLISECONDS);//设置超时\n                lock_value = timestamp.toString();\n                return;\n            }\n            //超过重试次数unlock 此步骤避免超时设置失败导致异常\n            blockTime -= WAIT_TIME_MILLIS;\n            if( blockTime <= 0 ){\n                String lock_value = mainRedis.opsForValue().get(lock_key);\n                if(lock_value != null && Long.valueOf(lock_value) < curr)//TODO 时间不同步，可能导致误解锁\n                    mainRedis.delete(lock_key);//TODO 非原子操作，可能导致误解锁.需借鉴lua脚本执行的方式\n            }\n            Thread.sleep(WAIT_TIME_MILLIS);\"+blockTime);\n        }\n    }\n```\n\n- lock_key来当锁。\n- timestamp作为value,在解锁的时候能有依据。\n- SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作。\n-  timeout 为过期时间，超时判断\n- blockTime  避免超时设置失败导致异常,当重试获得锁次数达到时候解锁\n\n释放锁\n\n```java\n  public void unlock(){\n        mainRedis.execute(new RedisCallback<Boolean>() {\n            @Override\n            public Boolean doInRedis(RedisConnection connection) throws DataAccessException {\n                connection.watch(lock_key_bytes);//redis事务,防止此时key超时，其他实例获得新锁被误删除\n                String alive_lock_value = KeyUtils.decode(connection.get(lock_key_bytes));\n                connection.multi();\n                //对比value是否为当前线程\n                if (alive_lock_value != null && lock_value.equals(alive_lock_value)){\n                    connection.del(lock_key_bytes);\n                }\n                return connection.exec() != null;\n            }\n        });\n    }\n```\n\n\n最新版本jedis 解决获取锁设置失效时间原子问题，下面代码仅供参考:\n\n```java\npublic boolean lock(String key, String request, int blockTime) throws InterruptedException {\n\n        while (blockTime >= 0) {\n\n            String result = this.jedis.set(lockPrefix + key, request, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, 10 * TIME);\n            if (LOCK_MSG.equals(result)) {\n                return true;\n            }\n            blockTime -= sleepTime;\n\n            Thread.sleep(sleepTime);\n        }\n        return false;\n}\n```\n\n\n\n# 总结\n\n至此一个基于 Redis 的分布式锁完成，但是依然有些问题。\n\n- 需要每个实例自己生成过期时间，要求多个客户端之间需要时间同步。\n- 设置key超时时候可以用lua脚本达到原子操作。或者用新版本jedis包。\n- 就算 Redis 是集群部署的，如果每个节点都只是 master 没有 slave，那么 master 宕机时该节点上的所有 key  在那一时刻都相当于是释放锁了，这样也会出现并发问题。就算是有 slave 节点，但如果在数据同步到 salve 之前 master  宕机也是会出现上面的问题。\n\n感兴趣的朋友还可以参考 [Redisson](https://github.com/redisson/redisson) 的实现。","slug":"RedisLock","published":1,"updated":"2018-05-11T03:27:56.524Z","_id":"cjh09eio80000okkcjzywyj48","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"关于分布式锁\"><a href=\"#关于分布式锁\" class=\"headerlink\" title=\"关于分布式锁\"></a>关于分布式锁</h1><p>分布式环境下，数据一致性问题一直是一个比较重要的话题，而又不同于单进程的情况。分布式与单机情况下最大的不同在于其不是多线程而是多进程。多线程由于可以共享堆内存，因此可以简单的采取内存作为标记存储位置。而进程之间甚至可能都不在同一台物理机上，因此需要将标记存储在一个所有进程都能看到的地方。</p>\n<a id=\"more\"></a>\n<h2 id=\"常见分布式锁方案\"><a href=\"#常见分布式锁方案\" class=\"headerlink\" title=\"常见分布式锁方案\"></a>常见分布式锁方案</h2><ul>\n<li>基于数据库实现分布式锁  </li>\n<li>基于缓存的锁实现方案，如 redis</li>\n<li>基于Zookeeper实现分布式锁 </li>\n</ul>\n<p>本文将讨论第二种方式，基于Redis实现分布式锁。 </p>\n<h1 id=\"基于Redis的实现\"><a href=\"#基于Redis的实现\" class=\"headerlink\" title=\"基于Redis的实现\"></a>基于Redis的实现</h1><h2 id=\"可靠性\"><a href=\"#可靠性\" class=\"headerlink\" title=\"可靠性\"></a>可靠性</h2><ol>\n<li><strong>排他性</strong>：任意时刻只能一个客户端自有其锁</li>\n<li><strong>避免死锁</strong> ：如果某个持有锁的客户端发生异常，而不能主动释放锁，其他客户端也能获得锁</li>\n<li><strong>容错性</strong>：大部分节点能够正常运行，就能保证加锁和释放 </li>\n</ol>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>使用redis的SETNX实现分布式锁，多个进程执行以下Redis命令： </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SETNX lock.id &lt;current Unix time + lock timeout + 1&gt;</span><br></pre></td></tr></table></figure>\n<p>SETNX是将 key 的值设为 value，当且仅当 key 不存在。若给定的 key 已经存在，则 SETNX 不做任何动作。   </p>\n<ul>\n<li>返回1，说明该进程获得锁，SETNX将键 lock.id 的值设置为锁的超时时间，当前时间 +加上锁的有效时间。 </li>\n<li>返回0，说明其他进程已经获得了锁，进程不能进入临界区。进程可以在一个循环中不断地尝试 SETNX 操作，以获得锁。</li>\n</ul>\n<h2 id=\"实现方式1\"><a href=\"#实现方式1\" class=\"headerlink\" title=\"实现方式1\"></a>实现方式1</h2><p>获得锁</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">(Integer sec)</span> <span class=\"keyword\">throws</span> Exception</span>&#123;</span><br><span class=\"line\">    Boolean lock = Boolean.FALSE;</span><br><span class=\"line\">    Long curr = System.currentTimeMillis();<span class=\"comment\">//TODO 需要每个实例自己生成过期时间，要求多个客户端之间需要时间同步</span></span><br><span class=\"line\">    Long timeout = sec * LOCK_TIME_MILLIS;</span><br><span class=\"line\">    Long timestamp = curr + timeout;</span><br><span class=\"line\">    Long blockTime = timeout;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!lock)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// SETNX方式尝试获得锁</span></span><br><span class=\"line\">        lock = mainRedis.opsForValue().setIfAbsent(lock_key, timestamp.toString());</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(lock)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//设置失效时间</span></span><br><span class=\"line\">            mainRedis.expire(lock_key, timeout, TimeUnit.MILLISECONDS);<span class=\"comment\">//设置超时</span></span><br><span class=\"line\">            lock_value = timestamp.toString();</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//超过重试次数unlock 此步骤避免超时设置失败导致异常</span></span><br><span class=\"line\">        blockTime -= WAIT_TIME_MILLIS;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>( blockTime &lt;= <span class=\"number\">0</span> )&#123;</span><br><span class=\"line\">            String lock_value = mainRedis.opsForValue().get(lock_key);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(lock_value != <span class=\"keyword\">null</span> &amp;&amp; Long.valueOf(lock_value) &lt; curr)<span class=\"comment\">//TODO 时间不同步，可能导致误解锁</span></span><br><span class=\"line\">                mainRedis.delete(lock_key);<span class=\"comment\">//TODO 非原子操作，可能导致误解锁.需借鉴lua脚本执行的方式</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Thread.sleep(WAIT_TIME_MILLIS);<span class=\"string\">\"+blockTime);</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>lock_key来当锁。</li>\n<li>timestamp作为value,在解锁的时候能有依据。</li>\n<li>SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作。</li>\n<li>timeout 为过期时间，超时判断</li>\n<li>blockTime  避免超时设置失败导致异常,当重试获得锁次数达到时候解锁</li>\n</ul>\n<p>释放锁</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">unlock</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">      mainRedis.execute(<span class=\"keyword\">new</span> RedisCallback&lt;Boolean&gt;() &#123;</span><br><span class=\"line\">          <span class=\"meta\">@Override</span></span><br><span class=\"line\">          <span class=\"function\"><span class=\"keyword\">public</span> Boolean <span class=\"title\">doInRedis</span><span class=\"params\">(RedisConnection connection)</span> <span class=\"keyword\">throws</span> DataAccessException </span>&#123;</span><br><span class=\"line\">              connection.watch(lock_key_bytes);<span class=\"comment\">//redis事务,防止此时key超时，其他实例获得新锁被误删除</span></span><br><span class=\"line\">              String alive_lock_value = KeyUtils.decode(connection.get(lock_key_bytes));</span><br><span class=\"line\">              connection.multi();</span><br><span class=\"line\">              <span class=\"comment\">//对比value是否为当前线程</span></span><br><span class=\"line\">              <span class=\"keyword\">if</span> (alive_lock_value != <span class=\"keyword\">null</span> &amp;&amp; lock_value.equals(alive_lock_value))&#123;</span><br><span class=\"line\">                  connection.del(lock_key_bytes);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> connection.exec() != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>最新版本jedis 解决获取锁设置失效时间原子问题，下面代码仅供参考:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">lock</span><span class=\"params\">(String key, String request, <span class=\"keyword\">int</span> blockTime)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (blockTime &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            String result = <span class=\"keyword\">this</span>.jedis.set(lockPrefix + key, request, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, <span class=\"number\">10</span> * TIME);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (LOCK_MSG.equals(result)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            blockTime -= sleepTime;</span><br><span class=\"line\"></span><br><span class=\"line\">            Thread.sleep(sleepTime);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>至此一个基于 Redis 的分布式锁完成，但是依然有些问题。</p>\n<ul>\n<li>需要每个实例自己生成过期时间，要求多个客户端之间需要时间同步。</li>\n<li>设置key超时时候可以用lua脚本达到原子操作。或者用新版本jedis包。</li>\n<li>就算 Redis 是集群部署的，如果每个节点都只是 master 没有 slave，那么 master 宕机时该节点上的所有 key  在那一时刻都相当于是释放锁了，这样也会出现并发问题。就算是有 slave 节点，但如果在数据同步到 salve 之前 master  宕机也是会出现上面的问题。</li>\n</ul>\n<p>感兴趣的朋友还可以参考 <a href=\"https://github.com/redisson/redisson\" target=\"_blank\" rel=\"noopener\">Redisson</a> 的实现。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"关于分布式锁\"><a href=\"#关于分布式锁\" class=\"headerlink\" title=\"关于分布式锁\"></a>关于分布式锁</h1><p>分布式环境下，数据一致性问题一直是一个比较重要的话题，而又不同于单进程的情况。分布式与单机情况下最大的不同在于其不是多线程而是多进程。多线程由于可以共享堆内存，因此可以简单的采取内存作为标记存储位置。而进程之间甚至可能都不在同一台物理机上，因此需要将标记存储在一个所有进程都能看到的地方。</p>","more":"<h2 id=\"常见分布式锁方案\"><a href=\"#常见分布式锁方案\" class=\"headerlink\" title=\"常见分布式锁方案\"></a>常见分布式锁方案</h2><ul>\n<li>基于数据库实现分布式锁  </li>\n<li>基于缓存的锁实现方案，如 redis</li>\n<li>基于Zookeeper实现分布式锁 </li>\n</ul>\n<p>本文将讨论第二种方式，基于Redis实现分布式锁。 </p>\n<h1 id=\"基于Redis的实现\"><a href=\"#基于Redis的实现\" class=\"headerlink\" title=\"基于Redis的实现\"></a>基于Redis的实现</h1><h2 id=\"可靠性\"><a href=\"#可靠性\" class=\"headerlink\" title=\"可靠性\"></a>可靠性</h2><ol>\n<li><strong>排他性</strong>：任意时刻只能一个客户端自有其锁</li>\n<li><strong>避免死锁</strong> ：如果某个持有锁的客户端发生异常，而不能主动释放锁，其他客户端也能获得锁</li>\n<li><strong>容错性</strong>：大部分节点能够正常运行，就能保证加锁和释放 </li>\n</ol>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>使用redis的SETNX实现分布式锁，多个进程执行以下Redis命令： </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SETNX lock.id &lt;current Unix time + lock timeout + 1&gt;</span><br></pre></td></tr></table></figure>\n<p>SETNX是将 key 的值设为 value，当且仅当 key 不存在。若给定的 key 已经存在，则 SETNX 不做任何动作。   </p>\n<ul>\n<li>返回1，说明该进程获得锁，SETNX将键 lock.id 的值设置为锁的超时时间，当前时间 +加上锁的有效时间。 </li>\n<li>返回0，说明其他进程已经获得了锁，进程不能进入临界区。进程可以在一个循环中不断地尝试 SETNX 操作，以获得锁。</li>\n</ul>\n<h2 id=\"实现方式1\"><a href=\"#实现方式1\" class=\"headerlink\" title=\"实现方式1\"></a>实现方式1</h2><p>获得锁</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">(Integer sec)</span> <span class=\"keyword\">throws</span> Exception</span>&#123;</span><br><span class=\"line\">    Boolean lock = Boolean.FALSE;</span><br><span class=\"line\">    Long curr = System.currentTimeMillis();<span class=\"comment\">//TODO 需要每个实例自己生成过期时间，要求多个客户端之间需要时间同步</span></span><br><span class=\"line\">    Long timeout = sec * LOCK_TIME_MILLIS;</span><br><span class=\"line\">    Long timestamp = curr + timeout;</span><br><span class=\"line\">    Long blockTime = timeout;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!lock)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// SETNX方式尝试获得锁</span></span><br><span class=\"line\">        lock = mainRedis.opsForValue().setIfAbsent(lock_key, timestamp.toString());</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(lock)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//设置失效时间</span></span><br><span class=\"line\">            mainRedis.expire(lock_key, timeout, TimeUnit.MILLISECONDS);<span class=\"comment\">//设置超时</span></span><br><span class=\"line\">            lock_value = timestamp.toString();</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//超过重试次数unlock 此步骤避免超时设置失败导致异常</span></span><br><span class=\"line\">        blockTime -= WAIT_TIME_MILLIS;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>( blockTime &lt;= <span class=\"number\">0</span> )&#123;</span><br><span class=\"line\">            String lock_value = mainRedis.opsForValue().get(lock_key);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(lock_value != <span class=\"keyword\">null</span> &amp;&amp; Long.valueOf(lock_value) &lt; curr)<span class=\"comment\">//TODO 时间不同步，可能导致误解锁</span></span><br><span class=\"line\">                mainRedis.delete(lock_key);<span class=\"comment\">//TODO 非原子操作，可能导致误解锁.需借鉴lua脚本执行的方式</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Thread.sleep(WAIT_TIME_MILLIS);<span class=\"string\">\"+blockTime);</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>lock_key来当锁。</li>\n<li>timestamp作为value,在解锁的时候能有依据。</li>\n<li>SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作。</li>\n<li>timeout 为过期时间，超时判断</li>\n<li>blockTime  避免超时设置失败导致异常,当重试获得锁次数达到时候解锁</li>\n</ul>\n<p>释放锁</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">unlock</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">      mainRedis.execute(<span class=\"keyword\">new</span> RedisCallback&lt;Boolean&gt;() &#123;</span><br><span class=\"line\">          <span class=\"meta\">@Override</span></span><br><span class=\"line\">          <span class=\"function\"><span class=\"keyword\">public</span> Boolean <span class=\"title\">doInRedis</span><span class=\"params\">(RedisConnection connection)</span> <span class=\"keyword\">throws</span> DataAccessException </span>&#123;</span><br><span class=\"line\">              connection.watch(lock_key_bytes);<span class=\"comment\">//redis事务,防止此时key超时，其他实例获得新锁被误删除</span></span><br><span class=\"line\">              String alive_lock_value = KeyUtils.decode(connection.get(lock_key_bytes));</span><br><span class=\"line\">              connection.multi();</span><br><span class=\"line\">              <span class=\"comment\">//对比value是否为当前线程</span></span><br><span class=\"line\">              <span class=\"keyword\">if</span> (alive_lock_value != <span class=\"keyword\">null</span> &amp;&amp; lock_value.equals(alive_lock_value))&#123;</span><br><span class=\"line\">                  connection.del(lock_key_bytes);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> connection.exec() != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>最新版本jedis 解决获取锁设置失效时间原子问题，下面代码仅供参考:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">lock</span><span class=\"params\">(String key, String request, <span class=\"keyword\">int</span> blockTime)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (blockTime &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            String result = <span class=\"keyword\">this</span>.jedis.set(lockPrefix + key, request, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, <span class=\"number\">10</span> * TIME);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (LOCK_MSG.equals(result)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            blockTime -= sleepTime;</span><br><span class=\"line\"></span><br><span class=\"line\">            Thread.sleep(sleepTime);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>至此一个基于 Redis 的分布式锁完成，但是依然有些问题。</p>\n<ul>\n<li>需要每个实例自己生成过期时间，要求多个客户端之间需要时间同步。</li>\n<li>设置key超时时候可以用lua脚本达到原子操作。或者用新版本jedis包。</li>\n<li>就算 Redis 是集群部署的，如果每个节点都只是 master 没有 slave，那么 master 宕机时该节点上的所有 key  在那一时刻都相当于是释放锁了，这样也会出现并发问题。就算是有 slave 节点，但如果在数据同步到 salve 之前 master  宕机也是会出现上面的问题。</li>\n</ul>\n<p>感兴趣的朋友还可以参考 <a href=\"https://github.com/redisson/redisson\" target=\"_blank\" rel=\"noopener\">Redisson</a> 的实现。</p>"},{"title":"快速排序了解下","author":"James","date":"2015-05-17T02:03:00.000Z","_content":"\n# 前言\n\n排序算法可能是应用最广泛的算法了，它的特点是简单、适用于不同的输入数据并且在一般的应用中比其他的排序算法要快。快速排序采用的也是分治思想，但是与归并排序不同的是快速排序是原地排序并不需要使用辅助数组能节省更多的内存资源。 \n\n<!-- more -->\n\n# 基本算法\n\n快速排序是将一个数组分成两个子数组，并将两个子数组独立的排序。数组的切分与归并排序有很大的不同，快速排序是找出一个元素作为基准，然后确定这个基准元素在数组中的位置，在这个过程中使基准左边的元素都不大于它右边的元素都不小于它。快速排序就是递归的调用切分的方法来完成排序的。 \n\n## 切分的方式\n\n快速排序中最重要的就是步骤就是将小于等于中轴元素的放到中轴元素的左边，将大于中轴元素的放到中轴元素的右边，我们暂时把这个步骤定义为切分。而剩下的步骤就是进行递归而已，递归的边界条件为数组的元素个数小于等于1。以首元素作为中轴，看看常见的切分方式。 \n\n\n\n```java\n/* * 递归调用 * lo, hi用于跟踪递归进度 */ \npublic static void sort(char[] src, int lo, int hi) { \n    if (lo >= hi) return ; \n    int splitIndex = partition(src, lo, hi); \n    //切分 \n    sort(src, lo, splitIndex - 1); \n    sort(src, splitIndex + 1, hi); \n}\n\n/* * 快速排序的核心 * 用段落的第一个元素作为切分的标准 \n 将小于它的都放在左部分，大于它的都放在右部分  \n 从左到右找大的，从右到左找小的，做交换 \n * 最后找到最靠右的小于标准元素的元素与标准元素进行交换 \n */ \npublic static int partition(char[] src, int lo, int hi) { \n    int base = src[lo]; \n    int l = lo, h = hi + 1; \n    while (true) { \n        while (src[++l] < base) \n            if (l == hi) break; \n        while (src[--h] > base) \n            if (h == lo) break; if (l < h) \n                exchange(src, l, h); else break; \n    } /* * 这里的h换成l-1都可以，表示左侧部分最右的一个元素 */ \n    exchange(src, lo, h); return h; \n}\n```\n\n# 提高性能 \n\n在小数组排序的时候我们可以将快速排序替换为插入排序，这样会进一步提升快速排序的性能，改进后的代码像下面这样 \n\n```java\npublic static void sort(char[] src, int lo, int hi) { \n    if (lo >= hi) return ; \n    if((hi - lo +1) < 10) {\n        insertionSort(arr,low, high);\n        return;\n    }\n    int splitIndex = partition(src, lo, hi); \n    //切分 \n    sort(src, lo, splitIndex - 1); \n    sort(src, splitIndex + 1, hi); \n}\n```\n\n# 再提升\n\n在实际应用中，我们很少会处理无重复元素的数组，经常会遇到含有大量重复元素的数组，而我们之前的基础排序算法对于重复的元素仍对其进行比较和大量的交换，这显然是没有必要的，在其中我们便可以发现巨大的优化潜力，在特定的情况下将线性对数级别的性能进一步改进。 \n\n## 三向切分\n\n之前的算法是将数组分为两个部分，小于基准元素和大于基准元素，三向切分将数组分为三个部分：小于、等于和大于基准元素。所以我们需要更多的指针跟踪（lo, lt, i, gt, hi），我们让**a[ lo ... lt - 1 ]**存储小于基准元素的元素，**a[ lt ... i - 1]**存储等于基准元素的元素，**a[ i ... gt ]**存储未访问到、未确定大小的元素，**a[ gt + 1 ... hi ]**存储大于基准元素的元素。\n\n```java\npublic static void sort(char[] arr, int lo, int hi) { \n    int n = hi - lo + 1; // 当子数组的长度为 8 时，调用插入排序 \n    if (n <= CUTOFF) { insertionSort(arr, lo, hi); return; } \n    // 调用三取样切分 \n    int m = median3(arr, lo, lo + n / 2, hi); \n    exchange(arr, m, lo); \n    int lt = lo; int gt = hi;\n    int v = arr[lo]; \n    int i = lo;\n    while (i <= gt) { \n        // arr[i] < v，交换 arr[lt] & arr[i]，将 lt & i 加一 \n        if (arr[i] < v) { exchange(arr, lt++, i++); } \n        // arr[i] > v，交换 arr[gt] & arr[i]，将 gt 减一 else\n        if (arr[i] > v) { exchange(arr, i, gt--); } \n        // arr[i] == v，将 i 加一 \n        else { \n            i++; \n        } \n    } \n    // arr[lo...lt-1] < v = arr[lt...gt] < arr[gt+1...hi] \n    sort(arr, lo, lt - 1); \n    sort(arr, gt + 1, hi); \n}\n\n// 取 arr[i] arr[j] arr[k] 三个元素值的中间元素的下标 \nprivate static int median3(char[] arr, int i, int j, int k) { \n    return (less(arr[i], arr[j]) ? \n            (less(arr[j], arr[k]) ? j : less(arr[i], arr[k]) ? k : i) : \t\t\t\t\t(less(arr[k], arr[j]) ? j : less(arr[k], arr[i]) ? k : i)); \n}\n\n```\n\n\n\n# 快速排序的优势\n\n相对于那些**初级排序算法**（插入排序、选择排序等），快速排序的优势不用多说，平均情况的线性对数级别比平方级别在性能上要好太多。而最差情况的平方级别完全可以通过随机化避免。\n\n相对于**归并排序**。在空间上，归并排序的劣势显露无疑，归并排序需要线性级别的空间，所以只需要对数级别的空间。在时间上，上面已经进行了详细讨论，三向切分快速排序在实际应用中的性能优于归并排序很多。\n\n相对于**堆排序**。堆排序在时间和空间上都有非常好的效果，但是它总是跳跃式地访问元素，无法利用缓存，而快速排序总会顺序地访问元素，可以利用缓存。而缓存对于性能的提升是非常有用的。\n\n快速排序的内循环中的指令很少，运行时间的增长数量级为~cNlgN，并且三向切分的快速排序对于实际应用中可能出现的某些分布的输入变成了线性级别，这使得其他的排序算法望而却步。","source":"_posts/quicksort.md","raw":"title: 快速排序了解下\nauthor: James\ntags:\n  - 快速排序\ncategories:\n  - 算法\ndate: 2015-05-17 10:03:00\n---\n\n# 前言\n\n排序算法可能是应用最广泛的算法了，它的特点是简单、适用于不同的输入数据并且在一般的应用中比其他的排序算法要快。快速排序采用的也是分治思想，但是与归并排序不同的是快速排序是原地排序并不需要使用辅助数组能节省更多的内存资源。 \n\n<!-- more -->\n\n# 基本算法\n\n快速排序是将一个数组分成两个子数组，并将两个子数组独立的排序。数组的切分与归并排序有很大的不同，快速排序是找出一个元素作为基准，然后确定这个基准元素在数组中的位置，在这个过程中使基准左边的元素都不大于它右边的元素都不小于它。快速排序就是递归的调用切分的方法来完成排序的。 \n\n## 切分的方式\n\n快速排序中最重要的就是步骤就是将小于等于中轴元素的放到中轴元素的左边，将大于中轴元素的放到中轴元素的右边，我们暂时把这个步骤定义为切分。而剩下的步骤就是进行递归而已，递归的边界条件为数组的元素个数小于等于1。以首元素作为中轴，看看常见的切分方式。 \n\n\n\n```java\n/* * 递归调用 * lo, hi用于跟踪递归进度 */ \npublic static void sort(char[] src, int lo, int hi) { \n    if (lo >= hi) return ; \n    int splitIndex = partition(src, lo, hi); \n    //切分 \n    sort(src, lo, splitIndex - 1); \n    sort(src, splitIndex + 1, hi); \n}\n\n/* * 快速排序的核心 * 用段落的第一个元素作为切分的标准 \n 将小于它的都放在左部分，大于它的都放在右部分  \n 从左到右找大的，从右到左找小的，做交换 \n * 最后找到最靠右的小于标准元素的元素与标准元素进行交换 \n */ \npublic static int partition(char[] src, int lo, int hi) { \n    int base = src[lo]; \n    int l = lo, h = hi + 1; \n    while (true) { \n        while (src[++l] < base) \n            if (l == hi) break; \n        while (src[--h] > base) \n            if (h == lo) break; if (l < h) \n                exchange(src, l, h); else break; \n    } /* * 这里的h换成l-1都可以，表示左侧部分最右的一个元素 */ \n    exchange(src, lo, h); return h; \n}\n```\n\n# 提高性能 \n\n在小数组排序的时候我们可以将快速排序替换为插入排序，这样会进一步提升快速排序的性能，改进后的代码像下面这样 \n\n```java\npublic static void sort(char[] src, int lo, int hi) { \n    if (lo >= hi) return ; \n    if((hi - lo +1) < 10) {\n        insertionSort(arr,low, high);\n        return;\n    }\n    int splitIndex = partition(src, lo, hi); \n    //切分 \n    sort(src, lo, splitIndex - 1); \n    sort(src, splitIndex + 1, hi); \n}\n```\n\n# 再提升\n\n在实际应用中，我们很少会处理无重复元素的数组，经常会遇到含有大量重复元素的数组，而我们之前的基础排序算法对于重复的元素仍对其进行比较和大量的交换，这显然是没有必要的，在其中我们便可以发现巨大的优化潜力，在特定的情况下将线性对数级别的性能进一步改进。 \n\n## 三向切分\n\n之前的算法是将数组分为两个部分，小于基准元素和大于基准元素，三向切分将数组分为三个部分：小于、等于和大于基准元素。所以我们需要更多的指针跟踪（lo, lt, i, gt, hi），我们让**a[ lo ... lt - 1 ]**存储小于基准元素的元素，**a[ lt ... i - 1]**存储等于基准元素的元素，**a[ i ... gt ]**存储未访问到、未确定大小的元素，**a[ gt + 1 ... hi ]**存储大于基准元素的元素。\n\n```java\npublic static void sort(char[] arr, int lo, int hi) { \n    int n = hi - lo + 1; // 当子数组的长度为 8 时，调用插入排序 \n    if (n <= CUTOFF) { insertionSort(arr, lo, hi); return; } \n    // 调用三取样切分 \n    int m = median3(arr, lo, lo + n / 2, hi); \n    exchange(arr, m, lo); \n    int lt = lo; int gt = hi;\n    int v = arr[lo]; \n    int i = lo;\n    while (i <= gt) { \n        // arr[i] < v，交换 arr[lt] & arr[i]，将 lt & i 加一 \n        if (arr[i] < v) { exchange(arr, lt++, i++); } \n        // arr[i] > v，交换 arr[gt] & arr[i]，将 gt 减一 else\n        if (arr[i] > v) { exchange(arr, i, gt--); } \n        // arr[i] == v，将 i 加一 \n        else { \n            i++; \n        } \n    } \n    // arr[lo...lt-1] < v = arr[lt...gt] < arr[gt+1...hi] \n    sort(arr, lo, lt - 1); \n    sort(arr, gt + 1, hi); \n}\n\n// 取 arr[i] arr[j] arr[k] 三个元素值的中间元素的下标 \nprivate static int median3(char[] arr, int i, int j, int k) { \n    return (less(arr[i], arr[j]) ? \n            (less(arr[j], arr[k]) ? j : less(arr[i], arr[k]) ? k : i) : \t\t\t\t\t(less(arr[k], arr[j]) ? j : less(arr[k], arr[i]) ? k : i)); \n}\n\n```\n\n\n\n# 快速排序的优势\n\n相对于那些**初级排序算法**（插入排序、选择排序等），快速排序的优势不用多说，平均情况的线性对数级别比平方级别在性能上要好太多。而最差情况的平方级别完全可以通过随机化避免。\n\n相对于**归并排序**。在空间上，归并排序的劣势显露无疑，归并排序需要线性级别的空间，所以只需要对数级别的空间。在时间上，上面已经进行了详细讨论，三向切分快速排序在实际应用中的性能优于归并排序很多。\n\n相对于**堆排序**。堆排序在时间和空间上都有非常好的效果，但是它总是跳跃式地访问元素，无法利用缓存，而快速排序总会顺序地访问元素，可以利用缓存。而缓存对于性能的提升是非常有用的。\n\n快速排序的内循环中的指令很少，运行时间的增长数量级为~cNlgN，并且三向切分的快速排序对于实际应用中可能出现的某些分布的输入变成了线性级别，这使得其他的排序算法望而却步。","slug":"quicksort","published":1,"updated":"2018-05-21T02:11:47.308Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjhfm7sm90000g4kcwhc9ghfu","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>排序算法可能是应用最广泛的算法了，它的特点是简单、适用于不同的输入数据并且在一般的应用中比其他的排序算法要快。快速排序采用的也是分治思想，但是与归并排序不同的是快速排序是原地排序并不需要使用辅助数组能节省更多的内存资源。 </p>\n<a id=\"more\"></a>\n<h1 id=\"基本算法\"><a href=\"#基本算法\" class=\"headerlink\" title=\"基本算法\"></a>基本算法</h1><p>快速排序是将一个数组分成两个子数组，并将两个子数组独立的排序。数组的切分与归并排序有很大的不同，快速排序是找出一个元素作为基准，然后确定这个基准元素在数组中的位置，在这个过程中使基准左边的元素都不大于它右边的元素都不小于它。快速排序就是递归的调用切分的方法来完成排序的。 </p>\n<h2 id=\"切分的方式\"><a href=\"#切分的方式\" class=\"headerlink\" title=\"切分的方式\"></a>切分的方式</h2><p>快速排序中最重要的就是步骤就是将小于等于中轴元素的放到中轴元素的左边，将大于中轴元素的放到中轴元素的右边，我们暂时把这个步骤定义为切分。而剩下的步骤就是进行递归而已，递归的边界条件为数组的元素个数小于等于1。以首元素作为中轴，看看常见的切分方式。 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* * 递归调用 * lo, hi用于跟踪递归进度 */</span> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(<span class=\"keyword\">char</span>[] src, <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi)</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lo &gt;= hi) <span class=\"keyword\">return</span> ; </span><br><span class=\"line\">    <span class=\"keyword\">int</span> splitIndex = partition(src, lo, hi); </span><br><span class=\"line\">    <span class=\"comment\">//切分 </span></span><br><span class=\"line\">    sort(src, lo, splitIndex - <span class=\"number\">1</span>); </span><br><span class=\"line\">    sort(src, splitIndex + <span class=\"number\">1</span>, hi); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* * 快速排序的核心 * 用段落的第一个元素作为切分的标准 </span></span><br><span class=\"line\"><span class=\"comment\"> 将小于它的都放在左部分，大于它的都放在右部分  </span></span><br><span class=\"line\"><span class=\"comment\"> 从左到右找大的，从右到左找小的，做交换 </span></span><br><span class=\"line\"><span class=\"comment\"> * 最后找到最靠右的小于标准元素的元素与标准元素进行交换 </span></span><br><span class=\"line\"><span class=\"comment\"> */</span> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">partition</span><span class=\"params\">(<span class=\"keyword\">char</span>[] src, <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi)</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">int</span> base = src[lo]; </span><br><span class=\"line\">    <span class=\"keyword\">int</span> l = lo, h = hi + <span class=\"number\">1</span>; </span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123; </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (src[++l] &lt; base) </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (l == hi) <span class=\"keyword\">break</span>; </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (src[--h] &gt; base) </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (h == lo) <span class=\"keyword\">break</span>; <span class=\"keyword\">if</span> (l &lt; h) </span><br><span class=\"line\">                exchange(src, l, h); <span class=\"keyword\">else</span> <span class=\"keyword\">break</span>; </span><br><span class=\"line\">    &#125; <span class=\"comment\">/* * 这里的h换成l-1都可以，表示左侧部分最右的一个元素 */</span> </span><br><span class=\"line\">    exchange(src, lo, h); <span class=\"keyword\">return</span> h; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"提高性能\"><a href=\"#提高性能\" class=\"headerlink\" title=\"提高性能\"></a>提高性能</h1><p>在小数组排序的时候我们可以将快速排序替换为插入排序，这样会进一步提升快速排序的性能，改进后的代码像下面这样 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(<span class=\"keyword\">char</span>[] src, <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi)</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lo &gt;= hi) <span class=\"keyword\">return</span> ; </span><br><span class=\"line\">    <span class=\"keyword\">if</span>((hi - lo +<span class=\"number\">1</span>) &lt; <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">        insertionSort(arr,low, high);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> splitIndex = partition(src, lo, hi); </span><br><span class=\"line\">    <span class=\"comment\">//切分 </span></span><br><span class=\"line\">    sort(src, lo, splitIndex - <span class=\"number\">1</span>); </span><br><span class=\"line\">    sort(src, splitIndex + <span class=\"number\">1</span>, hi); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"再提升\"><a href=\"#再提升\" class=\"headerlink\" title=\"再提升\"></a>再提升</h1><p>在实际应用中，我们很少会处理无重复元素的数组，经常会遇到含有大量重复元素的数组，而我们之前的基础排序算法对于重复的元素仍对其进行比较和大量的交换，这显然是没有必要的，在其中我们便可以发现巨大的优化潜力，在特定的情况下将线性对数级别的性能进一步改进。 </p>\n<h2 id=\"三向切分\"><a href=\"#三向切分\" class=\"headerlink\" title=\"三向切分\"></a>三向切分</h2><p>之前的算法是将数组分为两个部分，小于基准元素和大于基准元素，三向切分将数组分为三个部分：小于、等于和大于基准元素。所以我们需要更多的指针跟踪（lo, lt, i, gt, hi），我们让<strong>a[ lo … lt - 1 ]</strong>存储小于基准元素的元素，<strong>a[ lt … i - 1]</strong>存储等于基准元素的元素，<strong>a[ i … gt ]</strong>存储未访问到、未确定大小的元素，<strong>a[ gt + 1 … hi ]</strong>存储大于基准元素的元素。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(<span class=\"keyword\">char</span>[] arr, <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi)</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = hi - lo + <span class=\"number\">1</span>; <span class=\"comment\">// 当子数组的长度为 8 时，调用插入排序 </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &lt;= CUTOFF) &#123; insertionSort(arr, lo, hi); <span class=\"keyword\">return</span>; &#125; </span><br><span class=\"line\">    <span class=\"comment\">// 调用三取样切分 </span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> m = median3(arr, lo, lo + n / <span class=\"number\">2</span>, hi); </span><br><span class=\"line\">    exchange(arr, m, lo); </span><br><span class=\"line\">    <span class=\"keyword\">int</span> lt = lo; <span class=\"keyword\">int</span> gt = hi;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> v = arr[lo]; </span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = lo;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt;= gt) &#123; </span><br><span class=\"line\">        <span class=\"comment\">// arr[i] &lt; v，交换 arr[lt] &amp; arr[i]，将 lt &amp; i 加一 </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr[i] &lt; v) &#123; exchange(arr, lt++, i++); &#125; </span><br><span class=\"line\">        <span class=\"comment\">// arr[i] &gt; v，交换 arr[gt] &amp; arr[i]，将 gt 减一 else</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr[i] &gt; v) &#123; exchange(arr, i, gt--); &#125; </span><br><span class=\"line\">        <span class=\"comment\">// arr[i] == v，将 i 加一 </span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">            i++; </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"comment\">// arr[lo...lt-1] &lt; v = arr[lt...gt] &lt; arr[gt+1...hi] </span></span><br><span class=\"line\">    sort(arr, lo, lt - <span class=\"number\">1</span>); </span><br><span class=\"line\">    sort(arr, gt + <span class=\"number\">1</span>, hi); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 取 arr[i] arr[j] arr[k] 三个元素值的中间元素的下标 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">median3</span><span class=\"params\">(<span class=\"keyword\">char</span>[] arr, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j, <span class=\"keyword\">int</span> k)</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> (less(arr[i], arr[j]) ? </span><br><span class=\"line\">            (less(arr[j], arr[k]) ? j : less(arr[i], arr[k]) ? k : i) : \t\t\t\t\t(less(arr[k], arr[j]) ? j : less(arr[k], arr[i]) ? k : i)); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"快速排序的优势\"><a href=\"#快速排序的优势\" class=\"headerlink\" title=\"快速排序的优势\"></a>快速排序的优势</h1><p>相对于那些<strong>初级排序算法</strong>（插入排序、选择排序等），快速排序的优势不用多说，平均情况的线性对数级别比平方级别在性能上要好太多。而最差情况的平方级别完全可以通过随机化避免。</p>\n<p>相对于<strong>归并排序</strong>。在空间上，归并排序的劣势显露无疑，归并排序需要线性级别的空间，所以只需要对数级别的空间。在时间上，上面已经进行了详细讨论，三向切分快速排序在实际应用中的性能优于归并排序很多。</p>\n<p>相对于<strong>堆排序</strong>。堆排序在时间和空间上都有非常好的效果，但是它总是跳跃式地访问元素，无法利用缓存，而快速排序总会顺序地访问元素，可以利用缓存。而缓存对于性能的提升是非常有用的。</p>\n<p>快速排序的内循环中的指令很少，运行时间的增长数量级为~cNlgN，并且三向切分的快速排序对于实际应用中可能出现的某些分布的输入变成了线性级别，这使得其他的排序算法望而却步。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>排序算法可能是应用最广泛的算法了，它的特点是简单、适用于不同的输入数据并且在一般的应用中比其他的排序算法要快。快速排序采用的也是分治思想，但是与归并排序不同的是快速排序是原地排序并不需要使用辅助数组能节省更多的内存资源。 </p>","more":"<h1 id=\"基本算法\"><a href=\"#基本算法\" class=\"headerlink\" title=\"基本算法\"></a>基本算法</h1><p>快速排序是将一个数组分成两个子数组，并将两个子数组独立的排序。数组的切分与归并排序有很大的不同，快速排序是找出一个元素作为基准，然后确定这个基准元素在数组中的位置，在这个过程中使基准左边的元素都不大于它右边的元素都不小于它。快速排序就是递归的调用切分的方法来完成排序的。 </p>\n<h2 id=\"切分的方式\"><a href=\"#切分的方式\" class=\"headerlink\" title=\"切分的方式\"></a>切分的方式</h2><p>快速排序中最重要的就是步骤就是将小于等于中轴元素的放到中轴元素的左边，将大于中轴元素的放到中轴元素的右边，我们暂时把这个步骤定义为切分。而剩下的步骤就是进行递归而已，递归的边界条件为数组的元素个数小于等于1。以首元素作为中轴，看看常见的切分方式。 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* * 递归调用 * lo, hi用于跟踪递归进度 */</span> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(<span class=\"keyword\">char</span>[] src, <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi)</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lo &gt;= hi) <span class=\"keyword\">return</span> ; </span><br><span class=\"line\">    <span class=\"keyword\">int</span> splitIndex = partition(src, lo, hi); </span><br><span class=\"line\">    <span class=\"comment\">//切分 </span></span><br><span class=\"line\">    sort(src, lo, splitIndex - <span class=\"number\">1</span>); </span><br><span class=\"line\">    sort(src, splitIndex + <span class=\"number\">1</span>, hi); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* * 快速排序的核心 * 用段落的第一个元素作为切分的标准 </span></span><br><span class=\"line\"><span class=\"comment\"> 将小于它的都放在左部分，大于它的都放在右部分  </span></span><br><span class=\"line\"><span class=\"comment\"> 从左到右找大的，从右到左找小的，做交换 </span></span><br><span class=\"line\"><span class=\"comment\"> * 最后找到最靠右的小于标准元素的元素与标准元素进行交换 </span></span><br><span class=\"line\"><span class=\"comment\"> */</span> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">partition</span><span class=\"params\">(<span class=\"keyword\">char</span>[] src, <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi)</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">int</span> base = src[lo]; </span><br><span class=\"line\">    <span class=\"keyword\">int</span> l = lo, h = hi + <span class=\"number\">1</span>; </span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123; </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (src[++l] &lt; base) </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (l == hi) <span class=\"keyword\">break</span>; </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (src[--h] &gt; base) </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (h == lo) <span class=\"keyword\">break</span>; <span class=\"keyword\">if</span> (l &lt; h) </span><br><span class=\"line\">                exchange(src, l, h); <span class=\"keyword\">else</span> <span class=\"keyword\">break</span>; </span><br><span class=\"line\">    &#125; <span class=\"comment\">/* * 这里的h换成l-1都可以，表示左侧部分最右的一个元素 */</span> </span><br><span class=\"line\">    exchange(src, lo, h); <span class=\"keyword\">return</span> h; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"提高性能\"><a href=\"#提高性能\" class=\"headerlink\" title=\"提高性能\"></a>提高性能</h1><p>在小数组排序的时候我们可以将快速排序替换为插入排序，这样会进一步提升快速排序的性能，改进后的代码像下面这样 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(<span class=\"keyword\">char</span>[] src, <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi)</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lo &gt;= hi) <span class=\"keyword\">return</span> ; </span><br><span class=\"line\">    <span class=\"keyword\">if</span>((hi - lo +<span class=\"number\">1</span>) &lt; <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">        insertionSort(arr,low, high);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> splitIndex = partition(src, lo, hi); </span><br><span class=\"line\">    <span class=\"comment\">//切分 </span></span><br><span class=\"line\">    sort(src, lo, splitIndex - <span class=\"number\">1</span>); </span><br><span class=\"line\">    sort(src, splitIndex + <span class=\"number\">1</span>, hi); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"再提升\"><a href=\"#再提升\" class=\"headerlink\" title=\"再提升\"></a>再提升</h1><p>在实际应用中，我们很少会处理无重复元素的数组，经常会遇到含有大量重复元素的数组，而我们之前的基础排序算法对于重复的元素仍对其进行比较和大量的交换，这显然是没有必要的，在其中我们便可以发现巨大的优化潜力，在特定的情况下将线性对数级别的性能进一步改进。 </p>\n<h2 id=\"三向切分\"><a href=\"#三向切分\" class=\"headerlink\" title=\"三向切分\"></a>三向切分</h2><p>之前的算法是将数组分为两个部分，小于基准元素和大于基准元素，三向切分将数组分为三个部分：小于、等于和大于基准元素。所以我们需要更多的指针跟踪（lo, lt, i, gt, hi），我们让<strong>a[ lo … lt - 1 ]</strong>存储小于基准元素的元素，<strong>a[ lt … i - 1]</strong>存储等于基准元素的元素，<strong>a[ i … gt ]</strong>存储未访问到、未确定大小的元素，<strong>a[ gt + 1 … hi ]</strong>存储大于基准元素的元素。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(<span class=\"keyword\">char</span>[] arr, <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi)</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = hi - lo + <span class=\"number\">1</span>; <span class=\"comment\">// 当子数组的长度为 8 时，调用插入排序 </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &lt;= CUTOFF) &#123; insertionSort(arr, lo, hi); <span class=\"keyword\">return</span>; &#125; </span><br><span class=\"line\">    <span class=\"comment\">// 调用三取样切分 </span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> m = median3(arr, lo, lo + n / <span class=\"number\">2</span>, hi); </span><br><span class=\"line\">    exchange(arr, m, lo); </span><br><span class=\"line\">    <span class=\"keyword\">int</span> lt = lo; <span class=\"keyword\">int</span> gt = hi;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> v = arr[lo]; </span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = lo;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt;= gt) &#123; </span><br><span class=\"line\">        <span class=\"comment\">// arr[i] &lt; v，交换 arr[lt] &amp; arr[i]，将 lt &amp; i 加一 </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr[i] &lt; v) &#123; exchange(arr, lt++, i++); &#125; </span><br><span class=\"line\">        <span class=\"comment\">// arr[i] &gt; v，交换 arr[gt] &amp; arr[i]，将 gt 减一 else</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr[i] &gt; v) &#123; exchange(arr, i, gt--); &#125; </span><br><span class=\"line\">        <span class=\"comment\">// arr[i] == v，将 i 加一 </span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">            i++; </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"comment\">// arr[lo...lt-1] &lt; v = arr[lt...gt] &lt; arr[gt+1...hi] </span></span><br><span class=\"line\">    sort(arr, lo, lt - <span class=\"number\">1</span>); </span><br><span class=\"line\">    sort(arr, gt + <span class=\"number\">1</span>, hi); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 取 arr[i] arr[j] arr[k] 三个元素值的中间元素的下标 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">median3</span><span class=\"params\">(<span class=\"keyword\">char</span>[] arr, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j, <span class=\"keyword\">int</span> k)</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> (less(arr[i], arr[j]) ? </span><br><span class=\"line\">            (less(arr[j], arr[k]) ? j : less(arr[i], arr[k]) ? k : i) : \t\t\t\t\t(less(arr[k], arr[j]) ? j : less(arr[k], arr[i]) ? k : i)); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"快速排序的优势\"><a href=\"#快速排序的优势\" class=\"headerlink\" title=\"快速排序的优势\"></a>快速排序的优势</h1><p>相对于那些<strong>初级排序算法</strong>（插入排序、选择排序等），快速排序的优势不用多说，平均情况的线性对数级别比平方级别在性能上要好太多。而最差情况的平方级别完全可以通过随机化避免。</p>\n<p>相对于<strong>归并排序</strong>。在空间上，归并排序的劣势显露无疑，归并排序需要线性级别的空间，所以只需要对数级别的空间。在时间上，上面已经进行了详细讨论，三向切分快速排序在实际应用中的性能优于归并排序很多。</p>\n<p>相对于<strong>堆排序</strong>。堆排序在时间和空间上都有非常好的效果，但是它总是跳跃式地访问元素，无法利用缓存，而快速排序总会顺序地访问元素，可以利用缓存。而缓存对于性能的提升是非常有用的。</p>\n<p>快速排序的内循环中的指令很少，运行时间的增长数量级为~cNlgN，并且三向切分的快速排序对于实际应用中可能出现的某些分布的输入变成了线性级别，这使得其他的排序算法望而却步。</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjefa5bot000a6skc44xvg46r","category_id":"cjefa5boh00056skch6ssboy5","_id":"cjefa5bpe000g6skcahz6qnc0"},{"post_id":"cjefa5bo100026skcf0id5b8s","category_id":"cjefa5boh00056skch6ssboy5","_id":"cjefa5bpj000k6skc2m7ugiid"},{"post_id":"cjefa5bp9000e6skck12h91o0","category_id":"cjefa5boh00056skch6ssboy5","_id":"cjefa5bpl000m6skchs0ufqc9"},{"post_id":"cjefa5boa00046skc6qmw3y60","category_id":"cjefa5boh00056skch6ssboy5","_id":"cjefa5bpq000q6skccpoiejx5"},{"post_id":"cjefa5bpc000f6skc0u681bhw","category_id":"cjefa5boh00056skch6ssboy5","_id":"cjefa5bpr000s6skch3hx7dgf"},{"post_id":"cjefa5bp3000b6skcds3fuch6","category_id":"cjefa5bpm000n6skcy7e486jl","_id":"cjefa5bpt000v6skc06kgnnmq"},{"post_id":"cjehtoy8e0000dskcy7b2r8bt","category_id":"cjefa5boh00056skch6ssboy5","_id":"cjehtoy8v0003dskcwayamgbo"},{"post_id":"cjf26kpq40000mokcup8o4tke","category_id":"cjefa5bpm000n6skcy7e486jl","_id":"cjf26kpqj0002mokcz03yglqb"},{"post_id":"cjfktbq2f0000w0kc4cs6a9ev","category_id":"cjfktbq2p0001w0kc5gqcdado","_id":"cjfktbq2z0004w0kcj5ua70ce"},{"post_id":"cjfrwqk1s0000wckcf06oqq6q","category_id":"cjfrwqk2f0001wckcf0yvcysy","_id":"cjfrwqk2p0004wckcoq53pthe"},{"post_id":"cjgiyu41q000048kc7hmxes7v","category_id":"cjefa5boh00056skch6ssboy5","_id":"cjgiyu424000248kcgsscea0u"},{"post_id":"cjh09eio80000okkcjzywyj48","category_id":"cjh09eiol0001okkcnedll8dc","_id":"cjh09eios0005okkczuirjirk"},{"post_id":"cjhfm7sm90000g4kcwhc9ghfu","category_id":"cjfrwqk2f0001wckcf0yvcysy","_id":"cjhfm7smm0002g4kcv0dcnskj"}],"PostTag":[{"post_id":"cjefa5bp9000e6skck12h91o0","tag_id":"cjefa5bok00066skcilltmbh6","_id":"cjefa5bpi000j6skcbfhkrr2g"},{"post_id":"cjefa5bo100026skcf0id5b8s","tag_id":"cjefa5bok00066skcilltmbh6","_id":"cjefa5bpk000l6skcbh0zxkbl"},{"post_id":"cjefa5bo100026skcf0id5b8s","tag_id":"cjefa5bp6000d6skc2dsyj8t8","_id":"cjefa5bpp000p6skc6bxa6xg9"},{"post_id":"cjefa5boa00046skc6qmw3y60","tag_id":"cjefa5bok00066skcilltmbh6","_id":"cjefa5bpr000r6skc894itrll"},{"post_id":"cjefa5bot000a6skc44xvg46r","tag_id":"cjefa5bpt000w6skcpdwqfwqb","_id":"cjefa5bpx00106skcz4nruek2"},{"post_id":"cjefa5bp3000b6skcds3fuch6","tag_id":"cjefa5bpw000z6skceoeltg72","_id":"cjefa5bpy00126skc2igwzi4z"},{"post_id":"cjefa5bpc000f6skc0u681bhw","tag_id":"cjefa5bpx00116skcgdb963xf","_id":"cjefa5bq000146skc6vqie65t"},{"post_id":"cjefa5bpc000f6skc0u681bhw","tag_id":"cjefa5bpt000w6skcpdwqfwqb","_id":"cjefa5bq000156skc7zguyqgk"},{"post_id":"cjehtoy8e0000dskcy7b2r8bt","tag_id":"cjefa5bpo000o6skcoezmwr0p","_id":"cjehtoy8t0001dskcuz2kn12h"},{"post_id":"cjehtoy8e0000dskcy7b2r8bt","tag_id":"cjefa5bps000t6skc3pnit5e2","_id":"cjehtoy8u0002dskcb601mkid"},{"post_id":"cjf26kpq40000mokcup8o4tke","tag_id":"cjf26kpqe0001mokcakruchqs","_id":"cjf26kpql0003mokc8yrwpm0o"},{"post_id":"cjfktbq2f0000w0kc4cs6a9ev","tag_id":"cjfktbq2w0002w0kc55wyqj5h","_id":"cjfktbq2y0003w0kcx520isrn"},{"post_id":"cjfrwqk1s0000wckcf06oqq6q","tag_id":"cjfrwqk2n0003wckcemxx14a6","_id":"cjfrwqk2r0006wckc8hgquki1"},{"post_id":"cjgiyu41q000048kc7hmxes7v","tag_id":"cjgiyu41z000148kc6r4cv97s","_id":"cjgiyu426000348kcixseyxii"},{"post_id":"cjh09eio80000okkcjzywyj48","tag_id":"cjh09eioo0002okkcnsw2wcah","_id":"cjh09eior0003okkck4tyshcu"},{"post_id":"cjh09eio80000okkcjzywyj48","tag_id":"cjefa5bps000t6skc3pnit5e2","_id":"cjh09eios0004okkcre6rigln"},{"post_id":"cjhfm7sm90000g4kcwhc9ghfu","tag_id":"cjhfm7smi0001g4kczre5f3h6","_id":"cjhfm7smo0003g4kc356qlx42"}],"Tag":[{"name":"Java","_id":"cjefa5bok00066skcilltmbh6"},{"name":"GC","_id":"cjefa5bp6000d6skc2dsyj8t8"},{"name":"synchronized","_id":"cjefa5bpo000o6skcoezmwr0p"},{"name":"lock","_id":"cjefa5bps000t6skc3pnit5e2"},{"name":"java","_id":"cjefa5bpt000w6skcpdwqfwqb"},{"name":"threadpool","_id":"cjefa5bpw000z6skceoeltg72"},{"name":"jvm","_id":"cjefa5bpx00116skcgdb963xf"},{"name":"docker","_id":"cjf26kpqe0001mokcakruchqs"},{"name":"区块链","_id":"cjfktbq2w0002w0kc55wyqj5h"},{"name":"查找","_id":"cjfrwqk2l0002wckcmvxq33no"},{"name":"二分查找","_id":"cjfrwqk2n0003wckcemxx14a6"},{"name":"ConcurrentHashMap","_id":"cjgiyu41z000148kc6r4cv97s"},{"name":"redis","_id":"cjh09eioo0002okkcnsw2wcah"},{"name":"快速排序","_id":"cjhfm7smi0001g4kczre5f3h6"}]}}