{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next/source/CNAME","path":"CNAME","modified":0,"renderable":1},{"_id":"source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":0},{"_id":"source/images/arraylist/ArrayList_add.png","path":"images/arraylist/ArrayList_add.png","modified":0,"renderable":0},{"_id":"source/images/arraylist/ArrayList_base.png","path":"images/arraylist/ArrayList_base.png","modified":0,"renderable":0},{"_id":"source/images/arraylist/ArrayList_grow.png","path":"images/arraylist/ArrayList_grow.png","modified":0,"renderable":0},{"_id":"source/images/hashmap/HashMap_addEntry.png","path":"images/hashmap/HashMap_addEntry.png","modified":0,"renderable":0},{"_id":"source/images/hashmap/HashMap_base.png","path":"images/hashmap/HashMap_base.png","modified":0,"renderable":0},{"_id":"source/images/hashmap/HashMap_getEntry.png","path":"images/hashmap/HashMap_getEntry.png","modified":0,"renderable":0},{"_id":"source/images/jvm/array.jpg","path":"images/jvm/array.jpg","modified":0,"renderable":0},{"_id":"source/images/jvm/jvm_heap.jpg","path":"images/jvm/jvm_heap.jpg","modified":0,"renderable":0},{"_id":"source/images/jvm/jvm_struct.jpg","path":"images/jvm/jvm_struct.jpg","modified":0,"renderable":0},{"_id":"source/images/jvm/jvm_struct2.jpg","path":"images/jvm/jvm_struct2.jpg","modified":0,"renderable":0},{"_id":"source/images/linklist/LinkedList_add.png","path":"images/linklist/LinkedList_add.png","modified":0,"renderable":0},{"_id":"source/images/linklist/LinkedList_base.png","path":"images/linklist/LinkedList_base.png","modified":0,"renderable":0},{"_id":"source/images/linklist/LinkedList_remove.png","path":"images/linklist/LinkedList_remove.png","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"source/images/hashmap/HashMap_removeEntryForKey.png","path":"images/hashmap/HashMap_removeEntryForKey.png","modified":0,"renderable":0},{"_id":"source/images/threadpool/工作流程.jpg","path":"images/threadpool/工作流程.jpg","modified":0,"renderable":0},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/LICENSE","path":"vendors/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/README.md","path":"vendors/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/bower.json","path":"vendors/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/HELP-US-OUT.txt","path":"vendors/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/bower.json","path":"vendors/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/CONTRIBUTING.md","path":"vendors/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/bower.json","path":"vendors/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.lazyload.js","path":"vendors/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.scrollstop.js","path":"vendors/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/bower.json","path":"vendors/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","path":"vendors/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","path":"vendors/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","path":"vendors/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/README.md","path":"vendors/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery/index.js","path":"vendors/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","path":"vendors/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","path":"vendors/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css","path":"vendors/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.min.css","path":"vendors/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css.map","path":"vendors/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.min.js","path":"vendors/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.pack.js","path":"vendors/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","path":"vendors/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","path":"vendors/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","path":"vendors/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","path":"vendors/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","path":"vendors/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","path":"vendors/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","path":"vendors/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","path":"vendors/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","path":"vendors/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","path":"vendors/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/FontAwesome.otf","path":"vendors/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.js","path":"vendors/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","path":"vendors/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","path":"vendors/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","path":"vendors/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"source/images/synchronized/lockstatus.png","path":"images/synchronized/lockstatus.png","modified":0,"renderable":0},{"_id":"source/images/synchronized/object.png","path":"images/synchronized/object.png","modified":0,"renderable":0},{"_id":"source/images/synchronized/thread.png","path":"images/synchronized/thread.png","modified":0,"renderable":0},{"_id":"source/images/synchronized/syn_class.png","path":"images/synchronized/syn_class.png","modified":0,"renderable":0},{"_id":"source/images/docker/docker_struct.png","path":"images/docker/docker_struct.png","modified":0,"renderable":0},{"_id":"source/images/blockchain/arch.png","path":"images/blockchain/arch.png","modified":0,"renderable":0},{"_id":"source/images/blockchain/blockchain.png","path":"images/blockchain/blockchain.png","modified":0,"renderable":0},{"_id":"source/images/binarysearch/example1.png","path":"images/binarysearch/example1.png","modified":0,"renderable":0},{"_id":"source/images/binarysearch/example2.png","path":"images/binarysearch/example2.png","modified":0,"renderable":0},{"_id":"source/images/concurrentHashMap/image004.jpg","path":"images/concurrentHashMap/image004.jpg","modified":0,"renderable":0},{"_id":"source/images/concurrentHashMap/image005.jpg","path":"images/concurrentHashMap/image005.jpg","modified":0,"renderable":0},{"_id":"source/images/ratelimit/a2.png","path":"images/ratelimit/a2.png","modified":0,"renderable":0},{"_id":"source/images/ratelimit/a1.png","path":"images/ratelimit/a1.png","modified":0,"renderable":0},{"_id":"source/images/spring-ioc/bean_init.jpg","path":"images/spring-ioc/bean_init.jpg","modified":0,"renderable":0},{"_id":"source/images/spring-ioc/beanfactory.png","path":"images/spring-ioc/beanfactory.png","modified":0,"renderable":0},{"_id":"source/images/redis/redis-memcached.png","path":"images/redis/redis-memcached.png","modified":0,"renderable":0},{"_id":"source/images/jvm_trouble/top.png","path":"images/jvm_trouble/top.png","modified":0,"renderable":0},{"_id":"source/images/jvm_trouble/thread.png","path":"images/jvm_trouble/thread.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/404.html","hash":"3451ccd3230a849cf30ec06f4b2ca7ab4f11002d","modified":1519352794864},{"_id":"themes/next/.bowerrc","hash":"80e096fdc1cf912ee85dd9f7e6e77fd40cf60f10","modified":1508643418000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1508643418000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1508643418000},{"_id":"themes/next/.javascript_ignore","hash":"d619ee13031908cd72666e4ff652d2ea3483b1c3","modified":1508643418000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1508643418000},{"_id":"themes/next/README.en.md","hash":"565ba52b3825b85a9f05b41183caca7f18b741d4","modified":1508643418000},{"_id":"themes/next/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1508643418000},{"_id":"themes/next/_config.yml","hash":"1910e5e86015e6436b8f7a440c572836f8ce0371","modified":1519439061745},{"_id":"themes/next/bower.json","hash":"f89c6700a11d81e067cc97273ca6bf96cb88c8f9","modified":1508643418000},{"_id":"themes/next/gulpfile.coffee","hash":"26e5b1b945704c8bc78b928feede895c4c111c95","modified":1508643418000},{"_id":"themes/next/package.json","hash":"63e9c0f1dd9e5d7f51b4ae383981ef939a2ed45d","modified":1508643418000},{"_id":"source/404/index.md","hash":"1f081d7129ecc5880d0992fe90ec98c2fc7547a8","modified":1519352794865},{"_id":"source/_discarded/Java垃圾回收探究-1.md","hash":"793a49266c2c2cc587b203af0e42d57e6bfa627e","modified":1519884577392},{"_id":"source/_posts/HashMap.md","hash":"1f5a14ea185860abd2f7760559975e43bf19045f","modified":1519460303594},{"_id":"source/_discarded/test.md","hash":"774cfc05535907eb94710066526ca07eb47d39aa","modified":1519372586926},{"_id":"source/_posts/Javagc.md","hash":"40a4e84918e93c0c73c949237809dfced6fc17ed","modified":1519894103213},{"_id":"source/_posts/LinkedList.md","hash":"ee427a00f6312e5b7bdb1f39918dac8ed8528447","modified":1519611748180},{"_id":"source/_posts/synchronized_lock.md","hash":"b38b12f364939dd042a39cb601bd2f7bec6734f9","modified":1520318089296},{"_id":"source/_posts/threadpool.md","hash":"306bebc3e53de519d0c4f8b0e5d82c066ef17f8a","modified":1519712767449},{"_id":"source/about/index.md","hash":"e8767a0fef74236301e5accbe8ee40e39239bd3c","modified":1519366891902},{"_id":"source/_posts/arraylist.md","hash":"f8b1eb7d03b20dac7c232d3154aa43a7727648ef","modified":1519459612023},{"_id":"source/categories/index.md","hash":"ab753cae0f9eac08fb93a3fa4f373f70e7a1ebb4","modified":1519366922707},{"_id":"source/_posts/jvm_memory.md","hash":"f2cfa62b2ab0f1b43790671feb8eee32b6c0a78c","modified":1519868209979},{"_id":"source/tags/index.md","hash":"eec0aee6a3da51eca76d405b84b6d23ea9c2faaa","modified":1519366954155},{"_id":"themes/next/languages/de.yml","hash":"786afba25cfc98845a20d9901823ebeebcd1cbbf","modified":1508643418000},{"_id":"themes/next/languages/default.yml","hash":"9db835c0543ade5a89bc80ec5a898203227cf3d8","modified":1508643418000},{"_id":"themes/next/languages/fr-FR.yml","hash":"1a084623c39de74301f3e92f9388a3a815a542ca","modified":1508643418000},{"_id":"themes/next/languages/en.yml","hash":"f03799cbdb5a33064ead080bcac4baca1f6bc5f9","modified":1508643418000},{"_id":"themes/next/languages/id.yml","hash":"147c01e41b931085ad14250fa900c2249dcbbdd7","modified":1508643418000},{"_id":"themes/next/languages/ja.yml","hash":"a2c7b6301b5474aab798946fb700289df237c3cf","modified":1508643418000},{"_id":"themes/next/languages/pt.yml","hash":"ca239b39bf65c9462e59d51b12f0fe566d453197","modified":1508643418000},{"_id":"themes/next/languages/ru.yml","hash":"cc7b964a46587aea0e57b0a5269d8fd25570858e","modified":1508643418000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"bea452bc49aed171a210d09bd6cddc4e846ea8ab","modified":1508643418000},{"_id":"themes/next/languages/zh-hk.yml","hash":"519ab3d817ec3bc5bfc91159c494b6b3c170bea7","modified":1508643418000},{"_id":"themes/next/languages/zh-tw.yml","hash":"6b1f345aaefc13e6723dc8a6741b59ac05c20dfd","modified":1508643418000},{"_id":"themes/next/layout/_layout.swig","hash":"74157f6cfd679ea11febec632542793f37c5e5d4","modified":1508643418000},{"_id":"themes/next/layout/archive.swig","hash":"b5b59d70fc1563f482fa07afd435752774ad5981","modified":1508643418000},{"_id":"themes/next/layout/category.swig","hash":"6422d196ceaff4220d54b8af770e7e957f3364ad","modified":1508643418000},{"_id":"themes/next/layout/index.swig","hash":"427d0b95b854e311ae363088ab39a393bf8fdc8b","modified":1508643418000},{"_id":"themes/next/layout/page.swig","hash":"8019d02232a6dd1a665b6a4d2daef8e5dd2f0049","modified":1508643418000},{"_id":"themes/next/layout/tag.swig","hash":"07cf49c49c39a14dfbe9ce8e7d7eea3d4d0a4911","modified":1508643418000},{"_id":"themes/next/layout/post.swig","hash":"e2e512142961ddfe77eba29eaa88f4a2ee43ae18","modified":1508643418000},{"_id":"themes/next/source/CNAME","hash":"febc197e98f40f090cef2354869a2bf63921a07c","modified":1519439436313},{"_id":"themes/next/scripts/merge-configs.js","hash":"0c56be2e85c694247cfa327ea6d627b99ca265e8","modified":1508643418000},{"_id":"themes/next/test/.jshintrc","hash":"096ed6df627373edd820f24d46b8baf528dee61d","modified":1508643418000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1508643418000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1508643418000},{"_id":"source/images/avatar.jpg","hash":"ec40dfe5946dedbaced35335bb7267411a84b6bb","modified":1484706302506},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1508643418000},{"_id":"source/images/arraylist/ArrayList_add.png","hash":"6f14151eeba2344a0a5829ce36807cfa94c361c3","modified":1519458350141},{"_id":"source/images/arraylist/ArrayList_base.png","hash":"f031419ae27e024778f116480abf279191dea885","modified":1519458333318},{"_id":"source/images/arraylist/ArrayList_grow.png","hash":"b924e37892279f98b512963160ff0e66dba29911","modified":1519458340117},{"_id":"source/images/hashmap/HashMap_addEntry.png","hash":"413e4049c486c08e4303caf36a8af92b1afedd12","modified":1519460021938},{"_id":"source/images/hashmap/HashMap_base.png","hash":"925e94e3097898d266b8eb1889f07f47b236f860","modified":1519460015550},{"_id":"source/images/hashmap/HashMap_getEntry.png","hash":"660e0faf3eeef4cfe877b22eba4c2bb56590b65b","modified":1519460018646},{"_id":"source/images/jvm/array.jpg","hash":"09569845fccf6b8f54e5b94046823113e51e01eb","modified":1519798317541},{"_id":"source/images/jvm/jvm_heap.jpg","hash":"5527eb3274a46bf8cef51528c125b132ac857077","modified":1519800463882},{"_id":"source/images/jvm/jvm_struct.jpg","hash":"3ba46ae13a36c96bb6fd18a1e721e389839155a0","modified":1519797466835},{"_id":"source/images/jvm/jvm_struct2.jpg","hash":"175c7038a429759c88c31c2f5f22c071d22ca42b","modified":1519798060900},{"_id":"source/images/linklist/LinkedList_add.png","hash":"9e1625a7b779f21d6d33fec6b9446164322062f2","modified":1519611101941},{"_id":"source/images/linklist/LinkedList_base.png","hash":"13adabf1f86405f40b681cf6ea462da7128a7f1d","modified":1519611099098},{"_id":"source/images/linklist/LinkedList_remove.png","hash":"3f6480e185cba1ae835e9f7558bd46113afda2ab","modified":1519611104495},{"_id":"themes/next/layout/_partials/comments.swig","hash":"b73f9443bee2d3ea383aad52e49ffca8aa97dcc2","modified":1508643418000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"0ce71d8322ea7dea82d9371fa2fe13949aa870e3","modified":1508643418000},{"_id":"themes/next/layout/_partials/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1508643418000},{"_id":"themes/next/layout/_partials/head.swig","hash":"f83b1c55bedd2c1a3eb734c72c6997795a4e5f99","modified":1508643418000},{"_id":"themes/next/layout/_partials/header.swig","hash":"963a765dc00e6ac43cfc53ffaf5725eb854cf95e","modified":1508643418000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1508643418000},{"_id":"themes/next/layout/_partials/search.swig","hash":"011b9d6c9f0a2f4654908ea20b9391f9b7981271","modified":1508643418000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"43c3433155ccd9abcbe7dce2e6bfa1f3a66af18b","modified":1508643418000},{"_id":"themes/next/layout/_macro/post.swig","hash":"1ca03011bed92614832b1343b65be92183957dc5","modified":1508643418000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"37e5b7c42ec17b9b6b786c5512bcc481a21c974e","modified":1508643418000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"b883289054ee54a374caad5d4883591beb94bd8b","modified":1508643418000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"85327c2174d09c6d69c9033592e6c8f7eb7ac3ba","modified":1508643418000},{"_id":"themes/next/layout/_scripts/baidu-push.swig","hash":"82d060fe055d6e423bbc9199f82dfe5c68e74779","modified":1508643418000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1508643418000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1508643418000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"0b91cadecead8e0b5211cc42b085998d94af503a","modified":1508643418000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1508643418000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1508643418000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1508643418000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1508643418000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1508643418000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1508643418000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1508643418000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1508643418000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1508643418000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1508643418000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1508643418000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1508643418000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1508643418000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1508643418000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1508643418000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"3acce36db0feb11a982c6c799aa6b6b47df2827c","modified":1508643418000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1508643418000},{"_id":"source/images/hashmap/HashMap_removeEntryForKey.png","hash":"9ff4ce53602c95a6fa8e1bdbb85c2a258d254be6","modified":1519460024927},{"_id":"source/images/threadpool/工作流程.jpg","hash":"c2ea780babdea00adf46a199710c09b9b27f3efc","modified":1519696328516},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1508643418000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1508643418000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1508643418000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1508643418000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1508643418000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1508643418000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1508643418000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"bd07518060a73795d1250d93a74186444b292a9f","modified":1508643418000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"ff5523d5dacaa77a55a24e50e6e6530c3b98bfad","modified":1508643418000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1508643418000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1508643418000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"7ca5cb4daa58b3504e17f3e02975e794bc634658","modified":1508643418000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"c07f7b2f264e5215b8ed42d67e8cef2477558364","modified":1508643418000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1508643418000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1508643418000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1508643418000},{"_id":"themes/next/layout/_scripts/third-party/analytics.swig","hash":"0a89c04055bade7baa5962f1d5aefe438d83a244","modified":1508643418000},{"_id":"themes/next/layout/_scripts/third-party/comments.swig","hash":"907b931d775d32405d02a25b3b0a3ac03bf804d0","modified":1508643418000},{"_id":"themes/next/layout/_scripts/third-party/lean-analytics.swig","hash":"069bb17fb1db3bc7c85c88efa3ed94ab6becbe2c","modified":1508643418000},{"_id":"themes/next/layout/_scripts/third-party/localsearch.swig","hash":"1561bd0c107d725252c6d746e9ac177fc18f93bf","modified":1508643418000},{"_id":"themes/next/layout/_scripts/third-party/mathjax.swig","hash":"5bafc33f57508d1d04a9930165240f6e9efa8d6d","modified":1508643418000},{"_id":"themes/next/layout/_scripts/third-party/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1508643418000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1508643418000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"715d5b40dc52f319fe4bff0325beb874774d9bd9","modified":1508643418000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"78a83c38f69a8747bb74e420e6c9eeef1ea76525","modified":1508643418000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1508643418000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"3ead77befa064d6327dc7afd0a5af7be59a5f196","modified":1508643418000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1508643418000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1508643418000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1508643418000},{"_id":"themes/next/source/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1508643418000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1508643418000},{"_id":"themes/next/source/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1508643418000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1508643418000},{"_id":"themes/next/source/js/src/utils.js","hash":"e5cb720894c4bc28ca8f10b33df127fb394018d9","modified":1508643418000},{"_id":"themes/next/source/vendors/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1508643418000},{"_id":"themes/next/source/vendors/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1508643418000},{"_id":"themes/next/source/vendors/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1508643418000},{"_id":"themes/next/source/vendors/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1508643418000},{"_id":"themes/next/source/vendors/font-awesome/.bower.json","hash":"7da985a99674e54f514d4fd9fcd3bcea6e7e41d5","modified":1508643418000},{"_id":"themes/next/source/vendors/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1508643418000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"85b279027cb0102b0ad6636486f57f754892c5d4","modified":1508643418000},{"_id":"themes/next/source/vendors/font-awesome/HELP-US-OUT.txt","hash":"69a4c537d167b68a0ccf1c6febd138aeffca60d6","modified":1508643418000},{"_id":"themes/next/source/vendors/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1508643418000},{"_id":"themes/next/source/vendors/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1508643418000},{"_id":"themes/next/source/vendors/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1508643418000},{"_id":"themes/next/source/vendors/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1508643418000},{"_id":"themes/next/source/vendors/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1508643418000},{"_id":"themes/next/source/vendors/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1508643418000},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1508643418000},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1508643418000},{"_id":"themes/next/source/vendors/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1508643418000},{"_id":"themes/next/source/vendors/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1508643418000},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1508643418000},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1508643418000},{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1508643418000},{"_id":"themes/next/source/vendors/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1508643418000},{"_id":"themes/next/source/vendors/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"b49efc66bd055a2d0be7deabfcb02ee72a9a28c8","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"10994990d6e0b4d965a728a22cf7f6ee29cae9f6","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1508643418000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1508643418000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5304f99581da3a31de3ecec959b7adf9002fde83","modified":1508643418000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"54c90cf7bdbf5c596179d8dae6e671bad1292662","modified":1508643418000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1508643418000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"013619c472c7e4b08311c464fcbe9fcf5edde603","modified":1508643418000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1508643418000},{"_id":"themes/next/layout/_scripts/third-party/analytics/cnzz-analytics.swig","hash":"44e761721e8ad787ef571a3cc57bbc12d318a2a3","modified":1508643418000},{"_id":"themes/next/layout/_scripts/third-party/analytics/facebook-sdk.swig","hash":"394d008e5e94575280407ad8a1607a028026cbc3","modified":1508643418000},{"_id":"themes/next/layout/_scripts/third-party/analytics/google-analytics.swig","hash":"30a23fa7e816496fdec0e932aa42e2d13098a9c2","modified":1508643418000},{"_id":"themes/next/layout/_scripts/third-party/analytics/baidu-analytics.swig","hash":"7c43d66da93cde65b473a7d6db2a86f9a42647d6","modified":1508643418000},{"_id":"themes/next/layout/_scripts/third-party/analytics/busuanzi-counter.swig","hash":"4fcbf57c4918528ab51d3d042cff92cf5aefb599","modified":1508643418000},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1508643418000},{"_id":"themes/next/layout/_scripts/third-party/comments/disqus.swig","hash":"bff3b18f56175c53f3bc6d733166c4d998e08732","modified":1508643418000},{"_id":"themes/next/layout/_scripts/third-party/comments/duoshuo.swig","hash":"8c7af79407d223486fba72b8150fe045a553bf70","modified":1508643418000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"7506e7490c69a200831393c38d25e91c156bd471","modified":1508643418000},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1508643418000},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1508643418000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","hash":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1508643418000},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css","hash":"3b87c2560832748cd06f9bfd2fd6ea8edbdae8c7","modified":1508643418000},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.min.css","hash":"05ea25bc9b3ac48993e1fee322d3bc94b49a6e22","modified":1508643418000},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"4303776991ef28f5742ca51c7dffe6f12f0acf34","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"6ed60cc621bac096c0ed7534fa25b1a52dc571d4","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"c2c6c4f6434b4f94aac2af5861cd769427f0ee10","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"be22ad34f546a07f6d56b424338cdd898683eea4","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"ba0395aa8a717485bcc19b336aa0b228998df464","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Pisces/_full-image.styl","hash":"938d39eedc6e3d33918c1145a5bf1e79991d3fcf","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"d09280e5b79f3b573edb30f30c7a5f03ac640986","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"d4b7bd610ca03dbb2f5b66631c0e84a79fb4660b","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"1b10ba2d3ad0c063c418dc94a0b7e0db4b342c53","modified":1508643418000},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1508643418000},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1508643418000},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1508643418000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1508643418000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1508643418000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1508643418000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1508643418000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1508643418000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1508643418000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1508643418000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1508643418000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","hash":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1508643418000},{"_id":"themes/next/source/vendors/font-awesome/fonts/FontAwesome.otf","hash":"0112e96f327d413938d37c1693806f468ffdbace","modified":1508643418000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","hash":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1508643418000},{"_id":"themes/next/source/vendors/velocity/velocity.js","hash":"e63dc7cea055ca60a95d286f32349d88b10c5a4d","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"4da051c7f3924fa2db1e73c55b2baf1c2c150255","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"c890ce7fe933abad7baf39764a01894924854e92","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"90f8f9706cd7fe829cf06e9959a65fd3f8b994fa","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"3c46efd6601e268093ce6d7b1471d18501878f0d","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"8fae54591877a73dff0b29b2be2e8935e3c63575","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"b25132fe6a7ad67059a2c3afc60feabb479bdd75","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/post/post-more-link.styl","hash":"15063d79b5befc21820baf05d6f20cc1c1787477","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"cbca4842a54950e2934b3b8f3cd940f122111aef","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"e792c8dc41561c96d128e9b421187f1c3dc978a0","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"d543d1377c1f61b70e3adb6da0eb12797552e5f2","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"4eb18b12fa0ea6c35925d9a64f64e2a7dae8c7fd","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2e7ec9aaa3293941106b1bdd09055246aa3c3dc6","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"c44f6a553ec7ea5508f2054a13be33a62a15d3a9","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"7690b9596ec3a49befbe529a5a2649abec0faf76","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"2d3abbc85b979a648e0e579e45f16a6eba49d1e7","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"234facd038f144bd0fe09a31ed1357c5d74c517f","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"b03f891883446f3a5548b7cc90d29c77e62f1053","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"795d94561888d31cb7a6ff4a125596809ea69b7d","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"3afc459442c132c480d1d832f1a872f1070bb048","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"618f73450cf541f88a4fddc3d22898aee49d105d","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1508643418000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"8e66c2635d48e11de616bb29c4b1323698eebc0a","modified":1508643418000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","hash":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1508643418000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1508643418000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1508643418000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1508643418000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1508643418000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1508643418000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1508643418000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1508643418000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","hash":"2b3c8ba7008cc014d8fb37abc6f9f49aeda83824","modified":1508643418000},{"_id":"source/_posts/synchronized.md","hash":"6f0fb88d79dd705b5f7eefe1ffbdc40177dc6672","modified":1521096071291},{"_id":"source/images/synchronized/lockstatus.png","hash":"45028314addef8dca99f71ed6b9ac92782e71f31","modified":1520390832291},{"_id":"source/images/synchronized/object.png","hash":"49174afca507acfcf22d7098c3cc720ca2cab508","modified":1520329937797},{"_id":"source/images/synchronized/thread.png","hash":"ff3d368e89872c6235c992e0c6ff71d6ded6d25c","modified":1520324751565},{"_id":"source/images/synchronized/syn_class.png","hash":"0e900db684bf6ef74e249f0ee90e8fb560fe840c","modified":1520325561853},{"_id":"public/404.html","hash":"3bfd5db803b408bfc77f8c60313ad7683e2f23cb","modified":1532657189819},{"_id":"public/categories/index.html","hash":"eaae243cbb44bbedac8b9a25f80fbb3b378bf313","modified":1532657189832},{"_id":"public/about/index.html","hash":"d7b1446c9eb912e74cfb9872ea5a046848375407","modified":1532657189831},{"_id":"public/tags/index.html","hash":"621f5ddc01d6aa0229b76b0231be30f43e103d7a","modified":1532657189832},{"_id":"public/categories/language/index.html","hash":"a3e6631f3e7316800896948ca25c7d05d0509926","modified":1532657189934},{"_id":"public/categories/product/index.html","hash":"4ebd6d00d96244b93e84aec4542eb9fde8636022","modified":1532657189934},{"_id":"public/tags/Java/index.html","hash":"d45f1ec684da4a28435ad8c86eedbb38a977fd18","modified":1532657189935},{"_id":"public/tags/GC/index.html","hash":"626ee4be85bb9b55dfb4938dd11a1cf7da928177","modified":1532657189935},{"_id":"public/tags/synchronized/index.html","hash":"e93e22f98bf72d71f631af86dde632224d8a4ea7","modified":1532657189935},{"_id":"public/tags/lock/index.html","hash":"23272052362ca4f3f7dce82a812b33f3ad7ccac3","modified":1532657189935},{"_id":"public/tags/java/index.html","hash":"2d8032296391a5eeefe491f073b813b8b2a67451","modified":1532657189935},{"_id":"public/tags/threadpool/index.html","hash":"0581716da53c030a9e98c11e4dfe1a4e62d0e899","modified":1532657189935},{"_id":"public/tags/jvm/index.html","hash":"90dcaa5d0ac765bc3502cc45f06c42ced019f8f5","modified":1532657189936},{"_id":"public/archives/index.html","hash":"9280b03b00f1c906a88e22c9bb6862989afa1707","modified":1532657189938},{"_id":"public/archives/2013/index.html","hash":"54dba0caddbf5ff5fdc9c1c7628c4b9d8d16618e","modified":1532657189933},{"_id":"public/archives/2013/02/index.html","hash":"71659f84a6c9b8fb98c8c1aa1db7da25dc9a3030","modified":1532657189933},{"_id":"public/archives/2013/05/index.html","hash":"11ae7f99a3a6a0ff59ec77689e1553b49d598316","modified":1532657189933},{"_id":"public/archives/2013/06/index.html","hash":"dddf71e8c98d73c0f5a12d142c2ff25ad067b8e3","modified":1532657189933},{"_id":"public/archives/2013/07/index.html","hash":"ce6e6e3ebd36ead9738f80f87c2a558a17ae77ff","modified":1532657189933},{"_id":"public/product/threadpool/index.html","hash":"746b76d8b5c84a560bd00d077493bf1ceab77d72","modified":1532657189937},{"_id":"public/language/synchronized/index.html","hash":"462ca6c03d2a033be4cb567994651e9cac61f55d","modified":1532657189937},{"_id":"public/language/HashMap/index.html","hash":"05e967b1862dc12024b59d340274a7e1359d260c","modified":1532657189938},{"_id":"public/language/arraylist/index.html","hash":"1eeddcfd56210421a404ed90873670455ee23616","modified":1532657189938},{"_id":"public/language/Javagc/index.html","hash":"3fd94e3e0af40d329970ed4a0228e6bcaa19890b","modified":1532657189938},{"_id":"public/language/jvm_memory/index.html","hash":"e057a666448a331d2cafc8cc2dc3a7527c247287","modified":1532657189938},{"_id":"public/language/LinkedList/index.html","hash":"30130cf1a72422cef8812d2603bbc9fe1989fd0c","modified":1532657189938},{"_id":"public/index.html","hash":"309fc49a6ca15e2dba5da4b2b301c97ee218578f","modified":1532657189938},{"_id":"public/CNAME","hash":"febc197e98f40f090cef2354869a2bf63921a07c","modified":1521080794166},{"_id":"public/images/arraylist/ArrayList_add.png","hash":"6f14151eeba2344a0a5829ce36807cfa94c361c3","modified":1521080794166},{"_id":"public/images/arraylist/ArrayList_base.png","hash":"f031419ae27e024778f116480abf279191dea885","modified":1521080794166},{"_id":"public/images/arraylist/ArrayList_grow.png","hash":"b924e37892279f98b512963160ff0e66dba29911","modified":1521080794166},{"_id":"public/images/hashmap/HashMap_addEntry.png","hash":"413e4049c486c08e4303caf36a8af92b1afedd12","modified":1521080794166},{"_id":"public/images/hashmap/HashMap_base.png","hash":"925e94e3097898d266b8eb1889f07f47b236f860","modified":1521080794166},{"_id":"public/images/hashmap/HashMap_getEntry.png","hash":"660e0faf3eeef4cfe877b22eba4c2bb56590b65b","modified":1521080794166},{"_id":"public/images/jvm/jvm_heap.jpg","hash":"5527eb3274a46bf8cef51528c125b132ac857077","modified":1521080794166},{"_id":"public/images/jvm/array.jpg","hash":"09569845fccf6b8f54e5b94046823113e51e01eb","modified":1521080794166},{"_id":"public/images/jvm/jvm_struct.jpg","hash":"3ba46ae13a36c96bb6fd18a1e721e389839155a0","modified":1521080794166},{"_id":"public/images/jvm/jvm_struct2.jpg","hash":"175c7038a429759c88c31c2f5f22c071d22ca42b","modified":1521080794166},{"_id":"public/images/linklist/LinkedList_add.png","hash":"9e1625a7b779f21d6d33fec6b9446164322062f2","modified":1521080794166},{"_id":"public/images/linklist/LinkedList_base.png","hash":"13adabf1f86405f40b681cf6ea462da7128a7f1d","modified":1521080794167},{"_id":"public/images/linklist/LinkedList_remove.png","hash":"3f6480e185cba1ae835e9f7558bd46113afda2ab","modified":1521080794167},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1521080794167},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1521080794169},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1521080794169},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1521080794169},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1521080794169},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1521080794169},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1521080794169},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1521080794169},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1521080794169},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1521080794169},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1521080794169},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1521080794169},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1521080794169},{"_id":"public/vendors/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1521080794169},{"_id":"public/vendors/font-awesome/HELP-US-OUT.txt","hash":"69a4c537d167b68a0ccf1c6febd138aeffca60d6","modified":1521080794169},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.woff2","hash":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1521080794169},{"_id":"public/vendors/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1521080794170},{"_id":"public/vendors/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1521080794170},{"_id":"public/vendors/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1521080794170},{"_id":"public/vendors/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1521080794170},{"_id":"public/vendors/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1521080794170},{"_id":"public/vendors/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1521080794170},{"_id":"public/vendors/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1521080794170},{"_id":"public/vendors/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1521080794170},{"_id":"public/images/synchronized/lockstatus.png","hash":"45028314addef8dca99f71ed6b9ac92782e71f31","modified":1521080794170},{"_id":"public/images/synchronized/object.png","hash":"49174afca507acfcf22d7098c3cc720ca2cab508","modified":1521080794170},{"_id":"public/images/synchronized/thread.png","hash":"ff3d368e89872c6235c992e0c6ff71d6ded6d25c","modified":1521080794170},{"_id":"public/images/avatar.jpg","hash":"ec40dfe5946dedbaced35335bb7267411a84b6bb","modified":1521080794879},{"_id":"public/images/hashmap/HashMap_removeEntryForKey.png","hash":"9ff4ce53602c95a6fa8e1bdbb85c2a258d254be6","modified":1521080794879},{"_id":"public/images/threadpool/工作流程.jpg","hash":"c2ea780babdea00adf46a199710c09b9b27f3efc","modified":1521080794885},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.woff","hash":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1521080794885},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.eot","hash":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1521080794885},{"_id":"public/images/synchronized/syn_class.png","hash":"0e900db684bf6ef74e249f0ee90e8fb560fe840c","modified":1521080794885},{"_id":"public/vendors/font-awesome/fonts/FontAwesome.otf","hash":"0112e96f327d413938d37c1693806f468ffdbace","modified":1521080794885},{"_id":"public/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1521080794895},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1521080794895},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1521080794895},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1521080794895},{"_id":"public/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1521080794895},{"_id":"public/js/src/utils.js","hash":"e5cb720894c4bc28ca8f10b33df127fb394018d9","modified":1521080794895},{"_id":"public/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1521080794895},{"_id":"public/vendors/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1521080794895},{"_id":"public/vendors/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1521080794895},{"_id":"public/vendors/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1521080794895},{"_id":"public/vendors/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1521080794895},{"_id":"public/vendors/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1521080794895},{"_id":"public/vendors/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1521080794896},{"_id":"public/vendors/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1521080794896},{"_id":"public/vendors/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1521080794896},{"_id":"public/js/src/schemes/pisces.js","hash":"7506e7490c69a200831393c38d25e91c156bd471","modified":1521080794896},{"_id":"public/vendors/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1521080794896},{"_id":"public/vendors/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1521080794896},{"_id":"public/vendors/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1521080794896},{"_id":"public/vendors/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1521080794896},{"_id":"public/vendors/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1521080794896},{"_id":"public/vendors/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1521080794896},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1521080794896},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1521080794896},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1521080794896},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1521080794896},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1521080794896},{"_id":"public/css/main.css","hash":"38126bba9b0379deebb098e469d3109a31fd5fab","modified":1521080794896},{"_id":"public/vendors/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1521080794896},{"_id":"public/vendors/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1521080794896},{"_id":"public/vendors/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1521080794896},{"_id":"public/vendors/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1521080794896},{"_id":"public/vendors/font-awesome/css/font-awesome.min.css","hash":"05ea25bc9b3ac48993e1fee322d3bc94b49a6e22","modified":1521080794896},{"_id":"public/vendors/font-awesome/css/font-awesome.css","hash":"3b87c2560832748cd06f9bfd2fd6ea8edbdae8c7","modified":1521080794896},{"_id":"public/vendors/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1521080794896},{"_id":"public/vendors/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1521080794896},{"_id":"public/vendors/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1521080794896},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.ttf","hash":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1521080794896},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.svg","hash":"2b3c8ba7008cc014d8fb37abc6f9f49aeda83824","modified":1521080794914},{"_id":"source/_posts/Docker.md","hash":"ccb57b76d1efd4a50e827ab95bce11212f710617","modified":1521702796585},{"_id":"source/images/docker/docker_struct.png","hash":"6599cbb2f94af8b05127b0b57d798f15e067a9b7","modified":1521537103581},{"_id":"public/archives/2017/index.html","hash":"53198924de19ea4abff20e9d7900ed4ab0dd8c41","modified":1532657189934},{"_id":"public/archives/2017/03/index.html","hash":"a8a291ad5c625d329286b82c549a4e6cf759ef15","modified":1532657189934},{"_id":"public/tags/docker/index.html","hash":"1ae83bf1d3407a0e5c598fdc64113d4c5154c2c0","modified":1532657189936},{"_id":"public/product/Docker/index.html","hash":"4f09dbdb9931fe391d63a19def7c5fefd3415b46","modified":1532657189937},{"_id":"public/images/docker/docker_struct.png","hash":"6599cbb2f94af8b05127b0b57d798f15e067a9b7","modified":1521702831526},{"_id":"source/_posts/blockchain.md","hash":"013cb3bc630d71e260b12f22f3d11a58fd2971de","modified":1522830635237},{"_id":"source/images/blockchain/arch.png","hash":"7cae91f67f3a8b8cad8a29295f80c6e1d3615b59","modified":1522828736968},{"_id":"source/images/blockchain/blockchain.png","hash":"37e85ca67fe73cd927f95aad2682d84675ac73e2","modified":1522828549129},{"_id":"public/archives/2017/12/index.html","hash":"5d5595e74071cbe818b9b1b06ccdb90d7c637ac6","modified":1532657189934},{"_id":"public/categories/blocklink/index.html","hash":"aeb03c35a92e57d6e6ded54766a63b38e6ea63bf","modified":1532657189935},{"_id":"public/tags/区块链/index.html","hash":"99205652f8dc9909f5f145cf62a264582c2159f7","modified":1532657189936},{"_id":"public/blocklink/blockchain/index.html","hash":"b20af5a1fbec2c2b552e291f4ef7b7d11ae3cc51","modified":1532657189937},{"_id":"public/images/blockchain/arch.png","hash":"7cae91f67f3a8b8cad8a29295f80c6e1d3615b59","modified":1523152169572},{"_id":"public/images/blockchain/blockchain.png","hash":"37e85ca67fe73cd927f95aad2682d84675ac73e2","modified":1523152169593},{"_id":"source/_posts/binarysearch.md","hash":"7dd8dc248ee2630c18bbad9d258c591efe55e3ec","modified":1524043661501},{"_id":"public/archives/2015/index.html","hash":"df431421b8a99d8956650123942d9e5117e7437f","modified":1532657189933},{"_id":"public/archives/2015/04/index.html","hash":"a1978fc39d21bdc41175c983923d711bebea3337","modified":1532657189933},{"_id":"public/categories/algorithm/index.html","hash":"0509e6c20964d5743881f24c19fea7511b67413a","modified":1532657189935},{"_id":"public/tags/二分查找/index.html","hash":"38e1c9cad1471052f5b3ce9780e9172dcafc2fd6","modified":1532657189936},{"_id":"public/algorithm/binarysearch/index.html","hash":"fc9a7996c84f4af0075177b260266d890143cb32","modified":1532657189937},{"_id":"source/images/binarysearch/example1.png","hash":"6be8345b5824f64696e95c3900168cc8e5729003","modified":1524040660152},{"_id":"source/images/binarysearch/example2.png","hash":"c68720c8334e10b97718f4b9570c2ab5cd761810","modified":1524042208436},{"_id":"public/images/binarysearch/example1.png","hash":"6be8345b5824f64696e95c3900168cc8e5729003","modified":1524043802132},{"_id":"public/images/binarysearch/example2.png","hash":"c68720c8334e10b97718f4b9570c2ab5cd761810","modified":1524043802133},{"_id":"source/_posts/ConcurrentHashMap.md","hash":"4ca8c78cfd4dcc2fdc104fc00455a58c48bc56c6","modified":1524219511417},{"_id":"source/images/concurrentHashMap/image004.jpg","hash":"084ecde3dab2392c8dfacc687a2e9f124a9a6742","modified":1524216531158},{"_id":"source/images/concurrentHashMap/image005.jpg","hash":"21f7e88adba926244c9b8960839bfc5cf531c84c","modified":1524216711168},{"_id":"public/page/2/index.html","hash":"fe3e796e696d885b78b0298583f580efec1ead85","modified":1532657189938},{"_id":"public/archives/page/2/index.html","hash":"1000b803069fb111d4594192c4d6ecd841f25915","modified":1532657189932},{"_id":"public/archives/2013/08/index.html","hash":"e294fdb68d1d44686cb4648f3e54dd662d15700d","modified":1532657189933},{"_id":"public/tags/ConcurrentHashMap/index.html","hash":"becc95ef6aa5c36abcd4cdd76f41eca8a6d46e7d","modified":1532657189936},{"_id":"public/language/ConcurrentHashMap/index.html","hash":"5c23aafe118f5a7baaafd2dc24c252e8dca0eea3","modified":1532657189937},{"_id":"public/images/concurrentHashMap/image004.jpg","hash":"084ecde3dab2392c8dfacc687a2e9f124a9a6742","modified":1524894540415},{"_id":"public/images/concurrentHashMap/image005.jpg","hash":"21f7e88adba926244c9b8960839bfc5cf531c84c","modified":1524894540415},{"_id":"source/_posts/RedisLock.md","hash":"d5034fa67fd1310db062ec461e06d545c94dd112","modified":1527489777786},{"_id":"public/categories/架构/index.html","hash":"0a285965c2625af747551e1197a89c54297a771d","modified":1532657189937},{"_id":"public/archives/2017/05/index.html","hash":"8c66fb3afb7062469acacfbd1b508ba62db1236e","modified":1532657189934},{"_id":"public/架构/RedisLock/index.html","hash":"39f49e978d7244a998cf50f1c3e91462d1a04dee","modified":1532657189937},{"_id":"public/tags/redis/index.html","hash":"b670ea03789516b1cf48003904e917ca0a551eed","modified":1532657189936},{"_id":"source/_posts/quicksort.md","hash":"333c80f38e564ef5381a8252b423b4347e559b5a","modified":1526868707308},{"_id":"public/archives/2015/05/index.html","hash":"04fba8eec5aedf569c591793dba92b9153691f22","modified":1532657189934},{"_id":"public/tags/快速排序/index.html","hash":"9b77e7fe886fc4a50816c2e671e6361ea109603a","modified":1532657189936},{"_id":"public/algorithm/quicksort/index.html","hash":"79a7f0632c8b3e668f93dc75b4ade4e1b98bf269","modified":1532657189937},{"_id":"source/_posts/rate_limit.md","hash":"bfa3d1f13389d8dee0d6a7ff70e2a52209d25620","modified":1527217046601},{"_id":"source/images/ratelimit/a2.png","hash":"b7ad4e9759b069e5bbebaa6219905e7d52b16fcc","modified":1526970313488},{"_id":"source/images/ratelimit/a1.png","hash":"9b3e1f230ccf4a5f6ffd1bc4e2dffc0ab339fb5c","modified":1526969956934},{"_id":"public/archives/2017/07/index.html","hash":"653c67cfc6b1ca4f9b5d2d98b58496d68c3cedcb","modified":1532657189934},{"_id":"public/tags/接口限流/index.html","hash":"ab04723e601cb7bb1571608e1ecc5aa103f605ef","modified":1532657189936},{"_id":"public/架构/rate_limit/index.html","hash":"c69443ec0f693051c4838699b0644a40aa00bf60","modified":1532657189937},{"_id":"public/images/ratelimit/a1.png","hash":"9b3e1f230ccf4a5f6ffd1bc4e2dffc0ab339fb5c","modified":1527217063349},{"_id":"public/images/ratelimit/a2.png","hash":"b7ad4e9759b069e5bbebaa6219905e7d52b16fcc","modified":1527217063350},{"_id":"source/_posts/ThreadLocal.md","hash":"093622f767b0d20954a1682e939c5731bbd27492","modified":1528336129313},{"_id":"public/archives/2014/index.html","hash":"81df1cc1b4b0908ac7ca834073161c3f40129238","modified":1532657189934},{"_id":"public/archives/2014/06/index.html","hash":"08b58aa01ce2dab25aaa88708719563ecdf40cc3","modified":1532657189934},{"_id":"public/categories/Java/index.html","hash":"82037f3030330ea4c5b8b2b88c42328754bdf2a2","modified":1532657189935},{"_id":"public/tags/ThreadLocal/index.html","hash":"09a4749462688dabb3978089e74fe22a8274d726","modified":1532657189936},{"_id":"public/Java/ThreadLocal/index.html","hash":"e9fd6f40ecfa42ecd8c9a7159963d515bec2d997","modified":1532657189937},{"_id":"source/_posts/Spring-AOP.md","hash":"f422a320c9640518035d05327c7c25c6018baa0b","modified":1529388434721},{"_id":"public/categories/框架/index.html","hash":"93eb19d0e19717f3b54b0e93711452cd31dd4220","modified":1532657189937},{"_id":"public/archives/2013/09/index.html","hash":"bba51b34cb9aa697902ad5b7acbeadab36a1bda6","modified":1532657189933},{"_id":"public/tags/spring/index.html","hash":"6e58c03228457bd2f0d59e136dcafaf145530521","modified":1532657189936},{"_id":"public/tags/aop/index.html","hash":"64ebdcad0e470354888df9bcb3edad6abe45b489","modified":1532657189936},{"_id":"public/框架/Spring-AOP/index.html","hash":"d739e09c68a506d42c5e9d1801655f94b4c6466f","modified":1532657189937},{"_id":"source/_posts/Spring系列-IOC.md","hash":"21a234eb68514f3f404594f8a376acb811308f8c","modified":1530499270095},{"_id":"source/images/spring-ioc/bean_init.jpg","hash":"e093e2541a7f00954f747a13f50dbc8cb18a53c3","modified":1530239870474},{"_id":"source/images/spring-ioc/beanfactory.png","hash":"282ac4e40132384508fb9be82a8f8b9acbebee15","modified":1530498362473},{"_id":"public/框架/Spring系列-IOC/index.html","hash":"f7efa958a06dc428f2e45d73693c879b788ddc72","modified":1532657189937},{"_id":"public/tags/ioc/index.html","hash":"ccbcb50516795fe81e8f9e46887995a8342c50d9","modified":1532657189936},{"_id":"public/images/spring-ioc/bean_init.jpg","hash":"e093e2541a7f00954f747a13f50dbc8cb18a53c3","modified":1530774745522},{"_id":"public/images/spring-ioc/beanfactory.png","hash":"282ac4e40132384508fb9be82a8f8b9acbebee15","modified":1530774745537},{"_id":"source/_posts/Redis-experience.md","hash":"c09a794756a789e1e669660cd7be071a498c34db","modified":1532051524006},{"_id":"source/images/redis/redis-memcached.png","hash":"ae957c73ee927c797d0bf4e92703d985f7e12165","modified":1531967796341},{"_id":"public/archives/2016/index.html","hash":"39bc7f38ad75eeb2b84dfd6caedeabc61db6ee60","modified":1532657189934},{"_id":"public/archives/2016/03/index.html","hash":"4dc452dc6d635f6b31ea28389a1ba3a79de765d6","modified":1532657189934},{"_id":"public/categories/数据库/index.html","hash":"363beaabde0290bc0d3ee86cc10f4492d40b247b","modified":1532657189935},{"_id":"public/数据库/Redis-experience/index.html","hash":"d5f36edfc9ac17e4c28586b861e41828ea7899c0","modified":1532657189937},{"_id":"source/_posts/JVM_Trouble.md","hash":"279d584454b035700487fb19ddd24bea2ae79afe","modified":1532486664122},{"_id":"source/images/jvm_trouble/top.png","hash":"2855b217554911dabfb7343270baade0e5951ed2","modified":1532400416853},{"_id":"public/JVM/JVM_Trouble/index.html","hash":"6baebbc6b028077b3e40c0304083c168dc35e561","modified":1532400564584},{"_id":"public/archives/2016/05/index.html","hash":"9a246b67993ad605519a9b3f2baec94efa464c01","modified":1532400564584},{"_id":"public/categories/JVM/index.html","hash":"b32d155b34d869c678f37db2dc2e59ee30ea4bd9","modified":1532400564585},{"_id":"public/images/jvm_trouble/top.png","hash":"2855b217554911dabfb7343270baade0e5951ed2","modified":1532400564604},{"_id":"source/images/jvm_trouble/thread.png","hash":"421f82ba8484f7bc41a6a29778d3f8cbf669fbba","modified":1532400663450},{"_id":"source/_posts/JVM排查小记.md","hash":"50d810111019a05f3c3f730fb394be05104dc288","modified":1532655434541},{"_id":"public/tags/JVM/index.html","hash":"853eda9ba3dd1cdc82f126e247db6a2eb9262a7e","modified":1532657189936},{"_id":"public/archives/2016/07/index.html","hash":"b0e58ee31f1422c602846f36e451582ef530968a","modified":1532657189940},{"_id":"public/Java/JVM排查小记/index.html","hash":"bcaf4d92f4c2dc4719d1df07a7121afbfdfeaf0f","modified":1532657189940},{"_id":"public/images/jvm_trouble/thread.png","hash":"421f82ba8484f7bc41a6a29778d3f8cbf669fbba","modified":1532657189940},{"_id":"source/_posts/CAS.md","hash":"8d449e00c0e8429d8711de6368a79fe7db25c6dc","modified":1533181071542}],"Category":[{"name":"语言","_id":"cjefa5boh00056skch6ssboy5"},{"name":"实战","_id":"cjefa5bpm000n6skcy7e486jl"},{"name":"区块链","_id":"cjfktbq2p0001w0kc5gqcdado"},{"name":"算法","_id":"cjfrwqk2f0001wckcf0yvcysy"},{"name":"架构","_id":"cjh09eiol0001okkcnedll8dc"},{"name":"Java","_id":"cji3vntwz0001zgkcac7r3ujv"},{"name":"框架","_id":"cjila9qs30001o8kcr88vcqpj"},{"name":"数据库","_id":"cjjp5xnvv0001fgkc2eui6n11"},{"name":"JVM","_id":"cjjz3gdpo0001l8kc4bbc7jwb"},{"name":"并发","_id":"cjk7q5js20001v4kcczrbi5jk"}],"Data":[],"Page":[{"_content":"<html>\n<head>\n<meta charset=\"utf-8\">\n<script type=\"text/javascript\">\n\tfunction redirect(){\n\t\tlocation.href=\"https://onelee85.github.io/\";\n\t}\n</script>\n</head>\n\n<body onload=\"redirect();\">\n</body>\n</html>","source":"404.html","raw":"<html>\n<head>\n<meta charset=\"utf-8\">\n<script type=\"text/javascript\">\n\tfunction redirect(){\n\t\tlocation.href=\"https://onelee85.github.io/\";\n\t}\n</script>\n</head>\n\n<body onload=\"redirect();\">\n</body>\n</html>","date":"2018-02-23T09:29:35.584Z","updated":"2018-02-23T02:26:34.864Z","path":"404.html","title":"","comments":1,"layout":"page","_id":"cjefa5bmd00006skc7b1exrb9","content":"<html>\n<head>\n<meta charset=\"utf-8\">\n<script type=\"text/javascript\">\n\tfunction redirect(){\n\t\tlocation.href=\"https://onelee85.github.io/\";\n\t}\n</script>\n</head>\n\n<body onload=\"redirect();\">\n</body>\n</html>","site":{"data":{}},"excerpt":"","more":"<html>\n<head>\n<meta charset=\"utf-8\">\n<script type=\"text/javascript\">\n\tfunction redirect(){\n\t\tlocation.href=\"https://onelee85.github.io/\";\n\t}\n</script>\n</head>\n\n<body onload=\"redirect();\">\n</body>\n</html>"},{"title":"404","date":"2016-08-31T10:31:34.000Z","_content":"","source":"404/index.md","raw":"---\ntitle: 404\ndate: 2016-08-31 18:31:34\npermalink: /404\n---\n","updated":"2018-02-23T02:26:34.865Z","path":"/404.html","comments":1,"layout":"page","_id":"cjefa5bny00016skchdhkkf96","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"categories","date":"2016-06-05T08:20:37.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2016-06-05 16:20:37\ntype: \"categories\"\ncomments: false\n---","updated":"2018-02-23T06:22:02.707Z","path":"categories/index.html","layout":"page","_id":"cjefa5bo900036skcm37qxwwz","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"关于我","comments":0,"_content":"\n# 关于我\n\nJames 湖南人，热爱美食\n\n# 技术兴趣\n\n高性能服务端编程和分布式系统相关\n\n","source":"about/index.md","raw":"---\ntitle: 关于我\ncomments: false\n---\n\n# 关于我\n\nJames 湖南人，热爱美食\n\n# 技术兴趣\n\n高性能服务端编程和分布式系统相关\n\n","date":"2018-02-23T09:29:35.584Z","updated":"2018-02-23T06:21:31.902Z","path":"about/index.html","layout":"page","_id":"cjefa5bol00076skcogqzg32q","content":"<h1 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h1><p>James 湖南人，热爱美食</p>\n<h1 id=\"技术兴趣\"><a href=\"#技术兴趣\" class=\"headerlink\" title=\"技术兴趣\"></a>技术兴趣</h1><p>高性能服务端编程和分布式系统相关</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h1><p>James 湖南人，热爱美食</p>\n<h1 id=\"技术兴趣\"><a href=\"#技术兴趣\" class=\"headerlink\" title=\"技术兴趣\"></a>技术兴趣</h1><p>高性能服务端编程和分布式系统相关</p>\n"},{"title":"tags","date":"2016-06-13T15:10:40.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2016-06-13 23:10:40\ntype: \"tags\"\ncomments: false\n---\n","updated":"2018-02-23T06:22:34.155Z","path":"tags/index.html","layout":"page","_id":"cjefa5bor00096skc18z8qxo8","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Java垃圾回收探究","author":"James","date":"2013-06-01T06:09:00.000Z","_content":"\n# 介绍\n\nJava的内存分配与回收全部由JVM垃圾回收进程自动完成。与C语言不同，Java开发者不需要自己编写代码实现垃圾回收。本文主要通过几个方面来探索Java垃圾回收\n\n1. 什么时候需要垃圾回收\n2. 垃圾回收算法有哪些\n3. 垃圾回收器如何工作\n\n<!-- more -->\n\n# 内存的分配\n\n根据分析[JVM内存](/language/jvm_memory/)我们得知**堆**内存是主要用来保存运行时的对象实例,所以我们主要关注点就集中在堆内存。\n\nJ在JVM的堆内存空间中分为年老代和年轻代。将大量（据统计差不多90%以上）创建了没多久就会消亡的对象存储在年轻代，而年老代中存放生命周期长久的实例对象。\n\n![heap](/images/jvm/jvm_heap.jpg)\n\n1.新生代（Young Generation）\n\n2.老年代（Old Generation）实例将从S1提升到Tenured（终身代）\n\n3.久代（Permanent Generation）包含类、方法等细节的元信息\n\n\n\n# 垃圾回收的条件\n\n如何判定对象是否存活的？\n\n## 根搜索算法\n\n思路: 通过一系列的名为`GC Roots`的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到`GC Roots`没有任何引用链相连时，则证明此对象是不可用的。\n\n`GC Roots` 的对象包括下面几种:\n\n1. 虚拟机栈（栈帧中的本地变量表）中的引用的对象。\n2. 方法区中的类静态属性引用的对象。\n3. 方法区中的常量引用的对象。\n4. 本地方法栈中JNI（Native方法）的引用的对象。\n\n# 回收算法\n\n## 引用计数法\n\n引用计数是垃圾收集器中的早期策略。在这种方法中，堆中每个对象实例都有一个引用计数。当一个对象被创建时，且将该对象实例分配给一个变量，该变量计数设置为1。当任何其它变量被赋值为这个对象的引用时，计数加1（a = b,则b引用的对象实例的计数器+1），但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数器减1。任何引用计数器为0的对象实例可以被当作垃圾收集。当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器减1。**缺点**是无法检测出循环引用。如父对象有一个对子对象的引用，子对象反过来引用父对象。这样，他们的引用计数永远不可能为0.\n\n## 标记-清除算法\n\n标记-清除算法采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象进行回收。此算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片。\n\n## 标记-整理算法\n\n标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往空闲空间移动，并更新对应的指针。标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。\n\n## 复制算法\n\n该算法的提出是为了克服句柄的开销和解决堆碎片的垃圾回收。它开始时把堆分成 一个对象 面和多个空闲面， 程序从对象面为对象分配空间，当对象满了，基于copying算法的垃圾 收集就从根集中扫描活动对象，并将每个 活动对象复制到空闲面(使得活动对象所占的内存之间没有空闲洞)，这样空闲面变成了对象面，原来的对象面变成了空闲面，程序会在新的对象面中分配内存。\n\n\n\n# 回收策略\n\n在JVM中**不同的对象的生命周期是不一样的**。因此，不同生命周期的对象可以采取不同的回收算法，以便提高回收效率。\n\n## **年轻代（Young Generation）** 复制算法\n\n1. 所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。\n2. 新生代内存按照8:1:1的比例分为一个eden区和两个survivor(survivor0,survivor1)区。大部分对象在Eden区中生成。回收时先将eden区存活对象复制到一个survivor0区，然后清空eden区，当这个survivor0区也存放满了时，则将eden区和survivor0区存活对象复制到另一个survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后将survivor0区和survivor1区交换，即保持survivor1区为空， 如此往复。\n3. 当survivor1区不足以存放 eden和survivor0的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次Full GC，也就是新生代、老年代都进行回收。\n4. 新生代发生的GC也叫做Minor GC，MinorGC发生频率比较高(不一定等Eden区满了才触发)。\n\n## **年老代（Old Generation）**标记-整理算法\n\n1. 在年轻代中经历了N次垃圾回收后仍然存活的对象(`MaxTenuringThreshold`控制进入老年前生存次数)，会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。\n2. 年老代内存比新生代大很多(大概比例是1:2)，当老年代内存满时触发Major GC即Full GC，Full GC发生频率比较低，老年代对象存活时间比较长，存活率标记高。\n\n## **持久代（Permanent Generation）**\n\n​\t用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate 等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。\n\n# 垃圾收集器\n\n新生代收集器使用的收集器：Serial、PraNew、Parallel Scavenge\n\n老年代收集器使用的收集器：Serial Old、Parallel Old、CMS\n\n\n\n## **Serial收集器（复制算法)**\n\n新生代单线程收集器，标记和清理都是单线程，优点是简单高效。\n\n## **Serial Old收集器(标记-整理算法)**\n\n老年代单线程收集器，Serial收集器的老年代版本。\n\n## **ParNew收集器(停止-复制算法)　**\n\n新生代收集器，可以认为是Serial收集器的多线程版本,在多核CPU环境下有着比Serial更好的表现。\n\n## **Parallel Scavenge收集器(停止-复制算法)**\n\n并行收集器，追求高吞吐量，高效利用CPU。吞吐量一般为99%， 吞吐量= 用户线程时间/(用户线程时间+GC线程时间)。适合后台应用等对交互相应要求不高的场景。\n\n## **Parallel Old收集器(停止-复制算法)**\n\nParallel Scavenge收集器的老年代版本，并行收集器，吞吐量优先\n\n## **CMS(Concurrent Mark Sweep)收集器（标记-清理算法）**\n\n高并发、低停顿，追求最短GC回收停顿时间，cpu占用比较高，响应时间快，停顿时间短，多核cpu 追求高响应时间的选择\n\n## G1垃圾回收器\n\nG1垃圾回收器适用于堆内存很大的情况，他将堆内存分割成不同的区域，并且并发的对其进行垃圾回收。G1也可以在回收内存之后对剩余的堆内存空间进行压缩。并发扫描标记垃圾回收器在STW情况下压缩内存。G1垃圾回收会优先选择第一块垃圾最多的区域\n\n通过JVM参数 `–XX:+UseG1GC` 使用G1垃圾回收器\n\n# 常用JVM参数配置\n\n- **-Xmn**设置Young的空间大小\n- **-XX:NewRatio= 3** 为Tenured:Young的初始尺寸比例（设置了大小就不再设置此值），此时Young占用整个HeapSize的1/4大小\n- **-XX:SurvivorRatio= 6**：为Eden:Survivor比例大小，此时一个Survivor占用Young的1/8大小，而Eden占用3/4大小。\n- **-XX:MaxTenuringThreshold=3**：一般一个对象在Young经过多少次GC后会被移动到OLD区。\n- **-XX:+UseParNewGC**：对Yong区域启用并行回收算法。\n- **-XX:+UseConcMarkSweepGC** 启动并发GC，一般针对Tenured区域。\n\n\n\n# 实战问题\n\n常见的OOM现象有以下几种：\n\n1. heapSize溢出：**java.lang.OutOfMemoryError：**java heap space\n\n   这个需要设置Java虚拟机的内存情况\n\n2. PermSize溢出：**java.lang.OutOfMemoryError：**PermGen space\n\n   需要设置Perm相关参数以及检查内存中的常量情况，jdk1.7中的常量池移到了堆中。\n\n3. 栈内存溢出错误：**StackOverflowError**\n\n   通常都是程序的问题，JVM对栈帧的大小设置已经很大了，比如递归\n\n4. native Thread溢出，注意线程Stack的大小，以及本身操作系统的限制。","source":"_posts/Javagc.md","raw":"title: Java垃圾回收探究\nauthor: James\ntags:\n  - Java\n  - GC\ncategories:\n  - 语言\ndate: 2013-06-01 14:09:00\n---\n\n# 介绍\n\nJava的内存分配与回收全部由JVM垃圾回收进程自动完成。与C语言不同，Java开发者不需要自己编写代码实现垃圾回收。本文主要通过几个方面来探索Java垃圾回收\n\n1. 什么时候需要垃圾回收\n2. 垃圾回收算法有哪些\n3. 垃圾回收器如何工作\n\n<!-- more -->\n\n# 内存的分配\n\n根据分析[JVM内存](/language/jvm_memory/)我们得知**堆**内存是主要用来保存运行时的对象实例,所以我们主要关注点就集中在堆内存。\n\nJ在JVM的堆内存空间中分为年老代和年轻代。将大量（据统计差不多90%以上）创建了没多久就会消亡的对象存储在年轻代，而年老代中存放生命周期长久的实例对象。\n\n![heap](/images/jvm/jvm_heap.jpg)\n\n1.新生代（Young Generation）\n\n2.老年代（Old Generation）实例将从S1提升到Tenured（终身代）\n\n3.久代（Permanent Generation）包含类、方法等细节的元信息\n\n\n\n# 垃圾回收的条件\n\n如何判定对象是否存活的？\n\n## 根搜索算法\n\n思路: 通过一系列的名为`GC Roots`的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到`GC Roots`没有任何引用链相连时，则证明此对象是不可用的。\n\n`GC Roots` 的对象包括下面几种:\n\n1. 虚拟机栈（栈帧中的本地变量表）中的引用的对象。\n2. 方法区中的类静态属性引用的对象。\n3. 方法区中的常量引用的对象。\n4. 本地方法栈中JNI（Native方法）的引用的对象。\n\n# 回收算法\n\n## 引用计数法\n\n引用计数是垃圾收集器中的早期策略。在这种方法中，堆中每个对象实例都有一个引用计数。当一个对象被创建时，且将该对象实例分配给一个变量，该变量计数设置为1。当任何其它变量被赋值为这个对象的引用时，计数加1（a = b,则b引用的对象实例的计数器+1），但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数器减1。任何引用计数器为0的对象实例可以被当作垃圾收集。当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器减1。**缺点**是无法检测出循环引用。如父对象有一个对子对象的引用，子对象反过来引用父对象。这样，他们的引用计数永远不可能为0.\n\n## 标记-清除算法\n\n标记-清除算法采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象进行回收。此算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片。\n\n## 标记-整理算法\n\n标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往空闲空间移动，并更新对应的指针。标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。\n\n## 复制算法\n\n该算法的提出是为了克服句柄的开销和解决堆碎片的垃圾回收。它开始时把堆分成 一个对象 面和多个空闲面， 程序从对象面为对象分配空间，当对象满了，基于copying算法的垃圾 收集就从根集中扫描活动对象，并将每个 活动对象复制到空闲面(使得活动对象所占的内存之间没有空闲洞)，这样空闲面变成了对象面，原来的对象面变成了空闲面，程序会在新的对象面中分配内存。\n\n\n\n# 回收策略\n\n在JVM中**不同的对象的生命周期是不一样的**。因此，不同生命周期的对象可以采取不同的回收算法，以便提高回收效率。\n\n## **年轻代（Young Generation）** 复制算法\n\n1. 所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。\n2. 新生代内存按照8:1:1的比例分为一个eden区和两个survivor(survivor0,survivor1)区。大部分对象在Eden区中生成。回收时先将eden区存活对象复制到一个survivor0区，然后清空eden区，当这个survivor0区也存放满了时，则将eden区和survivor0区存活对象复制到另一个survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后将survivor0区和survivor1区交换，即保持survivor1区为空， 如此往复。\n3. 当survivor1区不足以存放 eden和survivor0的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次Full GC，也就是新生代、老年代都进行回收。\n4. 新生代发生的GC也叫做Minor GC，MinorGC发生频率比较高(不一定等Eden区满了才触发)。\n\n## **年老代（Old Generation）**标记-整理算法\n\n1. 在年轻代中经历了N次垃圾回收后仍然存活的对象(`MaxTenuringThreshold`控制进入老年前生存次数)，会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。\n2. 年老代内存比新生代大很多(大概比例是1:2)，当老年代内存满时触发Major GC即Full GC，Full GC发生频率比较低，老年代对象存活时间比较长，存活率标记高。\n\n## **持久代（Permanent Generation）**\n\n​\t用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate 等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。\n\n# 垃圾收集器\n\n新生代收集器使用的收集器：Serial、PraNew、Parallel Scavenge\n\n老年代收集器使用的收集器：Serial Old、Parallel Old、CMS\n\n\n\n## **Serial收集器（复制算法)**\n\n新生代单线程收集器，标记和清理都是单线程，优点是简单高效。\n\n## **Serial Old收集器(标记-整理算法)**\n\n老年代单线程收集器，Serial收集器的老年代版本。\n\n## **ParNew收集器(停止-复制算法)　**\n\n新生代收集器，可以认为是Serial收集器的多线程版本,在多核CPU环境下有着比Serial更好的表现。\n\n## **Parallel Scavenge收集器(停止-复制算法)**\n\n并行收集器，追求高吞吐量，高效利用CPU。吞吐量一般为99%， 吞吐量= 用户线程时间/(用户线程时间+GC线程时间)。适合后台应用等对交互相应要求不高的场景。\n\n## **Parallel Old收集器(停止-复制算法)**\n\nParallel Scavenge收集器的老年代版本，并行收集器，吞吐量优先\n\n## **CMS(Concurrent Mark Sweep)收集器（标记-清理算法）**\n\n高并发、低停顿，追求最短GC回收停顿时间，cpu占用比较高，响应时间快，停顿时间短，多核cpu 追求高响应时间的选择\n\n## G1垃圾回收器\n\nG1垃圾回收器适用于堆内存很大的情况，他将堆内存分割成不同的区域，并且并发的对其进行垃圾回收。G1也可以在回收内存之后对剩余的堆内存空间进行压缩。并发扫描标记垃圾回收器在STW情况下压缩内存。G1垃圾回收会优先选择第一块垃圾最多的区域\n\n通过JVM参数 `–XX:+UseG1GC` 使用G1垃圾回收器\n\n# 常用JVM参数配置\n\n- **-Xmn**设置Young的空间大小\n- **-XX:NewRatio= 3** 为Tenured:Young的初始尺寸比例（设置了大小就不再设置此值），此时Young占用整个HeapSize的1/4大小\n- **-XX:SurvivorRatio= 6**：为Eden:Survivor比例大小，此时一个Survivor占用Young的1/8大小，而Eden占用3/4大小。\n- **-XX:MaxTenuringThreshold=3**：一般一个对象在Young经过多少次GC后会被移动到OLD区。\n- **-XX:+UseParNewGC**：对Yong区域启用并行回收算法。\n- **-XX:+UseConcMarkSweepGC** 启动并发GC，一般针对Tenured区域。\n\n\n\n# 实战问题\n\n常见的OOM现象有以下几种：\n\n1. heapSize溢出：**java.lang.OutOfMemoryError：**java heap space\n\n   这个需要设置Java虚拟机的内存情况\n\n2. PermSize溢出：**java.lang.OutOfMemoryError：**PermGen space\n\n   需要设置Perm相关参数以及检查内存中的常量情况，jdk1.7中的常量池移到了堆中。\n\n3. 栈内存溢出错误：**StackOverflowError**\n\n   通常都是程序的问题，JVM对栈帧的大小设置已经很大了，比如递归\n\n4. native Thread溢出，注意线程Stack的大小，以及本身操作系统的限制。","slug":"Javagc","published":1,"updated":"2018-03-01T08:48:23.213Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjefa5bo100026skcf0id5b8s","content":"<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p>Java的内存分配与回收全部由JVM垃圾回收进程自动完成。与C语言不同，Java开发者不需要自己编写代码实现垃圾回收。本文主要通过几个方面来探索Java垃圾回收</p>\n<ol>\n<li>什么时候需要垃圾回收</li>\n<li>垃圾回收算法有哪些</li>\n<li>垃圾回收器如何工作</li>\n</ol>\n<a id=\"more\"></a>\n<h1 id=\"内存的分配\"><a href=\"#内存的分配\" class=\"headerlink\" title=\"内存的分配\"></a>内存的分配</h1><p>根据分析<a href=\"/language/jvm_memory/\">JVM内存</a>我们得知<strong>堆</strong>内存是主要用来保存运行时的对象实例,所以我们主要关注点就集中在堆内存。</p>\n<p>J在JVM的堆内存空间中分为年老代和年轻代。将大量（据统计差不多90%以上）创建了没多久就会消亡的对象存储在年轻代，而年老代中存放生命周期长久的实例对象。</p>\n<p><img src=\"/images/jvm/jvm_heap.jpg\" alt=\"heap\"></p>\n<p>1.新生代（Young Generation）</p>\n<p>2.老年代（Old Generation）实例将从S1提升到Tenured（终身代）</p>\n<p>3.久代（Permanent Generation）包含类、方法等细节的元信息</p>\n<h1 id=\"垃圾回收的条件\"><a href=\"#垃圾回收的条件\" class=\"headerlink\" title=\"垃圾回收的条件\"></a>垃圾回收的条件</h1><p>如何判定对象是否存活的？</p>\n<h2 id=\"根搜索算法\"><a href=\"#根搜索算法\" class=\"headerlink\" title=\"根搜索算法\"></a>根搜索算法</h2><p>思路: 通过一系列的名为<code>GC Roots</code>的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到<code>GC Roots</code>没有任何引用链相连时，则证明此对象是不可用的。</p>\n<p><code>GC Roots</code> 的对象包括下面几种:</p>\n<ol>\n<li>虚拟机栈（栈帧中的本地变量表）中的引用的对象。</li>\n<li>方法区中的类静态属性引用的对象。</li>\n<li>方法区中的常量引用的对象。</li>\n<li>本地方法栈中JNI（Native方法）的引用的对象。</li>\n</ol>\n<h1 id=\"回收算法\"><a href=\"#回收算法\" class=\"headerlink\" title=\"回收算法\"></a>回收算法</h1><h2 id=\"引用计数法\"><a href=\"#引用计数法\" class=\"headerlink\" title=\"引用计数法\"></a>引用计数法</h2><p>引用计数是垃圾收集器中的早期策略。在这种方法中，堆中每个对象实例都有一个引用计数。当一个对象被创建时，且将该对象实例分配给一个变量，该变量计数设置为1。当任何其它变量被赋值为这个对象的引用时，计数加1（a = b,则b引用的对象实例的计数器+1），但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数器减1。任何引用计数器为0的对象实例可以被当作垃圾收集。当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器减1。<strong>缺点</strong>是无法检测出循环引用。如父对象有一个对子对象的引用，子对象反过来引用父对象。这样，他们的引用计数永远不可能为0.</p>\n<h2 id=\"标记-清除算法\"><a href=\"#标记-清除算法\" class=\"headerlink\" title=\"标记-清除算法\"></a>标记-清除算法</h2><p>标记-清除算法采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象进行回收。此算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片。</p>\n<h2 id=\"标记-整理算法\"><a href=\"#标记-整理算法\" class=\"headerlink\" title=\"标记-整理算法\"></a>标记-整理算法</h2><p>标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往空闲空间移动，并更新对应的指针。标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。</p>\n<h2 id=\"复制算法\"><a href=\"#复制算法\" class=\"headerlink\" title=\"复制算法\"></a>复制算法</h2><p>该算法的提出是为了克服句柄的开销和解决堆碎片的垃圾回收。它开始时把堆分成 一个对象 面和多个空闲面， 程序从对象面为对象分配空间，当对象满了，基于copying算法的垃圾 收集就从根集中扫描活动对象，并将每个 活动对象复制到空闲面(使得活动对象所占的内存之间没有空闲洞)，这样空闲面变成了对象面，原来的对象面变成了空闲面，程序会在新的对象面中分配内存。</p>\n<h1 id=\"回收策略\"><a href=\"#回收策略\" class=\"headerlink\" title=\"回收策略\"></a>回收策略</h1><p>在JVM中<strong>不同的对象的生命周期是不一样的</strong>。因此，不同生命周期的对象可以采取不同的回收算法，以便提高回收效率。</p>\n<h2 id=\"年轻代（Young-Generation）-复制算法\"><a href=\"#年轻代（Young-Generation）-复制算法\" class=\"headerlink\" title=\"年轻代（Young Generation） 复制算法\"></a><strong>年轻代（Young Generation）</strong> 复制算法</h2><ol>\n<li>所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。</li>\n<li>新生代内存按照8:1:1的比例分为一个eden区和两个survivor(survivor0,survivor1)区。大部分对象在Eden区中生成。回收时先将eden区存活对象复制到一个survivor0区，然后清空eden区，当这个survivor0区也存放满了时，则将eden区和survivor0区存活对象复制到另一个survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后将survivor0区和survivor1区交换，即保持survivor1区为空， 如此往复。</li>\n<li>当survivor1区不足以存放 eden和survivor0的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次Full GC，也就是新生代、老年代都进行回收。</li>\n<li>新生代发生的GC也叫做Minor GC，MinorGC发生频率比较高(不一定等Eden区满了才触发)。</li>\n</ol>\n<h2 id=\"年老代（Old-Generation）标记-整理算法\"><a href=\"#年老代（Old-Generation）标记-整理算法\" class=\"headerlink\" title=\"年老代（Old Generation）标记-整理算法\"></a><strong>年老代（Old Generation）</strong>标记-整理算法</h2><ol>\n<li>在年轻代中经历了N次垃圾回收后仍然存活的对象(<code>MaxTenuringThreshold</code>控制进入老年前生存次数)，会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。</li>\n<li>年老代内存比新生代大很多(大概比例是1:2)，当老年代内存满时触发Major GC即Full GC，Full GC发生频率比较低，老年代对象存活时间比较长，存活率标记高。</li>\n</ol>\n<h2 id=\"持久代（Permanent-Generation）\"><a href=\"#持久代（Permanent-Generation）\" class=\"headerlink\" title=\"持久代（Permanent Generation）\"></a><strong>持久代（Permanent Generation）</strong></h2><p>​    用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate 等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。</p>\n<h1 id=\"垃圾收集器\"><a href=\"#垃圾收集器\" class=\"headerlink\" title=\"垃圾收集器\"></a>垃圾收集器</h1><p>新生代收集器使用的收集器：Serial、PraNew、Parallel Scavenge</p>\n<p>老年代收集器使用的收集器：Serial Old、Parallel Old、CMS</p>\n<h2 id=\"Serial收集器（复制算法\"><a href=\"#Serial收集器（复制算法\" class=\"headerlink\" title=\"Serial收集器（复制算法)\"></a><strong>Serial收集器（复制算法)</strong></h2><p>新生代单线程收集器，标记和清理都是单线程，优点是简单高效。</p>\n<h2 id=\"Serial-Old收集器-标记-整理算法\"><a href=\"#Serial-Old收集器-标记-整理算法\" class=\"headerlink\" title=\"Serial Old收集器(标记-整理算法)\"></a><strong>Serial Old收集器(标记-整理算法)</strong></h2><p>老年代单线程收集器，Serial收集器的老年代版本。</p>\n<h2 id=\"ParNew收集器-停止-复制算法\"><a href=\"#ParNew收集器-停止-复制算法\" class=\"headerlink\" title=\"ParNew收集器(停止-复制算法)　\"></a><strong>ParNew收集器(停止-复制算法)　</strong></h2><p>新生代收集器，可以认为是Serial收集器的多线程版本,在多核CPU环境下有着比Serial更好的表现。</p>\n<h2 id=\"Parallel-Scavenge收集器-停止-复制算法\"><a href=\"#Parallel-Scavenge收集器-停止-复制算法\" class=\"headerlink\" title=\"Parallel Scavenge收集器(停止-复制算法)\"></a><strong>Parallel Scavenge收集器(停止-复制算法)</strong></h2><p>并行收集器，追求高吞吐量，高效利用CPU。吞吐量一般为99%， 吞吐量= 用户线程时间/(用户线程时间+GC线程时间)。适合后台应用等对交互相应要求不高的场景。</p>\n<h2 id=\"Parallel-Old收集器-停止-复制算法\"><a href=\"#Parallel-Old收集器-停止-复制算法\" class=\"headerlink\" title=\"Parallel Old收集器(停止-复制算法)\"></a><strong>Parallel Old收集器(停止-复制算法)</strong></h2><p>Parallel Scavenge收集器的老年代版本，并行收集器，吞吐量优先</p>\n<h2 id=\"CMS-Concurrent-Mark-Sweep-收集器（标记-清理算法）\"><a href=\"#CMS-Concurrent-Mark-Sweep-收集器（标记-清理算法）\" class=\"headerlink\" title=\"CMS(Concurrent Mark Sweep)收集器（标记-清理算法）\"></a><strong>CMS(Concurrent Mark Sweep)收集器（标记-清理算法）</strong></h2><p>高并发、低停顿，追求最短GC回收停顿时间，cpu占用比较高，响应时间快，停顿时间短，多核cpu 追求高响应时间的选择</p>\n<h2 id=\"G1垃圾回收器\"><a href=\"#G1垃圾回收器\" class=\"headerlink\" title=\"G1垃圾回收器\"></a>G1垃圾回收器</h2><p>G1垃圾回收器适用于堆内存很大的情况，他将堆内存分割成不同的区域，并且并发的对其进行垃圾回收。G1也可以在回收内存之后对剩余的堆内存空间进行压缩。并发扫描标记垃圾回收器在STW情况下压缩内存。G1垃圾回收会优先选择第一块垃圾最多的区域</p>\n<p>通过JVM参数 <code>–XX:+UseG1GC</code> 使用G1垃圾回收器</p>\n<h1 id=\"常用JVM参数配置\"><a href=\"#常用JVM参数配置\" class=\"headerlink\" title=\"常用JVM参数配置\"></a>常用JVM参数配置</h1><ul>\n<li><strong>-Xmn</strong>设置Young的空间大小</li>\n<li><strong>-XX:NewRatio= 3</strong> 为Tenured:Young的初始尺寸比例（设置了大小就不再设置此值），此时Young占用整个HeapSize的1/4大小</li>\n<li><strong>-XX:SurvivorRatio= 6</strong>：为Eden:Survivor比例大小，此时一个Survivor占用Young的1/8大小，而Eden占用3/4大小。</li>\n<li><strong>-XX:MaxTenuringThreshold=3</strong>：一般一个对象在Young经过多少次GC后会被移动到OLD区。</li>\n<li><strong>-XX:+UseParNewGC</strong>：对Yong区域启用并行回收算法。</li>\n<li><strong>-XX:+UseConcMarkSweepGC</strong> 启动并发GC，一般针对Tenured区域。</li>\n</ul>\n<h1 id=\"实战问题\"><a href=\"#实战问题\" class=\"headerlink\" title=\"实战问题\"></a>实战问题</h1><p>常见的OOM现象有以下几种：</p>\n<ol>\n<li><p>heapSize溢出：<strong>java.lang.OutOfMemoryError：</strong>java heap space</p>\n<p>这个需要设置Java虚拟机的内存情况</p>\n</li>\n<li><p>PermSize溢出：<strong>java.lang.OutOfMemoryError：</strong>PermGen space</p>\n<p>需要设置Perm相关参数以及检查内存中的常量情况，jdk1.7中的常量池移到了堆中。</p>\n</li>\n<li><p>栈内存溢出错误：<strong>StackOverflowError</strong></p>\n<p>通常都是程序的问题，JVM对栈帧的大小设置已经很大了，比如递归</p>\n</li>\n<li><p>native Thread溢出，注意线程Stack的大小，以及本身操作系统的限制。</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p>Java的内存分配与回收全部由JVM垃圾回收进程自动完成。与C语言不同，Java开发者不需要自己编写代码实现垃圾回收。本文主要通过几个方面来探索Java垃圾回收</p>\n<ol>\n<li>什么时候需要垃圾回收</li>\n<li>垃圾回收算法有哪些</li>\n<li>垃圾回收器如何工作</li>\n</ol>","more":"<h1 id=\"内存的分配\"><a href=\"#内存的分配\" class=\"headerlink\" title=\"内存的分配\"></a>内存的分配</h1><p>根据分析<a href=\"/language/jvm_memory/\">JVM内存</a>我们得知<strong>堆</strong>内存是主要用来保存运行时的对象实例,所以我们主要关注点就集中在堆内存。</p>\n<p>J在JVM的堆内存空间中分为年老代和年轻代。将大量（据统计差不多90%以上）创建了没多久就会消亡的对象存储在年轻代，而年老代中存放生命周期长久的实例对象。</p>\n<p><img src=\"/images/jvm/jvm_heap.jpg\" alt=\"heap\"></p>\n<p>1.新生代（Young Generation）</p>\n<p>2.老年代（Old Generation）实例将从S1提升到Tenured（终身代）</p>\n<p>3.久代（Permanent Generation）包含类、方法等细节的元信息</p>\n<h1 id=\"垃圾回收的条件\"><a href=\"#垃圾回收的条件\" class=\"headerlink\" title=\"垃圾回收的条件\"></a>垃圾回收的条件</h1><p>如何判定对象是否存活的？</p>\n<h2 id=\"根搜索算法\"><a href=\"#根搜索算法\" class=\"headerlink\" title=\"根搜索算法\"></a>根搜索算法</h2><p>思路: 通过一系列的名为<code>GC Roots</code>的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到<code>GC Roots</code>没有任何引用链相连时，则证明此对象是不可用的。</p>\n<p><code>GC Roots</code> 的对象包括下面几种:</p>\n<ol>\n<li>虚拟机栈（栈帧中的本地变量表）中的引用的对象。</li>\n<li>方法区中的类静态属性引用的对象。</li>\n<li>方法区中的常量引用的对象。</li>\n<li>本地方法栈中JNI（Native方法）的引用的对象。</li>\n</ol>\n<h1 id=\"回收算法\"><a href=\"#回收算法\" class=\"headerlink\" title=\"回收算法\"></a>回收算法</h1><h2 id=\"引用计数法\"><a href=\"#引用计数法\" class=\"headerlink\" title=\"引用计数法\"></a>引用计数法</h2><p>引用计数是垃圾收集器中的早期策略。在这种方法中，堆中每个对象实例都有一个引用计数。当一个对象被创建时，且将该对象实例分配给一个变量，该变量计数设置为1。当任何其它变量被赋值为这个对象的引用时，计数加1（a = b,则b引用的对象实例的计数器+1），但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数器减1。任何引用计数器为0的对象实例可以被当作垃圾收集。当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器减1。<strong>缺点</strong>是无法检测出循环引用。如父对象有一个对子对象的引用，子对象反过来引用父对象。这样，他们的引用计数永远不可能为0.</p>\n<h2 id=\"标记-清除算法\"><a href=\"#标记-清除算法\" class=\"headerlink\" title=\"标记-清除算法\"></a>标记-清除算法</h2><p>标记-清除算法采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象进行回收。此算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片。</p>\n<h2 id=\"标记-整理算法\"><a href=\"#标记-整理算法\" class=\"headerlink\" title=\"标记-整理算法\"></a>标记-整理算法</h2><p>标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往空闲空间移动，并更新对应的指针。标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。</p>\n<h2 id=\"复制算法\"><a href=\"#复制算法\" class=\"headerlink\" title=\"复制算法\"></a>复制算法</h2><p>该算法的提出是为了克服句柄的开销和解决堆碎片的垃圾回收。它开始时把堆分成 一个对象 面和多个空闲面， 程序从对象面为对象分配空间，当对象满了，基于copying算法的垃圾 收集就从根集中扫描活动对象，并将每个 活动对象复制到空闲面(使得活动对象所占的内存之间没有空闲洞)，这样空闲面变成了对象面，原来的对象面变成了空闲面，程序会在新的对象面中分配内存。</p>\n<h1 id=\"回收策略\"><a href=\"#回收策略\" class=\"headerlink\" title=\"回收策略\"></a>回收策略</h1><p>在JVM中<strong>不同的对象的生命周期是不一样的</strong>。因此，不同生命周期的对象可以采取不同的回收算法，以便提高回收效率。</p>\n<h2 id=\"年轻代（Young-Generation）-复制算法\"><a href=\"#年轻代（Young-Generation）-复制算法\" class=\"headerlink\" title=\"年轻代（Young Generation） 复制算法\"></a><strong>年轻代（Young Generation）</strong> 复制算法</h2><ol>\n<li>所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。</li>\n<li>新生代内存按照8:1:1的比例分为一个eden区和两个survivor(survivor0,survivor1)区。大部分对象在Eden区中生成。回收时先将eden区存活对象复制到一个survivor0区，然后清空eden区，当这个survivor0区也存放满了时，则将eden区和survivor0区存活对象复制到另一个survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后将survivor0区和survivor1区交换，即保持survivor1区为空， 如此往复。</li>\n<li>当survivor1区不足以存放 eden和survivor0的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次Full GC，也就是新生代、老年代都进行回收。</li>\n<li>新生代发生的GC也叫做Minor GC，MinorGC发生频率比较高(不一定等Eden区满了才触发)。</li>\n</ol>\n<h2 id=\"年老代（Old-Generation）标记-整理算法\"><a href=\"#年老代（Old-Generation）标记-整理算法\" class=\"headerlink\" title=\"年老代（Old Generation）标记-整理算法\"></a><strong>年老代（Old Generation）</strong>标记-整理算法</h2><ol>\n<li>在年轻代中经历了N次垃圾回收后仍然存活的对象(<code>MaxTenuringThreshold</code>控制进入老年前生存次数)，会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。</li>\n<li>年老代内存比新生代大很多(大概比例是1:2)，当老年代内存满时触发Major GC即Full GC，Full GC发生频率比较低，老年代对象存活时间比较长，存活率标记高。</li>\n</ol>\n<h2 id=\"持久代（Permanent-Generation）\"><a href=\"#持久代（Permanent-Generation）\" class=\"headerlink\" title=\"持久代（Permanent Generation）\"></a><strong>持久代（Permanent Generation）</strong></h2><p>​    用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate 等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。</p>\n<h1 id=\"垃圾收集器\"><a href=\"#垃圾收集器\" class=\"headerlink\" title=\"垃圾收集器\"></a>垃圾收集器</h1><p>新生代收集器使用的收集器：Serial、PraNew、Parallel Scavenge</p>\n<p>老年代收集器使用的收集器：Serial Old、Parallel Old、CMS</p>\n<h2 id=\"Serial收集器（复制算法\"><a href=\"#Serial收集器（复制算法\" class=\"headerlink\" title=\"Serial收集器（复制算法)\"></a><strong>Serial收集器（复制算法)</strong></h2><p>新生代单线程收集器，标记和清理都是单线程，优点是简单高效。</p>\n<h2 id=\"Serial-Old收集器-标记-整理算法\"><a href=\"#Serial-Old收集器-标记-整理算法\" class=\"headerlink\" title=\"Serial Old收集器(标记-整理算法)\"></a><strong>Serial Old收集器(标记-整理算法)</strong></h2><p>老年代单线程收集器，Serial收集器的老年代版本。</p>\n<h2 id=\"ParNew收集器-停止-复制算法\"><a href=\"#ParNew收集器-停止-复制算法\" class=\"headerlink\" title=\"ParNew收集器(停止-复制算法)　\"></a><strong>ParNew收集器(停止-复制算法)　</strong></h2><p>新生代收集器，可以认为是Serial收集器的多线程版本,在多核CPU环境下有着比Serial更好的表现。</p>\n<h2 id=\"Parallel-Scavenge收集器-停止-复制算法\"><a href=\"#Parallel-Scavenge收集器-停止-复制算法\" class=\"headerlink\" title=\"Parallel Scavenge收集器(停止-复制算法)\"></a><strong>Parallel Scavenge收集器(停止-复制算法)</strong></h2><p>并行收集器，追求高吞吐量，高效利用CPU。吞吐量一般为99%， 吞吐量= 用户线程时间/(用户线程时间+GC线程时间)。适合后台应用等对交互相应要求不高的场景。</p>\n<h2 id=\"Parallel-Old收集器-停止-复制算法\"><a href=\"#Parallel-Old收集器-停止-复制算法\" class=\"headerlink\" title=\"Parallel Old收集器(停止-复制算法)\"></a><strong>Parallel Old收集器(停止-复制算法)</strong></h2><p>Parallel Scavenge收集器的老年代版本，并行收集器，吞吐量优先</p>\n<h2 id=\"CMS-Concurrent-Mark-Sweep-收集器（标记-清理算法）\"><a href=\"#CMS-Concurrent-Mark-Sweep-收集器（标记-清理算法）\" class=\"headerlink\" title=\"CMS(Concurrent Mark Sweep)收集器（标记-清理算法）\"></a><strong>CMS(Concurrent Mark Sweep)收集器（标记-清理算法）</strong></h2><p>高并发、低停顿，追求最短GC回收停顿时间，cpu占用比较高，响应时间快，停顿时间短，多核cpu 追求高响应时间的选择</p>\n<h2 id=\"G1垃圾回收器\"><a href=\"#G1垃圾回收器\" class=\"headerlink\" title=\"G1垃圾回收器\"></a>G1垃圾回收器</h2><p>G1垃圾回收器适用于堆内存很大的情况，他将堆内存分割成不同的区域，并且并发的对其进行垃圾回收。G1也可以在回收内存之后对剩余的堆内存空间进行压缩。并发扫描标记垃圾回收器在STW情况下压缩内存。G1垃圾回收会优先选择第一块垃圾最多的区域</p>\n<p>通过JVM参数 <code>–XX:+UseG1GC</code> 使用G1垃圾回收器</p>\n<h1 id=\"常用JVM参数配置\"><a href=\"#常用JVM参数配置\" class=\"headerlink\" title=\"常用JVM参数配置\"></a>常用JVM参数配置</h1><ul>\n<li><strong>-Xmn</strong>设置Young的空间大小</li>\n<li><strong>-XX:NewRatio= 3</strong> 为Tenured:Young的初始尺寸比例（设置了大小就不再设置此值），此时Young占用整个HeapSize的1/4大小</li>\n<li><strong>-XX:SurvivorRatio= 6</strong>：为Eden:Survivor比例大小，此时一个Survivor占用Young的1/8大小，而Eden占用3/4大小。</li>\n<li><strong>-XX:MaxTenuringThreshold=3</strong>：一般一个对象在Young经过多少次GC后会被移动到OLD区。</li>\n<li><strong>-XX:+UseParNewGC</strong>：对Yong区域启用并行回收算法。</li>\n<li><strong>-XX:+UseConcMarkSweepGC</strong> 启动并发GC，一般针对Tenured区域。</li>\n</ul>\n<h1 id=\"实战问题\"><a href=\"#实战问题\" class=\"headerlink\" title=\"实战问题\"></a>实战问题</h1><p>常见的OOM现象有以下几种：</p>\n<ol>\n<li><p>heapSize溢出：<strong>java.lang.OutOfMemoryError：</strong>java heap space</p>\n<p>这个需要设置Java虚拟机的内存情况</p>\n</li>\n<li><p>PermSize溢出：<strong>java.lang.OutOfMemoryError：</strong>PermGen space</p>\n<p>需要设置Perm相关参数以及检查内存中的常量情况，jdk1.7中的常量池移到了堆中。</p>\n</li>\n<li><p>栈内存溢出错误：<strong>StackOverflowError</strong></p>\n<p>通常都是程序的问题，JVM对栈帧的大小设置已经很大了，比如递归</p>\n</li>\n<li><p>native Thread溢出，注意线程Stack的大小，以及本身操作系统的限制。</p>\n</li>\n</ol>"},{"title":"HashMap源码学习","author":"James","date":"2013-06-24T08:10:00.000Z","_content":"# 介绍\n*HashMap*实现了*Map*接口，即允许放入`key`为`null`的元素，也允许插入`value`为`null`的元素；除该类未实现同步外，其余跟`Hashtable`大致相同；跟*TreeMap*不同，该容器不保证元素顺序，根据需要该容器可能会对元素重新哈希，元素的顺序也会被重新打散，因此不同时间迭代同一个*HashMap*的顺序可能会不同。\n根据对冲突的处理方式不同，哈希表有两种实现方式，一种开放地址方式（Open addressing），另一种是冲突链表方式（Separate chaining with linked lists）。**Java *HashMap*采用的是冲突链表方式**。\n<!-- more -->\n![HashMap_base](/images/hashmap/HashMap_base.png)\n\n从上图容易看出，如果选择合适的哈希函数，`put()`和`get()`方法可以在常数时间内完成。但在对*HashMap*进行迭代时，需要遍历整个table以及后面跟的冲突链表。因此对于迭代比较频繁的场景，不宜将*HashMap*的初始大小设的过大。\n\n有两个参数可以影响*HashMap*的性能：初始容量（inital capacity）和负载系数（load factor）。初始容量指定了初始`table`的大小，负载系数用来指定自动扩容的临界值。当`entry`的数量超过`capacity*load_factor`时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。\n\n将对象放入到*HashMap*或*HashSet*中时，有两个方法需要特别关心：`hashCode()`和`equals()`。**`hashCode()`方法决定了对象会被放到哪个`bucket`里，当多个对象的哈希值冲突时，`equals()`方法决定了这些对象是否是“同一个对象”**。所以，如果要将自定义的对象放入到`HashMap`或`HashSet`中，需要*@Override*`hashCode()`和`equals()`方法。\n\n# 方法剖析\n\n## get()\n\n`get(Object key)`方法根据指定的`key`值返回对应的`value`，该方法调用了`getEntry(Object key)`得到相应的`entry`，然后返回`entry.getValue()`。因此`getEntry()`是算法的核心。\n算法思想是首先通过`hash()`函数得到对应`bucket`的下标，然后依次遍历冲突链表，通过`key.equals(k)`方法来判断是否是要找的那个`entry`。\n![HashMap_getEntry](/images/hashmap/HashMap_getEntry.png)\n上图中`hash(k)&(table.length-1)`等价于`hash(k)%table.length`，原因是*HashMap*要求`table.length`必须是2的指数，因此`table.length-1`就是二进制低位全是1，跟`hash(k)`相与会将哈希值的高位全抹掉，剩下的就是余数了。\n```Java\n//getEntry()方法\nfinal Entry<K,V> getEntry(Object key) {\n\t......\n\tint hash = (key == null) ? 0 : hash(key);\n    for (Entry<K,V> e = table[hash&(table.length-1)];//得到冲突链表\n         e != null; e = e.next) {//依次遍历冲突链表中的每个entry\n        Object k;\n        //依据equals()方法判断是否相等\n        if (e.hash == hash &&\n            ((k = e.key) == key || (key != null && key.equals(k))))\n            return e;\n    }\n    return null;\n}\n```\n\n## put()\n\n`put(K key, V value)`方法是将指定的`key, value`对添加到`map`里。该方法首先会对`map`做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于`getEntry()`方法；如果没有找到，则会通过`addEntry(int hash, K key, V value, int bucketIndex)`方法插入新的`entry`，插入方式为**头插法**。\n![HashMap_addEntry](/images/hashmap/HashMap_addEntry.png)\n```Java\n//addEntry()\nvoid addEntry(int hash, K key, V value, int bucketIndex) {\n    if ((size >= threshold) && (null != table[bucketIndex])) {\n        resize(2 * table.length);//自动扩容，并重新哈希\n        hash = (null != key) ? hash(key) : 0;\n        bucketIndex = hash & (table.length-1);//hash%table.length\n    }\n    //在冲突链表头部插入新的entry\n    Entry<K,V> e = table[bucketIndex];\n    table[bucketIndex] = new Entry<>(hash, key, value, e);\n    size++;\n}\n```\n\n## remove()\n\n`remove(Object key)`的作用是删除`key`值对应的`entry`，该方法的具体逻辑是在`removeEntryForKey(Object key)`里实现的。`removeEntryForKey()`方法会首先找到`key`值对应的`entry`，然后删除该`entry`（修改链表的相应引用）。查找过程跟`getEntry()`过程类似。\n![HashMap_removeEntryForKey](/images/hashmap/HashMap_removeEntryForKey.png)\n```Java\n//removeEntryForKey()\nfinal Entry<K,V> removeEntryForKey(Object key) {\n\t......\n\tint hash = (key == null) ? 0 : hash(key);\n    int i = indexFor(hash, table.length);//hash&(table.length-1)\n    Entry<K,V> prev = table[i];//得到冲突链表\n    Entry<K,V> e = prev;\n    while (e != null) {//遍历冲突链表\n        Entry<K,V> next = e.next;\n        Object k;\n        if (e.hash == hash &&\n            ((k = e.key) == key || (key != null && key.equals(k)))) {//找到要删除的entry\n            modCount++; size--;\n            if (prev == e) table[i] = next;//删除的是冲突链表的第一个entry\n            else prev.next = next;\n            return e;\n        }\n        prev = e; e = next;\n    }\n    return e;\n}\n```\n\n\n","source":"_posts/HashMap.md","raw":"title: HashMap源码学习\nauthor: James\ntags:\n  - Java\ncategories:\n  - 语言\ndate: 2013-06-24 16:10:00\n---\n# 介绍\n*HashMap*实现了*Map*接口，即允许放入`key`为`null`的元素，也允许插入`value`为`null`的元素；除该类未实现同步外，其余跟`Hashtable`大致相同；跟*TreeMap*不同，该容器不保证元素顺序，根据需要该容器可能会对元素重新哈希，元素的顺序也会被重新打散，因此不同时间迭代同一个*HashMap*的顺序可能会不同。\n根据对冲突的处理方式不同，哈希表有两种实现方式，一种开放地址方式（Open addressing），另一种是冲突链表方式（Separate chaining with linked lists）。**Java *HashMap*采用的是冲突链表方式**。\n<!-- more -->\n![HashMap_base](/images/hashmap/HashMap_base.png)\n\n从上图容易看出，如果选择合适的哈希函数，`put()`和`get()`方法可以在常数时间内完成。但在对*HashMap*进行迭代时，需要遍历整个table以及后面跟的冲突链表。因此对于迭代比较频繁的场景，不宜将*HashMap*的初始大小设的过大。\n\n有两个参数可以影响*HashMap*的性能：初始容量（inital capacity）和负载系数（load factor）。初始容量指定了初始`table`的大小，负载系数用来指定自动扩容的临界值。当`entry`的数量超过`capacity*load_factor`时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。\n\n将对象放入到*HashMap*或*HashSet*中时，有两个方法需要特别关心：`hashCode()`和`equals()`。**`hashCode()`方法决定了对象会被放到哪个`bucket`里，当多个对象的哈希值冲突时，`equals()`方法决定了这些对象是否是“同一个对象”**。所以，如果要将自定义的对象放入到`HashMap`或`HashSet`中，需要*@Override*`hashCode()`和`equals()`方法。\n\n# 方法剖析\n\n## get()\n\n`get(Object key)`方法根据指定的`key`值返回对应的`value`，该方法调用了`getEntry(Object key)`得到相应的`entry`，然后返回`entry.getValue()`。因此`getEntry()`是算法的核心。\n算法思想是首先通过`hash()`函数得到对应`bucket`的下标，然后依次遍历冲突链表，通过`key.equals(k)`方法来判断是否是要找的那个`entry`。\n![HashMap_getEntry](/images/hashmap/HashMap_getEntry.png)\n上图中`hash(k)&(table.length-1)`等价于`hash(k)%table.length`，原因是*HashMap*要求`table.length`必须是2的指数，因此`table.length-1`就是二进制低位全是1，跟`hash(k)`相与会将哈希值的高位全抹掉，剩下的就是余数了。\n```Java\n//getEntry()方法\nfinal Entry<K,V> getEntry(Object key) {\n\t......\n\tint hash = (key == null) ? 0 : hash(key);\n    for (Entry<K,V> e = table[hash&(table.length-1)];//得到冲突链表\n         e != null; e = e.next) {//依次遍历冲突链表中的每个entry\n        Object k;\n        //依据equals()方法判断是否相等\n        if (e.hash == hash &&\n            ((k = e.key) == key || (key != null && key.equals(k))))\n            return e;\n    }\n    return null;\n}\n```\n\n## put()\n\n`put(K key, V value)`方法是将指定的`key, value`对添加到`map`里。该方法首先会对`map`做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于`getEntry()`方法；如果没有找到，则会通过`addEntry(int hash, K key, V value, int bucketIndex)`方法插入新的`entry`，插入方式为**头插法**。\n![HashMap_addEntry](/images/hashmap/HashMap_addEntry.png)\n```Java\n//addEntry()\nvoid addEntry(int hash, K key, V value, int bucketIndex) {\n    if ((size >= threshold) && (null != table[bucketIndex])) {\n        resize(2 * table.length);//自动扩容，并重新哈希\n        hash = (null != key) ? hash(key) : 0;\n        bucketIndex = hash & (table.length-1);//hash%table.length\n    }\n    //在冲突链表头部插入新的entry\n    Entry<K,V> e = table[bucketIndex];\n    table[bucketIndex] = new Entry<>(hash, key, value, e);\n    size++;\n}\n```\n\n## remove()\n\n`remove(Object key)`的作用是删除`key`值对应的`entry`，该方法的具体逻辑是在`removeEntryForKey(Object key)`里实现的。`removeEntryForKey()`方法会首先找到`key`值对应的`entry`，然后删除该`entry`（修改链表的相应引用）。查找过程跟`getEntry()`过程类似。\n![HashMap_removeEntryForKey](/images/hashmap/HashMap_removeEntryForKey.png)\n```Java\n//removeEntryForKey()\nfinal Entry<K,V> removeEntryForKey(Object key) {\n\t......\n\tint hash = (key == null) ? 0 : hash(key);\n    int i = indexFor(hash, table.length);//hash&(table.length-1)\n    Entry<K,V> prev = table[i];//得到冲突链表\n    Entry<K,V> e = prev;\n    while (e != null) {//遍历冲突链表\n        Entry<K,V> next = e.next;\n        Object k;\n        if (e.hash == hash &&\n            ((k = e.key) == key || (key != null && key.equals(k)))) {//找到要删除的entry\n            modCount++; size--;\n            if (prev == e) table[i] = next;//删除的是冲突链表的第一个entry\n            else prev.next = next;\n            return e;\n        }\n        prev = e; e = next;\n    }\n    return e;\n}\n```\n\n\n","slug":"HashMap","published":1,"updated":"2018-02-24T08:18:23.594Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjefa5boa00046skc6qmw3y60","content":"<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p><em>HashMap</em>实现了<em>Map</em>接口，即允许放入<code>key</code>为<code>null</code>的元素，也允许插入<code>value</code>为<code>null</code>的元素；除该类未实现同步外，其余跟<code>Hashtable</code>大致相同；跟<em>TreeMap</em>不同，该容器不保证元素顺序，根据需要该容器可能会对元素重新哈希，元素的顺序也会被重新打散，因此不同时间迭代同一个<em>HashMap</em>的顺序可能会不同。<br>根据对冲突的处理方式不同，哈希表有两种实现方式，一种开放地址方式（Open addressing），另一种是冲突链表方式（Separate chaining with linked lists）。<strong>Java <em>HashMap</em>采用的是冲突链表方式</strong>。<br><a id=\"more\"></a><br><img src=\"/images/hashmap/HashMap_base.png\" alt=\"HashMap_base\"></p>\n<p>从上图容易看出，如果选择合适的哈希函数，<code>put()</code>和<code>get()</code>方法可以在常数时间内完成。但在对<em>HashMap</em>进行迭代时，需要遍历整个table以及后面跟的冲突链表。因此对于迭代比较频繁的场景，不宜将<em>HashMap</em>的初始大小设的过大。</p>\n<p>有两个参数可以影响<em>HashMap</em>的性能：初始容量（inital capacity）和负载系数（load factor）。初始容量指定了初始<code>table</code>的大小，负载系数用来指定自动扩容的临界值。当<code>entry</code>的数量超过<code>capacity*load_factor</code>时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。</p>\n<p>将对象放入到<em>HashMap</em>或<em>HashSet</em>中时，有两个方法需要特别关心：<code>hashCode()</code>和<code>equals()</code>。<strong><code>hashCode()</code>方法决定了对象会被放到哪个<code>bucket</code>里，当多个对象的哈希值冲突时，<code>equals()</code>方法决定了这些对象是否是“同一个对象”</strong>。所以，如果要将自定义的对象放入到<code>HashMap</code>或<code>HashSet</code>中，需要<em>@Override</em><code>hashCode()</code>和<code>equals()</code>方法。</p>\n<h1 id=\"方法剖析\"><a href=\"#方法剖析\" class=\"headerlink\" title=\"方法剖析\"></a>方法剖析</h1><h2 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get()\"></a>get()</h2><p><code>get(Object key)</code>方法根据指定的<code>key</code>值返回对应的<code>value</code>，该方法调用了<code>getEntry(Object key)</code>得到相应的<code>entry</code>，然后返回<code>entry.getValue()</code>。因此<code>getEntry()</code>是算法的核心。<br>算法思想是首先通过<code>hash()</code>函数得到对应<code>bucket</code>的下标，然后依次遍历冲突链表，通过<code>key.equals(k)</code>方法来判断是否是要找的那个<code>entry</code>。<br><img src=\"/images/hashmap/HashMap_getEntry.png\" alt=\"HashMap_getEntry\"><br>上图中<code>hash(k)&amp;(table.length-1)</code>等价于<code>hash(k)%table.length</code>，原因是<em>HashMap</em>要求<code>table.length</code>必须是2的指数，因此<code>table.length-1</code>就是二进制低位全是1，跟<code>hash(k)</code>相与会将哈希值的高位全抹掉，剩下的就是余数了。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//getEntry()方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Entry&lt;K,V&gt; <span class=\"title\">getEntry</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> hash = (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : hash(key);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Entry&lt;K,V&gt; e = table[hash&amp;(table.length-<span class=\"number\">1</span>)];<span class=\"comment\">//得到冲突链表</span></span><br><span class=\"line\">         e != <span class=\"keyword\">null</span>; e = e.next) &#123;<span class=\"comment\">//依次遍历冲突链表中的每个entry</span></span><br><span class=\"line\">        Object k;</span><br><span class=\"line\">        <span class=\"comment\">//依据equals()方法判断是否相等</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">            ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"put\"><a href=\"#put\" class=\"headerlink\" title=\"put()\"></a>put()</h2><p><code>put(K key, V value)</code>方法是将指定的<code>key, value</code>对添加到<code>map</code>里。该方法首先会对<code>map</code>做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于<code>getEntry()</code>方法；如果没有找到，则会通过<code>addEntry(int hash, K key, V value, int bucketIndex)</code>方法插入新的<code>entry</code>，插入方式为<strong>头插法</strong>。<br><img src=\"/images/hashmap/HashMap_addEntry.png\" alt=\"HashMap_addEntry\"><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//addEntry()</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addEntry</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">int</span> bucketIndex)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((size &gt;= threshold) &amp;&amp; (<span class=\"keyword\">null</span> != table[bucketIndex])) &#123;</span><br><span class=\"line\">        resize(<span class=\"number\">2</span> * table.length);<span class=\"comment\">//自动扩容，并重新哈希</span></span><br><span class=\"line\">        hash = (<span class=\"keyword\">null</span> != key) ? hash(key) : <span class=\"number\">0</span>;</span><br><span class=\"line\">        bucketIndex = hash &amp; (table.length-<span class=\"number\">1</span>);<span class=\"comment\">//hash%table.length</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//在冲突链表头部插入新的entry</span></span><br><span class=\"line\">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class=\"line\">    table[bucketIndex] = <span class=\"keyword\">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class=\"line\">    size++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"remove\"><a href=\"#remove\" class=\"headerlink\" title=\"remove()\"></a>remove()</h2><p><code>remove(Object key)</code>的作用是删除<code>key</code>值对应的<code>entry</code>，该方法的具体逻辑是在<code>removeEntryForKey(Object key)</code>里实现的。<code>removeEntryForKey()</code>方法会首先找到<code>key</code>值对应的<code>entry</code>，然后删除该<code>entry</code>（修改链表的相应引用）。查找过程跟<code>getEntry()</code>过程类似。<br><img src=\"/images/hashmap/HashMap_removeEntryForKey.png\" alt=\"HashMap_removeEntryForKey\"><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//removeEntryForKey()</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Entry&lt;K,V&gt; <span class=\"title\">removeEntryForKey</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> hash = (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : hash(key);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = indexFor(hash, table.length);<span class=\"comment\">//hash&amp;(table.length-1)</span></span><br><span class=\"line\">    Entry&lt;K,V&gt; prev = table[i];<span class=\"comment\">//得到冲突链表</span></span><br><span class=\"line\">    Entry&lt;K,V&gt; e = prev;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (e != <span class=\"keyword\">null</span>) &#123;<span class=\"comment\">//遍历冲突链表</span></span><br><span class=\"line\">        Entry&lt;K,V&gt; next = e.next;</span><br><span class=\"line\">        Object k;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">            ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k)))) &#123;<span class=\"comment\">//找到要删除的entry</span></span><br><span class=\"line\">            modCount++; size--;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (prev == e) table[i] = next;<span class=\"comment\">//删除的是冲突链表的第一个entry</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> prev.next = next;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        prev = e; e = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p><em>HashMap</em>实现了<em>Map</em>接口，即允许放入<code>key</code>为<code>null</code>的元素，也允许插入<code>value</code>为<code>null</code>的元素；除该类未实现同步外，其余跟<code>Hashtable</code>大致相同；跟<em>TreeMap</em>不同，该容器不保证元素顺序，根据需要该容器可能会对元素重新哈希，元素的顺序也会被重新打散，因此不同时间迭代同一个<em>HashMap</em>的顺序可能会不同。<br>根据对冲突的处理方式不同，哈希表有两种实现方式，一种开放地址方式（Open addressing），另一种是冲突链表方式（Separate chaining with linked lists）。<strong>Java <em>HashMap</em>采用的是冲突链表方式</strong>。<br>","more":"<br><img src=\"/images/hashmap/HashMap_base.png\" alt=\"HashMap_base\"></p>\n<p>从上图容易看出，如果选择合适的哈希函数，<code>put()</code>和<code>get()</code>方法可以在常数时间内完成。但在对<em>HashMap</em>进行迭代时，需要遍历整个table以及后面跟的冲突链表。因此对于迭代比较频繁的场景，不宜将<em>HashMap</em>的初始大小设的过大。</p>\n<p>有两个参数可以影响<em>HashMap</em>的性能：初始容量（inital capacity）和负载系数（load factor）。初始容量指定了初始<code>table</code>的大小，负载系数用来指定自动扩容的临界值。当<code>entry</code>的数量超过<code>capacity*load_factor</code>时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。</p>\n<p>将对象放入到<em>HashMap</em>或<em>HashSet</em>中时，有两个方法需要特别关心：<code>hashCode()</code>和<code>equals()</code>。<strong><code>hashCode()</code>方法决定了对象会被放到哪个<code>bucket</code>里，当多个对象的哈希值冲突时，<code>equals()</code>方法决定了这些对象是否是“同一个对象”</strong>。所以，如果要将自定义的对象放入到<code>HashMap</code>或<code>HashSet</code>中，需要<em>@Override</em><code>hashCode()</code>和<code>equals()</code>方法。</p>\n<h1 id=\"方法剖析\"><a href=\"#方法剖析\" class=\"headerlink\" title=\"方法剖析\"></a>方法剖析</h1><h2 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get()\"></a>get()</h2><p><code>get(Object key)</code>方法根据指定的<code>key</code>值返回对应的<code>value</code>，该方法调用了<code>getEntry(Object key)</code>得到相应的<code>entry</code>，然后返回<code>entry.getValue()</code>。因此<code>getEntry()</code>是算法的核心。<br>算法思想是首先通过<code>hash()</code>函数得到对应<code>bucket</code>的下标，然后依次遍历冲突链表，通过<code>key.equals(k)</code>方法来判断是否是要找的那个<code>entry</code>。<br><img src=\"/images/hashmap/HashMap_getEntry.png\" alt=\"HashMap_getEntry\"><br>上图中<code>hash(k)&amp;(table.length-1)</code>等价于<code>hash(k)%table.length</code>，原因是<em>HashMap</em>要求<code>table.length</code>必须是2的指数，因此<code>table.length-1</code>就是二进制低位全是1，跟<code>hash(k)</code>相与会将哈希值的高位全抹掉，剩下的就是余数了。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//getEntry()方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Entry&lt;K,V&gt; <span class=\"title\">getEntry</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> hash = (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : hash(key);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Entry&lt;K,V&gt; e = table[hash&amp;(table.length-<span class=\"number\">1</span>)];<span class=\"comment\">//得到冲突链表</span></span><br><span class=\"line\">         e != <span class=\"keyword\">null</span>; e = e.next) &#123;<span class=\"comment\">//依次遍历冲突链表中的每个entry</span></span><br><span class=\"line\">        Object k;</span><br><span class=\"line\">        <span class=\"comment\">//依据equals()方法判断是否相等</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">            ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"put\"><a href=\"#put\" class=\"headerlink\" title=\"put()\"></a>put()</h2><p><code>put(K key, V value)</code>方法是将指定的<code>key, value</code>对添加到<code>map</code>里。该方法首先会对<code>map</code>做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于<code>getEntry()</code>方法；如果没有找到，则会通过<code>addEntry(int hash, K key, V value, int bucketIndex)</code>方法插入新的<code>entry</code>，插入方式为<strong>头插法</strong>。<br><img src=\"/images/hashmap/HashMap_addEntry.png\" alt=\"HashMap_addEntry\"><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//addEntry()</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addEntry</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">int</span> bucketIndex)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((size &gt;= threshold) &amp;&amp; (<span class=\"keyword\">null</span> != table[bucketIndex])) &#123;</span><br><span class=\"line\">        resize(<span class=\"number\">2</span> * table.length);<span class=\"comment\">//自动扩容，并重新哈希</span></span><br><span class=\"line\">        hash = (<span class=\"keyword\">null</span> != key) ? hash(key) : <span class=\"number\">0</span>;</span><br><span class=\"line\">        bucketIndex = hash &amp; (table.length-<span class=\"number\">1</span>);<span class=\"comment\">//hash%table.length</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//在冲突链表头部插入新的entry</span></span><br><span class=\"line\">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class=\"line\">    table[bucketIndex] = <span class=\"keyword\">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class=\"line\">    size++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"remove\"><a href=\"#remove\" class=\"headerlink\" title=\"remove()\"></a>remove()</h2><p><code>remove(Object key)</code>的作用是删除<code>key</code>值对应的<code>entry</code>，该方法的具体逻辑是在<code>removeEntryForKey(Object key)</code>里实现的。<code>removeEntryForKey()</code>方法会首先找到<code>key</code>值对应的<code>entry</code>，然后删除该<code>entry</code>（修改链表的相应引用）。查找过程跟<code>getEntry()</code>过程类似。<br><img src=\"/images/hashmap/HashMap_removeEntryForKey.png\" alt=\"HashMap_removeEntryForKey\"><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//removeEntryForKey()</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Entry&lt;K,V&gt; <span class=\"title\">removeEntryForKey</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> hash = (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : hash(key);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = indexFor(hash, table.length);<span class=\"comment\">//hash&amp;(table.length-1)</span></span><br><span class=\"line\">    Entry&lt;K,V&gt; prev = table[i];<span class=\"comment\">//得到冲突链表</span></span><br><span class=\"line\">    Entry&lt;K,V&gt; e = prev;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (e != <span class=\"keyword\">null</span>) &#123;<span class=\"comment\">//遍历冲突链表</span></span><br><span class=\"line\">        Entry&lt;K,V&gt; next = e.next;</span><br><span class=\"line\">        Object k;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">            ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k)))) &#123;<span class=\"comment\">//找到要删除的entry</span></span><br><span class=\"line\">            modCount++; size--;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (prev == e) table[i] = next;<span class=\"comment\">//删除的是冲突链表的第一个entry</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> prev.next = next;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        prev = e; e = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>"},{"title":"LinkedList源码学习","author":"James","date":"2013-02-26T01:58:00.000Z","_content":"# LinkedList\n\n# 介绍\n\n*LinkedList*同时实现了*List*接口和*Deque*接口，也就是说它既可以看作一个顺序容器，又可以看作一个队列（*Queue*），同时又可以看作一个栈（*Stack*）。这样看来，*LinkedList*简直就是个全能冠军。当你需要使用栈或者队列时，可以考虑使用*LinkedList*，一方面是因为Java官方已经声明不建议使用*Stack*类，更遗憾的是，Java里根本没有一个叫做*Queue*的类（它是个接口名字）。关于栈或队列，现在的首选是*ArrayDeque*，它有着比*LinkedList*（当作栈或队列使用时）有着更好的性能。\n<!-- more -->\n\n![LinkedList_base](/images/linklist/LinkedList_base.png)\n\n*LinkedList*底层**通过双向链表实现**，本节将着重讲解插入和删除元素时双向链表的维护过程，也即是之间解跟*List*接口相关的函数，双向链表的每个节点用内部类*Node*表示。*LinkedList*通过`first`和`last`引用分别指向链表的第一个和最后一个元素。注意这里没有所谓的哑元，当链表为空的时候`first`和`last`都指向`null`。\n\n```Java\n//Node内部类\nprivate static class Node<E> {\n    E item;\n    Node<E> next;\n    Node<E> prev;\n    Node(Node<E> prev, E element, Node<E> next) {\n        this.item = element;\n        this.next = next;\n        this.prev = prev;\n    }\n}\n```\n\n*LinkedList*的实现方式决定了所有跟下标相关的操作都是线性时间，而在首段或者末尾删除元素只需要常数时间。为追求效率*LinkedList*没有实现同步（synchronized），如果需要多个线程并发访问，可以先采用`Collections.synchronizedList()`方法对其进行包装。\n\n# 方法剖析\n\n## add()\n\n*add()*方法有两个版本，一个是`add(E e)`，该方法在*LinkedList*的末尾插入元素，因为有`last`指向链表末尾，在末尾插入元素的花费是常数时间。只需要简单修改几个相关引用即可；另一个是`add(int index, E element)`，该方法是在指定下表处插入元素，需要先通过线性查找找到具体位置，然后修改相关引用完成插入操作。\n\n![LinkedList_add](/images/linklist/LinkedList_add.png)\n\n结合上图，可以看出`add(E e)`的逻辑非常简单。\n```Java\n//add(E e)\npublic boolean add(E e) {\n    final Node<E> l = last;\n    final Node<E> newNode = new Node<>(l, e, null);\n    last = newNode;\n    if (l == null)\n        first = newNode;//原来链表为空，这是插入的第一个元素\n    else\n        l.next = newNode;\n    size++;\n    return true;\n}\n```\n\n`add(int index, E element)`的逻辑稍显复杂，可以分成两部分，1.先根据index找到要插入的位置；2.修改引用，完成插入操作。\n\n```Java\n//add(int index, E element)\npublic void add(int index, E element) {\n\tcheckPositionIndex(index);//index >= 0 && index <= size;\n\tif (index == size)//插入位置是末尾，包括列表为空的情况\n        add(element);\n    else{\n    \tNode<E> succ = node(index);//1.先根据index找到要插入的位置\n        //2.修改引用，完成插入操作。\n        final Node<E> pred = succ.prev;\n        final Node<E> newNode = new Node<>(pred, e, succ);\n        succ.prev = newNode;\n        if (pred == null)//插入位置为0\n            first = newNode;\n        else\n            pred.next = newNode;\n        size++;\n    }\n}\n```\n\n上面代码中的`node(int index)`函数有一点小小的trick，因为链表双向的，可以从开始往后找，也可以从结尾往前找，具体朝那个方向找取决于条件`index < (size >> 1)`，也即是index是靠近前端还是后端。\n\n## remove()\n\n`remove()`方法也有两个版本，一个是删除跟指定元素相等的第一个元素`remove(Object o)`，另一个是删除指定下标处的元素`remove(int index)`。\n\n![LinkedList_remove.png](/images/linklist/LinkedList_remove.png)\n\n两个删除操作都要1.先找到要删除元素的引用，2.修改相关引用，完成删除操作。在寻找被删元素引用的时候`remove(Object o)`调用的是元素的`equals`方法，而`remove(int index)`使用的是下标计数，两种方式都是线性时间复杂度。在步骤2中，两个`revome()`方法都是通过`unlink(Node<E> x)`方法完成的。这里需要考虑删除元素是第一个或者最后一个时的边界情况。\n\n```Java\n//unlink(Node<E> x)，删除一个Node\nE unlink(Node<E> x) {\n    final E element = x.item;\n    final Node<E> next = x.next;\n    final Node<E> prev = x.prev;\n    if (prev == null) {//删除的是第一个元素\n        first = next;\n    } else {\n        prev.next = next;\n        x.prev = null;\n    }\n    if (next == null) {//删除的是最后一个元素\n        last = prev;\n    } else {\n        next.prev = prev;\n        x.next = null;\n    }\n    x.item = null;//let GC work\n    size--;\n    return element;\n}\n```\n\n# get()\n\n`get(int index)`得到指定下标处元素的引用，通过调用上文中提到的`node(int index)`方法实现。\n```Java\npublic E get(int index) {\n    checkElementIndex(index);//index >= 0 && index < size;\n    return node(index).item;\n}\n```\n\n# set()\n\n`set(int index, E element)`方法将指定下标处的元素修改成指定值，也是先通过`node(int index)`找到对应下表元素的引用，然后修改`Node`中`item`的值。\n```Java\npublic E set(int index, E element) {\n    checkElementIndex(index);\n    Node<E> x = node(index);\n    E oldVal = x.item;\n    x.item = element;//替换新值\n    return oldVal;\n}\n```","source":"_posts/LinkedList.md","raw":"title: LinkedList源码学习\nauthor: James\ntags:\n  - java\ncategories:\n  - 语言\ndate: 2013-02-26 09:58:00\n---\n# LinkedList\n\n# 介绍\n\n*LinkedList*同时实现了*List*接口和*Deque*接口，也就是说它既可以看作一个顺序容器，又可以看作一个队列（*Queue*），同时又可以看作一个栈（*Stack*）。这样看来，*LinkedList*简直就是个全能冠军。当你需要使用栈或者队列时，可以考虑使用*LinkedList*，一方面是因为Java官方已经声明不建议使用*Stack*类，更遗憾的是，Java里根本没有一个叫做*Queue*的类（它是个接口名字）。关于栈或队列，现在的首选是*ArrayDeque*，它有着比*LinkedList*（当作栈或队列使用时）有着更好的性能。\n<!-- more -->\n\n![LinkedList_base](/images/linklist/LinkedList_base.png)\n\n*LinkedList*底层**通过双向链表实现**，本节将着重讲解插入和删除元素时双向链表的维护过程，也即是之间解跟*List*接口相关的函数，双向链表的每个节点用内部类*Node*表示。*LinkedList*通过`first`和`last`引用分别指向链表的第一个和最后一个元素。注意这里没有所谓的哑元，当链表为空的时候`first`和`last`都指向`null`。\n\n```Java\n//Node内部类\nprivate static class Node<E> {\n    E item;\n    Node<E> next;\n    Node<E> prev;\n    Node(Node<E> prev, E element, Node<E> next) {\n        this.item = element;\n        this.next = next;\n        this.prev = prev;\n    }\n}\n```\n\n*LinkedList*的实现方式决定了所有跟下标相关的操作都是线性时间，而在首段或者末尾删除元素只需要常数时间。为追求效率*LinkedList*没有实现同步（synchronized），如果需要多个线程并发访问，可以先采用`Collections.synchronizedList()`方法对其进行包装。\n\n# 方法剖析\n\n## add()\n\n*add()*方法有两个版本，一个是`add(E e)`，该方法在*LinkedList*的末尾插入元素，因为有`last`指向链表末尾，在末尾插入元素的花费是常数时间。只需要简单修改几个相关引用即可；另一个是`add(int index, E element)`，该方法是在指定下表处插入元素，需要先通过线性查找找到具体位置，然后修改相关引用完成插入操作。\n\n![LinkedList_add](/images/linklist/LinkedList_add.png)\n\n结合上图，可以看出`add(E e)`的逻辑非常简单。\n```Java\n//add(E e)\npublic boolean add(E e) {\n    final Node<E> l = last;\n    final Node<E> newNode = new Node<>(l, e, null);\n    last = newNode;\n    if (l == null)\n        first = newNode;//原来链表为空，这是插入的第一个元素\n    else\n        l.next = newNode;\n    size++;\n    return true;\n}\n```\n\n`add(int index, E element)`的逻辑稍显复杂，可以分成两部分，1.先根据index找到要插入的位置；2.修改引用，完成插入操作。\n\n```Java\n//add(int index, E element)\npublic void add(int index, E element) {\n\tcheckPositionIndex(index);//index >= 0 && index <= size;\n\tif (index == size)//插入位置是末尾，包括列表为空的情况\n        add(element);\n    else{\n    \tNode<E> succ = node(index);//1.先根据index找到要插入的位置\n        //2.修改引用，完成插入操作。\n        final Node<E> pred = succ.prev;\n        final Node<E> newNode = new Node<>(pred, e, succ);\n        succ.prev = newNode;\n        if (pred == null)//插入位置为0\n            first = newNode;\n        else\n            pred.next = newNode;\n        size++;\n    }\n}\n```\n\n上面代码中的`node(int index)`函数有一点小小的trick，因为链表双向的，可以从开始往后找，也可以从结尾往前找，具体朝那个方向找取决于条件`index < (size >> 1)`，也即是index是靠近前端还是后端。\n\n## remove()\n\n`remove()`方法也有两个版本，一个是删除跟指定元素相等的第一个元素`remove(Object o)`，另一个是删除指定下标处的元素`remove(int index)`。\n\n![LinkedList_remove.png](/images/linklist/LinkedList_remove.png)\n\n两个删除操作都要1.先找到要删除元素的引用，2.修改相关引用，完成删除操作。在寻找被删元素引用的时候`remove(Object o)`调用的是元素的`equals`方法，而`remove(int index)`使用的是下标计数，两种方式都是线性时间复杂度。在步骤2中，两个`revome()`方法都是通过`unlink(Node<E> x)`方法完成的。这里需要考虑删除元素是第一个或者最后一个时的边界情况。\n\n```Java\n//unlink(Node<E> x)，删除一个Node\nE unlink(Node<E> x) {\n    final E element = x.item;\n    final Node<E> next = x.next;\n    final Node<E> prev = x.prev;\n    if (prev == null) {//删除的是第一个元素\n        first = next;\n    } else {\n        prev.next = next;\n        x.prev = null;\n    }\n    if (next == null) {//删除的是最后一个元素\n        last = prev;\n    } else {\n        next.prev = prev;\n        x.next = null;\n    }\n    x.item = null;//let GC work\n    size--;\n    return element;\n}\n```\n\n# get()\n\n`get(int index)`得到指定下标处元素的引用，通过调用上文中提到的`node(int index)`方法实现。\n```Java\npublic E get(int index) {\n    checkElementIndex(index);//index >= 0 && index < size;\n    return node(index).item;\n}\n```\n\n# set()\n\n`set(int index, E element)`方法将指定下标处的元素修改成指定值，也是先通过`node(int index)`找到对应下表元素的引用，然后修改`Node`中`item`的值。\n```Java\npublic E set(int index, E element) {\n    checkElementIndex(index);\n    Node<E> x = node(index);\n    E oldVal = x.item;\n    x.item = element;//替换新值\n    return oldVal;\n}\n```","slug":"LinkedList","published":1,"updated":"2018-02-26T02:22:28.180Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjefa5bot000a6skc44xvg46r","content":"<h1 id=\"LinkedList\"><a href=\"#LinkedList\" class=\"headerlink\" title=\"LinkedList\"></a>LinkedList</h1><h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p><em>LinkedList</em>同时实现了<em>List</em>接口和<em>Deque</em>接口，也就是说它既可以看作一个顺序容器，又可以看作一个队列（<em>Queue</em>），同时又可以看作一个栈（<em>Stack</em>）。这样看来，<em>LinkedList</em>简直就是个全能冠军。当你需要使用栈或者队列时，可以考虑使用<em>LinkedList</em>，一方面是因为Java官方已经声明不建议使用<em>Stack</em>类，更遗憾的是，Java里根本没有一个叫做<em>Queue</em>的类（它是个接口名字）。关于栈或队列，现在的首选是<em>ArrayDeque</em>，它有着比<em>LinkedList</em>（当作栈或队列使用时）有着更好的性能。<br><a id=\"more\"></a></p>\n<p><img src=\"/images/linklist/LinkedList_base.png\" alt=\"LinkedList_base\"></p>\n<p><em>LinkedList</em>底层<strong>通过双向链表实现</strong>，本节将着重讲解插入和删除元素时双向链表的维护过程，也即是之间解跟<em>List</em>接口相关的函数，双向链表的每个节点用内部类<em>Node</em>表示。<em>LinkedList</em>通过<code>first</code>和<code>last</code>引用分别指向链表的第一个和最后一个元素。注意这里没有所谓的哑元，当链表为空的时候<code>first</code>和<code>last</code>都指向<code>null</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Node内部类</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">    E item;</span><br><span class=\"line\">    Node&lt;E&gt; next;</span><br><span class=\"line\">    Node&lt;E&gt; prev;</span><br><span class=\"line\">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.item = element;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.next = next;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.prev = prev;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><em>LinkedList</em>的实现方式决定了所有跟下标相关的操作都是线性时间，而在首段或者末尾删除元素只需要常数时间。为追求效率<em>LinkedList</em>没有实现同步（synchronized），如果需要多个线程并发访问，可以先采用<code>Collections.synchronizedList()</code>方法对其进行包装。</p>\n<h1 id=\"方法剖析\"><a href=\"#方法剖析\" class=\"headerlink\" title=\"方法剖析\"></a>方法剖析</h1><h2 id=\"add\"><a href=\"#add\" class=\"headerlink\" title=\"add()\"></a>add()</h2><p><em>add()</em>方法有两个版本，一个是<code>add(E e)</code>，该方法在<em>LinkedList</em>的末尾插入元素，因为有<code>last</code>指向链表末尾，在末尾插入元素的花费是常数时间。只需要简单修改几个相关引用即可；另一个是<code>add(int index, E element)</code>，该方法是在指定下表处插入元素，需要先通过线性查找找到具体位置，然后修改相关引用完成插入操作。</p>\n<p><img src=\"/images/linklist/LinkedList_add.png\" alt=\"LinkedList_add\"></p>\n<p>结合上图，可以看出<code>add(E e)</code>的逻辑非常简单。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//add(E e)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; l = last;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; newNode = <span class=\"keyword\">new</span> Node&lt;&gt;(l, e, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    last = newNode;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        first = newNode;<span class=\"comment\">//原来链表为空，这是插入的第一个元素</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        l.next = newNode;</span><br><span class=\"line\">    size++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>add(int index, E element)</code>的逻辑稍显复杂，可以分成两部分，1.先根据index找到要插入的位置；2.修改引用，完成插入操作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//add(int index, E element)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\">\tcheckPositionIndex(index);<span class=\"comment\">//index &gt;= 0 &amp;&amp; index &lt;= size;</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (index == size)<span class=\"comment\">//插入位置是末尾，包括列表为空的情况</span></span><br><span class=\"line\">        add(element);</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    \tNode&lt;E&gt; succ = node(index);<span class=\"comment\">//1.先根据index找到要插入的位置</span></span><br><span class=\"line\">        <span class=\"comment\">//2.修改引用，完成插入操作。</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Node&lt;E&gt; newNode = <span class=\"keyword\">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class=\"line\">        succ.prev = newNode;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pred == <span class=\"keyword\">null</span>)<span class=\"comment\">//插入位置为0</span></span><br><span class=\"line\">            first = newNode;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            pred.next = newNode;</span><br><span class=\"line\">        size++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码中的<code>node(int index)</code>函数有一点小小的trick，因为链表双向的，可以从开始往后找，也可以从结尾往前找，具体朝那个方向找取决于条件<code>index &lt; (size &gt;&gt; 1)</code>，也即是index是靠近前端还是后端。</p>\n<h2 id=\"remove\"><a href=\"#remove\" class=\"headerlink\" title=\"remove()\"></a>remove()</h2><p><code>remove()</code>方法也有两个版本，一个是删除跟指定元素相等的第一个元素<code>remove(Object o)</code>，另一个是删除指定下标处的元素<code>remove(int index)</code>。</p>\n<p><img src=\"/images/linklist/LinkedList_remove.png\" alt=\"LinkedList_remove.png\"></p>\n<p>两个删除操作都要1.先找到要删除元素的引用，2.修改相关引用，完成删除操作。在寻找被删元素引用的时候<code>remove(Object o)</code>调用的是元素的<code>equals</code>方法，而<code>remove(int index)</code>使用的是下标计数，两种方式都是线性时间复杂度。在步骤2中，两个<code>revome()</code>方法都是通过<code>unlink(Node&lt;E&gt; x)</code>方法完成的。这里需要考虑删除元素是第一个或者最后一个时的边界情况。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//unlink(Node&lt;E&gt; x)，删除一个Node</span></span><br><span class=\"line\"><span class=\"function\">E <span class=\"title\">unlink</span><span class=\"params\">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> E element = x.item;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; next = x.next;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (prev == <span class=\"keyword\">null</span>) &#123;<span class=\"comment\">//删除的是第一个元素</span></span><br><span class=\"line\">        first = next;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        prev.next = next;</span><br><span class=\"line\">        x.prev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (next == <span class=\"keyword\">null</span>) &#123;<span class=\"comment\">//删除的是最后一个元素</span></span><br><span class=\"line\">        last = prev;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        next.prev = prev;</span><br><span class=\"line\">        x.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    x.item = <span class=\"keyword\">null</span>;<span class=\"comment\">//let GC work</span></span><br><span class=\"line\">    size--;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> element;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get()\"></a>get()</h1><p><code>get(int index)</code>得到指定下标处元素的引用，通过调用上文中提到的<code>node(int index)</code>方法实现。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    checkElementIndex(index);<span class=\"comment\">//index &gt;= 0 &amp;&amp; index &lt; size;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> node(index).item;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set()\"></a>set()</h1><p><code>set(int index, E element)</code>方法将指定下标处的元素修改成指定值，也是先通过<code>node(int index)</code>找到对应下表元素的引用，然后修改<code>Node</code>中<code>item</code>的值。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">set</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\">    checkElementIndex(index);</span><br><span class=\"line\">    Node&lt;E&gt; x = node(index);</span><br><span class=\"line\">    E oldVal = x.item;</span><br><span class=\"line\">    x.item = element;<span class=\"comment\">//替换新值</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> oldVal;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"LinkedList\"><a href=\"#LinkedList\" class=\"headerlink\" title=\"LinkedList\"></a>LinkedList</h1><h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p><em>LinkedList</em>同时实现了<em>List</em>接口和<em>Deque</em>接口，也就是说它既可以看作一个顺序容器，又可以看作一个队列（<em>Queue</em>），同时又可以看作一个栈（<em>Stack</em>）。这样看来，<em>LinkedList</em>简直就是个全能冠军。当你需要使用栈或者队列时，可以考虑使用<em>LinkedList</em>，一方面是因为Java官方已经声明不建议使用<em>Stack</em>类，更遗憾的是，Java里根本没有一个叫做<em>Queue</em>的类（它是个接口名字）。关于栈或队列，现在的首选是<em>ArrayDeque</em>，它有着比<em>LinkedList</em>（当作栈或队列使用时）有着更好的性能。<br>","more":"</p>\n<p><img src=\"/images/linklist/LinkedList_base.png\" alt=\"LinkedList_base\"></p>\n<p><em>LinkedList</em>底层<strong>通过双向链表实现</strong>，本节将着重讲解插入和删除元素时双向链表的维护过程，也即是之间解跟<em>List</em>接口相关的函数，双向链表的每个节点用内部类<em>Node</em>表示。<em>LinkedList</em>通过<code>first</code>和<code>last</code>引用分别指向链表的第一个和最后一个元素。注意这里没有所谓的哑元，当链表为空的时候<code>first</code>和<code>last</code>都指向<code>null</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Node内部类</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">    E item;</span><br><span class=\"line\">    Node&lt;E&gt; next;</span><br><span class=\"line\">    Node&lt;E&gt; prev;</span><br><span class=\"line\">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.item = element;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.next = next;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.prev = prev;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><em>LinkedList</em>的实现方式决定了所有跟下标相关的操作都是线性时间，而在首段或者末尾删除元素只需要常数时间。为追求效率<em>LinkedList</em>没有实现同步（synchronized），如果需要多个线程并发访问，可以先采用<code>Collections.synchronizedList()</code>方法对其进行包装。</p>\n<h1 id=\"方法剖析\"><a href=\"#方法剖析\" class=\"headerlink\" title=\"方法剖析\"></a>方法剖析</h1><h2 id=\"add\"><a href=\"#add\" class=\"headerlink\" title=\"add()\"></a>add()</h2><p><em>add()</em>方法有两个版本，一个是<code>add(E e)</code>，该方法在<em>LinkedList</em>的末尾插入元素，因为有<code>last</code>指向链表末尾，在末尾插入元素的花费是常数时间。只需要简单修改几个相关引用即可；另一个是<code>add(int index, E element)</code>，该方法是在指定下表处插入元素，需要先通过线性查找找到具体位置，然后修改相关引用完成插入操作。</p>\n<p><img src=\"/images/linklist/LinkedList_add.png\" alt=\"LinkedList_add\"></p>\n<p>结合上图，可以看出<code>add(E e)</code>的逻辑非常简单。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//add(E e)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; l = last;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; newNode = <span class=\"keyword\">new</span> Node&lt;&gt;(l, e, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    last = newNode;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        first = newNode;<span class=\"comment\">//原来链表为空，这是插入的第一个元素</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        l.next = newNode;</span><br><span class=\"line\">    size++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>add(int index, E element)</code>的逻辑稍显复杂，可以分成两部分，1.先根据index找到要插入的位置；2.修改引用，完成插入操作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//add(int index, E element)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\">\tcheckPositionIndex(index);<span class=\"comment\">//index &gt;= 0 &amp;&amp; index &lt;= size;</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (index == size)<span class=\"comment\">//插入位置是末尾，包括列表为空的情况</span></span><br><span class=\"line\">        add(element);</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    \tNode&lt;E&gt; succ = node(index);<span class=\"comment\">//1.先根据index找到要插入的位置</span></span><br><span class=\"line\">        <span class=\"comment\">//2.修改引用，完成插入操作。</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Node&lt;E&gt; newNode = <span class=\"keyword\">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class=\"line\">        succ.prev = newNode;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pred == <span class=\"keyword\">null</span>)<span class=\"comment\">//插入位置为0</span></span><br><span class=\"line\">            first = newNode;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            pred.next = newNode;</span><br><span class=\"line\">        size++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码中的<code>node(int index)</code>函数有一点小小的trick，因为链表双向的，可以从开始往后找，也可以从结尾往前找，具体朝那个方向找取决于条件<code>index &lt; (size &gt;&gt; 1)</code>，也即是index是靠近前端还是后端。</p>\n<h2 id=\"remove\"><a href=\"#remove\" class=\"headerlink\" title=\"remove()\"></a>remove()</h2><p><code>remove()</code>方法也有两个版本，一个是删除跟指定元素相等的第一个元素<code>remove(Object o)</code>，另一个是删除指定下标处的元素<code>remove(int index)</code>。</p>\n<p><img src=\"/images/linklist/LinkedList_remove.png\" alt=\"LinkedList_remove.png\"></p>\n<p>两个删除操作都要1.先找到要删除元素的引用，2.修改相关引用，完成删除操作。在寻找被删元素引用的时候<code>remove(Object o)</code>调用的是元素的<code>equals</code>方法，而<code>remove(int index)</code>使用的是下标计数，两种方式都是线性时间复杂度。在步骤2中，两个<code>revome()</code>方法都是通过<code>unlink(Node&lt;E&gt; x)</code>方法完成的。这里需要考虑删除元素是第一个或者最后一个时的边界情况。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//unlink(Node&lt;E&gt; x)，删除一个Node</span></span><br><span class=\"line\"><span class=\"function\">E <span class=\"title\">unlink</span><span class=\"params\">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> E element = x.item;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; next = x.next;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (prev == <span class=\"keyword\">null</span>) &#123;<span class=\"comment\">//删除的是第一个元素</span></span><br><span class=\"line\">        first = next;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        prev.next = next;</span><br><span class=\"line\">        x.prev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (next == <span class=\"keyword\">null</span>) &#123;<span class=\"comment\">//删除的是最后一个元素</span></span><br><span class=\"line\">        last = prev;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        next.prev = prev;</span><br><span class=\"line\">        x.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    x.item = <span class=\"keyword\">null</span>;<span class=\"comment\">//let GC work</span></span><br><span class=\"line\">    size--;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> element;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get()\"></a>get()</h1><p><code>get(int index)</code>得到指定下标处元素的引用，通过调用上文中提到的<code>node(int index)</code>方法实现。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    checkElementIndex(index);<span class=\"comment\">//index &gt;= 0 &amp;&amp; index &lt; size;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> node(index).item;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set()\"></a>set()</h1><p><code>set(int index, E element)</code>方法将指定下标处的元素修改成指定值，也是先通过<code>node(int index)</code>找到对应下表元素的引用，然后修改<code>Node</code>中<code>item</code>的值。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">set</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\">    checkElementIndex(index);</span><br><span class=\"line\">    Node&lt;E&gt; x = node(index);</span><br><span class=\"line\">    E oldVal = x.item;</span><br><span class=\"line\">    x.item = element;<span class=\"comment\">//替换新值</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> oldVal;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>"},{"title":"线程池探究","author":"James","date":"2013-07-26T06:07:00.000Z","_content":"\n# 基本概念\n\n在多线程编程的时候，为每一个任务临时分配一个线程开销很大，所以线程池应运而生，成为我们管理线程的工具。Java中提供了`Executor`接口，提供了一种标准的方法将任务的提交过程和执行过程解耦开来，并用`Runnable`表示任务。\n\n下面我们将基于JDK1.7分析下线程池框架的实现`ThreadPoolExecutor`以及用途。\n\n# 源码分析\n\n```java\npublic ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue,\n                              ThreadFactory threadFactory,\n                              RejectedExecutionHandler handler) {\n        if (corePoolSize < 0 ||\n            maximumPoolSize <= 0 ||\n            maximumPoolSize < corePoolSize ||\n            keepAliveTime < 0)\n            throw new IllegalArgumentException();\n        if (workQueue == null || threadFactory == null || handler == null)\n            throw new NullPointerException();\n        this.corePoolSize = corePoolSize;\n        this.maximumPoolSize = maximumPoolSize;\n        this.workQueue = workQueue;\n        this.keepAliveTime = unit.toNanos(keepAliveTime);\n        this.threadFactory = threadFactory;\n        this.handler = handler;\n    }\n```\n\n## 核心参数\n\n- **corePoolSize** ： 线程池中所保存的核心线程数，包括空闲线程。\n- **maximumPoolSize** ：允许的最大线程数。\n- **workQueue** ：阻塞队列，存储待执行的队列。\n  - JDK中提供如下阻塞队列：\n    1. `ArrayBlockingQueue`：基于数组结构的有界阻塞队列，按FIFO排序任务；\n    2. `LinkedBlockingQuene`：基于链表结构的阻塞队列，按FIFO排序任务\n    3. `SynchronousQuene`：一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态\n    4. `priorityBlockingQuene`：具有优先级的无界阻塞队列\n- **keepAliveTime** ：当无任务执行时，线程空闲的存活时间，时间单位由`TimeUnit`指定。\n- **threadFactory** ： 是构造Thread的方法，你可以自己去包装和传递，主要实现newThread方法。\n- **handler** ：达到`maximumPoolSize`后丢弃处理的方法，提供了几种丢弃处理的方法，当然你也可以自己实现接口：`RejectedExecutionHandler`中的方法\n  - 线程池提供了4种策略：\n    1. AbortPolicy：直接抛出异常，默认策略；\n    2. CallerRunsPolicy：用调用者所在的线程来执行任务；\n    3. DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；\n    4. DiscardPolicy：直接丢弃任务；\n\n## 执行流程\n\n当使用execute执行Runnable方法时候：\n\n```java\n\tpublic void execute(Runnable command) {\n        if (command == null)\n            throw new NullPointerException();\n        int c = ctl.get();\n    \t//当前工作线程小于corePoolSize 则启用新线程开始当前任务。\n        if (workerCountOf(c) < corePoolSize) {\n            if (addWorker(command, true))\n                return;\n            c = ctl.get();\n        }\n    \t//如果线程池处于RUNNING状态，且把提交的任务成功放入阻塞队列中\n        if (isRunning(c) && workQueue.offer(command)) {\n            int recheck = ctl.get();\n            //再次检查线程池的状态，如果线程池没有RUNNING，且成功从阻塞队列中删除任务\n            if (! isRunning(recheck) && remove(command))\n                reject(command);\n            //则执行reject方法处理任务\n            else if (workerCountOf(recheck) == 0)\n                addWorker(null, false);\n        }\n    \t//创建新的线程执行任务，如果执行失败，则执行reject方法处理任务\n        else if (!addWorker(command, false))\n            reject(command);\n\t}\n\n\tprivate boolean addWorker(Runnable firstTask, boolean core) {\n        retry:\n        for (;;) {\n            int c = ctl.get();\n            int rs = runStateOf(c);\n\n            // Check if queue empty only if necessary.\n            if (rs >= SHUTDOWN &&\n                ! (rs == SHUTDOWN &&\n                   firstTask == null &&\n                   ! workQueue.isEmpty()))\n                return false;\n\n            for (;;) {\n                int wc = workerCountOf(c);\n                if (wc >= CAPACITY ||\n                    //判断当前需要创建的线程是否为核心线程\n                    wc >= (core ? corePoolSize : maximumPoolSize))\n                    return false;\n                if (compareAndIncrementWorkerCount(c))\n                    break retry;\n                c = ctl.get();  // Re-read ctl\n                if (runStateOf(c) != rs)\n                    continue retry;\n                // else CAS failed due to workerCount change; retry inner loop\n            }\n        }\n\t\t//开始创建新的线程\n        boolean workerStarted = false;\n        boolean workerAdded = false;\n        Worker w = null;\n        try {\n            final ReentrantLock mainLock = this.mainLock;\n            //work内会通过factory创建一个线程   Work是个关键地方后面会分析。\n            w = new Worker(firstTask);\n            final Thread t = w.thread;\n            if (t != null) {\n                mainLock.lock();\n                try {\n                    int c = ctl.get();\n                    int rs = runStateOf(c);\n\n                    if (rs < SHUTDOWN ||\n                        (rs == SHUTDOWN && firstTask == null)) {\n                        if (t.isAlive()) // precheck that t is startable\n                            throw new IllegalThreadStateException();\n                        //把Woker实例插入到HashSet\n                        workers.add(w);\n                        int s = workers.size();\n                        if (s > largestPoolSize)\n                            largestPoolSize = s;\n                        workerAdded = true;\n                    }\n                } finally {\n                    mainLock.unlock();\n                }\n                if (workerAdded) {\n                    t.start();//并启动Woker中的线程\n                    workerStarted = true;\n                }\n            }\n        } finally {\n            if (! workerStarted)\n                addWorkerFailed(w);\n        }\n        return workerStarted;\n \t}\n```\n\n\n\n1. 如果线程池中的线程数量**小于**corePoolSize，即使线程池中有空闲线程，也会创建一个新的线程来执行新添加的任务。\n2. 如果线程池中的线程数量**大于等于** corePoolSize\n   1. 缓冲队列workQueue未满，则将新添加的任务放到workQueue中，按照FIFO的原则依次等待执行（线程池中有线程空闲出来后依次将缓冲队列中的任务交付给空闲的线程执行）。\n   2. 缓冲队列workQueue已满\n      1. 但线程池中的线程数量小于maximumPoolSize，则会创建新的线程来处理被添加的任务。\n      2. 如果线程池中的线程数量等于了maximumPoolSize，执行丢弃处理。\n\n**小结**:当有新的任务要处理时，先判断线程池中的线程数量是否大于`corePoolSize`，再看缓冲队列`workQueue`是否满，最后看线程池中的线程数量是否大于`maximumPoolSize`。\n\n![工作流程](/images/threadpool/工作流程.jpg)\n\n下面一起看下核心方法**runWorker **具体的执行流程是怎么样的。 \n\n```java\nfinal void runWorker(Worker w) {\n        Thread wt = Thread.currentThread();\n        //获取第一个任务firstTask\n        Runnable task = w.firstTask;\n        w.firstTask = null;\n    \t//通过unlock方法释放锁\n        w.unlock(); // allow interrupts\n        boolean completedAbruptly = true;\n        try {\n            //如果第一个任务firstTask为空，则从阻塞队列中获取等待的任务\n            while (task != null || (task = getTask()) != null) {\n                w.lock();\n                if ((runStateAtLeast(ctl.get(), STOP) ||\n                     (Thread.interrupted() &&\n                      runStateAtLeast(ctl.get(), STOP))) &&\n                    !wt.isInterrupted())\n                    wt.interrupt();\n                try {\n                    beforeExecute(wt, task);\n                    Throwable thrown = null;\n                    try {\n                        //执行任务的run方法\n                        task.run();\n                    } catch (RuntimeException x) {\n                        thrown = x; throw x;\n                    } finally {\n                        afterExecute(task, thrown);\n                    }\n                } finally {\n                    task = null;\n                    w.completedTasks++;\n                    w.unlock();\n                }\n            }\n            completedAbruptly = false;\n        } finally {\n            processWorkerExit(w, completedAbruptly);\n        }\n    }\n```\n\n从阻塞队列中获取等待的任务**getTask**方法\n\n```java\nprivate Runnable getTask() {\n        boolean timedOut = false; // Did the last poll() time out?\n        retry:\n        for (;;) {\n            int c = ctl.get();\n            int rs = runStateOf(c);\n            // 队列为空则直接返回null\n            if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {\n                decrementWorkerCount();\n                return null;\n            }\n            boolean timed;      // Are workers subject to culling?\n            for (;;) {\n                int wc = workerCountOf(c);\n                timed = allowCoreThreadTimeOut || wc > corePoolSize;\n                if (wc <= maximumPoolSize && ! (timedOut && timed))\n                    break;\n                if (compareAndDecrementWorkerCount(c))\n                    return null;\n                c = ctl.get();  // Re-read ctl\n                if (runStateOf(c) != rs)\n                    continue retry;\n                // else CAS failed due to workerCount change; retry inner loop\n            }\n            try {\n                //根据timed在阻塞队列上超时等待或者阻塞等待任务\n                Runnable r = timed ?\n                    //如果在keepAliveTime时间内，阻塞队列还是没有任务，则返回null\n                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :\n                    workQueue.take();\n                if (r != null)\n                    return r;\n                timedOut = true;\n            } catch (InterruptedException retry) {\n                timedOut = false;\n            }\n        }\n    }\n```\n\n\n\n# 使用方法\n\n## 创建\n\n```java\nthreadsPool = new ThreadPoolExecutor(corePoolSize, maximumPoolSize,\n\tkeepAliveTime, milliseconds,runnableTaskQueue, threadFactory,handler);\n```\n\n`Exectors`工厂类提供了线程池的初始化接口，主要有如下几种：\n\n-  `newFixedThreadPool`：初始化一个指定线程数的线程池，其中corePoolSize == maximumPoolSize\n-  `newCachedThreadPool`：初始化一个可以缓存线程的线程池，默认缓存60s，线程池的线程数可达到Integer.MAX_VALUE，即2147483647，内部使用SynchronousQueue作为阻塞队列\n-  `newSingleThreadExecutor`：初始化的线程池中只有一个线程，如果该线程异常结束，会重新创建一个新的线程继续执行任务，唯一的线程可以保证所提交任务的顺序执行\n-  `newScheduledThreadPool`：初始化的线程池可以在指定的时间内周期性的执行所提交的任务，在实际的业务场景中可以使用该线程池定期的同步数据。\n\n## 提交任务\n\n通过`execute`提交任务\n\n```JAVA\nthreadsPool.execute(new Runnable() {\n\tpublic void run() {\n\t\t// TODO Auto-generated method stub\n\t}\n});\n```\n\n使用`submit` 方法来提交任务，它会返回一个`future`,那么我们可以通过这个future来判断任务是否执行成功\n\n```java\ntry {\n\tObject s = future.get();\n} catch (InterruptedException e) {\n    \n} catch (ExecutionException e) {\n    \n} finally {\n\t// 关闭线程池\n    executor.shutdown();\n}\n```\n\n## 线程池的关闭\n\n我们可以通过调用线程池的`shutdown`或者`shutdownNow`方法来关闭线程池。他们之间的不同\n\n`shutdown`：只是将线程池的状态设置成 *SHUTDOWN* 状态，然后中断所有没有正在执行任务的线程。\n\n`shutdownNow`：遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。\n\n# 实战相关问题\n\n## 线程池大小的估算\n\n合理的配置线程池，就必须首先分析任务特性，可以从以下几个角度来进行分析：\n\n1. 任务的性质: CPU密集型任务，IO密集型任务和混合型任务。\n2. 任务执行时间的长短：长，中和短。\n3. 任务的优先级：高，中和低。\n\nCPU密集型任务配置尽可能少的线程数量，如配置Ncpu+1个线程的线程池。\n\nIO密集型任务则由于需要等待IO操作，线程并不是一直在执行任务，则配置尽可能多的线程，如2*Ncpu。\n\n**线程等待时间所占比例越高，需要越多线程。线程CPU时间所占比例越高，需要越少线程。**\n\n\n\n","source":"_posts/threadpool.md","raw":"title: 线程池探究\nauthor: James\ntags:\n  - threadpool\ncategories:\n  - 实战\ndate: 2013-07-26 14:07:00\n---\n\n# 基本概念\n\n在多线程编程的时候，为每一个任务临时分配一个线程开销很大，所以线程池应运而生，成为我们管理线程的工具。Java中提供了`Executor`接口，提供了一种标准的方法将任务的提交过程和执行过程解耦开来，并用`Runnable`表示任务。\n\n下面我们将基于JDK1.7分析下线程池框架的实现`ThreadPoolExecutor`以及用途。\n\n# 源码分析\n\n```java\npublic ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue,\n                              ThreadFactory threadFactory,\n                              RejectedExecutionHandler handler) {\n        if (corePoolSize < 0 ||\n            maximumPoolSize <= 0 ||\n            maximumPoolSize < corePoolSize ||\n            keepAliveTime < 0)\n            throw new IllegalArgumentException();\n        if (workQueue == null || threadFactory == null || handler == null)\n            throw new NullPointerException();\n        this.corePoolSize = corePoolSize;\n        this.maximumPoolSize = maximumPoolSize;\n        this.workQueue = workQueue;\n        this.keepAliveTime = unit.toNanos(keepAliveTime);\n        this.threadFactory = threadFactory;\n        this.handler = handler;\n    }\n```\n\n## 核心参数\n\n- **corePoolSize** ： 线程池中所保存的核心线程数，包括空闲线程。\n- **maximumPoolSize** ：允许的最大线程数。\n- **workQueue** ：阻塞队列，存储待执行的队列。\n  - JDK中提供如下阻塞队列：\n    1. `ArrayBlockingQueue`：基于数组结构的有界阻塞队列，按FIFO排序任务；\n    2. `LinkedBlockingQuene`：基于链表结构的阻塞队列，按FIFO排序任务\n    3. `SynchronousQuene`：一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态\n    4. `priorityBlockingQuene`：具有优先级的无界阻塞队列\n- **keepAliveTime** ：当无任务执行时，线程空闲的存活时间，时间单位由`TimeUnit`指定。\n- **threadFactory** ： 是构造Thread的方法，你可以自己去包装和传递，主要实现newThread方法。\n- **handler** ：达到`maximumPoolSize`后丢弃处理的方法，提供了几种丢弃处理的方法，当然你也可以自己实现接口：`RejectedExecutionHandler`中的方法\n  - 线程池提供了4种策略：\n    1. AbortPolicy：直接抛出异常，默认策略；\n    2. CallerRunsPolicy：用调用者所在的线程来执行任务；\n    3. DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；\n    4. DiscardPolicy：直接丢弃任务；\n\n## 执行流程\n\n当使用execute执行Runnable方法时候：\n\n```java\n\tpublic void execute(Runnable command) {\n        if (command == null)\n            throw new NullPointerException();\n        int c = ctl.get();\n    \t//当前工作线程小于corePoolSize 则启用新线程开始当前任务。\n        if (workerCountOf(c) < corePoolSize) {\n            if (addWorker(command, true))\n                return;\n            c = ctl.get();\n        }\n    \t//如果线程池处于RUNNING状态，且把提交的任务成功放入阻塞队列中\n        if (isRunning(c) && workQueue.offer(command)) {\n            int recheck = ctl.get();\n            //再次检查线程池的状态，如果线程池没有RUNNING，且成功从阻塞队列中删除任务\n            if (! isRunning(recheck) && remove(command))\n                reject(command);\n            //则执行reject方法处理任务\n            else if (workerCountOf(recheck) == 0)\n                addWorker(null, false);\n        }\n    \t//创建新的线程执行任务，如果执行失败，则执行reject方法处理任务\n        else if (!addWorker(command, false))\n            reject(command);\n\t}\n\n\tprivate boolean addWorker(Runnable firstTask, boolean core) {\n        retry:\n        for (;;) {\n            int c = ctl.get();\n            int rs = runStateOf(c);\n\n            // Check if queue empty only if necessary.\n            if (rs >= SHUTDOWN &&\n                ! (rs == SHUTDOWN &&\n                   firstTask == null &&\n                   ! workQueue.isEmpty()))\n                return false;\n\n            for (;;) {\n                int wc = workerCountOf(c);\n                if (wc >= CAPACITY ||\n                    //判断当前需要创建的线程是否为核心线程\n                    wc >= (core ? corePoolSize : maximumPoolSize))\n                    return false;\n                if (compareAndIncrementWorkerCount(c))\n                    break retry;\n                c = ctl.get();  // Re-read ctl\n                if (runStateOf(c) != rs)\n                    continue retry;\n                // else CAS failed due to workerCount change; retry inner loop\n            }\n        }\n\t\t//开始创建新的线程\n        boolean workerStarted = false;\n        boolean workerAdded = false;\n        Worker w = null;\n        try {\n            final ReentrantLock mainLock = this.mainLock;\n            //work内会通过factory创建一个线程   Work是个关键地方后面会分析。\n            w = new Worker(firstTask);\n            final Thread t = w.thread;\n            if (t != null) {\n                mainLock.lock();\n                try {\n                    int c = ctl.get();\n                    int rs = runStateOf(c);\n\n                    if (rs < SHUTDOWN ||\n                        (rs == SHUTDOWN && firstTask == null)) {\n                        if (t.isAlive()) // precheck that t is startable\n                            throw new IllegalThreadStateException();\n                        //把Woker实例插入到HashSet\n                        workers.add(w);\n                        int s = workers.size();\n                        if (s > largestPoolSize)\n                            largestPoolSize = s;\n                        workerAdded = true;\n                    }\n                } finally {\n                    mainLock.unlock();\n                }\n                if (workerAdded) {\n                    t.start();//并启动Woker中的线程\n                    workerStarted = true;\n                }\n            }\n        } finally {\n            if (! workerStarted)\n                addWorkerFailed(w);\n        }\n        return workerStarted;\n \t}\n```\n\n\n\n1. 如果线程池中的线程数量**小于**corePoolSize，即使线程池中有空闲线程，也会创建一个新的线程来执行新添加的任务。\n2. 如果线程池中的线程数量**大于等于** corePoolSize\n   1. 缓冲队列workQueue未满，则将新添加的任务放到workQueue中，按照FIFO的原则依次等待执行（线程池中有线程空闲出来后依次将缓冲队列中的任务交付给空闲的线程执行）。\n   2. 缓冲队列workQueue已满\n      1. 但线程池中的线程数量小于maximumPoolSize，则会创建新的线程来处理被添加的任务。\n      2. 如果线程池中的线程数量等于了maximumPoolSize，执行丢弃处理。\n\n**小结**:当有新的任务要处理时，先判断线程池中的线程数量是否大于`corePoolSize`，再看缓冲队列`workQueue`是否满，最后看线程池中的线程数量是否大于`maximumPoolSize`。\n\n![工作流程](/images/threadpool/工作流程.jpg)\n\n下面一起看下核心方法**runWorker **具体的执行流程是怎么样的。 \n\n```java\nfinal void runWorker(Worker w) {\n        Thread wt = Thread.currentThread();\n        //获取第一个任务firstTask\n        Runnable task = w.firstTask;\n        w.firstTask = null;\n    \t//通过unlock方法释放锁\n        w.unlock(); // allow interrupts\n        boolean completedAbruptly = true;\n        try {\n            //如果第一个任务firstTask为空，则从阻塞队列中获取等待的任务\n            while (task != null || (task = getTask()) != null) {\n                w.lock();\n                if ((runStateAtLeast(ctl.get(), STOP) ||\n                     (Thread.interrupted() &&\n                      runStateAtLeast(ctl.get(), STOP))) &&\n                    !wt.isInterrupted())\n                    wt.interrupt();\n                try {\n                    beforeExecute(wt, task);\n                    Throwable thrown = null;\n                    try {\n                        //执行任务的run方法\n                        task.run();\n                    } catch (RuntimeException x) {\n                        thrown = x; throw x;\n                    } finally {\n                        afterExecute(task, thrown);\n                    }\n                } finally {\n                    task = null;\n                    w.completedTasks++;\n                    w.unlock();\n                }\n            }\n            completedAbruptly = false;\n        } finally {\n            processWorkerExit(w, completedAbruptly);\n        }\n    }\n```\n\n从阻塞队列中获取等待的任务**getTask**方法\n\n```java\nprivate Runnable getTask() {\n        boolean timedOut = false; // Did the last poll() time out?\n        retry:\n        for (;;) {\n            int c = ctl.get();\n            int rs = runStateOf(c);\n            // 队列为空则直接返回null\n            if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {\n                decrementWorkerCount();\n                return null;\n            }\n            boolean timed;      // Are workers subject to culling?\n            for (;;) {\n                int wc = workerCountOf(c);\n                timed = allowCoreThreadTimeOut || wc > corePoolSize;\n                if (wc <= maximumPoolSize && ! (timedOut && timed))\n                    break;\n                if (compareAndDecrementWorkerCount(c))\n                    return null;\n                c = ctl.get();  // Re-read ctl\n                if (runStateOf(c) != rs)\n                    continue retry;\n                // else CAS failed due to workerCount change; retry inner loop\n            }\n            try {\n                //根据timed在阻塞队列上超时等待或者阻塞等待任务\n                Runnable r = timed ?\n                    //如果在keepAliveTime时间内，阻塞队列还是没有任务，则返回null\n                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :\n                    workQueue.take();\n                if (r != null)\n                    return r;\n                timedOut = true;\n            } catch (InterruptedException retry) {\n                timedOut = false;\n            }\n        }\n    }\n```\n\n\n\n# 使用方法\n\n## 创建\n\n```java\nthreadsPool = new ThreadPoolExecutor(corePoolSize, maximumPoolSize,\n\tkeepAliveTime, milliseconds,runnableTaskQueue, threadFactory,handler);\n```\n\n`Exectors`工厂类提供了线程池的初始化接口，主要有如下几种：\n\n-  `newFixedThreadPool`：初始化一个指定线程数的线程池，其中corePoolSize == maximumPoolSize\n-  `newCachedThreadPool`：初始化一个可以缓存线程的线程池，默认缓存60s，线程池的线程数可达到Integer.MAX_VALUE，即2147483647，内部使用SynchronousQueue作为阻塞队列\n-  `newSingleThreadExecutor`：初始化的线程池中只有一个线程，如果该线程异常结束，会重新创建一个新的线程继续执行任务，唯一的线程可以保证所提交任务的顺序执行\n-  `newScheduledThreadPool`：初始化的线程池可以在指定的时间内周期性的执行所提交的任务，在实际的业务场景中可以使用该线程池定期的同步数据。\n\n## 提交任务\n\n通过`execute`提交任务\n\n```JAVA\nthreadsPool.execute(new Runnable() {\n\tpublic void run() {\n\t\t// TODO Auto-generated method stub\n\t}\n});\n```\n\n使用`submit` 方法来提交任务，它会返回一个`future`,那么我们可以通过这个future来判断任务是否执行成功\n\n```java\ntry {\n\tObject s = future.get();\n} catch (InterruptedException e) {\n    \n} catch (ExecutionException e) {\n    \n} finally {\n\t// 关闭线程池\n    executor.shutdown();\n}\n```\n\n## 线程池的关闭\n\n我们可以通过调用线程池的`shutdown`或者`shutdownNow`方法来关闭线程池。他们之间的不同\n\n`shutdown`：只是将线程池的状态设置成 *SHUTDOWN* 状态，然后中断所有没有正在执行任务的线程。\n\n`shutdownNow`：遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。\n\n# 实战相关问题\n\n## 线程池大小的估算\n\n合理的配置线程池，就必须首先分析任务特性，可以从以下几个角度来进行分析：\n\n1. 任务的性质: CPU密集型任务，IO密集型任务和混合型任务。\n2. 任务执行时间的长短：长，中和短。\n3. 任务的优先级：高，中和低。\n\nCPU密集型任务配置尽可能少的线程数量，如配置Ncpu+1个线程的线程池。\n\nIO密集型任务则由于需要等待IO操作，线程并不是一直在执行任务，则配置尽可能多的线程，如2*Ncpu。\n\n**线程等待时间所占比例越高，需要越多线程。线程CPU时间所占比例越高，需要越少线程。**\n\n\n\n","slug":"threadpool","published":1,"updated":"2018-02-27T06:26:07.449Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjefa5bp3000b6skcds3fuch6","content":"<h1 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h1><p>在多线程编程的时候，为每一个任务临时分配一个线程开销很大，所以线程池应运而生，成为我们管理线程的工具。Java中提供了<code>Executor</code>接口，提供了一种标准的方法将任务的提交过程和执行过程解耦开来，并用<code>Runnable</code>表示任务。</p>\n<p>下面我们将基于JDK1.7分析下线程池框架的实现<code>ThreadPoolExecutor</code>以及用途。</p>\n<h1 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ThreadPoolExecutor</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              <span class=\"keyword\">int</span> maximumPoolSize,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              <span class=\"keyword\">long</span> keepAliveTime,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              TimeUnit unit,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              ThreadFactory threadFactory,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (corePoolSize &lt; <span class=\"number\">0</span> ||</span><br><span class=\"line\">            maximumPoolSize &lt;= <span class=\"number\">0</span> ||</span><br><span class=\"line\">            maximumPoolSize &lt; corePoolSize ||</span><br><span class=\"line\">            keepAliveTime &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (workQueue == <span class=\"keyword\">null</span> || threadFactory == <span class=\"keyword\">null</span> || handler == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.corePoolSize = corePoolSize;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.workQueue = workQueue;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.threadFactory = threadFactory;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.handler = handler;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"核心参数\"><a href=\"#核心参数\" class=\"headerlink\" title=\"核心参数\"></a>核心参数</h2><ul>\n<li><strong>corePoolSize</strong> ： 线程池中所保存的核心线程数，包括空闲线程。</li>\n<li><strong>maximumPoolSize</strong> ：允许的最大线程数。</li>\n<li><strong>workQueue</strong> ：阻塞队列，存储待执行的队列。<ul>\n<li>JDK中提供如下阻塞队列：<ol>\n<li><code>ArrayBlockingQueue</code>：基于数组结构的有界阻塞队列，按FIFO排序任务；</li>\n<li><code>LinkedBlockingQuene</code>：基于链表结构的阻塞队列，按FIFO排序任务</li>\n<li><code>SynchronousQuene</code>：一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态</li>\n<li><code>priorityBlockingQuene</code>：具有优先级的无界阻塞队列</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><strong>keepAliveTime</strong> ：当无任务执行时，线程空闲的存活时间，时间单位由<code>TimeUnit</code>指定。</li>\n<li><strong>threadFactory</strong> ： 是构造Thread的方法，你可以自己去包装和传递，主要实现newThread方法。</li>\n<li><strong>handler</strong> ：达到<code>maximumPoolSize</code>后丢弃处理的方法，提供了几种丢弃处理的方法，当然你也可以自己实现接口：<code>RejectedExecutionHandler</code>中的方法<ul>\n<li>线程池提供了4种策略：<ol>\n<li>AbortPolicy：直接抛出异常，默认策略；</li>\n<li>CallerRunsPolicy：用调用者所在的线程来执行任务；</li>\n<li>DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；</li>\n<li>DiscardPolicy：直接丢弃任务；</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"执行流程\"><a href=\"#执行流程\" class=\"headerlink\" title=\"执行流程\"></a>执行流程</h2><p>当使用execute执行Runnable方法时候：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable command)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (command == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">           <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">       <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">   \t<span class=\"comment\">//当前工作线程小于corePoolSize 则启用新线程开始当前任务。</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (addWorker(command, <span class=\"keyword\">true</span>))</span><br><span class=\"line\">               <span class=\"keyword\">return</span>;</span><br><span class=\"line\">           c = ctl.get();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   \t<span class=\"comment\">//如果线程池处于RUNNING状态，且把提交的任务成功放入阻塞队列中</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">int</span> recheck = ctl.get();</span><br><span class=\"line\">           <span class=\"comment\">//再次检查线程池的状态，如果线程池没有RUNNING，且成功从阻塞队列中删除任务</span></span><br><span class=\"line\">           <span class=\"keyword\">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class=\"line\">               reject(command);</span><br><span class=\"line\">           <span class=\"comment\">//则执行reject方法处理任务</span></span><br><span class=\"line\">           <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (workerCountOf(recheck) == <span class=\"number\">0</span>)</span><br><span class=\"line\">               addWorker(<span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   \t<span class=\"comment\">//创建新的线程执行任务，如果执行失败，则执行reject方法处理任务</span></span><br><span class=\"line\">       <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!addWorker(command, <span class=\"keyword\">false</span>))</span><br><span class=\"line\">           reject(command);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addWorker</span><span class=\"params\">(Runnable firstTask, <span class=\"keyword\">boolean</span> core)</span> </span>&#123;</span><br><span class=\"line\">       retry:</span><br><span class=\"line\">       <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">           <span class=\"keyword\">int</span> rs = runStateOf(c);</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"comment\">// Check if queue empty only if necessary.</span></span><br><span class=\"line\">           <span class=\"keyword\">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class=\"line\">               ! (rs == SHUTDOWN &amp;&amp;</span><br><span class=\"line\">                  firstTask == <span class=\"keyword\">null</span> &amp;&amp;</span><br><span class=\"line\">                  ! workQueue.isEmpty()))</span><br><span class=\"line\">               <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">               <span class=\"keyword\">int</span> wc = workerCountOf(c);</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (wc &gt;= CAPACITY ||</span><br><span class=\"line\">                   <span class=\"comment\">//判断当前需要创建的线程是否为核心线程</span></span><br><span class=\"line\">                   wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class=\"line\">                   <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class=\"line\">                   <span class=\"keyword\">break</span> retry;</span><br><span class=\"line\">               c = ctl.get();  <span class=\"comment\">// Re-read ctl</span></span><br><span class=\"line\">               <span class=\"keyword\">if</span> (runStateOf(c) != rs)</span><br><span class=\"line\">                   <span class=\"keyword\">continue</span> retry;</span><br><span class=\"line\">               <span class=\"comment\">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">\t<span class=\"comment\">//开始创建新的线程</span></span><br><span class=\"line\">       <span class=\"keyword\">boolean</span> workerStarted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">       <span class=\"keyword\">boolean</span> workerAdded = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">       Worker w = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">       <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">           <span class=\"keyword\">final</span> ReentrantLock mainLock = <span class=\"keyword\">this</span>.mainLock;</span><br><span class=\"line\">           <span class=\"comment\">//work内会通过factory创建一个线程   Work是个关键地方后面会分析。</span></span><br><span class=\"line\">           w = <span class=\"keyword\">new</span> Worker(firstTask);</span><br><span class=\"line\">           <span class=\"keyword\">final</span> Thread t = w.thread;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (t != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">               mainLock.lock();</span><br><span class=\"line\">               <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                   <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">                   <span class=\"keyword\">int</span> rs = runStateOf(c);</span><br><span class=\"line\"></span><br><span class=\"line\">                   <span class=\"keyword\">if</span> (rs &lt; SHUTDOWN ||</span><br><span class=\"line\">                       (rs == SHUTDOWN &amp;&amp; firstTask == <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">                       <span class=\"keyword\">if</span> (t.isAlive()) <span class=\"comment\">// precheck that t is startable</span></span><br><span class=\"line\">                           <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalThreadStateException();</span><br><span class=\"line\">                       <span class=\"comment\">//把Woker实例插入到HashSet</span></span><br><span class=\"line\">                       workers.add(w);</span><br><span class=\"line\">                       <span class=\"keyword\">int</span> s = workers.size();</span><br><span class=\"line\">                       <span class=\"keyword\">if</span> (s &gt; largestPoolSize)</span><br><span class=\"line\">                           largestPoolSize = s;</span><br><span class=\"line\">                       workerAdded = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                   &#125;</span><br><span class=\"line\">               &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                   mainLock.unlock();</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (workerAdded) &#123;</span><br><span class=\"line\">                   t.start();<span class=\"comment\">//并启动Woker中的线程</span></span><br><span class=\"line\">                   workerStarted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (! workerStarted)</span><br><span class=\"line\">               addWorkerFailed(w);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> workerStarted;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>如果线程池中的线程数量<strong>小于</strong>corePoolSize，即使线程池中有空闲线程，也会创建一个新的线程来执行新添加的任务。</li>\n<li>如果线程池中的线程数量<strong>大于等于</strong> corePoolSize<ol>\n<li>缓冲队列workQueue未满，则将新添加的任务放到workQueue中，按照FIFO的原则依次等待执行（线程池中有线程空闲出来后依次将缓冲队列中的任务交付给空闲的线程执行）。</li>\n<li>缓冲队列workQueue已满<ol>\n<li>但线程池中的线程数量小于maximumPoolSize，则会创建新的线程来处理被添加的任务。</li>\n<li>如果线程池中的线程数量等于了maximumPoolSize，执行丢弃处理。</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<p><strong>小结</strong>:当有新的任务要处理时，先判断线程池中的线程数量是否大于<code>corePoolSize</code>，再看缓冲队列<code>workQueue</code>是否满，最后看线程池中的线程数量是否大于<code>maximumPoolSize</code>。</p>\n<p><img src=\"/images/threadpool/工作流程.jpg\" alt=\"工作流程\"></p>\n<p>下面一起看下核心方法<strong>runWorker </strong>具体的执行流程是怎么样的。 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">runWorker</span><span class=\"params\">(Worker w)</span> </span>&#123;</span><br><span class=\"line\">        Thread wt = Thread.currentThread();</span><br><span class=\"line\">        <span class=\"comment\">//获取第一个任务firstTask</span></span><br><span class=\"line\">        Runnable task = w.firstTask;</span><br><span class=\"line\">        w.firstTask = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    \t<span class=\"comment\">//通过unlock方法释放锁</span></span><br><span class=\"line\">        w.unlock(); <span class=\"comment\">// allow interrupts</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> completedAbruptly = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果第一个任务firstTask为空，则从阻塞队列中获取等待的任务</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (task != <span class=\"keyword\">null</span> || (task = getTask()) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                w.lock();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class=\"line\">                     (Thread.interrupted() &amp;&amp;</span><br><span class=\"line\">                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class=\"line\">                    !wt.isInterrupted())</span><br><span class=\"line\">                    wt.interrupt();</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    beforeExecute(wt, task);</span><br><span class=\"line\">                    Throwable thrown = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">//执行任务的run方法</span></span><br><span class=\"line\">                        task.run();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (RuntimeException x) &#123;</span><br><span class=\"line\">                        thrown = x; <span class=\"keyword\">throw</span> x;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                        afterExecute(task, thrown);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    task = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    w.completedTasks++;</span><br><span class=\"line\">                    w.unlock();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            completedAbruptly = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            processWorkerExit(w, completedAbruptly);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>从阻塞队列中获取等待的任务<strong>getTask</strong>方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Runnable <span class=\"title\">getTask</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> timedOut = <span class=\"keyword\">false</span>; <span class=\"comment\">// Did the last poll() time out?</span></span><br><span class=\"line\">        retry:</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> rs = runStateOf(c);</span><br><span class=\"line\">            <span class=\"comment\">// 队列为空则直接返回null</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class=\"line\">                decrementWorkerCount();</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> timed;      <span class=\"comment\">// Are workers subject to culling?</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> wc = workerCountOf(c);</span><br><span class=\"line\">                timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (wc &lt;= maximumPoolSize &amp;&amp; ! (timedOut &amp;&amp; timed))</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                c = ctl.get();  <span class=\"comment\">// Re-read ctl</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (runStateOf(c) != rs)</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span> retry;</span><br><span class=\"line\">                <span class=\"comment\">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//根据timed在阻塞队列上超时等待或者阻塞等待任务</span></span><br><span class=\"line\">                Runnable r = timed ?</span><br><span class=\"line\">                    <span class=\"comment\">//如果在keepAliveTime时间内，阻塞队列还是没有任务，则返回null</span></span><br><span class=\"line\">                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class=\"line\">                    workQueue.take();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (r != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">                timedOut = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException retry) &#123;</span><br><span class=\"line\">                timedOut = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h1><h2 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">threadsPool = <span class=\"keyword\">new</span> ThreadPoolExecutor(corePoolSize, maximumPoolSize,</span><br><span class=\"line\">\tkeepAliveTime, milliseconds,runnableTaskQueue, threadFactory,handler);</span><br></pre></td></tr></table></figure>\n<p><code>Exectors</code>工厂类提供了线程池的初始化接口，主要有如下几种：</p>\n<ul>\n<li><code>newFixedThreadPool</code>：初始化一个指定线程数的线程池，其中corePoolSize == maximumPoolSize</li>\n<li><code>newCachedThreadPool</code>：初始化一个可以缓存线程的线程池，默认缓存60s，线程池的线程数可达到Integer.MAX_VALUE，即2147483647，内部使用SynchronousQueue作为阻塞队列</li>\n<li><code>newSingleThreadExecutor</code>：初始化的线程池中只有一个线程，如果该线程异常结束，会重新创建一个新的线程继续执行任务，唯一的线程可以保证所提交任务的顺序执行</li>\n<li><code>newScheduledThreadPool</code>：初始化的线程池可以在指定的时间内周期性的执行所提交的任务，在实际的业务场景中可以使用该线程池定期的同步数据。</li>\n</ul>\n<h2 id=\"提交任务\"><a href=\"#提交任务\" class=\"headerlink\" title=\"提交任务\"></a>提交任务</h2><p>通过<code>execute</code>提交任务</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">threadsPool.execute(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>使用<code>submit</code> 方法来提交任务，它会返回一个<code>future</code>,那么我们可以通过这个future来判断任务是否执行成功</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\tObject s = future.get();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (ExecutionException e) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 关闭线程池</span></span><br><span class=\"line\">    executor.shutdown();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"线程池的关闭\"><a href=\"#线程池的关闭\" class=\"headerlink\" title=\"线程池的关闭\"></a>线程池的关闭</h2><p>我们可以通过调用线程池的<code>shutdown</code>或者<code>shutdownNow</code>方法来关闭线程池。他们之间的不同</p>\n<p><code>shutdown</code>：只是将线程池的状态设置成 <em>SHUTDOWN</em> 状态，然后中断所有没有正在执行任务的线程。</p>\n<p><code>shutdownNow</code>：遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。</p>\n<h1 id=\"实战相关问题\"><a href=\"#实战相关问题\" class=\"headerlink\" title=\"实战相关问题\"></a>实战相关问题</h1><h2 id=\"线程池大小的估算\"><a href=\"#线程池大小的估算\" class=\"headerlink\" title=\"线程池大小的估算\"></a>线程池大小的估算</h2><p>合理的配置线程池，就必须首先分析任务特性，可以从以下几个角度来进行分析：</p>\n<ol>\n<li>任务的性质: CPU密集型任务，IO密集型任务和混合型任务。</li>\n<li>任务执行时间的长短：长，中和短。</li>\n<li>任务的优先级：高，中和低。</li>\n</ol>\n<p>CPU密集型任务配置尽可能少的线程数量，如配置Ncpu+1个线程的线程池。</p>\n<p>IO密集型任务则由于需要等待IO操作，线程并不是一直在执行任务，则配置尽可能多的线程，如2*Ncpu。</p>\n<p><strong>线程等待时间所占比例越高，需要越多线程。线程CPU时间所占比例越高，需要越少线程。</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h1><p>在多线程编程的时候，为每一个任务临时分配一个线程开销很大，所以线程池应运而生，成为我们管理线程的工具。Java中提供了<code>Executor</code>接口，提供了一种标准的方法将任务的提交过程和执行过程解耦开来，并用<code>Runnable</code>表示任务。</p>\n<p>下面我们将基于JDK1.7分析下线程池框架的实现<code>ThreadPoolExecutor</code>以及用途。</p>\n<h1 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ThreadPoolExecutor</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              <span class=\"keyword\">int</span> maximumPoolSize,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              <span class=\"keyword\">long</span> keepAliveTime,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              TimeUnit unit,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              ThreadFactory threadFactory,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (corePoolSize &lt; <span class=\"number\">0</span> ||</span><br><span class=\"line\">            maximumPoolSize &lt;= <span class=\"number\">0</span> ||</span><br><span class=\"line\">            maximumPoolSize &lt; corePoolSize ||</span><br><span class=\"line\">            keepAliveTime &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (workQueue == <span class=\"keyword\">null</span> || threadFactory == <span class=\"keyword\">null</span> || handler == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.corePoolSize = corePoolSize;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.workQueue = workQueue;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.threadFactory = threadFactory;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.handler = handler;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"核心参数\"><a href=\"#核心参数\" class=\"headerlink\" title=\"核心参数\"></a>核心参数</h2><ul>\n<li><strong>corePoolSize</strong> ： 线程池中所保存的核心线程数，包括空闲线程。</li>\n<li><strong>maximumPoolSize</strong> ：允许的最大线程数。</li>\n<li><strong>workQueue</strong> ：阻塞队列，存储待执行的队列。<ul>\n<li>JDK中提供如下阻塞队列：<ol>\n<li><code>ArrayBlockingQueue</code>：基于数组结构的有界阻塞队列，按FIFO排序任务；</li>\n<li><code>LinkedBlockingQuene</code>：基于链表结构的阻塞队列，按FIFO排序任务</li>\n<li><code>SynchronousQuene</code>：一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态</li>\n<li><code>priorityBlockingQuene</code>：具有优先级的无界阻塞队列</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><strong>keepAliveTime</strong> ：当无任务执行时，线程空闲的存活时间，时间单位由<code>TimeUnit</code>指定。</li>\n<li><strong>threadFactory</strong> ： 是构造Thread的方法，你可以自己去包装和传递，主要实现newThread方法。</li>\n<li><strong>handler</strong> ：达到<code>maximumPoolSize</code>后丢弃处理的方法，提供了几种丢弃处理的方法，当然你也可以自己实现接口：<code>RejectedExecutionHandler</code>中的方法<ul>\n<li>线程池提供了4种策略：<ol>\n<li>AbortPolicy：直接抛出异常，默认策略；</li>\n<li>CallerRunsPolicy：用调用者所在的线程来执行任务；</li>\n<li>DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；</li>\n<li>DiscardPolicy：直接丢弃任务；</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"执行流程\"><a href=\"#执行流程\" class=\"headerlink\" title=\"执行流程\"></a>执行流程</h2><p>当使用execute执行Runnable方法时候：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable command)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (command == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">           <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">       <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">   \t<span class=\"comment\">//当前工作线程小于corePoolSize 则启用新线程开始当前任务。</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (addWorker(command, <span class=\"keyword\">true</span>))</span><br><span class=\"line\">               <span class=\"keyword\">return</span>;</span><br><span class=\"line\">           c = ctl.get();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   \t<span class=\"comment\">//如果线程池处于RUNNING状态，且把提交的任务成功放入阻塞队列中</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">int</span> recheck = ctl.get();</span><br><span class=\"line\">           <span class=\"comment\">//再次检查线程池的状态，如果线程池没有RUNNING，且成功从阻塞队列中删除任务</span></span><br><span class=\"line\">           <span class=\"keyword\">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class=\"line\">               reject(command);</span><br><span class=\"line\">           <span class=\"comment\">//则执行reject方法处理任务</span></span><br><span class=\"line\">           <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (workerCountOf(recheck) == <span class=\"number\">0</span>)</span><br><span class=\"line\">               addWorker(<span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   \t<span class=\"comment\">//创建新的线程执行任务，如果执行失败，则执行reject方法处理任务</span></span><br><span class=\"line\">       <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!addWorker(command, <span class=\"keyword\">false</span>))</span><br><span class=\"line\">           reject(command);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addWorker</span><span class=\"params\">(Runnable firstTask, <span class=\"keyword\">boolean</span> core)</span> </span>&#123;</span><br><span class=\"line\">       retry:</span><br><span class=\"line\">       <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">           <span class=\"keyword\">int</span> rs = runStateOf(c);</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"comment\">// Check if queue empty only if necessary.</span></span><br><span class=\"line\">           <span class=\"keyword\">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class=\"line\">               ! (rs == SHUTDOWN &amp;&amp;</span><br><span class=\"line\">                  firstTask == <span class=\"keyword\">null</span> &amp;&amp;</span><br><span class=\"line\">                  ! workQueue.isEmpty()))</span><br><span class=\"line\">               <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">               <span class=\"keyword\">int</span> wc = workerCountOf(c);</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (wc &gt;= CAPACITY ||</span><br><span class=\"line\">                   <span class=\"comment\">//判断当前需要创建的线程是否为核心线程</span></span><br><span class=\"line\">                   wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class=\"line\">                   <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class=\"line\">                   <span class=\"keyword\">break</span> retry;</span><br><span class=\"line\">               c = ctl.get();  <span class=\"comment\">// Re-read ctl</span></span><br><span class=\"line\">               <span class=\"keyword\">if</span> (runStateOf(c) != rs)</span><br><span class=\"line\">                   <span class=\"keyword\">continue</span> retry;</span><br><span class=\"line\">               <span class=\"comment\">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">\t<span class=\"comment\">//开始创建新的线程</span></span><br><span class=\"line\">       <span class=\"keyword\">boolean</span> workerStarted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">       <span class=\"keyword\">boolean</span> workerAdded = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">       Worker w = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">       <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">           <span class=\"keyword\">final</span> ReentrantLock mainLock = <span class=\"keyword\">this</span>.mainLock;</span><br><span class=\"line\">           <span class=\"comment\">//work内会通过factory创建一个线程   Work是个关键地方后面会分析。</span></span><br><span class=\"line\">           w = <span class=\"keyword\">new</span> Worker(firstTask);</span><br><span class=\"line\">           <span class=\"keyword\">final</span> Thread t = w.thread;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (t != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">               mainLock.lock();</span><br><span class=\"line\">               <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                   <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">                   <span class=\"keyword\">int</span> rs = runStateOf(c);</span><br><span class=\"line\"></span><br><span class=\"line\">                   <span class=\"keyword\">if</span> (rs &lt; SHUTDOWN ||</span><br><span class=\"line\">                       (rs == SHUTDOWN &amp;&amp; firstTask == <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">                       <span class=\"keyword\">if</span> (t.isAlive()) <span class=\"comment\">// precheck that t is startable</span></span><br><span class=\"line\">                           <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalThreadStateException();</span><br><span class=\"line\">                       <span class=\"comment\">//把Woker实例插入到HashSet</span></span><br><span class=\"line\">                       workers.add(w);</span><br><span class=\"line\">                       <span class=\"keyword\">int</span> s = workers.size();</span><br><span class=\"line\">                       <span class=\"keyword\">if</span> (s &gt; largestPoolSize)</span><br><span class=\"line\">                           largestPoolSize = s;</span><br><span class=\"line\">                       workerAdded = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                   &#125;</span><br><span class=\"line\">               &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                   mainLock.unlock();</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (workerAdded) &#123;</span><br><span class=\"line\">                   t.start();<span class=\"comment\">//并启动Woker中的线程</span></span><br><span class=\"line\">                   workerStarted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (! workerStarted)</span><br><span class=\"line\">               addWorkerFailed(w);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> workerStarted;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>如果线程池中的线程数量<strong>小于</strong>corePoolSize，即使线程池中有空闲线程，也会创建一个新的线程来执行新添加的任务。</li>\n<li>如果线程池中的线程数量<strong>大于等于</strong> corePoolSize<ol>\n<li>缓冲队列workQueue未满，则将新添加的任务放到workQueue中，按照FIFO的原则依次等待执行（线程池中有线程空闲出来后依次将缓冲队列中的任务交付给空闲的线程执行）。</li>\n<li>缓冲队列workQueue已满<ol>\n<li>但线程池中的线程数量小于maximumPoolSize，则会创建新的线程来处理被添加的任务。</li>\n<li>如果线程池中的线程数量等于了maximumPoolSize，执行丢弃处理。</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<p><strong>小结</strong>:当有新的任务要处理时，先判断线程池中的线程数量是否大于<code>corePoolSize</code>，再看缓冲队列<code>workQueue</code>是否满，最后看线程池中的线程数量是否大于<code>maximumPoolSize</code>。</p>\n<p><img src=\"/images/threadpool/工作流程.jpg\" alt=\"工作流程\"></p>\n<p>下面一起看下核心方法<strong>runWorker </strong>具体的执行流程是怎么样的。 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">runWorker</span><span class=\"params\">(Worker w)</span> </span>&#123;</span><br><span class=\"line\">        Thread wt = Thread.currentThread();</span><br><span class=\"line\">        <span class=\"comment\">//获取第一个任务firstTask</span></span><br><span class=\"line\">        Runnable task = w.firstTask;</span><br><span class=\"line\">        w.firstTask = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    \t<span class=\"comment\">//通过unlock方法释放锁</span></span><br><span class=\"line\">        w.unlock(); <span class=\"comment\">// allow interrupts</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> completedAbruptly = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果第一个任务firstTask为空，则从阻塞队列中获取等待的任务</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (task != <span class=\"keyword\">null</span> || (task = getTask()) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                w.lock();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class=\"line\">                     (Thread.interrupted() &amp;&amp;</span><br><span class=\"line\">                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class=\"line\">                    !wt.isInterrupted())</span><br><span class=\"line\">                    wt.interrupt();</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    beforeExecute(wt, task);</span><br><span class=\"line\">                    Throwable thrown = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">//执行任务的run方法</span></span><br><span class=\"line\">                        task.run();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (RuntimeException x) &#123;</span><br><span class=\"line\">                        thrown = x; <span class=\"keyword\">throw</span> x;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                        afterExecute(task, thrown);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    task = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    w.completedTasks++;</span><br><span class=\"line\">                    w.unlock();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            completedAbruptly = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            processWorkerExit(w, completedAbruptly);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>从阻塞队列中获取等待的任务<strong>getTask</strong>方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Runnable <span class=\"title\">getTask</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> timedOut = <span class=\"keyword\">false</span>; <span class=\"comment\">// Did the last poll() time out?</span></span><br><span class=\"line\">        retry:</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> rs = runStateOf(c);</span><br><span class=\"line\">            <span class=\"comment\">// 队列为空则直接返回null</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class=\"line\">                decrementWorkerCount();</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> timed;      <span class=\"comment\">// Are workers subject to culling?</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> wc = workerCountOf(c);</span><br><span class=\"line\">                timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (wc &lt;= maximumPoolSize &amp;&amp; ! (timedOut &amp;&amp; timed))</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                c = ctl.get();  <span class=\"comment\">// Re-read ctl</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (runStateOf(c) != rs)</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span> retry;</span><br><span class=\"line\">                <span class=\"comment\">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//根据timed在阻塞队列上超时等待或者阻塞等待任务</span></span><br><span class=\"line\">                Runnable r = timed ?</span><br><span class=\"line\">                    <span class=\"comment\">//如果在keepAliveTime时间内，阻塞队列还是没有任务，则返回null</span></span><br><span class=\"line\">                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class=\"line\">                    workQueue.take();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (r != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">                timedOut = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException retry) &#123;</span><br><span class=\"line\">                timedOut = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h1><h2 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">threadsPool = <span class=\"keyword\">new</span> ThreadPoolExecutor(corePoolSize, maximumPoolSize,</span><br><span class=\"line\">\tkeepAliveTime, milliseconds,runnableTaskQueue, threadFactory,handler);</span><br></pre></td></tr></table></figure>\n<p><code>Exectors</code>工厂类提供了线程池的初始化接口，主要有如下几种：</p>\n<ul>\n<li><code>newFixedThreadPool</code>：初始化一个指定线程数的线程池，其中corePoolSize == maximumPoolSize</li>\n<li><code>newCachedThreadPool</code>：初始化一个可以缓存线程的线程池，默认缓存60s，线程池的线程数可达到Integer.MAX_VALUE，即2147483647，内部使用SynchronousQueue作为阻塞队列</li>\n<li><code>newSingleThreadExecutor</code>：初始化的线程池中只有一个线程，如果该线程异常结束，会重新创建一个新的线程继续执行任务，唯一的线程可以保证所提交任务的顺序执行</li>\n<li><code>newScheduledThreadPool</code>：初始化的线程池可以在指定的时间内周期性的执行所提交的任务，在实际的业务场景中可以使用该线程池定期的同步数据。</li>\n</ul>\n<h2 id=\"提交任务\"><a href=\"#提交任务\" class=\"headerlink\" title=\"提交任务\"></a>提交任务</h2><p>通过<code>execute</code>提交任务</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">threadsPool.execute(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>使用<code>submit</code> 方法来提交任务，它会返回一个<code>future</code>,那么我们可以通过这个future来判断任务是否执行成功</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\tObject s = future.get();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (ExecutionException e) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 关闭线程池</span></span><br><span class=\"line\">    executor.shutdown();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"线程池的关闭\"><a href=\"#线程池的关闭\" class=\"headerlink\" title=\"线程池的关闭\"></a>线程池的关闭</h2><p>我们可以通过调用线程池的<code>shutdown</code>或者<code>shutdownNow</code>方法来关闭线程池。他们之间的不同</p>\n<p><code>shutdown</code>：只是将线程池的状态设置成 <em>SHUTDOWN</em> 状态，然后中断所有没有正在执行任务的线程。</p>\n<p><code>shutdownNow</code>：遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。</p>\n<h1 id=\"实战相关问题\"><a href=\"#实战相关问题\" class=\"headerlink\" title=\"实战相关问题\"></a>实战相关问题</h1><h2 id=\"线程池大小的估算\"><a href=\"#线程池大小的估算\" class=\"headerlink\" title=\"线程池大小的估算\"></a>线程池大小的估算</h2><p>合理的配置线程池，就必须首先分析任务特性，可以从以下几个角度来进行分析：</p>\n<ol>\n<li>任务的性质: CPU密集型任务，IO密集型任务和混合型任务。</li>\n<li>任务执行时间的长短：长，中和短。</li>\n<li>任务的优先级：高，中和低。</li>\n</ol>\n<p>CPU密集型任务配置尽可能少的线程数量，如配置Ncpu+1个线程的线程池。</p>\n<p>IO密集型任务则由于需要等待IO操作，线程并不是一直在执行任务，则配置尽可能多的线程，如2*Ncpu。</p>\n<p><strong>线程等待时间所占比例越高，需要越多线程。线程CPU时间所占比例越高，需要越少线程。</strong></p>\n"},{"title":"ArrayList源码学习","date":"2013-06-16T00:09:00.000Z","_content":"# Introduction\n\n本文是学习ArrayList源码的学习总结，组织结构如下：\n\n- 总体介绍\n- 核心方法剖析\n\n# 总体介绍\n\n*ArrayList*实现了*List*接口，是顺序容器，即元素存放的数据与放进去的顺序相同，允许放入`null`元素，底层通过**数组实现**。除该类未实现同步外，其余跟*Vector*大致相同。每个*ArrayList*都有一个容量（capacity），表示底层数组的实际大小，容器内存储元素的个数不能多于当前容量。当向容器中添加元素时，如果容量不足，容器会自动增大底层数组的大小。前面已经提过，Java泛型只是编译器提供的语法糖，所以这里的数组是一个Object数组，以便能够容纳任何类型的对象。\n\n<!-- more -->\n\n![ArrayList_base](/images/arraylist/ArrayList_base.png)\n\nsize(), isEmpty(), get(), set()方法均能在常数时间内完成，add()方法的时间开销跟插入位置有关，addAll()方法的时间开销跟添加元素的个数成正比。其余方法大都是线性时间。\n\n为追求效率，ArrayList没有实现同步（synchronized），如果需要多个线程并发访问，用户可以手动同步，也可使用Vector替代。\n\n# 方法剖析\n\n### set()\n\n既然底层是一个数组*ArrayList*的`set()`方法也就变得非常简单，直接对数组的指定位置赋值即可。\n```java\npublic E set(int index, E element) {\n    rangeCheck(index);//下标越界检查\n    E oldValue = elementData(index);\n    elementData[index] = element;//赋值到指定位置，复制的仅仅是引用\n    return oldValue;\n}\n```\n\n### get()\n\n`get()`方法同样很简单，唯一要注意的是由于底层数组是Object[]，得到元素后需要进行类型转换。\n```java\npublic E get(int index) {\n    rangeCheck(index);\n    return (E) elementData[index];//注意类型转换\n}\n```\n\n### add()\n\n跟C++ 的*vector*不同，*ArrayList*没有`push_back()`方法，对应的方法是`add(E e)`，*ArrayList*也没有`insert()`方法，对应的方法是`add(int index, E e)`。这两个方法都是向容器中添加新元素，这可能会导致*capacity*不足，因此在添加元素之前，都需要进行剩余空间检查，如果需要则自动扩容。扩容操作最终是通过`grow()`方法完成的。\n```java\nprivate void grow(int minCapacity) {\n    int oldCapacity = elementData.length;\n    int newCapacity = oldCapacity + (oldCapacity >> 1);//原来的1.5倍\n    if (newCapacity - minCapacity < 0)\n        newCapacity = minCapacity;\n    if (newCapacity - MAX_ARRAY_SIZE > 0)\n        newCapacity = hugeCapacity(minCapacity);\n    elementData = Arrays.copyOf(elementData, newCapacity);//扩展空间并复制\n}\n```\n由于Java GC自动管理了内存，这里也就不需要考虑源数组释放的问题。\n\n![ArrayList_grow](/images/arraylist/ArrayList_grow.png)\n\n空间的问题解决后，插入过程就显得非常简单。\n\n![ArrayList_add](/images/arraylist/ArrayList_add.png)\n\n`add(int index, E e)`需要先对元素进行移动，然后完成插入操作，也就意味着该方法有着线性的时间复杂度。\n\n### addAll()\n\n`addAll()`方法能够一次添加多个元素，根据位置不同也有两个版本，一个是在末尾添加的`addAll(Collection<? extends E> c)`方法，一个是从指定位置开始插入的`addAll(int index, Collection<? extends E> c)`方法。跟`add()`方法类似，在插入之前也需要进行空间检查，如果需要则自动扩容；如果从指定位置插入，也会存在移动元素的情况。\n`addAll()`的时间复杂度不仅跟插入元素的多少有关，也跟插入的位置相关。\n\n### remove()\n\n`remove()`方法也有两个版本，一个是`remove(int index)`删除指定位置的元素，另一个是`remove(Object o)`删除第一个满足`o.equals(elementData[index])`的元素。删除操作是`add()`操作的逆过程，需要将删除点之后的元素向前移动一个位置。需要注意的是为了让GC起作用，必须显式的为最后一个位置赋`null`值。\n```java\npublic E remove(int index) {\n    rangeCheck(index);\n    modCount++;\n    E oldValue = elementData(index);\n    int numMoved = size - index - 1;\n    if (numMoved > 0)\n        System.arraycopy(elementData, index+1, elementData, index, numMoved);\n    elementData[--size] = null; //清除该位置的引用，让GC起作用\n    return oldValue;\n}\n```","source":"_posts/arraylist.md","raw":"title: ArrayList源码学习\ncategories:\n  - 语言\ntags:\n  - Java\ndate: 2013-06-16 08:09:00\n---\n# Introduction\n\n本文是学习ArrayList源码的学习总结，组织结构如下：\n\n- 总体介绍\n- 核心方法剖析\n\n# 总体介绍\n\n*ArrayList*实现了*List*接口，是顺序容器，即元素存放的数据与放进去的顺序相同，允许放入`null`元素，底层通过**数组实现**。除该类未实现同步外，其余跟*Vector*大致相同。每个*ArrayList*都有一个容量（capacity），表示底层数组的实际大小，容器内存储元素的个数不能多于当前容量。当向容器中添加元素时，如果容量不足，容器会自动增大底层数组的大小。前面已经提过，Java泛型只是编译器提供的语法糖，所以这里的数组是一个Object数组，以便能够容纳任何类型的对象。\n\n<!-- more -->\n\n![ArrayList_base](/images/arraylist/ArrayList_base.png)\n\nsize(), isEmpty(), get(), set()方法均能在常数时间内完成，add()方法的时间开销跟插入位置有关，addAll()方法的时间开销跟添加元素的个数成正比。其余方法大都是线性时间。\n\n为追求效率，ArrayList没有实现同步（synchronized），如果需要多个线程并发访问，用户可以手动同步，也可使用Vector替代。\n\n# 方法剖析\n\n### set()\n\n既然底层是一个数组*ArrayList*的`set()`方法也就变得非常简单，直接对数组的指定位置赋值即可。\n```java\npublic E set(int index, E element) {\n    rangeCheck(index);//下标越界检查\n    E oldValue = elementData(index);\n    elementData[index] = element;//赋值到指定位置，复制的仅仅是引用\n    return oldValue;\n}\n```\n\n### get()\n\n`get()`方法同样很简单，唯一要注意的是由于底层数组是Object[]，得到元素后需要进行类型转换。\n```java\npublic E get(int index) {\n    rangeCheck(index);\n    return (E) elementData[index];//注意类型转换\n}\n```\n\n### add()\n\n跟C++ 的*vector*不同，*ArrayList*没有`push_back()`方法，对应的方法是`add(E e)`，*ArrayList*也没有`insert()`方法，对应的方法是`add(int index, E e)`。这两个方法都是向容器中添加新元素，这可能会导致*capacity*不足，因此在添加元素之前，都需要进行剩余空间检查，如果需要则自动扩容。扩容操作最终是通过`grow()`方法完成的。\n```java\nprivate void grow(int minCapacity) {\n    int oldCapacity = elementData.length;\n    int newCapacity = oldCapacity + (oldCapacity >> 1);//原来的1.5倍\n    if (newCapacity - minCapacity < 0)\n        newCapacity = minCapacity;\n    if (newCapacity - MAX_ARRAY_SIZE > 0)\n        newCapacity = hugeCapacity(minCapacity);\n    elementData = Arrays.copyOf(elementData, newCapacity);//扩展空间并复制\n}\n```\n由于Java GC自动管理了内存，这里也就不需要考虑源数组释放的问题。\n\n![ArrayList_grow](/images/arraylist/ArrayList_grow.png)\n\n空间的问题解决后，插入过程就显得非常简单。\n\n![ArrayList_add](/images/arraylist/ArrayList_add.png)\n\n`add(int index, E e)`需要先对元素进行移动，然后完成插入操作，也就意味着该方法有着线性的时间复杂度。\n\n### addAll()\n\n`addAll()`方法能够一次添加多个元素，根据位置不同也有两个版本，一个是在末尾添加的`addAll(Collection<? extends E> c)`方法，一个是从指定位置开始插入的`addAll(int index, Collection<? extends E> c)`方法。跟`add()`方法类似，在插入之前也需要进行空间检查，如果需要则自动扩容；如果从指定位置插入，也会存在移动元素的情况。\n`addAll()`的时间复杂度不仅跟插入元素的多少有关，也跟插入的位置相关。\n\n### remove()\n\n`remove()`方法也有两个版本，一个是`remove(int index)`删除指定位置的元素，另一个是`remove(Object o)`删除第一个满足`o.equals(elementData[index])`的元素。删除操作是`add()`操作的逆过程，需要将删除点之后的元素向前移动一个位置。需要注意的是为了让GC起作用，必须显式的为最后一个位置赋`null`值。\n```java\npublic E remove(int index) {\n    rangeCheck(index);\n    modCount++;\n    E oldValue = elementData(index);\n    int numMoved = size - index - 1;\n    if (numMoved > 0)\n        System.arraycopy(elementData, index+1, elementData, index, numMoved);\n    elementData[--size] = null; //清除该位置的引用，让GC起作用\n    return oldValue;\n}\n```","slug":"arraylist","published":1,"updated":"2018-02-24T08:06:52.023Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjefa5bp9000e6skck12h91o0","content":"<h1 id=\"Introduction\"><a href=\"#Introduction\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h1><p>本文是学习ArrayList源码的学习总结，组织结构如下：</p>\n<ul>\n<li>总体介绍</li>\n<li>核心方法剖析</li>\n</ul>\n<h1 id=\"总体介绍\"><a href=\"#总体介绍\" class=\"headerlink\" title=\"总体介绍\"></a>总体介绍</h1><p><em>ArrayList</em>实现了<em>List</em>接口，是顺序容器，即元素存放的数据与放进去的顺序相同，允许放入<code>null</code>元素，底层通过<strong>数组实现</strong>。除该类未实现同步外，其余跟<em>Vector</em>大致相同。每个<em>ArrayList</em>都有一个容量（capacity），表示底层数组的实际大小，容器内存储元素的个数不能多于当前容量。当向容器中添加元素时，如果容量不足，容器会自动增大底层数组的大小。前面已经提过，Java泛型只是编译器提供的语法糖，所以这里的数组是一个Object数组，以便能够容纳任何类型的对象。</p>\n<a id=\"more\"></a>\n<p><img src=\"/images/arraylist/ArrayList_base.png\" alt=\"ArrayList_base\"></p>\n<p>size(), isEmpty(), get(), set()方法均能在常数时间内完成，add()方法的时间开销跟插入位置有关，addAll()方法的时间开销跟添加元素的个数成正比。其余方法大都是线性时间。</p>\n<p>为追求效率，ArrayList没有实现同步（synchronized），如果需要多个线程并发访问，用户可以手动同步，也可使用Vector替代。</p>\n<h1 id=\"方法剖析\"><a href=\"#方法剖析\" class=\"headerlink\" title=\"方法剖析\"></a>方法剖析</h1><h3 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set()\"></a>set()</h3><p>既然底层是一个数组<em>ArrayList</em>的<code>set()</code>方法也就变得非常简单，直接对数组的指定位置赋值即可。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">set</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\">    rangeCheck(index);<span class=\"comment\">//下标越界检查</span></span><br><span class=\"line\">    E oldValue = elementData(index);</span><br><span class=\"line\">    elementData[index] = element;<span class=\"comment\">//赋值到指定位置，复制的仅仅是引用</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get()\"></a>get()</h3><p><code>get()</code>方法同样很简单，唯一要注意的是由于底层数组是Object[]，得到元素后需要进行类型转换。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    rangeCheck(index);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (E) elementData[index];<span class=\"comment\">//注意类型转换</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"add\"><a href=\"#add\" class=\"headerlink\" title=\"add()\"></a>add()</h3><p>跟C++ 的<em>vector</em>不同，<em>ArrayList</em>没有<code>push_back()</code>方法，对应的方法是<code>add(E e)</code>，<em>ArrayList</em>也没有<code>insert()</code>方法，对应的方法是<code>add(int index, E e)</code>。这两个方法都是向容器中添加新元素，这可能会导致<em>capacity</em>不足，因此在添加元素之前，都需要进行剩余空间检查，如果需要则自动扩容。扩容操作最终是通过<code>grow()</code>方法完成的。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">grow</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCapacity = elementData.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class=\"number\">1</span>);<span class=\"comment\">//原来的1.5倍</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = minCapacity;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">    elementData = Arrays.copyOf(elementData, newCapacity);<span class=\"comment\">//扩展空间并复制</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>由于Java GC自动管理了内存，这里也就不需要考虑源数组释放的问题。</p>\n<p><img src=\"/images/arraylist/ArrayList_grow.png\" alt=\"ArrayList_grow\"></p>\n<p>空间的问题解决后，插入过程就显得非常简单。</p>\n<p><img src=\"/images/arraylist/ArrayList_add.png\" alt=\"ArrayList_add\"></p>\n<p><code>add(int index, E e)</code>需要先对元素进行移动，然后完成插入操作，也就意味着该方法有着线性的时间复杂度。</p>\n<h3 id=\"addAll\"><a href=\"#addAll\" class=\"headerlink\" title=\"addAll()\"></a>addAll()</h3><p><code>addAll()</code>方法能够一次添加多个元素，根据位置不同也有两个版本，一个是在末尾添加的<code>addAll(Collection&lt;? extends E&gt; c)</code>方法，一个是从指定位置开始插入的<code>addAll(int index, Collection&lt;? extends E&gt; c)</code>方法。跟<code>add()</code>方法类似，在插入之前也需要进行空间检查，如果需要则自动扩容；如果从指定位置插入，也会存在移动元素的情况。<br><code>addAll()</code>的时间复杂度不仅跟插入元素的多少有关，也跟插入的位置相关。</p>\n<h3 id=\"remove\"><a href=\"#remove\" class=\"headerlink\" title=\"remove()\"></a>remove()</h3><p><code>remove()</code>方法也有两个版本，一个是<code>remove(int index)</code>删除指定位置的元素，另一个是<code>remove(Object o)</code>删除第一个满足<code>o.equals(elementData[index])</code>的元素。删除操作是<code>add()</code>操作的逆过程，需要将删除点之后的元素向前移动一个位置。需要注意的是为了让GC起作用，必须显式的为最后一个位置赋<code>null</code>值。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">remove</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    rangeCheck(index);</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">    E oldValue = elementData(index);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> numMoved = size - index - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (numMoved &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        System.arraycopy(elementData, index+<span class=\"number\">1</span>, elementData, index, numMoved);</span><br><span class=\"line\">    elementData[--size] = <span class=\"keyword\">null</span>; <span class=\"comment\">//清除该位置的引用，让GC起作用</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Introduction\"><a href=\"#Introduction\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h1><p>本文是学习ArrayList源码的学习总结，组织结构如下：</p>\n<ul>\n<li>总体介绍</li>\n<li>核心方法剖析</li>\n</ul>\n<h1 id=\"总体介绍\"><a href=\"#总体介绍\" class=\"headerlink\" title=\"总体介绍\"></a>总体介绍</h1><p><em>ArrayList</em>实现了<em>List</em>接口，是顺序容器，即元素存放的数据与放进去的顺序相同，允许放入<code>null</code>元素，底层通过<strong>数组实现</strong>。除该类未实现同步外，其余跟<em>Vector</em>大致相同。每个<em>ArrayList</em>都有一个容量（capacity），表示底层数组的实际大小，容器内存储元素的个数不能多于当前容量。当向容器中添加元素时，如果容量不足，容器会自动增大底层数组的大小。前面已经提过，Java泛型只是编译器提供的语法糖，所以这里的数组是一个Object数组，以便能够容纳任何类型的对象。</p>","more":"<p><img src=\"/images/arraylist/ArrayList_base.png\" alt=\"ArrayList_base\"></p>\n<p>size(), isEmpty(), get(), set()方法均能在常数时间内完成，add()方法的时间开销跟插入位置有关，addAll()方法的时间开销跟添加元素的个数成正比。其余方法大都是线性时间。</p>\n<p>为追求效率，ArrayList没有实现同步（synchronized），如果需要多个线程并发访问，用户可以手动同步，也可使用Vector替代。</p>\n<h1 id=\"方法剖析\"><a href=\"#方法剖析\" class=\"headerlink\" title=\"方法剖析\"></a>方法剖析</h1><h3 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set()\"></a>set()</h3><p>既然底层是一个数组<em>ArrayList</em>的<code>set()</code>方法也就变得非常简单，直接对数组的指定位置赋值即可。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">set</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\">    rangeCheck(index);<span class=\"comment\">//下标越界检查</span></span><br><span class=\"line\">    E oldValue = elementData(index);</span><br><span class=\"line\">    elementData[index] = element;<span class=\"comment\">//赋值到指定位置，复制的仅仅是引用</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get()\"></a>get()</h3><p><code>get()</code>方法同样很简单，唯一要注意的是由于底层数组是Object[]，得到元素后需要进行类型转换。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    rangeCheck(index);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (E) elementData[index];<span class=\"comment\">//注意类型转换</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"add\"><a href=\"#add\" class=\"headerlink\" title=\"add()\"></a>add()</h3><p>跟C++ 的<em>vector</em>不同，<em>ArrayList</em>没有<code>push_back()</code>方法，对应的方法是<code>add(E e)</code>，<em>ArrayList</em>也没有<code>insert()</code>方法，对应的方法是<code>add(int index, E e)</code>。这两个方法都是向容器中添加新元素，这可能会导致<em>capacity</em>不足，因此在添加元素之前，都需要进行剩余空间检查，如果需要则自动扩容。扩容操作最终是通过<code>grow()</code>方法完成的。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">grow</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCapacity = elementData.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class=\"number\">1</span>);<span class=\"comment\">//原来的1.5倍</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = minCapacity;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">    elementData = Arrays.copyOf(elementData, newCapacity);<span class=\"comment\">//扩展空间并复制</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>由于Java GC自动管理了内存，这里也就不需要考虑源数组释放的问题。</p>\n<p><img src=\"/images/arraylist/ArrayList_grow.png\" alt=\"ArrayList_grow\"></p>\n<p>空间的问题解决后，插入过程就显得非常简单。</p>\n<p><img src=\"/images/arraylist/ArrayList_add.png\" alt=\"ArrayList_add\"></p>\n<p><code>add(int index, E e)</code>需要先对元素进行移动，然后完成插入操作，也就意味着该方法有着线性的时间复杂度。</p>\n<h3 id=\"addAll\"><a href=\"#addAll\" class=\"headerlink\" title=\"addAll()\"></a>addAll()</h3><p><code>addAll()</code>方法能够一次添加多个元素，根据位置不同也有两个版本，一个是在末尾添加的<code>addAll(Collection&lt;? extends E&gt; c)</code>方法，一个是从指定位置开始插入的<code>addAll(int index, Collection&lt;? extends E&gt; c)</code>方法。跟<code>add()</code>方法类似，在插入之前也需要进行空间检查，如果需要则自动扩容；如果从指定位置插入，也会存在移动元素的情况。<br><code>addAll()</code>的时间复杂度不仅跟插入元素的多少有关，也跟插入的位置相关。</p>\n<h3 id=\"remove\"><a href=\"#remove\" class=\"headerlink\" title=\"remove()\"></a>remove()</h3><p><code>remove()</code>方法也有两个版本，一个是<code>remove(int index)</code>删除指定位置的元素，另一个是<code>remove(Object o)</code>删除第一个满足<code>o.equals(elementData[index])</code>的元素。删除操作是<code>add()</code>操作的逆过程，需要将删除点之后的元素向前移动一个位置。需要注意的是为了让GC起作用，必须显式的为最后一个位置赋<code>null</code>值。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">remove</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    rangeCheck(index);</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">    E oldValue = elementData(index);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> numMoved = size - index - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (numMoved &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        System.arraycopy(elementData, index+<span class=\"number\">1</span>, elementData, index, numMoved);</span><br><span class=\"line\">    elementData[--size] = <span class=\"keyword\">null</span>; <span class=\"comment\">//清除该位置的引用，让GC起作用</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>"},{"title":"JVM内存分析","author":"James","date":"2013-05-27T08:13:00.000Z","_content":"# 概要\n\n开发人员编写Java代码(.java文件)，然后将之编译成字节码(.class文件)。最后字节码被装入内存，一旦字节码进入虚拟机，它就会被解释器解释执行，或者是被即时代码发生器有选择的转换成机器码执行。在Java平台的结构中, 可以看出，Java虚拟机(JVM) 处在核心的位置，是程序与底层操作系统和硬件无关的关键。它的下方是移植接口，移植接口由两部分组成：适配器和Java操作系统, 其中依赖于平台的部分称为适配器；JVM 通过移植接口在具体的平台和操作系统上实现；在JVM 的上方是Java的基本类库和扩展类库以及它们的API， 利用Java API编写的应用程序(application) 和小程序(Java applet) 可以在任何Java平台上运行而无需考虑底层平台, 就是因为有Java虚拟机(JVM)实现了程序与操作系统的分离，从而实现了Java 的平台无关性。\n\n<!-- more -->\n\n![jvm_struct2](/images/jvm/jvm_struct2.jpg)\n\n\n\n# 详细介绍\n\n## 程序计数器\n\n程序计数器，可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作就是通过改变程序计数器的值来选择下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都要依赖这个计数器来完成。\n\n多线程中，为了让线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间互不影响、独立存储，因此这块内存是 线程私有 的。\n\n当线程正在执行的是一个Java方法，这个计数器记录的是在正在执行的虚拟机字节码指令的地址；当执行的是Native方法，这个计数器值为空。\n\n此内存区域是唯一一个没有规定任何OutOfMemoryError情况的区域 。\n\n##  Java虚拟机栈\n\nJava虚拟机栈也是线程私有的 ，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储**局部变量表**、**操作数栈**、**动态链表**、方法出口信息等。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。\n\n**局部变量表**中存放了编译器可知的各种**基本数据类型**(boolean、byte、char、short、int、float、long、double)、对象引用（reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。\n\n如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。\n\n## Java堆\n\nJava堆是所有线程共享的一块内存区域，在虚拟机启动时创建，此内存区域的唯一目的就是存放**对象实例 **。\n\nJava堆是垃圾收集器管理的主要区域。由于现在收集器基本采用分代回收算法，所以Java堆还可细分为：新生代和老年代。从内存分配的角度来看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区(TLAB)。\n\nJava堆可以处于物理上不连续的内存空间，只要逻辑上连续的即可。在实现上，既可以实现固定大小的，也可以是扩展的。\n\n如果堆中没有内存完成实例分配，并且堆也无法完成扩展时，将会抛出OutOfMemoryError异常。\n\n![jvm_heap](/images/jvm/jvm_heap.jpg)\n\n## 方法区\n\n方法区是各个线程共享的内存区域，它用于存储已被虚拟机加载的*类信息*、*常量*、*静态变量*、即时编译器编译后的代码等数据 。\n\n相对而言，垃圾收集行为在这个区域比较少出现，但并非数据进了方法区就永久的存在了，这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，\n\n运行时常量池：用于存放编译期生成的各种字面量和符号引用。\n\n当方法区无法满足内存分配需要时，将抛出OutOfMemoryError异常。\n\n## 直接内存\n\n直接内存不是虚拟机运行时数据区的一部分，在NIO类中引入一种基于通道与缓冲区的IO方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。\n\n直接内存的分配不会受到Java堆大小的限制，但是会受到本机内存大小的限制，所有也可能会抛OutOfMemoryError异常。\n\n## 本地方法栈\n\n本地方法栈与虚拟机的作用相似，不同之处在于虚拟机栈为虚拟机执行的Java方法服务，而本地方法栈则为虚拟机使用到的Native方法服务。有的虚拟机直接把本地方法栈和虚拟机栈合二为一。\n\n会抛出stackOverflowError和OutOfMemoryError异常。\n\n一个数组的在堆中的简单表示:\n\n![array](/images/jvm/array.jpg)\n\n\n\n# 设置参数\n\n| 设置                       | 说明                                                         |\n| -------------------------- | ------------------------------------------------------------ |\n| -Xms512m                   | 表示JVM初始分配的堆内存大小为512m（JVM Heap(堆内存)最小尺寸，初始分配） |\n| -Xmx1024m                  | JVM最大允许分配的堆内存大小为1024m，按需分配（JVM Heap(堆内存)最大允许的尺寸，按需分配） |\n| -XX:PermSize=512M          | JVM初始分配的非堆内存                                        |\n| -XX:MaxPermSize=1024M      | JVM最大允许分配的非堆内存，按需分配                          |\n| -XX:NewSize/-XX:MaxNewSize | 定义YOUNG段的尺寸，NewSize为JVM启动时YOUNG的内存大小； MaxNewSize为最大可占用的YOUNG内存大小。 |\n| -XX:SurvivorRatio          | 设置YOUNG代中Survivor空间和Eden空间的比例                    |\n\n## 说明\n\n- -Xmx不指定或者指定偏小，应用可能会导致java.lang.OutOfMemory错误\n- PermSize和MaxPermSize指明虚拟机为java永久生成对象（Permanate generation）如，class对象、方法对象这些可反射（reflective）对象分配内存限制\n- -XX:MaxPermSize分配过小会导致：java.lang.OutOfMemoryError: PermGen space\n\n# 内存监控方法\n\njmap -heap 查看java 堆（heap）使用情况\n\n参数配置：内存溢出自动dump内存快照\n\n-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/home/logs\n\njmap -dump:format=b,file=heap.bin <pid>  \n\nformat=b的含义是，dump出来的文件时二进制格式。\n\nfile-heap.bin的含义是，dump出来的文件名是heap.bin。\n\n <pid>就是JVM的进程号。\n\n （在linux下）先执行ps aux | grep java，找到JVM的pid；然后再执行jmap -dump:format=b,file=heap.bin <pid>，得到heap dump文件。\n\n或者可以使用 jps -lv 查看java pid","source":"_posts/jvm_memory.md","raw":"title: JVM内存分析\nauthor: James\ntags:\n  - jvm\n  - java\ncategories:\n  - 语言\ndate: 2013-05-27 16:13:00\n---\n# 概要\n\n开发人员编写Java代码(.java文件)，然后将之编译成字节码(.class文件)。最后字节码被装入内存，一旦字节码进入虚拟机，它就会被解释器解释执行，或者是被即时代码发生器有选择的转换成机器码执行。在Java平台的结构中, 可以看出，Java虚拟机(JVM) 处在核心的位置，是程序与底层操作系统和硬件无关的关键。它的下方是移植接口，移植接口由两部分组成：适配器和Java操作系统, 其中依赖于平台的部分称为适配器；JVM 通过移植接口在具体的平台和操作系统上实现；在JVM 的上方是Java的基本类库和扩展类库以及它们的API， 利用Java API编写的应用程序(application) 和小程序(Java applet) 可以在任何Java平台上运行而无需考虑底层平台, 就是因为有Java虚拟机(JVM)实现了程序与操作系统的分离，从而实现了Java 的平台无关性。\n\n<!-- more -->\n\n![jvm_struct2](/images/jvm/jvm_struct2.jpg)\n\n\n\n# 详细介绍\n\n## 程序计数器\n\n程序计数器，可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作就是通过改变程序计数器的值来选择下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都要依赖这个计数器来完成。\n\n多线程中，为了让线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间互不影响、独立存储，因此这块内存是 线程私有 的。\n\n当线程正在执行的是一个Java方法，这个计数器记录的是在正在执行的虚拟机字节码指令的地址；当执行的是Native方法，这个计数器值为空。\n\n此内存区域是唯一一个没有规定任何OutOfMemoryError情况的区域 。\n\n##  Java虚拟机栈\n\nJava虚拟机栈也是线程私有的 ，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储**局部变量表**、**操作数栈**、**动态链表**、方法出口信息等。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。\n\n**局部变量表**中存放了编译器可知的各种**基本数据类型**(boolean、byte、char、short、int、float、long、double)、对象引用（reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。\n\n如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。\n\n## Java堆\n\nJava堆是所有线程共享的一块内存区域，在虚拟机启动时创建，此内存区域的唯一目的就是存放**对象实例 **。\n\nJava堆是垃圾收集器管理的主要区域。由于现在收集器基本采用分代回收算法，所以Java堆还可细分为：新生代和老年代。从内存分配的角度来看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区(TLAB)。\n\nJava堆可以处于物理上不连续的内存空间，只要逻辑上连续的即可。在实现上，既可以实现固定大小的，也可以是扩展的。\n\n如果堆中没有内存完成实例分配，并且堆也无法完成扩展时，将会抛出OutOfMemoryError异常。\n\n![jvm_heap](/images/jvm/jvm_heap.jpg)\n\n## 方法区\n\n方法区是各个线程共享的内存区域，它用于存储已被虚拟机加载的*类信息*、*常量*、*静态变量*、即时编译器编译后的代码等数据 。\n\n相对而言，垃圾收集行为在这个区域比较少出现，但并非数据进了方法区就永久的存在了，这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，\n\n运行时常量池：用于存放编译期生成的各种字面量和符号引用。\n\n当方法区无法满足内存分配需要时，将抛出OutOfMemoryError异常。\n\n## 直接内存\n\n直接内存不是虚拟机运行时数据区的一部分，在NIO类中引入一种基于通道与缓冲区的IO方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。\n\n直接内存的分配不会受到Java堆大小的限制，但是会受到本机内存大小的限制，所有也可能会抛OutOfMemoryError异常。\n\n## 本地方法栈\n\n本地方法栈与虚拟机的作用相似，不同之处在于虚拟机栈为虚拟机执行的Java方法服务，而本地方法栈则为虚拟机使用到的Native方法服务。有的虚拟机直接把本地方法栈和虚拟机栈合二为一。\n\n会抛出stackOverflowError和OutOfMemoryError异常。\n\n一个数组的在堆中的简单表示:\n\n![array](/images/jvm/array.jpg)\n\n\n\n# 设置参数\n\n| 设置                       | 说明                                                         |\n| -------------------------- | ------------------------------------------------------------ |\n| -Xms512m                   | 表示JVM初始分配的堆内存大小为512m（JVM Heap(堆内存)最小尺寸，初始分配） |\n| -Xmx1024m                  | JVM最大允许分配的堆内存大小为1024m，按需分配（JVM Heap(堆内存)最大允许的尺寸，按需分配） |\n| -XX:PermSize=512M          | JVM初始分配的非堆内存                                        |\n| -XX:MaxPermSize=1024M      | JVM最大允许分配的非堆内存，按需分配                          |\n| -XX:NewSize/-XX:MaxNewSize | 定义YOUNG段的尺寸，NewSize为JVM启动时YOUNG的内存大小； MaxNewSize为最大可占用的YOUNG内存大小。 |\n| -XX:SurvivorRatio          | 设置YOUNG代中Survivor空间和Eden空间的比例                    |\n\n## 说明\n\n- -Xmx不指定或者指定偏小，应用可能会导致java.lang.OutOfMemory错误\n- PermSize和MaxPermSize指明虚拟机为java永久生成对象（Permanate generation）如，class对象、方法对象这些可反射（reflective）对象分配内存限制\n- -XX:MaxPermSize分配过小会导致：java.lang.OutOfMemoryError: PermGen space\n\n# 内存监控方法\n\njmap -heap 查看java 堆（heap）使用情况\n\n参数配置：内存溢出自动dump内存快照\n\n-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/home/logs\n\njmap -dump:format=b,file=heap.bin <pid>  \n\nformat=b的含义是，dump出来的文件时二进制格式。\n\nfile-heap.bin的含义是，dump出来的文件名是heap.bin。\n\n <pid>就是JVM的进程号。\n\n （在linux下）先执行ps aux | grep java，找到JVM的pid；然后再执行jmap -dump:format=b,file=heap.bin <pid>，得到heap dump文件。\n\n或者可以使用 jps -lv 查看java pid","slug":"jvm_memory","published":1,"updated":"2018-03-01T01:36:49.979Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjefa5bpc000f6skc0u681bhw","content":"<h1 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h1><p>开发人员编写Java代码(.java文件)，然后将之编译成字节码(.class文件)。最后字节码被装入内存，一旦字节码进入虚拟机，它就会被解释器解释执行，或者是被即时代码发生器有选择的转换成机器码执行。在Java平台的结构中, 可以看出，Java虚拟机(JVM) 处在核心的位置，是程序与底层操作系统和硬件无关的关键。它的下方是移植接口，移植接口由两部分组成：适配器和Java操作系统, 其中依赖于平台的部分称为适配器；JVM 通过移植接口在具体的平台和操作系统上实现；在JVM 的上方是Java的基本类库和扩展类库以及它们的API， 利用Java API编写的应用程序(application) 和小程序(Java applet) 可以在任何Java平台上运行而无需考虑底层平台, 就是因为有Java虚拟机(JVM)实现了程序与操作系统的分离，从而实现了Java 的平台无关性。</p>\n<a id=\"more\"></a>\n<p><img src=\"/images/jvm/jvm_struct2.jpg\" alt=\"jvm_struct2\"></p>\n<h1 id=\"详细介绍\"><a href=\"#详细介绍\" class=\"headerlink\" title=\"详细介绍\"></a>详细介绍</h1><h2 id=\"程序计数器\"><a href=\"#程序计数器\" class=\"headerlink\" title=\"程序计数器\"></a>程序计数器</h2><p>程序计数器，可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作就是通过改变程序计数器的值来选择下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都要依赖这个计数器来完成。</p>\n<p>多线程中，为了让线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间互不影响、独立存储，因此这块内存是 线程私有 的。</p>\n<p>当线程正在执行的是一个Java方法，这个计数器记录的是在正在执行的虚拟机字节码指令的地址；当执行的是Native方法，这个计数器值为空。</p>\n<p>此内存区域是唯一一个没有规定任何OutOfMemoryError情况的区域 。</p>\n<h2 id=\"Java虚拟机栈\"><a href=\"#Java虚拟机栈\" class=\"headerlink\" title=\"Java虚拟机栈\"></a>Java虚拟机栈</h2><p>Java虚拟机栈也是线程私有的 ，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储<strong>局部变量表</strong>、<strong>操作数栈</strong>、<strong>动态链表</strong>、方法出口信息等。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p>\n<p><strong>局部变量表</strong>中存放了编译器可知的各种<strong>基本数据类型</strong>(boolean、byte、char、short、int、float、long、double)、对象引用（reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。</p>\n<p>如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。</p>\n<h2 id=\"Java堆\"><a href=\"#Java堆\" class=\"headerlink\" title=\"Java堆\"></a>Java堆</h2><p>Java堆是所有线程共享的一块内存区域，在虚拟机启动时创建，此内存区域的唯一目的就是存放<strong>对象实例 </strong>。</p>\n<p>Java堆是垃圾收集器管理的主要区域。由于现在收集器基本采用分代回收算法，所以Java堆还可细分为：新生代和老年代。从内存分配的角度来看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区(TLAB)。</p>\n<p>Java堆可以处于物理上不连续的内存空间，只要逻辑上连续的即可。在实现上，既可以实现固定大小的，也可以是扩展的。</p>\n<p>如果堆中没有内存完成实例分配，并且堆也无法完成扩展时，将会抛出OutOfMemoryError异常。</p>\n<p><img src=\"/images/jvm/jvm_heap.jpg\" alt=\"jvm_heap\"></p>\n<h2 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区\"></a>方法区</h2><p>方法区是各个线程共享的内存区域，它用于存储已被虚拟机加载的<em>类信息</em>、<em>常量</em>、<em>静态变量</em>、即时编译器编译后的代码等数据 。</p>\n<p>相对而言，垃圾收集行为在这个区域比较少出现，但并非数据进了方法区就永久的存在了，这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，</p>\n<p>运行时常量池：用于存放编译期生成的各种字面量和符号引用。</p>\n<p>当方法区无法满足内存分配需要时，将抛出OutOfMemoryError异常。</p>\n<h2 id=\"直接内存\"><a href=\"#直接内存\" class=\"headerlink\" title=\"直接内存\"></a>直接内存</h2><p>直接内存不是虚拟机运行时数据区的一部分，在NIO类中引入一种基于通道与缓冲区的IO方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。</p>\n<p>直接内存的分配不会受到Java堆大小的限制，但是会受到本机内存大小的限制，所有也可能会抛OutOfMemoryError异常。</p>\n<h2 id=\"本地方法栈\"><a href=\"#本地方法栈\" class=\"headerlink\" title=\"本地方法栈\"></a>本地方法栈</h2><p>本地方法栈与虚拟机的作用相似，不同之处在于虚拟机栈为虚拟机执行的Java方法服务，而本地方法栈则为虚拟机使用到的Native方法服务。有的虚拟机直接把本地方法栈和虚拟机栈合二为一。</p>\n<p>会抛出stackOverflowError和OutOfMemoryError异常。</p>\n<p>一个数组的在堆中的简单表示:</p>\n<p><img src=\"/images/jvm/array.jpg\" alt=\"array\"></p>\n<h1 id=\"设置参数\"><a href=\"#设置参数\" class=\"headerlink\" title=\"设置参数\"></a>设置参数</h1><table>\n<thead>\n<tr>\n<th>设置</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-Xms512m</td>\n<td>表示JVM初始分配的堆内存大小为512m（JVM Heap(堆内存)最小尺寸，初始分配）</td>\n</tr>\n<tr>\n<td>-Xmx1024m</td>\n<td>JVM最大允许分配的堆内存大小为1024m，按需分配（JVM Heap(堆内存)最大允许的尺寸，按需分配）</td>\n</tr>\n<tr>\n<td>-XX:PermSize=512M</td>\n<td>JVM初始分配的非堆内存</td>\n</tr>\n<tr>\n<td>-XX:MaxPermSize=1024M</td>\n<td>JVM最大允许分配的非堆内存，按需分配</td>\n</tr>\n<tr>\n<td>-XX:NewSize/-XX:MaxNewSize</td>\n<td>定义YOUNG段的尺寸，NewSize为JVM启动时YOUNG的内存大小； MaxNewSize为最大可占用的YOUNG内存大小。</td>\n</tr>\n<tr>\n<td>-XX:SurvivorRatio</td>\n<td>设置YOUNG代中Survivor空间和Eden空间的比例</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><ul>\n<li>-Xmx不指定或者指定偏小，应用可能会导致java.lang.OutOfMemory错误</li>\n<li>PermSize和MaxPermSize指明虚拟机为java永久生成对象（Permanate generation）如，class对象、方法对象这些可反射（reflective）对象分配内存限制</li>\n<li>-XX:MaxPermSize分配过小会导致：java.lang.OutOfMemoryError: PermGen space</li>\n</ul>\n<h1 id=\"内存监控方法\"><a href=\"#内存监控方法\" class=\"headerlink\" title=\"内存监控方法\"></a>内存监控方法</h1><p>jmap -heap 查看java 堆（heap）使用情况</p>\n<p>参数配置：内存溢出自动dump内存快照</p>\n<p>-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/home/logs</p>\n<p>jmap -dump:format=b,file=heap.bin <pid>  </pid></p>\n<p>format=b的含义是，dump出来的文件时二进制格式。</p>\n<p>file-heap.bin的含义是，dump出来的文件名是heap.bin。</p>\n<p> <pid>就是JVM的进程号。</pid></p>\n<p> （在linux下）先执行ps aux | grep java，找到JVM的pid；然后再执行jmap -dump:format=b,file=heap.bin <pid>，得到heap dump文件。</pid></p>\n<p>或者可以使用 jps -lv 查看java pid</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h1><p>开发人员编写Java代码(.java文件)，然后将之编译成字节码(.class文件)。最后字节码被装入内存，一旦字节码进入虚拟机，它就会被解释器解释执行，或者是被即时代码发生器有选择的转换成机器码执行。在Java平台的结构中, 可以看出，Java虚拟机(JVM) 处在核心的位置，是程序与底层操作系统和硬件无关的关键。它的下方是移植接口，移植接口由两部分组成：适配器和Java操作系统, 其中依赖于平台的部分称为适配器；JVM 通过移植接口在具体的平台和操作系统上实现；在JVM 的上方是Java的基本类库和扩展类库以及它们的API， 利用Java API编写的应用程序(application) 和小程序(Java applet) 可以在任何Java平台上运行而无需考虑底层平台, 就是因为有Java虚拟机(JVM)实现了程序与操作系统的分离，从而实现了Java 的平台无关性。</p>","more":"<p><img src=\"/images/jvm/jvm_struct2.jpg\" alt=\"jvm_struct2\"></p>\n<h1 id=\"详细介绍\"><a href=\"#详细介绍\" class=\"headerlink\" title=\"详细介绍\"></a>详细介绍</h1><h2 id=\"程序计数器\"><a href=\"#程序计数器\" class=\"headerlink\" title=\"程序计数器\"></a>程序计数器</h2><p>程序计数器，可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作就是通过改变程序计数器的值来选择下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都要依赖这个计数器来完成。</p>\n<p>多线程中，为了让线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间互不影响、独立存储，因此这块内存是 线程私有 的。</p>\n<p>当线程正在执行的是一个Java方法，这个计数器记录的是在正在执行的虚拟机字节码指令的地址；当执行的是Native方法，这个计数器值为空。</p>\n<p>此内存区域是唯一一个没有规定任何OutOfMemoryError情况的区域 。</p>\n<h2 id=\"Java虚拟机栈\"><a href=\"#Java虚拟机栈\" class=\"headerlink\" title=\"Java虚拟机栈\"></a>Java虚拟机栈</h2><p>Java虚拟机栈也是线程私有的 ，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储<strong>局部变量表</strong>、<strong>操作数栈</strong>、<strong>动态链表</strong>、方法出口信息等。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p>\n<p><strong>局部变量表</strong>中存放了编译器可知的各种<strong>基本数据类型</strong>(boolean、byte、char、short、int、float、long、double)、对象引用（reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。</p>\n<p>如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。</p>\n<h2 id=\"Java堆\"><a href=\"#Java堆\" class=\"headerlink\" title=\"Java堆\"></a>Java堆</h2><p>Java堆是所有线程共享的一块内存区域，在虚拟机启动时创建，此内存区域的唯一目的就是存放<strong>对象实例 </strong>。</p>\n<p>Java堆是垃圾收集器管理的主要区域。由于现在收集器基本采用分代回收算法，所以Java堆还可细分为：新生代和老年代。从内存分配的角度来看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区(TLAB)。</p>\n<p>Java堆可以处于物理上不连续的内存空间，只要逻辑上连续的即可。在实现上，既可以实现固定大小的，也可以是扩展的。</p>\n<p>如果堆中没有内存完成实例分配，并且堆也无法完成扩展时，将会抛出OutOfMemoryError异常。</p>\n<p><img src=\"/images/jvm/jvm_heap.jpg\" alt=\"jvm_heap\"></p>\n<h2 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区\"></a>方法区</h2><p>方法区是各个线程共享的内存区域，它用于存储已被虚拟机加载的<em>类信息</em>、<em>常量</em>、<em>静态变量</em>、即时编译器编译后的代码等数据 。</p>\n<p>相对而言，垃圾收集行为在这个区域比较少出现，但并非数据进了方法区就永久的存在了，这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，</p>\n<p>运行时常量池：用于存放编译期生成的各种字面量和符号引用。</p>\n<p>当方法区无法满足内存分配需要时，将抛出OutOfMemoryError异常。</p>\n<h2 id=\"直接内存\"><a href=\"#直接内存\" class=\"headerlink\" title=\"直接内存\"></a>直接内存</h2><p>直接内存不是虚拟机运行时数据区的一部分，在NIO类中引入一种基于通道与缓冲区的IO方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。</p>\n<p>直接内存的分配不会受到Java堆大小的限制，但是会受到本机内存大小的限制，所有也可能会抛OutOfMemoryError异常。</p>\n<h2 id=\"本地方法栈\"><a href=\"#本地方法栈\" class=\"headerlink\" title=\"本地方法栈\"></a>本地方法栈</h2><p>本地方法栈与虚拟机的作用相似，不同之处在于虚拟机栈为虚拟机执行的Java方法服务，而本地方法栈则为虚拟机使用到的Native方法服务。有的虚拟机直接把本地方法栈和虚拟机栈合二为一。</p>\n<p>会抛出stackOverflowError和OutOfMemoryError异常。</p>\n<p>一个数组的在堆中的简单表示:</p>\n<p><img src=\"/images/jvm/array.jpg\" alt=\"array\"></p>\n<h1 id=\"设置参数\"><a href=\"#设置参数\" class=\"headerlink\" title=\"设置参数\"></a>设置参数</h1><table>\n<thead>\n<tr>\n<th>设置</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-Xms512m</td>\n<td>表示JVM初始分配的堆内存大小为512m（JVM Heap(堆内存)最小尺寸，初始分配）</td>\n</tr>\n<tr>\n<td>-Xmx1024m</td>\n<td>JVM最大允许分配的堆内存大小为1024m，按需分配（JVM Heap(堆内存)最大允许的尺寸，按需分配）</td>\n</tr>\n<tr>\n<td>-XX:PermSize=512M</td>\n<td>JVM初始分配的非堆内存</td>\n</tr>\n<tr>\n<td>-XX:MaxPermSize=1024M</td>\n<td>JVM最大允许分配的非堆内存，按需分配</td>\n</tr>\n<tr>\n<td>-XX:NewSize/-XX:MaxNewSize</td>\n<td>定义YOUNG段的尺寸，NewSize为JVM启动时YOUNG的内存大小； MaxNewSize为最大可占用的YOUNG内存大小。</td>\n</tr>\n<tr>\n<td>-XX:SurvivorRatio</td>\n<td>设置YOUNG代中Survivor空间和Eden空间的比例</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><ul>\n<li>-Xmx不指定或者指定偏小，应用可能会导致java.lang.OutOfMemory错误</li>\n<li>PermSize和MaxPermSize指明虚拟机为java永久生成对象（Permanate generation）如，class对象、方法对象这些可反射（reflective）对象分配内存限制</li>\n<li>-XX:MaxPermSize分配过小会导致：java.lang.OutOfMemoryError: PermGen space</li>\n</ul>\n<h1 id=\"内存监控方法\"><a href=\"#内存监控方法\" class=\"headerlink\" title=\"内存监控方法\"></a>内存监控方法</h1><p>jmap -heap 查看java 堆（heap）使用情况</p>\n<p>参数配置：内存溢出自动dump内存快照</p>\n<p>-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/home/logs</p>\n<p>jmap -dump:format=b,file=heap.bin <pid>  </pid></p>\n<p>format=b的含义是，dump出来的文件时二进制格式。</p>\n<p>file-heap.bin的含义是，dump出来的文件名是heap.bin。</p>\n<p> <pid>就是JVM的进程号。</pid></p>\n<p> （在linux下）先执行ps aux | grep java，找到JVM的pid；然后再执行jmap -dump:format=b,file=heap.bin <pid>，得到heap dump文件。</pid></p>\n<p>或者可以使用 jps -lv 查看java pid</p>"},{"title":"synchronized的故事","author":"James","date":"2013-07-01T03:30:00.000Z","_content":"\n# 前言\n\n并发编程几乎是每个程序员都必须要掌握的技能，但是也是比较难理解和熟练掌握，使用过程中也很容易出现问题；本文将从java Synchronized的关键字入手，着重讲解其应用方式和实现原理。\n\n<!-- more -->\n\n# 为什么需要它\n\n##  共享性\n\n数据共享性是线程安全的主要原因之一。如果所有的数据只是在线程内有效，那就不存在线程安全性问题，这也是我们在编程的时候经常不需要考虑线程安全的主要原因之一。但是，在多线程编程中，数据共享是不可避免的。对共享变量操作，在多线程环境下很容易出现各种意想不到的的结果。\n\n## 互斥性\n\n资源互斥是指同时只允许一个访问者对其进行访问，具有唯一性和排它性。我们通常允许多个线程同时对数据进行读操作，但同一时间内只允许一个线程对数据进行写操作。\n\n## 可见性\n\n要理解可见性，需要先对JVM的内存模型有一定的了解,如下图:\n\n图中每个线程都有一个自己的工作内存，对于共享变量，线程每次读取的是工作内存中共享变量的副本，写入的时候也直接修改工作内存中副本的值，然后在某个时间点上再将工作内存与主内存中的值进行同步。这样导致的问题是，如果线程1对某个变量进行了修改，线程2却有可能看不到线程1对共享变量所做的修改。\n\n![线程内存共享图](/images/synchronized/thread.png)\n\n## 重排序\n\n为了提高性能，编译器和处理器可能会对指令做重排序。重排序可以分为以下几种：\n\n1. 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。\n2. 指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。\n3. 内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。\n\n# 应用方式\n\nsynchronized关键字最主要有以下3种应用方式:\n\n- 修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁。*注意*：一个对象只有一把锁，当一个线程获取了该对象的锁之后，其他线程无法获取该对象的锁，所以无法访问该对象的其他synchronized实例方法\n- 修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁。\n- 修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。\n\n# 实现原理\n\n先从下面一段代码来看看Synchronized是如何实现对代码块同步的\n\n```java\npackage com.paddx.test.concurrent;\n\npublic class Test {\n    public void method() {\n        synchronized (this) {\n            System.out.println(\"Method...\");\n        }\n    }\n}\n```\n\n然后我们反编译下面的代码来看看\n\n![反编译代码](/images/synchronized/syn_class.png)\n\n红框的两条指令是关键：\n\n`monitorenter` ：每个对象有一个监视器锁`monitor`。当`monitor`被占用时就会处于锁定状态，线程执行`monitorenter`指令时尝试获取`monitor`的所有权，过程如下：\n\n​\t1. 如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。\n\n​\t2. 如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1.\n\n​\t3. 如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。\n\n`monitorexit`：执行`monitorexit`的线程必须是`objectref`所对应的`monitor`的所有者。\n\n​\t指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是\n\n​\t这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权.\n\n​\t从上图字节码中也可以看出多了一个monitorexit指令，它是异常结束时被执行的释放monitor 的指令。\n\n# JDK 实现机制\n\n首先需要了解对象内存的布局：\n\n1. 对象头：标记字（32位虚拟机4B，64位虚拟机8B） + 类型指针（32位虚拟机4B，64位虚拟机8B）+ [数组长（对于数据对象才需要此部分信息）]\n2. 实例数据\n3. 对齐填充：对于64位虚拟机来说，对象大小必须是8B的整数倍，不够的话需要占位填充\n\n![反编译代码](/images/synchronized/object.png)\n\n**Mark Word** 用于存储对象自身的运行时数据，它是实现轻量级锁和偏向锁的关键，所以下面将重点阐述。，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程 \nID、偏向时间戳等等。Java对象头一般占有两个机器码（在32位虚拟机中，1个机器码等于4字节，也就是32bit），但是如果对象是数组类型，则需要三个机器码，因为JVM虚拟机可以通过Java对象的元数据信息确定Java对象的大小，但是无法从数组的元数据来确认数组的大小，所以用一块来记录数组长度。\n![锁存储状态](/images/synchronized/lockstatus.png)\n\n## 几种锁类型\n\n　锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级）。JDK\n 1.6中默认是开启偏向锁和轻量级锁的，我们也可以通过-XX:-UseBiasedLocking来禁用偏向锁。\n\n### 轻量级锁\n\n1. 在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝。\n2. 拷贝对象头中的Mark Word复制到锁记录中。\n3. 拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock record里的owner指针指向object mark word。\n4. 如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，即表示此对象处于轻量级锁定状态。\n5. 如果这个更新操作失败了，虚拟机首先会检查对象的Mark \n   Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。否则说明多个线程竞争锁，轻量级锁就要膨胀为重量级锁，锁标志的状态值变为“10”，Mark\n    Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。 \n   而当前线程便尝试使用自旋来获取锁，自旋就是为了不让线程阻塞，而采用循环去获取锁的过程。\n\n### 偏向锁\n\n引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗必须小于节省下来的CAS原子指令的性能消耗）。上面说过，轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能。\n\n1. 访问Mark Word中偏向锁的标识是否设置成1，锁标志位是否为01——确认为可偏向状态。\n2. 如果为可偏向状态，则测试线程ID是否指向当前线程，如果是，进入步骤5，否则进入步骤3。\n3. 如果线程ID并未指向当前线程，则通过CAS操作竞争锁。如果竞争成功，则将Mark Word中线程ID设置为当前线程ID，然后执行步骤5；如果竞争失败，执行步骤4。\n4. 如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点（safepoint）时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。\n5. 执行同步代码。\n\n\n### 重量级锁\n\n重量级锁通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。\n\n\n**总结** : JDk中采用轻量级锁和偏向锁等对Synchronized的优化，但是这两种锁也不是完全没缺点的，比如竞争比较激烈的时候，不但无法提升效率，反而会降低效率，因为多了一个锁升级的过程\n\n| 锁       | 优点                                                         | 缺点                                             | 适用场景                             |\n| -------- | ------------------------------------------------------------ | ------------------------------------------------ | ------------------------------------ |\n| 偏向锁   | 加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。 | 如果线程间存在锁竞争，会带来额外的锁撤销的消耗。 | 适用于只有一个线程访问同步块场景。   |\n| 轻量级锁 | 竞争的线程不会阻塞，提高了程序的响应速度。                   | 如果始终得不到锁竞争的线程使用自旋会消耗CPU。    | 追求响应时间。同步块执行速度非常快。 |\n| 重量级锁 | 线程竞争不使用自旋，不会消耗CPU。                            | 线程阻塞，响应时间缓慢。                         | 追求吞吐量。同步块执行速度较长。     |\n\n### 锁消除\n\n消除锁是虚拟机另外一种锁的优化，这种优化更彻底，Java虚拟机在JIT编译时(可以简单理解为当某段代码即将第一次被执行时进行编译，又称即时编译)，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间，如下StringBuffer的append是一个同步方法，但是在add方法中的StringBuffer属于一个局部变量，并且不会被其他线程所使用，因此StringBuffer不可能存在共享资源竞争的情景，JVM会自动将其锁消除。\n","source":"_posts/synchronized.md","raw":"title: synchronized的故事\nauthor: James\ntags:\n  - synchronized\n  - lock\ncategories:\n  - 语言\ndate: 2013-07-01 11:30:00\n---\n\n# 前言\n\n并发编程几乎是每个程序员都必须要掌握的技能，但是也是比较难理解和熟练掌握，使用过程中也很容易出现问题；本文将从java Synchronized的关键字入手，着重讲解其应用方式和实现原理。\n\n<!-- more -->\n\n# 为什么需要它\n\n##  共享性\n\n数据共享性是线程安全的主要原因之一。如果所有的数据只是在线程内有效，那就不存在线程安全性问题，这也是我们在编程的时候经常不需要考虑线程安全的主要原因之一。但是，在多线程编程中，数据共享是不可避免的。对共享变量操作，在多线程环境下很容易出现各种意想不到的的结果。\n\n## 互斥性\n\n资源互斥是指同时只允许一个访问者对其进行访问，具有唯一性和排它性。我们通常允许多个线程同时对数据进行读操作，但同一时间内只允许一个线程对数据进行写操作。\n\n## 可见性\n\n要理解可见性，需要先对JVM的内存模型有一定的了解,如下图:\n\n图中每个线程都有一个自己的工作内存，对于共享变量，线程每次读取的是工作内存中共享变量的副本，写入的时候也直接修改工作内存中副本的值，然后在某个时间点上再将工作内存与主内存中的值进行同步。这样导致的问题是，如果线程1对某个变量进行了修改，线程2却有可能看不到线程1对共享变量所做的修改。\n\n![线程内存共享图](/images/synchronized/thread.png)\n\n## 重排序\n\n为了提高性能，编译器和处理器可能会对指令做重排序。重排序可以分为以下几种：\n\n1. 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。\n2. 指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。\n3. 内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。\n\n# 应用方式\n\nsynchronized关键字最主要有以下3种应用方式:\n\n- 修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁。*注意*：一个对象只有一把锁，当一个线程获取了该对象的锁之后，其他线程无法获取该对象的锁，所以无法访问该对象的其他synchronized实例方法\n- 修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁。\n- 修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。\n\n# 实现原理\n\n先从下面一段代码来看看Synchronized是如何实现对代码块同步的\n\n```java\npackage com.paddx.test.concurrent;\n\npublic class Test {\n    public void method() {\n        synchronized (this) {\n            System.out.println(\"Method...\");\n        }\n    }\n}\n```\n\n然后我们反编译下面的代码来看看\n\n![反编译代码](/images/synchronized/syn_class.png)\n\n红框的两条指令是关键：\n\n`monitorenter` ：每个对象有一个监视器锁`monitor`。当`monitor`被占用时就会处于锁定状态，线程执行`monitorenter`指令时尝试获取`monitor`的所有权，过程如下：\n\n​\t1. 如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。\n\n​\t2. 如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1.\n\n​\t3. 如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。\n\n`monitorexit`：执行`monitorexit`的线程必须是`objectref`所对应的`monitor`的所有者。\n\n​\t指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是\n\n​\t这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权.\n\n​\t从上图字节码中也可以看出多了一个monitorexit指令，它是异常结束时被执行的释放monitor 的指令。\n\n# JDK 实现机制\n\n首先需要了解对象内存的布局：\n\n1. 对象头：标记字（32位虚拟机4B，64位虚拟机8B） + 类型指针（32位虚拟机4B，64位虚拟机8B）+ [数组长（对于数据对象才需要此部分信息）]\n2. 实例数据\n3. 对齐填充：对于64位虚拟机来说，对象大小必须是8B的整数倍，不够的话需要占位填充\n\n![反编译代码](/images/synchronized/object.png)\n\n**Mark Word** 用于存储对象自身的运行时数据，它是实现轻量级锁和偏向锁的关键，所以下面将重点阐述。，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程 \nID、偏向时间戳等等。Java对象头一般占有两个机器码（在32位虚拟机中，1个机器码等于4字节，也就是32bit），但是如果对象是数组类型，则需要三个机器码，因为JVM虚拟机可以通过Java对象的元数据信息确定Java对象的大小，但是无法从数组的元数据来确认数组的大小，所以用一块来记录数组长度。\n![锁存储状态](/images/synchronized/lockstatus.png)\n\n## 几种锁类型\n\n　锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级）。JDK\n 1.6中默认是开启偏向锁和轻量级锁的，我们也可以通过-XX:-UseBiasedLocking来禁用偏向锁。\n\n### 轻量级锁\n\n1. 在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝。\n2. 拷贝对象头中的Mark Word复制到锁记录中。\n3. 拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock record里的owner指针指向object mark word。\n4. 如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，即表示此对象处于轻量级锁定状态。\n5. 如果这个更新操作失败了，虚拟机首先会检查对象的Mark \n   Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。否则说明多个线程竞争锁，轻量级锁就要膨胀为重量级锁，锁标志的状态值变为“10”，Mark\n    Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。 \n   而当前线程便尝试使用自旋来获取锁，自旋就是为了不让线程阻塞，而采用循环去获取锁的过程。\n\n### 偏向锁\n\n引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗必须小于节省下来的CAS原子指令的性能消耗）。上面说过，轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能。\n\n1. 访问Mark Word中偏向锁的标识是否设置成1，锁标志位是否为01——确认为可偏向状态。\n2. 如果为可偏向状态，则测试线程ID是否指向当前线程，如果是，进入步骤5，否则进入步骤3。\n3. 如果线程ID并未指向当前线程，则通过CAS操作竞争锁。如果竞争成功，则将Mark Word中线程ID设置为当前线程ID，然后执行步骤5；如果竞争失败，执行步骤4。\n4. 如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点（safepoint）时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。\n5. 执行同步代码。\n\n\n### 重量级锁\n\n重量级锁通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。\n\n\n**总结** : JDk中采用轻量级锁和偏向锁等对Synchronized的优化，但是这两种锁也不是完全没缺点的，比如竞争比较激烈的时候，不但无法提升效率，反而会降低效率，因为多了一个锁升级的过程\n\n| 锁       | 优点                                                         | 缺点                                             | 适用场景                             |\n| -------- | ------------------------------------------------------------ | ------------------------------------------------ | ------------------------------------ |\n| 偏向锁   | 加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。 | 如果线程间存在锁竞争，会带来额外的锁撤销的消耗。 | 适用于只有一个线程访问同步块场景。   |\n| 轻量级锁 | 竞争的线程不会阻塞，提高了程序的响应速度。                   | 如果始终得不到锁竞争的线程使用自旋会消耗CPU。    | 追求响应时间。同步块执行速度非常快。 |\n| 重量级锁 | 线程竞争不使用自旋，不会消耗CPU。                            | 线程阻塞，响应时间缓慢。                         | 追求吞吐量。同步块执行速度较长。     |\n\n### 锁消除\n\n消除锁是虚拟机另外一种锁的优化，这种优化更彻底，Java虚拟机在JIT编译时(可以简单理解为当某段代码即将第一次被执行时进行编译，又称即时编译)，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间，如下StringBuffer的append是一个同步方法，但是在add方法中的StringBuffer属于一个局部变量，并且不会被其他线程所使用，因此StringBuffer不可能存在共享资源竞争的情景，JVM会自动将其锁消除。\n","slug":"synchronized","published":1,"updated":"2018-03-15T06:41:11.291Z","_id":"cjehtoy8e0000dskcy7b2r8bt","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>并发编程几乎是每个程序员都必须要掌握的技能，但是也是比较难理解和熟练掌握，使用过程中也很容易出现问题；本文将从java Synchronized的关键字入手，着重讲解其应用方式和实现原理。</p>\n<a id=\"more\"></a>\n<h1 id=\"为什么需要它\"><a href=\"#为什么需要它\" class=\"headerlink\" title=\"为什么需要它\"></a>为什么需要它</h1><h2 id=\"共享性\"><a href=\"#共享性\" class=\"headerlink\" title=\"共享性\"></a>共享性</h2><p>数据共享性是线程安全的主要原因之一。如果所有的数据只是在线程内有效，那就不存在线程安全性问题，这也是我们在编程的时候经常不需要考虑线程安全的主要原因之一。但是，在多线程编程中，数据共享是不可避免的。对共享变量操作，在多线程环境下很容易出现各种意想不到的的结果。</p>\n<h2 id=\"互斥性\"><a href=\"#互斥性\" class=\"headerlink\" title=\"互斥性\"></a>互斥性</h2><p>资源互斥是指同时只允许一个访问者对其进行访问，具有唯一性和排它性。我们通常允许多个线程同时对数据进行读操作，但同一时间内只允许一个线程对数据进行写操作。</p>\n<h2 id=\"可见性\"><a href=\"#可见性\" class=\"headerlink\" title=\"可见性\"></a>可见性</h2><p>要理解可见性，需要先对JVM的内存模型有一定的了解,如下图:</p>\n<p>图中每个线程都有一个自己的工作内存，对于共享变量，线程每次读取的是工作内存中共享变量的副本，写入的时候也直接修改工作内存中副本的值，然后在某个时间点上再将工作内存与主内存中的值进行同步。这样导致的问题是，如果线程1对某个变量进行了修改，线程2却有可能看不到线程1对共享变量所做的修改。</p>\n<p><img src=\"/images/synchronized/thread.png\" alt=\"线程内存共享图\"></p>\n<h2 id=\"重排序\"><a href=\"#重排序\" class=\"headerlink\" title=\"重排序\"></a>重排序</h2><p>为了提高性能，编译器和处理器可能会对指令做重排序。重排序可以分为以下几种：</p>\n<ol>\n<li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li>\n<li>指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>\n<li>内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li>\n</ol>\n<h1 id=\"应用方式\"><a href=\"#应用方式\" class=\"headerlink\" title=\"应用方式\"></a>应用方式</h1><p>synchronized关键字最主要有以下3种应用方式:</p>\n<ul>\n<li>修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁。<em>注意</em>：一个对象只有一把锁，当一个线程获取了该对象的锁之后，其他线程无法获取该对象的锁，所以无法访问该对象的其他synchronized实例方法</li>\n<li>修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁。</li>\n<li>修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</li>\n</ul>\n<h1 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h1><p>先从下面一段代码来看看Synchronized是如何实现对代码块同步的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.paddx.test.concurrent;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"Method...\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后我们反编译下面的代码来看看</p>\n<p><img src=\"/images/synchronized/syn_class.png\" alt=\"反编译代码\"></p>\n<p>红框的两条指令是关键：</p>\n<p><code>monitorenter</code> ：每个对象有一个监视器锁<code>monitor</code>。当<code>monitor</code>被占用时就会处于锁定状态，线程执行<code>monitorenter</code>指令时尝试获取<code>monitor</code>的所有权，过程如下：</p>\n<p>​    1. 如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。</p>\n<p>​    2. 如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1.</p>\n<p>​    3. 如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。</p>\n<p><code>monitorexit</code>：执行<code>monitorexit</code>的线程必须是<code>objectref</code>所对应的<code>monitor</code>的所有者。</p>\n<p>​    指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是</p>\n<p>​    这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权.</p>\n<p>​    从上图字节码中也可以看出多了一个monitorexit指令，它是异常结束时被执行的释放monitor 的指令。</p>\n<h1 id=\"JDK-实现机制\"><a href=\"#JDK-实现机制\" class=\"headerlink\" title=\"JDK 实现机制\"></a>JDK 实现机制</h1><p>首先需要了解对象内存的布局：</p>\n<ol>\n<li>对象头：标记字（32位虚拟机4B，64位虚拟机8B） + 类型指针（32位虚拟机4B，64位虚拟机8B）+ [数组长（对于数据对象才需要此部分信息）]</li>\n<li>实例数据</li>\n<li>对齐填充：对于64位虚拟机来说，对象大小必须是8B的整数倍，不够的话需要占位填充</li>\n</ol>\n<p><img src=\"/images/synchronized/object.png\" alt=\"反编译代码\"></p>\n<p><strong>Mark Word</strong> 用于存储对象自身的运行时数据，它是实现轻量级锁和偏向锁的关键，所以下面将重点阐述。，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程<br>ID、偏向时间戳等等。Java对象头一般占有两个机器码（在32位虚拟机中，1个机器码等于4字节，也就是32bit），但是如果对象是数组类型，则需要三个机器码，因为JVM虚拟机可以通过Java对象的元数据信息确定Java对象的大小，但是无法从数组的元数据来确认数组的大小，所以用一块来记录数组长度。<br><img src=\"/images/synchronized/lockstatus.png\" alt=\"锁存储状态\"></p>\n<h2 id=\"几种锁类型\"><a href=\"#几种锁类型\" class=\"headerlink\" title=\"几种锁类型\"></a>几种锁类型</h2><p>　锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级）。JDK<br> 1.6中默认是开启偏向锁和轻量级锁的，我们也可以通过-XX:-UseBiasedLocking来禁用偏向锁。</p>\n<h3 id=\"轻量级锁\"><a href=\"#轻量级锁\" class=\"headerlink\" title=\"轻量级锁\"></a>轻量级锁</h3><ol>\n<li>在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝。</li>\n<li>拷贝对象头中的Mark Word复制到锁记录中。</li>\n<li>拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock record里的owner指针指向object mark word。</li>\n<li>如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，即表示此对象处于轻量级锁定状态。</li>\n<li>如果这个更新操作失败了，虚拟机首先会检查对象的Mark<br>Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。否则说明多个线程竞争锁，轻量级锁就要膨胀为重量级锁，锁标志的状态值变为“10”，Mark<br> Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。<br>而当前线程便尝试使用自旋来获取锁，自旋就是为了不让线程阻塞，而采用循环去获取锁的过程。</li>\n</ol>\n<h3 id=\"偏向锁\"><a href=\"#偏向锁\" class=\"headerlink\" title=\"偏向锁\"></a>偏向锁</h3><p>引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗必须小于节省下来的CAS原子指令的性能消耗）。上面说过，轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能。</p>\n<ol>\n<li>访问Mark Word中偏向锁的标识是否设置成1，锁标志位是否为01——确认为可偏向状态。</li>\n<li>如果为可偏向状态，则测试线程ID是否指向当前线程，如果是，进入步骤5，否则进入步骤3。</li>\n<li>如果线程ID并未指向当前线程，则通过CAS操作竞争锁。如果竞争成功，则将Mark Word中线程ID设置为当前线程ID，然后执行步骤5；如果竞争失败，执行步骤4。</li>\n<li>如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点（safepoint）时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。</li>\n<li>执行同步代码。</li>\n</ol>\n<h3 id=\"重量级锁\"><a href=\"#重量级锁\" class=\"headerlink\" title=\"重量级锁\"></a>重量级锁</h3><p>重量级锁通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。</p>\n<p><strong>总结</strong> : JDk中采用轻量级锁和偏向锁等对Synchronized的优化，但是这两种锁也不是完全没缺点的，比如竞争比较激烈的时候，不但无法提升效率，反而会降低效率，因为多了一个锁升级的过程</p>\n<table>\n<thead>\n<tr>\n<th>锁</th>\n<th>优点</th>\n<th>缺点</th>\n<th>适用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>偏向锁</td>\n<td>加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。</td>\n<td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗。</td>\n<td>适用于只有一个线程访问同步块场景。</td>\n</tr>\n<tr>\n<td>轻量级锁</td>\n<td>竞争的线程不会阻塞，提高了程序的响应速度。</td>\n<td>如果始终得不到锁竞争的线程使用自旋会消耗CPU。</td>\n<td>追求响应时间。同步块执行速度非常快。</td>\n</tr>\n<tr>\n<td>重量级锁</td>\n<td>线程竞争不使用自旋，不会消耗CPU。</td>\n<td>线程阻塞，响应时间缓慢。</td>\n<td>追求吞吐量。同步块执行速度较长。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"锁消除\"><a href=\"#锁消除\" class=\"headerlink\" title=\"锁消除\"></a>锁消除</h3><p>消除锁是虚拟机另外一种锁的优化，这种优化更彻底，Java虚拟机在JIT编译时(可以简单理解为当某段代码即将第一次被执行时进行编译，又称即时编译)，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间，如下StringBuffer的append是一个同步方法，但是在add方法中的StringBuffer属于一个局部变量，并且不会被其他线程所使用，因此StringBuffer不可能存在共享资源竞争的情景，JVM会自动将其锁消除。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>并发编程几乎是每个程序员都必须要掌握的技能，但是也是比较难理解和熟练掌握，使用过程中也很容易出现问题；本文将从java Synchronized的关键字入手，着重讲解其应用方式和实现原理。</p>","more":"<h1 id=\"为什么需要它\"><a href=\"#为什么需要它\" class=\"headerlink\" title=\"为什么需要它\"></a>为什么需要它</h1><h2 id=\"共享性\"><a href=\"#共享性\" class=\"headerlink\" title=\"共享性\"></a>共享性</h2><p>数据共享性是线程安全的主要原因之一。如果所有的数据只是在线程内有效，那就不存在线程安全性问题，这也是我们在编程的时候经常不需要考虑线程安全的主要原因之一。但是，在多线程编程中，数据共享是不可避免的。对共享变量操作，在多线程环境下很容易出现各种意想不到的的结果。</p>\n<h2 id=\"互斥性\"><a href=\"#互斥性\" class=\"headerlink\" title=\"互斥性\"></a>互斥性</h2><p>资源互斥是指同时只允许一个访问者对其进行访问，具有唯一性和排它性。我们通常允许多个线程同时对数据进行读操作，但同一时间内只允许一个线程对数据进行写操作。</p>\n<h2 id=\"可见性\"><a href=\"#可见性\" class=\"headerlink\" title=\"可见性\"></a>可见性</h2><p>要理解可见性，需要先对JVM的内存模型有一定的了解,如下图:</p>\n<p>图中每个线程都有一个自己的工作内存，对于共享变量，线程每次读取的是工作内存中共享变量的副本，写入的时候也直接修改工作内存中副本的值，然后在某个时间点上再将工作内存与主内存中的值进行同步。这样导致的问题是，如果线程1对某个变量进行了修改，线程2却有可能看不到线程1对共享变量所做的修改。</p>\n<p><img src=\"/images/synchronized/thread.png\" alt=\"线程内存共享图\"></p>\n<h2 id=\"重排序\"><a href=\"#重排序\" class=\"headerlink\" title=\"重排序\"></a>重排序</h2><p>为了提高性能，编译器和处理器可能会对指令做重排序。重排序可以分为以下几种：</p>\n<ol>\n<li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li>\n<li>指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>\n<li>内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li>\n</ol>\n<h1 id=\"应用方式\"><a href=\"#应用方式\" class=\"headerlink\" title=\"应用方式\"></a>应用方式</h1><p>synchronized关键字最主要有以下3种应用方式:</p>\n<ul>\n<li>修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁。<em>注意</em>：一个对象只有一把锁，当一个线程获取了该对象的锁之后，其他线程无法获取该对象的锁，所以无法访问该对象的其他synchronized实例方法</li>\n<li>修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁。</li>\n<li>修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</li>\n</ul>\n<h1 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h1><p>先从下面一段代码来看看Synchronized是如何实现对代码块同步的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.paddx.test.concurrent;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"Method...\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后我们反编译下面的代码来看看</p>\n<p><img src=\"/images/synchronized/syn_class.png\" alt=\"反编译代码\"></p>\n<p>红框的两条指令是关键：</p>\n<p><code>monitorenter</code> ：每个对象有一个监视器锁<code>monitor</code>。当<code>monitor</code>被占用时就会处于锁定状态，线程执行<code>monitorenter</code>指令时尝试获取<code>monitor</code>的所有权，过程如下：</p>\n<p>​    1. 如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。</p>\n<p>​    2. 如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1.</p>\n<p>​    3. 如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。</p>\n<p><code>monitorexit</code>：执行<code>monitorexit</code>的线程必须是<code>objectref</code>所对应的<code>monitor</code>的所有者。</p>\n<p>​    指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是</p>\n<p>​    这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权.</p>\n<p>​    从上图字节码中也可以看出多了一个monitorexit指令，它是异常结束时被执行的释放monitor 的指令。</p>\n<h1 id=\"JDK-实现机制\"><a href=\"#JDK-实现机制\" class=\"headerlink\" title=\"JDK 实现机制\"></a>JDK 实现机制</h1><p>首先需要了解对象内存的布局：</p>\n<ol>\n<li>对象头：标记字（32位虚拟机4B，64位虚拟机8B） + 类型指针（32位虚拟机4B，64位虚拟机8B）+ [数组长（对于数据对象才需要此部分信息）]</li>\n<li>实例数据</li>\n<li>对齐填充：对于64位虚拟机来说，对象大小必须是8B的整数倍，不够的话需要占位填充</li>\n</ol>\n<p><img src=\"/images/synchronized/object.png\" alt=\"反编译代码\"></p>\n<p><strong>Mark Word</strong> 用于存储对象自身的运行时数据，它是实现轻量级锁和偏向锁的关键，所以下面将重点阐述。，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程<br>ID、偏向时间戳等等。Java对象头一般占有两个机器码（在32位虚拟机中，1个机器码等于4字节，也就是32bit），但是如果对象是数组类型，则需要三个机器码，因为JVM虚拟机可以通过Java对象的元数据信息确定Java对象的大小，但是无法从数组的元数据来确认数组的大小，所以用一块来记录数组长度。<br><img src=\"/images/synchronized/lockstatus.png\" alt=\"锁存储状态\"></p>\n<h2 id=\"几种锁类型\"><a href=\"#几种锁类型\" class=\"headerlink\" title=\"几种锁类型\"></a>几种锁类型</h2><p>　锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级）。JDK<br> 1.6中默认是开启偏向锁和轻量级锁的，我们也可以通过-XX:-UseBiasedLocking来禁用偏向锁。</p>\n<h3 id=\"轻量级锁\"><a href=\"#轻量级锁\" class=\"headerlink\" title=\"轻量级锁\"></a>轻量级锁</h3><ol>\n<li>在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝。</li>\n<li>拷贝对象头中的Mark Word复制到锁记录中。</li>\n<li>拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock record里的owner指针指向object mark word。</li>\n<li>如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，即表示此对象处于轻量级锁定状态。</li>\n<li>如果这个更新操作失败了，虚拟机首先会检查对象的Mark<br>Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。否则说明多个线程竞争锁，轻量级锁就要膨胀为重量级锁，锁标志的状态值变为“10”，Mark<br> Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。<br>而当前线程便尝试使用自旋来获取锁，自旋就是为了不让线程阻塞，而采用循环去获取锁的过程。</li>\n</ol>\n<h3 id=\"偏向锁\"><a href=\"#偏向锁\" class=\"headerlink\" title=\"偏向锁\"></a>偏向锁</h3><p>引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗必须小于节省下来的CAS原子指令的性能消耗）。上面说过，轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能。</p>\n<ol>\n<li>访问Mark Word中偏向锁的标识是否设置成1，锁标志位是否为01——确认为可偏向状态。</li>\n<li>如果为可偏向状态，则测试线程ID是否指向当前线程，如果是，进入步骤5，否则进入步骤3。</li>\n<li>如果线程ID并未指向当前线程，则通过CAS操作竞争锁。如果竞争成功，则将Mark Word中线程ID设置为当前线程ID，然后执行步骤5；如果竞争失败，执行步骤4。</li>\n<li>如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点（safepoint）时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。</li>\n<li>执行同步代码。</li>\n</ol>\n<h3 id=\"重量级锁\"><a href=\"#重量级锁\" class=\"headerlink\" title=\"重量级锁\"></a>重量级锁</h3><p>重量级锁通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。</p>\n<p><strong>总结</strong> : JDk中采用轻量级锁和偏向锁等对Synchronized的优化，但是这两种锁也不是完全没缺点的，比如竞争比较激烈的时候，不但无法提升效率，反而会降低效率，因为多了一个锁升级的过程</p>\n<table>\n<thead>\n<tr>\n<th>锁</th>\n<th>优点</th>\n<th>缺点</th>\n<th>适用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>偏向锁</td>\n<td>加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。</td>\n<td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗。</td>\n<td>适用于只有一个线程访问同步块场景。</td>\n</tr>\n<tr>\n<td>轻量级锁</td>\n<td>竞争的线程不会阻塞，提高了程序的响应速度。</td>\n<td>如果始终得不到锁竞争的线程使用自旋会消耗CPU。</td>\n<td>追求响应时间。同步块执行速度非常快。</td>\n</tr>\n<tr>\n<td>重量级锁</td>\n<td>线程竞争不使用自旋，不会消耗CPU。</td>\n<td>线程阻塞，响应时间缓慢。</td>\n<td>追求吞吐量。同步块执行速度较长。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"锁消除\"><a href=\"#锁消除\" class=\"headerlink\" title=\"锁消除\"></a>锁消除</h3><p>消除锁是虚拟机另外一种锁的优化，这种优化更彻底，Java虚拟机在JIT编译时(可以简单理解为当某段代码即将第一次被执行时进行编译，又称即时编译)，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间，如下StringBuffer的append是一个同步方法，但是在add方法中的StringBuffer属于一个局部变量，并且不会被其他线程所使用，因此StringBuffer不可能存在共享资源竞争的情景，JVM会自动将其锁消除。</p>"},{"title":"Docker学习","author":"James","date":"2017-03-20T08:10:00.000Z","_content":"# Docker是什么\nDocker 是 Docker 公司的开源项目，使用 Google 公司推出的 Go 语言开发的,并于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 GitHub 上进行维护。\n\nDocker是一个虚拟环境容器，可以将你的开发环境、代码、配置文件等一并打包到这个容器中，并发布和应用到任意平台中。比如，你在本地用Python开发网站后台，开发测试完成后，就可以将Python3及其依赖包、Flask及其各种插件、Mysql、Nginx等打包到一个容器中，然后部署到任意你想部署到的环境。\n\n<!-- more -->\n\n![HashMap_base](/images/docker/docker_struct.png)\n\n# 为什么使用 Docker\n\nDocker 跟传统的虚拟化方式相比具有以下优势:\n\n## 更高效的利用系统资源\n\n由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。\n\n## 更快速的启动时间\n\n传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。\n\n## 一致的运行环境\n\n开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 “这段代码在我机器上没问题啊” 这类问题。\n\n## 持续交付和部署\n\n对开发和运维人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。\n\n使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 Dockerfile 来进行镜像构建，并结合 持续集成系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合持续部署系统进行自动部署。\n\n而且使用 Dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。\n\n## 更轻松的迁移\n\n由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。\n\n## 更轻松的维护和扩展\n\nDocker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。\n\n# 三个重要概念\n\n1. **镜像（Image）**：类似于虚拟机中的镜像，是一个包含有文件系统的面向Docker引擎的只读模板。任何应用程序运行都需要环境，而镜像就是用来提供这种运行环境的。例如一个Ubuntu镜像就是一个包含Ubuntu操作系统环境的模板，同理在该镜像上装上Apache软件，就可以称为Apache镜像。\n2. **容器（Container）**：类似于一个轻量级的沙盒，可以将其看作一个极简的Linux系统环境（包括root权限、进程空间、用户空间和网络空间等），以及运行在其中的应用程序。Docker引擎利用容器来运行、隔离各个应用。容器是镜像创建的应用实例，可以创建、启动、停止、删除容器，各个容器之间是是相互隔离的，互不影响。注意：镜像本身是只读的，容器从镜像启动时，Docker在镜像的上层创建一个可写层，镜像本身不变。\n3. **仓库（Repository）**：类似于代码仓库，这里是镜像仓库，是Docker用来集中存放镜像文件的地方。注意与注册服务器（Registry）的区别：注册服务器是存放仓库的地方，一般会有多个仓库；而仓库是存放镜像的地方，一般每个仓库存放一类镜像，每个镜像利用tag进行区分，比如Ubuntu仓库存放有多个版本（12.04、14.04等）的Ubuntu镜像。\n\n\n## 安装\n\nDocker可以安装在Windows、Linux、Mac等各个平台上。具体可以查看文档[Install Docker](https%3A//docs.docker.com/engine/installation/)。安装完成之后，可以查看Docker的版本信息：\n\n```bash\n[root@xxx ~]# docker  version\nClient:\n Version:       18.02.0-ce\n API version:   1.35 (downgraded from 1.36)\n Go version:    go1.9.4\n Git commit:    fc4de447b5\n Built: Mon Feb 12 19:03:38 2018\n OS/Arch:       windows/amd64\n Experimental:  false\n Orchestrator:  swarm\n\nServer:\n Engine:\n  Version:      17.12.1-ce\n  API version:  1.35 (minimum version 1.12)\n  Go version:   go1.9.4\n  Git commit:   7390fc6\n  Built:        Tue Feb 27 22:20:43 2018\n  OS/Arch:      linux/amd64\n  Experimental: false\n```\n\n## 镜像\n\n安装完Docker引擎之后，就可以对镜像进行基本的操作了。\n\n我们从官方注册服务器（[https://hub.docker.com](https://link.zhihu.com/?target=https%3A//hub.docker.com)）的仓库中pull下CentOS的镜像，前边说过，每个仓库会有多个镜像，用tag标示，如果不加tag，默认使用latest镜像：\n\n```bash\n[root@xxx ~]# docker search centos    # 查看centos镜像是否存在\n[root@xxx ~]# docker pull centos    # 利用pull命令获取镜像\nUsing default tag: latest\nlatest: Pulling from library/centos\n08d48e6f1cff: Pull complete\nDigest: sha256:b2f9d1c0ff5f87a4743104d099a3d561002ac500db1b9bfa02a783a46e0d366c\nStatus: Downloaded newer image for centos:latest\n\n[root@xxx ~]# docker images    # 查看当前系统中的images信息\nREPOSITORY      TAG            IMAGE ID       CREATED        SIZE\ncentos          latest         0584b3d2cf6d   9 days ago     196.5 MB\n```\n\n### 创建自定义镜像\n\n#### commit的方式\n\n1.启动一个容器后进行修改 ==> 利用commit提交更新后的副本\n\n```bash\n[root@xxx ~]# docker run -it centos:latest /bin/bash    # 启动一个容器\n[root@72f1a8a0e394 /]#    # 这里命令行形式变了，表示已经进入了一个新环境\n[root@72f1a8a0e394 /]# git --version    # 此时的容器中没有git\nbash: git: command not found\n[root@72f1a8a0e394 /]# yum install git    # 利用yum安装git\n......\n[root@72f1a8a0e394 /]# git --version   # 此时的容器中已经装有git了\ngit version 1.8.3.1\n```\n\n2.退出该容器，然后查看docker中运行的容器：\n\n```bash\n[root@xxx ~]# docker ps -a\nCONTAINER ID  IMAGE    COMMAND      CREATED   STATUS   PORTS    NAMES\n72f1a8a0e394  centos:latest \"/bin/bash\"  9 minutes ago   Exited (0) 3 minutes ago  \n```\n\n3.将容器转化为一个镜像，即执行commit操作(不推荐)\n\n```bash\n[root@xxx ~]# docker commit -m \"centos with git\" -a \"james\" 72f1a8a0e394 xianhu/centos:git\n\n[root@xxx ~]# docker images\nREPOSITORY       TAG    IMAGE ID         CREATED             SIZE\njames/centos    git    52166e4475ed     5 seconds ago       358.1 MB\ncentos           latest 0584b3d2cf6d     9 days ago          196.5 MB\n```\n\n`-m`指定说明信息；`-a`指定用户信息；72f1a8a0e394代表容器的id；james/centos:git指定目标镜像的用户名、仓库名和 tag 信息。\n\n4.此时Docker引擎中就有了我们新建的镜像james/centos:git，此镜像和原有的CentOS镜像区别在于多了个Git工具。此时我们利用新镜像创建的容器，本身就自带git了。\n\n```bash\n[root@xxx ~]# docker run -it james/centos:git /bin/bash\n[root@520afc596c51 /]# git --version\ngit version 1.8.3.1\n```\n\n#### Dockerfile方式\n\nDockerfile可以理解为一种配置文件，用来告诉docker build命令应该执行哪些操作。一个简易的Dockerfile文件如下所示，官方说明：[Dockerfile reference](https%3A//docs.docker.com/engine/reference/builder/)：\n\n```ini\n# 说明该镜像以哪个镜像为基础\nFROM centos:latest\n\n# 构建者的基本信息\nMAINTAINER james\n\n# 在build这个镜像时执行的操作\nRUN yum update\nRUN yum install -y git\n\n# 拷贝本地文件到镜像中\nCOPY ./* /usr/share/gitdir/\n```\n\n用build命令构建镜像了：\n\n```bash\n$ docker build -t nginx:v3 .\ndocker build [选项] <上下文路径/URL/->\n```\n\n## 容器\n\n镜像和容器的关系，就像是面向对象程序设计中的`类`和`实例`一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。\n\n每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为**容器存储层**。\n\n容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。\n\n按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 [数据卷（Volume）](https://docs.docker.com/engine/tutorials/dockervolumes/)、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主(或网络存储)发生读写，其性能和稳定性更高。\n\n数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器可以随意删除、重新 `run`，数据却不会丢失。\n\n### 启动\n\n启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（stopped）的容器重新启动。\n\n命令主要为 `docker run`。\n\n### 查看\n\n利用 `docker ps -a` 命令可以查看所有容器   \n\n### 终止\n\n可以使用 `docker stop` 命令和上面使用的 `docker ps -a` 查看到的 `CONTAINER ID`或 `NAMES`，来终止一个运行中的容器。\n\n### 删除\n\n可以使用 `docker rm` 来删除一个处于终止状态的容器。\n\n## 仓库\n\n仓库（`Repository`）是集中存放镜像的地方，镜像构建完成后，可以很容易的在当前宿主上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，[Docker Registry](https://docs.docker.com/registry/) 就是这样的服务。\n\n一个容易混淆的概念是注册服务器（`Registry`）。实际上注册服务器是管理仓库的具体服务器，每个服务器上可以有多个仓库，而每个仓库下面有多个镜像。从这方面来说，仓库可以被认为是一个具体的项目或目录。例如对于仓库地址 `dl.dockerpool.com/ubuntu` 来说，`dl.dockerpool.com` 是注册服务器地址，`ubuntu` 是仓库名。","source":"_posts/Docker.md","raw":"title: Docker学习\nauthor: James\ntags:\n  - docker\ncategories:\n  - 实战\ndate: 2017-03-20 16:10:00\n---\n# Docker是什么\nDocker 是 Docker 公司的开源项目，使用 Google 公司推出的 Go 语言开发的,并于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 GitHub 上进行维护。\n\nDocker是一个虚拟环境容器，可以将你的开发环境、代码、配置文件等一并打包到这个容器中，并发布和应用到任意平台中。比如，你在本地用Python开发网站后台，开发测试完成后，就可以将Python3及其依赖包、Flask及其各种插件、Mysql、Nginx等打包到一个容器中，然后部署到任意你想部署到的环境。\n\n<!-- more -->\n\n![HashMap_base](/images/docker/docker_struct.png)\n\n# 为什么使用 Docker\n\nDocker 跟传统的虚拟化方式相比具有以下优势:\n\n## 更高效的利用系统资源\n\n由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。\n\n## 更快速的启动时间\n\n传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。\n\n## 一致的运行环境\n\n开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 “这段代码在我机器上没问题啊” 这类问题。\n\n## 持续交付和部署\n\n对开发和运维人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。\n\n使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 Dockerfile 来进行镜像构建，并结合 持续集成系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合持续部署系统进行自动部署。\n\n而且使用 Dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。\n\n## 更轻松的迁移\n\n由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。\n\n## 更轻松的维护和扩展\n\nDocker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。\n\n# 三个重要概念\n\n1. **镜像（Image）**：类似于虚拟机中的镜像，是一个包含有文件系统的面向Docker引擎的只读模板。任何应用程序运行都需要环境，而镜像就是用来提供这种运行环境的。例如一个Ubuntu镜像就是一个包含Ubuntu操作系统环境的模板，同理在该镜像上装上Apache软件，就可以称为Apache镜像。\n2. **容器（Container）**：类似于一个轻量级的沙盒，可以将其看作一个极简的Linux系统环境（包括root权限、进程空间、用户空间和网络空间等），以及运行在其中的应用程序。Docker引擎利用容器来运行、隔离各个应用。容器是镜像创建的应用实例，可以创建、启动、停止、删除容器，各个容器之间是是相互隔离的，互不影响。注意：镜像本身是只读的，容器从镜像启动时，Docker在镜像的上层创建一个可写层，镜像本身不变。\n3. **仓库（Repository）**：类似于代码仓库，这里是镜像仓库，是Docker用来集中存放镜像文件的地方。注意与注册服务器（Registry）的区别：注册服务器是存放仓库的地方，一般会有多个仓库；而仓库是存放镜像的地方，一般每个仓库存放一类镜像，每个镜像利用tag进行区分，比如Ubuntu仓库存放有多个版本（12.04、14.04等）的Ubuntu镜像。\n\n\n## 安装\n\nDocker可以安装在Windows、Linux、Mac等各个平台上。具体可以查看文档[Install Docker](https%3A//docs.docker.com/engine/installation/)。安装完成之后，可以查看Docker的版本信息：\n\n```bash\n[root@xxx ~]# docker  version\nClient:\n Version:       18.02.0-ce\n API version:   1.35 (downgraded from 1.36)\n Go version:    go1.9.4\n Git commit:    fc4de447b5\n Built: Mon Feb 12 19:03:38 2018\n OS/Arch:       windows/amd64\n Experimental:  false\n Orchestrator:  swarm\n\nServer:\n Engine:\n  Version:      17.12.1-ce\n  API version:  1.35 (minimum version 1.12)\n  Go version:   go1.9.4\n  Git commit:   7390fc6\n  Built:        Tue Feb 27 22:20:43 2018\n  OS/Arch:      linux/amd64\n  Experimental: false\n```\n\n## 镜像\n\n安装完Docker引擎之后，就可以对镜像进行基本的操作了。\n\n我们从官方注册服务器（[https://hub.docker.com](https://link.zhihu.com/?target=https%3A//hub.docker.com)）的仓库中pull下CentOS的镜像，前边说过，每个仓库会有多个镜像，用tag标示，如果不加tag，默认使用latest镜像：\n\n```bash\n[root@xxx ~]# docker search centos    # 查看centos镜像是否存在\n[root@xxx ~]# docker pull centos    # 利用pull命令获取镜像\nUsing default tag: latest\nlatest: Pulling from library/centos\n08d48e6f1cff: Pull complete\nDigest: sha256:b2f9d1c0ff5f87a4743104d099a3d561002ac500db1b9bfa02a783a46e0d366c\nStatus: Downloaded newer image for centos:latest\n\n[root@xxx ~]# docker images    # 查看当前系统中的images信息\nREPOSITORY      TAG            IMAGE ID       CREATED        SIZE\ncentos          latest         0584b3d2cf6d   9 days ago     196.5 MB\n```\n\n### 创建自定义镜像\n\n#### commit的方式\n\n1.启动一个容器后进行修改 ==> 利用commit提交更新后的副本\n\n```bash\n[root@xxx ~]# docker run -it centos:latest /bin/bash    # 启动一个容器\n[root@72f1a8a0e394 /]#    # 这里命令行形式变了，表示已经进入了一个新环境\n[root@72f1a8a0e394 /]# git --version    # 此时的容器中没有git\nbash: git: command not found\n[root@72f1a8a0e394 /]# yum install git    # 利用yum安装git\n......\n[root@72f1a8a0e394 /]# git --version   # 此时的容器中已经装有git了\ngit version 1.8.3.1\n```\n\n2.退出该容器，然后查看docker中运行的容器：\n\n```bash\n[root@xxx ~]# docker ps -a\nCONTAINER ID  IMAGE    COMMAND      CREATED   STATUS   PORTS    NAMES\n72f1a8a0e394  centos:latest \"/bin/bash\"  9 minutes ago   Exited (0) 3 minutes ago  \n```\n\n3.将容器转化为一个镜像，即执行commit操作(不推荐)\n\n```bash\n[root@xxx ~]# docker commit -m \"centos with git\" -a \"james\" 72f1a8a0e394 xianhu/centos:git\n\n[root@xxx ~]# docker images\nREPOSITORY       TAG    IMAGE ID         CREATED             SIZE\njames/centos    git    52166e4475ed     5 seconds ago       358.1 MB\ncentos           latest 0584b3d2cf6d     9 days ago          196.5 MB\n```\n\n`-m`指定说明信息；`-a`指定用户信息；72f1a8a0e394代表容器的id；james/centos:git指定目标镜像的用户名、仓库名和 tag 信息。\n\n4.此时Docker引擎中就有了我们新建的镜像james/centos:git，此镜像和原有的CentOS镜像区别在于多了个Git工具。此时我们利用新镜像创建的容器，本身就自带git了。\n\n```bash\n[root@xxx ~]# docker run -it james/centos:git /bin/bash\n[root@520afc596c51 /]# git --version\ngit version 1.8.3.1\n```\n\n#### Dockerfile方式\n\nDockerfile可以理解为一种配置文件，用来告诉docker build命令应该执行哪些操作。一个简易的Dockerfile文件如下所示，官方说明：[Dockerfile reference](https%3A//docs.docker.com/engine/reference/builder/)：\n\n```ini\n# 说明该镜像以哪个镜像为基础\nFROM centos:latest\n\n# 构建者的基本信息\nMAINTAINER james\n\n# 在build这个镜像时执行的操作\nRUN yum update\nRUN yum install -y git\n\n# 拷贝本地文件到镜像中\nCOPY ./* /usr/share/gitdir/\n```\n\n用build命令构建镜像了：\n\n```bash\n$ docker build -t nginx:v3 .\ndocker build [选项] <上下文路径/URL/->\n```\n\n## 容器\n\n镜像和容器的关系，就像是面向对象程序设计中的`类`和`实例`一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。\n\n每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为**容器存储层**。\n\n容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。\n\n按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 [数据卷（Volume）](https://docs.docker.com/engine/tutorials/dockervolumes/)、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主(或网络存储)发生读写，其性能和稳定性更高。\n\n数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器可以随意删除、重新 `run`，数据却不会丢失。\n\n### 启动\n\n启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（stopped）的容器重新启动。\n\n命令主要为 `docker run`。\n\n### 查看\n\n利用 `docker ps -a` 命令可以查看所有容器   \n\n### 终止\n\n可以使用 `docker stop` 命令和上面使用的 `docker ps -a` 查看到的 `CONTAINER ID`或 `NAMES`，来终止一个运行中的容器。\n\n### 删除\n\n可以使用 `docker rm` 来删除一个处于终止状态的容器。\n\n## 仓库\n\n仓库（`Repository`）是集中存放镜像的地方，镜像构建完成后，可以很容易的在当前宿主上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，[Docker Registry](https://docs.docker.com/registry/) 就是这样的服务。\n\n一个容易混淆的概念是注册服务器（`Registry`）。实际上注册服务器是管理仓库的具体服务器，每个服务器上可以有多个仓库，而每个仓库下面有多个镜像。从这方面来说，仓库可以被认为是一个具体的项目或目录。例如对于仓库地址 `dl.dockerpool.com/ubuntu` 来说，`dl.dockerpool.com` 是注册服务器地址，`ubuntu` 是仓库名。","slug":"Docker","published":1,"updated":"2018-03-22T07:13:16.585Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf26kpq40000mokcup8o4tke","content":"<h1 id=\"Docker是什么\"><a href=\"#Docker是什么\" class=\"headerlink\" title=\"Docker是什么\"></a>Docker是什么</h1><p>Docker 是 Docker 公司的开源项目，使用 Google 公司推出的 Go 语言开发的,并于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 GitHub 上进行维护。</p>\n<p>Docker是一个虚拟环境容器，可以将你的开发环境、代码、配置文件等一并打包到这个容器中，并发布和应用到任意平台中。比如，你在本地用Python开发网站后台，开发测试完成后，就可以将Python3及其依赖包、Flask及其各种插件、Mysql、Nginx等打包到一个容器中，然后部署到任意你想部署到的环境。</p>\n<a id=\"more\"></a>\n<p><img src=\"/images/docker/docker_struct.png\" alt=\"HashMap_base\"></p>\n<h1 id=\"为什么使用-Docker\"><a href=\"#为什么使用-Docker\" class=\"headerlink\" title=\"为什么使用 Docker\"></a>为什么使用 Docker</h1><p>Docker 跟传统的虚拟化方式相比具有以下优势:</p>\n<h2 id=\"更高效的利用系统资源\"><a href=\"#更高效的利用系统资源\" class=\"headerlink\" title=\"更高效的利用系统资源\"></a>更高效的利用系统资源</h2><p>由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。</p>\n<h2 id=\"更快速的启动时间\"><a href=\"#更快速的启动时间\" class=\"headerlink\" title=\"更快速的启动时间\"></a>更快速的启动时间</h2><p>传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。</p>\n<h2 id=\"一致的运行环境\"><a href=\"#一致的运行环境\" class=\"headerlink\" title=\"一致的运行环境\"></a>一致的运行环境</h2><p>开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 “这段代码在我机器上没问题啊” 这类问题。</p>\n<h2 id=\"持续交付和部署\"><a href=\"#持续交付和部署\" class=\"headerlink\" title=\"持续交付和部署\"></a>持续交付和部署</h2><p>对开发和运维人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。</p>\n<p>使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 Dockerfile 来进行镜像构建，并结合 持续集成系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合持续部署系统进行自动部署。</p>\n<p>而且使用 Dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。</p>\n<h2 id=\"更轻松的迁移\"><a href=\"#更轻松的迁移\" class=\"headerlink\" title=\"更轻松的迁移\"></a>更轻松的迁移</h2><p>由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</p>\n<h2 id=\"更轻松的维护和扩展\"><a href=\"#更轻松的维护和扩展\" class=\"headerlink\" title=\"更轻松的维护和扩展\"></a>更轻松的维护和扩展</h2><p>Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。</p>\n<h1 id=\"三个重要概念\"><a href=\"#三个重要概念\" class=\"headerlink\" title=\"三个重要概念\"></a>三个重要概念</h1><ol>\n<li><strong>镜像（Image）</strong>：类似于虚拟机中的镜像，是一个包含有文件系统的面向Docker引擎的只读模板。任何应用程序运行都需要环境，而镜像就是用来提供这种运行环境的。例如一个Ubuntu镜像就是一个包含Ubuntu操作系统环境的模板，同理在该镜像上装上Apache软件，就可以称为Apache镜像。</li>\n<li><strong>容器（Container）</strong>：类似于一个轻量级的沙盒，可以将其看作一个极简的Linux系统环境（包括root权限、进程空间、用户空间和网络空间等），以及运行在其中的应用程序。Docker引擎利用容器来运行、隔离各个应用。容器是镜像创建的应用实例，可以创建、启动、停止、删除容器，各个容器之间是是相互隔离的，互不影响。注意：镜像本身是只读的，容器从镜像启动时，Docker在镜像的上层创建一个可写层，镜像本身不变。</li>\n<li><strong>仓库（Repository）</strong>：类似于代码仓库，这里是镜像仓库，是Docker用来集中存放镜像文件的地方。注意与注册服务器（Registry）的区别：注册服务器是存放仓库的地方，一般会有多个仓库；而仓库是存放镜像的地方，一般每个仓库存放一类镜像，每个镜像利用tag进行区分，比如Ubuntu仓库存放有多个版本（12.04、14.04等）的Ubuntu镜像。</li>\n</ol>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>Docker可以安装在Windows、Linux、Mac等各个平台上。具体可以查看文档<a href=\"https%3A//docs.docker.com/engine/installation/\">Install Docker</a>。安装完成之后，可以查看Docker的版本信息：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@xxx ~]<span class=\"comment\"># docker  version</span></span><br><span class=\"line\">Client:</span><br><span class=\"line\"> Version:       18.02.0-ce</span><br><span class=\"line\"> API version:   1.35 (downgraded from 1.36)</span><br><span class=\"line\"> Go version:    go1.9.4</span><br><span class=\"line\"> Git commit:    fc4de447b5</span><br><span class=\"line\"> Built: Mon Feb 12 19:03:38 2018</span><br><span class=\"line\"> OS/Arch:       windows/amd64</span><br><span class=\"line\"> Experimental:  <span class=\"literal\">false</span></span><br><span class=\"line\"> Orchestrator:  swarm</span><br><span class=\"line\"></span><br><span class=\"line\">Server:</span><br><span class=\"line\"> Engine:</span><br><span class=\"line\">  Version:      17.12.1-ce</span><br><span class=\"line\">  API version:  1.35 (minimum version 1.12)</span><br><span class=\"line\">  Go version:   go1.9.4</span><br><span class=\"line\">  Git commit:   7390fc6</span><br><span class=\"line\">  Built:        Tue Feb 27 22:20:43 2018</span><br><span class=\"line\">  OS/Arch:      linux/amd64</span><br><span class=\"line\">  Experimental: <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"镜像\"><a href=\"#镜像\" class=\"headerlink\" title=\"镜像\"></a>镜像</h2><p>安装完Docker引擎之后，就可以对镜像进行基本的操作了。</p>\n<p>我们从官方注册服务器（<a href=\"https://link.zhihu.com/?target=https%3A//hub.docker.com\" target=\"_blank\" rel=\"noopener\">https://hub.docker.com</a>）的仓库中pull下CentOS的镜像，前边说过，每个仓库会有多个镜像，用tag标示，如果不加tag，默认使用latest镜像：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@xxx ~]<span class=\"comment\"># docker search centos    # 查看centos镜像是否存在</span></span><br><span class=\"line\">[root@xxx ~]<span class=\"comment\"># docker pull centos    # 利用pull命令获取镜像</span></span><br><span class=\"line\">Using default tag: latest</span><br><span class=\"line\">latest: Pulling from library/centos</span><br><span class=\"line\">08d48e6f1cff: Pull complete</span><br><span class=\"line\">Digest: sha256:b2f9d1c0ff5f87a4743104d099a3d561002ac500db1b9bfa02a783a46e0d366c</span><br><span class=\"line\">Status: Downloaded newer image <span class=\"keyword\">for</span> centos:latest</span><br><span class=\"line\"></span><br><span class=\"line\">[root@xxx ~]<span class=\"comment\"># docker images    # 查看当前系统中的images信息</span></span><br><span class=\"line\">REPOSITORY      TAG            IMAGE ID       CREATED        SIZE</span><br><span class=\"line\">centos          latest         0584b3d2cf6d   9 days ago     196.5 MB</span><br></pre></td></tr></table></figure>\n<h3 id=\"创建自定义镜像\"><a href=\"#创建自定义镜像\" class=\"headerlink\" title=\"创建自定义镜像\"></a>创建自定义镜像</h3><h4 id=\"commit的方式\"><a href=\"#commit的方式\" class=\"headerlink\" title=\"commit的方式\"></a>commit的方式</h4><p>1.启动一个容器后进行修改 ==&gt; 利用commit提交更新后的副本</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@xxx ~]<span class=\"comment\"># docker run -it centos:latest /bin/bash    # 启动一个容器</span></span><br><span class=\"line\">[root@72f1a8a0e394 /]<span class=\"comment\">#    # 这里命令行形式变了，表示已经进入了一个新环境</span></span><br><span class=\"line\">[root@72f1a8a0e394 /]<span class=\"comment\"># git --version    # 此时的容器中没有git</span></span><br><span class=\"line\">bash: git: <span class=\"built_in\">command</span> not found</span><br><span class=\"line\">[root@72f1a8a0e394 /]<span class=\"comment\"># yum install git    # 利用yum安装git</span></span><br><span class=\"line\">......</span><br><span class=\"line\">[root@72f1a8a0e394 /]<span class=\"comment\"># git --version   # 此时的容器中已经装有git了</span></span><br><span class=\"line\">git version 1.8.3.1</span><br></pre></td></tr></table></figure>\n<p>2.退出该容器，然后查看docker中运行的容器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@xxx ~]<span class=\"comment\"># docker ps -a</span></span><br><span class=\"line\">CONTAINER ID  IMAGE    COMMAND      CREATED   STATUS   PORTS    NAMES</span><br><span class=\"line\">72f1a8a0e394  centos:latest <span class=\"string\">\"/bin/bash\"</span>  9 minutes ago   Exited (0) 3 minutes ago</span><br></pre></td></tr></table></figure>\n<p>3.将容器转化为一个镜像，即执行commit操作(不推荐)</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@xxx ~]<span class=\"comment\"># docker commit -m \"centos with git\" -a \"james\" 72f1a8a0e394 xianhu/centos:git</span></span><br><span class=\"line\"></span><br><span class=\"line\">[root@xxx ~]<span class=\"comment\"># docker images</span></span><br><span class=\"line\">REPOSITORY       TAG    IMAGE ID         CREATED             SIZE</span><br><span class=\"line\">james/centos    git    52166e4475ed     5 seconds ago       358.1 MB</span><br><span class=\"line\">centos           latest 0584b3d2cf6d     9 days ago          196.5 MB</span><br></pre></td></tr></table></figure>\n<p><code>-m</code>指定说明信息；<code>-a</code>指定用户信息；72f1a8a0e394代表容器的id；james/centos:git指定目标镜像的用户名、仓库名和 tag 信息。</p>\n<p>4.此时Docker引擎中就有了我们新建的镜像james/centos:git，此镜像和原有的CentOS镜像区别在于多了个Git工具。此时我们利用新镜像创建的容器，本身就自带git了。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@xxx ~]<span class=\"comment\"># docker run -it james/centos:git /bin/bash</span></span><br><span class=\"line\">[root@520afc596c51 /]<span class=\"comment\"># git --version</span></span><br><span class=\"line\">git version 1.8.3.1</span><br></pre></td></tr></table></figure>\n<h4 id=\"Dockerfile方式\"><a href=\"#Dockerfile方式\" class=\"headerlink\" title=\"Dockerfile方式\"></a>Dockerfile方式</h4><p>Dockerfile可以理解为一种配置文件，用来告诉docker build命令应该执行哪些操作。一个简易的Dockerfile文件如下所示，官方说明：<a href=\"https%3A//docs.docker.com/engine/reference/builder/\">Dockerfile reference</a>：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 说明该镜像以哪个镜像为基础</span></span><br><span class=\"line\">FROM centos:latest</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 构建者的基本信息</span></span><br><span class=\"line\">MAINTAINER james</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在build这个镜像时执行的操作</span></span><br><span class=\"line\">RUN yum update</span><br><span class=\"line\">RUN yum install -y git</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 拷贝本地文件到镜像中</span></span><br><span class=\"line\">COPY ./* /usr/share/gitdir/</span><br></pre></td></tr></table></figure>\n<p>用build命令构建镜像了：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker build -t nginx:v3 .</span><br><span class=\"line\">docker build [选项] &lt;上下文路径/URL/-&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"容器\"><a href=\"#容器\" class=\"headerlink\" title=\"容器\"></a>容器</h2><p>镜像和容器的关系，就像是面向对象程序设计中的<code>类</code>和<code>实例</code>一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p>\n<p>每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为<strong>容器存储层</strong>。</p>\n<p>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p>\n<p>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 <a href=\"https://docs.docker.com/engine/tutorials/dockervolumes/\" target=\"_blank\" rel=\"noopener\">数据卷（Volume）</a>、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主(或网络存储)发生读写，其性能和稳定性更高。</p>\n<p>数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器可以随意删除、重新 <code>run</code>，数据却不会丢失。</p>\n<h3 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h3><p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（stopped）的容器重新启动。</p>\n<p>命令主要为 <code>docker run</code>。</p>\n<h3 id=\"查看\"><a href=\"#查看\" class=\"headerlink\" title=\"查看\"></a>查看</h3><p>利用 <code>docker ps -a</code> 命令可以查看所有容器   </p>\n<h3 id=\"终止\"><a href=\"#终止\" class=\"headerlink\" title=\"终止\"></a>终止</h3><p>可以使用 <code>docker stop</code> 命令和上面使用的 <code>docker ps -a</code> 查看到的 <code>CONTAINER ID</code>或 <code>NAMES</code>，来终止一个运行中的容器。</p>\n<h3 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h3><p>可以使用 <code>docker rm</code> 来删除一个处于终止状态的容器。</p>\n<h2 id=\"仓库\"><a href=\"#仓库\" class=\"headerlink\" title=\"仓库\"></a>仓库</h2><p>仓库（<code>Repository</code>）是集中存放镜像的地方，镜像构建完成后，可以很容易的在当前宿主上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，<a href=\"https://docs.docker.com/registry/\" target=\"_blank\" rel=\"noopener\">Docker Registry</a> 就是这样的服务。</p>\n<p>一个容易混淆的概念是注册服务器（<code>Registry</code>）。实际上注册服务器是管理仓库的具体服务器，每个服务器上可以有多个仓库，而每个仓库下面有多个镜像。从这方面来说，仓库可以被认为是一个具体的项目或目录。例如对于仓库地址 <code>dl.dockerpool.com/ubuntu</code> 来说，<code>dl.dockerpool.com</code> 是注册服务器地址，<code>ubuntu</code> 是仓库名。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Docker是什么\"><a href=\"#Docker是什么\" class=\"headerlink\" title=\"Docker是什么\"></a>Docker是什么</h1><p>Docker 是 Docker 公司的开源项目，使用 Google 公司推出的 Go 语言开发的,并于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 GitHub 上进行维护。</p>\n<p>Docker是一个虚拟环境容器，可以将你的开发环境、代码、配置文件等一并打包到这个容器中，并发布和应用到任意平台中。比如，你在本地用Python开发网站后台，开发测试完成后，就可以将Python3及其依赖包、Flask及其各种插件、Mysql、Nginx等打包到一个容器中，然后部署到任意你想部署到的环境。</p>","more":"<p><img src=\"/images/docker/docker_struct.png\" alt=\"HashMap_base\"></p>\n<h1 id=\"为什么使用-Docker\"><a href=\"#为什么使用-Docker\" class=\"headerlink\" title=\"为什么使用 Docker\"></a>为什么使用 Docker</h1><p>Docker 跟传统的虚拟化方式相比具有以下优势:</p>\n<h2 id=\"更高效的利用系统资源\"><a href=\"#更高效的利用系统资源\" class=\"headerlink\" title=\"更高效的利用系统资源\"></a>更高效的利用系统资源</h2><p>由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。</p>\n<h2 id=\"更快速的启动时间\"><a href=\"#更快速的启动时间\" class=\"headerlink\" title=\"更快速的启动时间\"></a>更快速的启动时间</h2><p>传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。</p>\n<h2 id=\"一致的运行环境\"><a href=\"#一致的运行环境\" class=\"headerlink\" title=\"一致的运行环境\"></a>一致的运行环境</h2><p>开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 “这段代码在我机器上没问题啊” 这类问题。</p>\n<h2 id=\"持续交付和部署\"><a href=\"#持续交付和部署\" class=\"headerlink\" title=\"持续交付和部署\"></a>持续交付和部署</h2><p>对开发和运维人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。</p>\n<p>使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 Dockerfile 来进行镜像构建，并结合 持续集成系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合持续部署系统进行自动部署。</p>\n<p>而且使用 Dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。</p>\n<h2 id=\"更轻松的迁移\"><a href=\"#更轻松的迁移\" class=\"headerlink\" title=\"更轻松的迁移\"></a>更轻松的迁移</h2><p>由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</p>\n<h2 id=\"更轻松的维护和扩展\"><a href=\"#更轻松的维护和扩展\" class=\"headerlink\" title=\"更轻松的维护和扩展\"></a>更轻松的维护和扩展</h2><p>Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。</p>\n<h1 id=\"三个重要概念\"><a href=\"#三个重要概念\" class=\"headerlink\" title=\"三个重要概念\"></a>三个重要概念</h1><ol>\n<li><strong>镜像（Image）</strong>：类似于虚拟机中的镜像，是一个包含有文件系统的面向Docker引擎的只读模板。任何应用程序运行都需要环境，而镜像就是用来提供这种运行环境的。例如一个Ubuntu镜像就是一个包含Ubuntu操作系统环境的模板，同理在该镜像上装上Apache软件，就可以称为Apache镜像。</li>\n<li><strong>容器（Container）</strong>：类似于一个轻量级的沙盒，可以将其看作一个极简的Linux系统环境（包括root权限、进程空间、用户空间和网络空间等），以及运行在其中的应用程序。Docker引擎利用容器来运行、隔离各个应用。容器是镜像创建的应用实例，可以创建、启动、停止、删除容器，各个容器之间是是相互隔离的，互不影响。注意：镜像本身是只读的，容器从镜像启动时，Docker在镜像的上层创建一个可写层，镜像本身不变。</li>\n<li><strong>仓库（Repository）</strong>：类似于代码仓库，这里是镜像仓库，是Docker用来集中存放镜像文件的地方。注意与注册服务器（Registry）的区别：注册服务器是存放仓库的地方，一般会有多个仓库；而仓库是存放镜像的地方，一般每个仓库存放一类镜像，每个镜像利用tag进行区分，比如Ubuntu仓库存放有多个版本（12.04、14.04等）的Ubuntu镜像。</li>\n</ol>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>Docker可以安装在Windows、Linux、Mac等各个平台上。具体可以查看文档<a href=\"https%3A//docs.docker.com/engine/installation/\">Install Docker</a>。安装完成之后，可以查看Docker的版本信息：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@xxx ~]<span class=\"comment\"># docker  version</span></span><br><span class=\"line\">Client:</span><br><span class=\"line\"> Version:       18.02.0-ce</span><br><span class=\"line\"> API version:   1.35 (downgraded from 1.36)</span><br><span class=\"line\"> Go version:    go1.9.4</span><br><span class=\"line\"> Git commit:    fc4de447b5</span><br><span class=\"line\"> Built: Mon Feb 12 19:03:38 2018</span><br><span class=\"line\"> OS/Arch:       windows/amd64</span><br><span class=\"line\"> Experimental:  <span class=\"literal\">false</span></span><br><span class=\"line\"> Orchestrator:  swarm</span><br><span class=\"line\"></span><br><span class=\"line\">Server:</span><br><span class=\"line\"> Engine:</span><br><span class=\"line\">  Version:      17.12.1-ce</span><br><span class=\"line\">  API version:  1.35 (minimum version 1.12)</span><br><span class=\"line\">  Go version:   go1.9.4</span><br><span class=\"line\">  Git commit:   7390fc6</span><br><span class=\"line\">  Built:        Tue Feb 27 22:20:43 2018</span><br><span class=\"line\">  OS/Arch:      linux/amd64</span><br><span class=\"line\">  Experimental: <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"镜像\"><a href=\"#镜像\" class=\"headerlink\" title=\"镜像\"></a>镜像</h2><p>安装完Docker引擎之后，就可以对镜像进行基本的操作了。</p>\n<p>我们从官方注册服务器（<a href=\"https://link.zhihu.com/?target=https%3A//hub.docker.com\" target=\"_blank\" rel=\"noopener\">https://hub.docker.com</a>）的仓库中pull下CentOS的镜像，前边说过，每个仓库会有多个镜像，用tag标示，如果不加tag，默认使用latest镜像：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@xxx ~]<span class=\"comment\"># docker search centos    # 查看centos镜像是否存在</span></span><br><span class=\"line\">[root@xxx ~]<span class=\"comment\"># docker pull centos    # 利用pull命令获取镜像</span></span><br><span class=\"line\">Using default tag: latest</span><br><span class=\"line\">latest: Pulling from library/centos</span><br><span class=\"line\">08d48e6f1cff: Pull complete</span><br><span class=\"line\">Digest: sha256:b2f9d1c0ff5f87a4743104d099a3d561002ac500db1b9bfa02a783a46e0d366c</span><br><span class=\"line\">Status: Downloaded newer image <span class=\"keyword\">for</span> centos:latest</span><br><span class=\"line\"></span><br><span class=\"line\">[root@xxx ~]<span class=\"comment\"># docker images    # 查看当前系统中的images信息</span></span><br><span class=\"line\">REPOSITORY      TAG            IMAGE ID       CREATED        SIZE</span><br><span class=\"line\">centos          latest         0584b3d2cf6d   9 days ago     196.5 MB</span><br></pre></td></tr></table></figure>\n<h3 id=\"创建自定义镜像\"><a href=\"#创建自定义镜像\" class=\"headerlink\" title=\"创建自定义镜像\"></a>创建自定义镜像</h3><h4 id=\"commit的方式\"><a href=\"#commit的方式\" class=\"headerlink\" title=\"commit的方式\"></a>commit的方式</h4><p>1.启动一个容器后进行修改 ==&gt; 利用commit提交更新后的副本</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@xxx ~]<span class=\"comment\"># docker run -it centos:latest /bin/bash    # 启动一个容器</span></span><br><span class=\"line\">[root@72f1a8a0e394 /]<span class=\"comment\">#    # 这里命令行形式变了，表示已经进入了一个新环境</span></span><br><span class=\"line\">[root@72f1a8a0e394 /]<span class=\"comment\"># git --version    # 此时的容器中没有git</span></span><br><span class=\"line\">bash: git: <span class=\"built_in\">command</span> not found</span><br><span class=\"line\">[root@72f1a8a0e394 /]<span class=\"comment\"># yum install git    # 利用yum安装git</span></span><br><span class=\"line\">......</span><br><span class=\"line\">[root@72f1a8a0e394 /]<span class=\"comment\"># git --version   # 此时的容器中已经装有git了</span></span><br><span class=\"line\">git version 1.8.3.1</span><br></pre></td></tr></table></figure>\n<p>2.退出该容器，然后查看docker中运行的容器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@xxx ~]<span class=\"comment\"># docker ps -a</span></span><br><span class=\"line\">CONTAINER ID  IMAGE    COMMAND      CREATED   STATUS   PORTS    NAMES</span><br><span class=\"line\">72f1a8a0e394  centos:latest <span class=\"string\">\"/bin/bash\"</span>  9 minutes ago   Exited (0) 3 minutes ago</span><br></pre></td></tr></table></figure>\n<p>3.将容器转化为一个镜像，即执行commit操作(不推荐)</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@xxx ~]<span class=\"comment\"># docker commit -m \"centos with git\" -a \"james\" 72f1a8a0e394 xianhu/centos:git</span></span><br><span class=\"line\"></span><br><span class=\"line\">[root@xxx ~]<span class=\"comment\"># docker images</span></span><br><span class=\"line\">REPOSITORY       TAG    IMAGE ID         CREATED             SIZE</span><br><span class=\"line\">james/centos    git    52166e4475ed     5 seconds ago       358.1 MB</span><br><span class=\"line\">centos           latest 0584b3d2cf6d     9 days ago          196.5 MB</span><br></pre></td></tr></table></figure>\n<p><code>-m</code>指定说明信息；<code>-a</code>指定用户信息；72f1a8a0e394代表容器的id；james/centos:git指定目标镜像的用户名、仓库名和 tag 信息。</p>\n<p>4.此时Docker引擎中就有了我们新建的镜像james/centos:git，此镜像和原有的CentOS镜像区别在于多了个Git工具。此时我们利用新镜像创建的容器，本身就自带git了。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@xxx ~]<span class=\"comment\"># docker run -it james/centos:git /bin/bash</span></span><br><span class=\"line\">[root@520afc596c51 /]<span class=\"comment\"># git --version</span></span><br><span class=\"line\">git version 1.8.3.1</span><br></pre></td></tr></table></figure>\n<h4 id=\"Dockerfile方式\"><a href=\"#Dockerfile方式\" class=\"headerlink\" title=\"Dockerfile方式\"></a>Dockerfile方式</h4><p>Dockerfile可以理解为一种配置文件，用来告诉docker build命令应该执行哪些操作。一个简易的Dockerfile文件如下所示，官方说明：<a href=\"https%3A//docs.docker.com/engine/reference/builder/\">Dockerfile reference</a>：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 说明该镜像以哪个镜像为基础</span></span><br><span class=\"line\">FROM centos:latest</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 构建者的基本信息</span></span><br><span class=\"line\">MAINTAINER james</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在build这个镜像时执行的操作</span></span><br><span class=\"line\">RUN yum update</span><br><span class=\"line\">RUN yum install -y git</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 拷贝本地文件到镜像中</span></span><br><span class=\"line\">COPY ./* /usr/share/gitdir/</span><br></pre></td></tr></table></figure>\n<p>用build命令构建镜像了：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker build -t nginx:v3 .</span><br><span class=\"line\">docker build [选项] &lt;上下文路径/URL/-&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"容器\"><a href=\"#容器\" class=\"headerlink\" title=\"容器\"></a>容器</h2><p>镜像和容器的关系，就像是面向对象程序设计中的<code>类</code>和<code>实例</code>一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p>\n<p>每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为<strong>容器存储层</strong>。</p>\n<p>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p>\n<p>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 <a href=\"https://docs.docker.com/engine/tutorials/dockervolumes/\" target=\"_blank\" rel=\"noopener\">数据卷（Volume）</a>、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主(或网络存储)发生读写，其性能和稳定性更高。</p>\n<p>数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器可以随意删除、重新 <code>run</code>，数据却不会丢失。</p>\n<h3 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h3><p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（stopped）的容器重新启动。</p>\n<p>命令主要为 <code>docker run</code>。</p>\n<h3 id=\"查看\"><a href=\"#查看\" class=\"headerlink\" title=\"查看\"></a>查看</h3><p>利用 <code>docker ps -a</code> 命令可以查看所有容器   </p>\n<h3 id=\"终止\"><a href=\"#终止\" class=\"headerlink\" title=\"终止\"></a>终止</h3><p>可以使用 <code>docker stop</code> 命令和上面使用的 <code>docker ps -a</code> 查看到的 <code>CONTAINER ID</code>或 <code>NAMES</code>，来终止一个运行中的容器。</p>\n<h3 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h3><p>可以使用 <code>docker rm</code> 来删除一个处于终止状态的容器。</p>\n<h2 id=\"仓库\"><a href=\"#仓库\" class=\"headerlink\" title=\"仓库\"></a>仓库</h2><p>仓库（<code>Repository</code>）是集中存放镜像的地方，镜像构建完成后，可以很容易的在当前宿主上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，<a href=\"https://docs.docker.com/registry/\" target=\"_blank\" rel=\"noopener\">Docker Registry</a> 就是这样的服务。</p>\n<p>一个容易混淆的概念是注册服务器（<code>Registry</code>）。实际上注册服务器是管理仓库的具体服务器，每个服务器上可以有多个仓库，而每个仓库下面有多个镜像。从这方面来说，仓库可以被认为是一个具体的项目或目录。例如对于仓库地址 <code>dl.dockerpool.com/ubuntu</code> 来说，<code>dl.dockerpool.com</code> 是注册服务器地址，<code>ubuntu</code> 是仓库名。</p>"},{"title":"区块链解谜","author":"James","date":"2017-12-29T03:58:00.000Z","_content":"\n# 什么是区块链\n\n区块链是一个分布式的，去中心化的，点对点的，不可篡改的，共享账本系统。\n\n<!-- more -->\n\n![jvm_struct2](/images/blockchain/blockchain.png)\n\n#  区块链架构\n\n区块链整体架构上划分为网络层、共识层、数据层、智能合约层和应用层。共识层和数据层之间的联系比较密切，需要“通力合作”完成数据的存取。\n\n- 网络层，几乎都是基于P2P的网络，它主要完成节点之间的交互和数据块的传输。\n- 共识层，提供在不可信、分布式环境中的共识协议，通过它保证节点之间的数据一致性。\n- 数据层，提供数据保存的数据结构，它要承担防篡改的任务，所以技术上用了区块链表、Hash、Merkle Tree来实现。\n- 智能合约层，相当于数据访问接口，对区块链上的数据读写都是通过智能合约进行的，任何人的数据读写动作都是被明确定义的。\n- 应用层，各种各样的应用程序。\n\n\n![jvm_struct2](/images/blockchain/arch.png)\n\n\n# 区块链和比特币的关系\n\n每个区块数据由谁来记录或者说打包，是可以设置一个游戏规则的，比如说掷骰子，大家约定谁能连续3次掷出6，那就让他来记这个数据，为了补偿 一下他的劳动投入，奖励给他一些收益， \n比特币正是使用了这样的原理来不断的发行新的比特币出来，奖励给打包的那个人的比特币就是新发行的比特币。\n\n# 挖矿和区块链\n\n作为一个“数据库应用”比特币必须要“做点什么”。于是它就设计了一个小游戏环节——挖矿。游戏设计师中本聪在他大作《比特币：一种点对点式的电子现金系统》详细讲述的设计内幕和游戏方法。\n\n# 区块链的技术组合\n\n## 公开密钥算法\n\n属于计算机密码学里传统的技术，公开密钥算法是一种不对称的加密算法，拥有两个密钥，可以互相加解密，通常其中的一个密钥是公开的称之为公钥，另外一个密钥是保密的称之为私钥\n\n## 哈希算法\n\n也是属于计算机密码学中传统的技术，应用就更广泛了，主要用来对一段数据进行计算，得出一个摘要信息，通俗点说就是给一段数据生成1个身份证号；不同的消息生成的摘要数据是不一样的（某些抗碰撞能力弱的哈希算法可能在这里面会有些问题，但是使用广泛的一些知名的哈希算法，发生碰撞的概率很低），相当于给⼀段数据生成了一个身份证号这么个意思，在区块链系统中，哈希算法的使用很多，例如如区块与区块之间，就是通过区块头的哈希关联起来的，在区块中的每一笔交易事务也都会生成一个哈希值作为交易易数据的ID，通过这些身份证号可以方便的检索或者关联区块，也能方便的指定某一笔交易事务。 \n\n## 网络共识算法\n\n在很久前就有计算机科学家研究过，并且提出过一些模型，如拜占庭容错算法之类，比特币、以太坊这些使用的是一种工作量证明算法，其它的一些区块链系统有使用其他各种衍生的算法，算法的原理都很简单，就是约一个规则，通过共同执行这个规则，让每个分布式的节点数据都保持最终一致；\n\n## 梅克尔数据证明\n\n这是利用哈希算法将一组数据创建为一棵哈希树结构，用于验证数据完整性的一种结构，同时也应用在了轻量级钱包中。不同的区块链系统对梅克尔树的应用不尽相同，比特币中是二叉梅克尔树，比较简单，通过交易事务的哈希值两两配合生成一棵树，以太坊这种就复杂的多了，称之为梅克尔.帕特里夏树，这里暂时不赘述。\n\n## 可编程脚本合约\n\n什么叫合约？就是一组约定的规则，例如银行的结算系统，小明转账100给小王，在这个过程中，银系统就会根据一组规则自动执行，规则包含如检测小明的密码是否正确，余额是否足够，小王的账号是否正确，检测通过则分别更改两者的账户余额并写入事务日志。是的，这就是合约的意思了，当然，如果范围再广泛些，各种商业合约也都是这么个意思，因此可编程脚本合约也没什么好稀奇的，如果将这种编程合约放到区块链的环境中，比较有趣了，看两个特点：\n\n第一个，区块链系统是无中新的分布式网络，没有边界\n\n第二个，区块链系统通过一系列的技术实现了可信任网络\n\n加起来，就是无边界的可信任网络，在这样的网络中执行既定的合约，成本低而且安全，比特币在本质上也是属于这种脚本合约，只不过在比特币软件中，合约中处理的事情是比特币的转账","source":"_posts/blockchain.md","raw":"title: 区块链解谜\nauthor: James\ntags:\n  - 区块链\ncategories:\n  - 区块链\ndate: 2017-12-29 11:58:00\n---\n\n# 什么是区块链\n\n区块链是一个分布式的，去中心化的，点对点的，不可篡改的，共享账本系统。\n\n<!-- more -->\n\n![jvm_struct2](/images/blockchain/blockchain.png)\n\n#  区块链架构\n\n区块链整体架构上划分为网络层、共识层、数据层、智能合约层和应用层。共识层和数据层之间的联系比较密切，需要“通力合作”完成数据的存取。\n\n- 网络层，几乎都是基于P2P的网络，它主要完成节点之间的交互和数据块的传输。\n- 共识层，提供在不可信、分布式环境中的共识协议，通过它保证节点之间的数据一致性。\n- 数据层，提供数据保存的数据结构，它要承担防篡改的任务，所以技术上用了区块链表、Hash、Merkle Tree来实现。\n- 智能合约层，相当于数据访问接口，对区块链上的数据读写都是通过智能合约进行的，任何人的数据读写动作都是被明确定义的。\n- 应用层，各种各样的应用程序。\n\n\n![jvm_struct2](/images/blockchain/arch.png)\n\n\n# 区块链和比特币的关系\n\n每个区块数据由谁来记录或者说打包，是可以设置一个游戏规则的，比如说掷骰子，大家约定谁能连续3次掷出6，那就让他来记这个数据，为了补偿 一下他的劳动投入，奖励给他一些收益， \n比特币正是使用了这样的原理来不断的发行新的比特币出来，奖励给打包的那个人的比特币就是新发行的比特币。\n\n# 挖矿和区块链\n\n作为一个“数据库应用”比特币必须要“做点什么”。于是它就设计了一个小游戏环节——挖矿。游戏设计师中本聪在他大作《比特币：一种点对点式的电子现金系统》详细讲述的设计内幕和游戏方法。\n\n# 区块链的技术组合\n\n## 公开密钥算法\n\n属于计算机密码学里传统的技术，公开密钥算法是一种不对称的加密算法，拥有两个密钥，可以互相加解密，通常其中的一个密钥是公开的称之为公钥，另外一个密钥是保密的称之为私钥\n\n## 哈希算法\n\n也是属于计算机密码学中传统的技术，应用就更广泛了，主要用来对一段数据进行计算，得出一个摘要信息，通俗点说就是给一段数据生成1个身份证号；不同的消息生成的摘要数据是不一样的（某些抗碰撞能力弱的哈希算法可能在这里面会有些问题，但是使用广泛的一些知名的哈希算法，发生碰撞的概率很低），相当于给⼀段数据生成了一个身份证号这么个意思，在区块链系统中，哈希算法的使用很多，例如如区块与区块之间，就是通过区块头的哈希关联起来的，在区块中的每一笔交易事务也都会生成一个哈希值作为交易易数据的ID，通过这些身份证号可以方便的检索或者关联区块，也能方便的指定某一笔交易事务。 \n\n## 网络共识算法\n\n在很久前就有计算机科学家研究过，并且提出过一些模型，如拜占庭容错算法之类，比特币、以太坊这些使用的是一种工作量证明算法，其它的一些区块链系统有使用其他各种衍生的算法，算法的原理都很简单，就是约一个规则，通过共同执行这个规则，让每个分布式的节点数据都保持最终一致；\n\n## 梅克尔数据证明\n\n这是利用哈希算法将一组数据创建为一棵哈希树结构，用于验证数据完整性的一种结构，同时也应用在了轻量级钱包中。不同的区块链系统对梅克尔树的应用不尽相同，比特币中是二叉梅克尔树，比较简单，通过交易事务的哈希值两两配合生成一棵树，以太坊这种就复杂的多了，称之为梅克尔.帕特里夏树，这里暂时不赘述。\n\n## 可编程脚本合约\n\n什么叫合约？就是一组约定的规则，例如银行的结算系统，小明转账100给小王，在这个过程中，银系统就会根据一组规则自动执行，规则包含如检测小明的密码是否正确，余额是否足够，小王的账号是否正确，检测通过则分别更改两者的账户余额并写入事务日志。是的，这就是合约的意思了，当然，如果范围再广泛些，各种商业合约也都是这么个意思，因此可编程脚本合约也没什么好稀奇的，如果将这种编程合约放到区块链的环境中，比较有趣了，看两个特点：\n\n第一个，区块链系统是无中新的分布式网络，没有边界\n\n第二个，区块链系统通过一系列的技术实现了可信任网络\n\n加起来，就是无边界的可信任网络，在这样的网络中执行既定的合约，成本低而且安全，比特币在本质上也是属于这种脚本合约，只不过在比特币软件中，合约中处理的事情是比特币的转账","slug":"blockchain","published":1,"updated":"2018-04-04T08:30:35.237Z","_id":"cjfktbq2f0000w0kc4cs6a9ev","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"什么是区块链\"><a href=\"#什么是区块链\" class=\"headerlink\" title=\"什么是区块链\"></a>什么是区块链</h1><p>区块链是一个分布式的，去中心化的，点对点的，不可篡改的，共享账本系统。</p>\n<a id=\"more\"></a>\n<p><img src=\"/images/blockchain/blockchain.png\" alt=\"jvm_struct2\"></p>\n<h1 id=\"区块链架构\"><a href=\"#区块链架构\" class=\"headerlink\" title=\"区块链架构\"></a>区块链架构</h1><p>区块链整体架构上划分为网络层、共识层、数据层、智能合约层和应用层。共识层和数据层之间的联系比较密切，需要“通力合作”完成数据的存取。</p>\n<ul>\n<li>网络层，几乎都是基于P2P的网络，它主要完成节点之间的交互和数据块的传输。</li>\n<li>共识层，提供在不可信、分布式环境中的共识协议，通过它保证节点之间的数据一致性。</li>\n<li>数据层，提供数据保存的数据结构，它要承担防篡改的任务，所以技术上用了区块链表、Hash、Merkle Tree来实现。</li>\n<li>智能合约层，相当于数据访问接口，对区块链上的数据读写都是通过智能合约进行的，任何人的数据读写动作都是被明确定义的。</li>\n<li>应用层，各种各样的应用程序。</li>\n</ul>\n<p><img src=\"/images/blockchain/arch.png\" alt=\"jvm_struct2\"></p>\n<h1 id=\"区块链和比特币的关系\"><a href=\"#区块链和比特币的关系\" class=\"headerlink\" title=\"区块链和比特币的关系\"></a>区块链和比特币的关系</h1><p>每个区块数据由谁来记录或者说打包，是可以设置一个游戏规则的，比如说掷骰子，大家约定谁能连续3次掷出6，那就让他来记这个数据，为了补偿 一下他的劳动投入，奖励给他一些收益，<br>比特币正是使用了这样的原理来不断的发行新的比特币出来，奖励给打包的那个人的比特币就是新发行的比特币。</p>\n<h1 id=\"挖矿和区块链\"><a href=\"#挖矿和区块链\" class=\"headerlink\" title=\"挖矿和区块链\"></a>挖矿和区块链</h1><p>作为一个“数据库应用”比特币必须要“做点什么”。于是它就设计了一个小游戏环节——挖矿。游戏设计师中本聪在他大作《比特币：一种点对点式的电子现金系统》详细讲述的设计内幕和游戏方法。</p>\n<h1 id=\"区块链的技术组合\"><a href=\"#区块链的技术组合\" class=\"headerlink\" title=\"区块链的技术组合\"></a>区块链的技术组合</h1><h2 id=\"公开密钥算法\"><a href=\"#公开密钥算法\" class=\"headerlink\" title=\"公开密钥算法\"></a>公开密钥算法</h2><p>属于计算机密码学里传统的技术，公开密钥算法是一种不对称的加密算法，拥有两个密钥，可以互相加解密，通常其中的一个密钥是公开的称之为公钥，另外一个密钥是保密的称之为私钥</p>\n<h2 id=\"哈希算法\"><a href=\"#哈希算法\" class=\"headerlink\" title=\"哈希算法\"></a>哈希算法</h2><p>也是属于计算机密码学中传统的技术，应用就更广泛了，主要用来对一段数据进行计算，得出一个摘要信息，通俗点说就是给一段数据生成1个身份证号；不同的消息生成的摘要数据是不一样的（某些抗碰撞能力弱的哈希算法可能在这里面会有些问题，但是使用广泛的一些知名的哈希算法，发生碰撞的概率很低），相当于给⼀段数据生成了一个身份证号这么个意思，在区块链系统中，哈希算法的使用很多，例如如区块与区块之间，就是通过区块头的哈希关联起来的，在区块中的每一笔交易事务也都会生成一个哈希值作为交易易数据的ID，通过这些身份证号可以方便的检索或者关联区块，也能方便的指定某一笔交易事务。 </p>\n<h2 id=\"网络共识算法\"><a href=\"#网络共识算法\" class=\"headerlink\" title=\"网络共识算法\"></a>网络共识算法</h2><p>在很久前就有计算机科学家研究过，并且提出过一些模型，如拜占庭容错算法之类，比特币、以太坊这些使用的是一种工作量证明算法，其它的一些区块链系统有使用其他各种衍生的算法，算法的原理都很简单，就是约一个规则，通过共同执行这个规则，让每个分布式的节点数据都保持最终一致；</p>\n<h2 id=\"梅克尔数据证明\"><a href=\"#梅克尔数据证明\" class=\"headerlink\" title=\"梅克尔数据证明\"></a>梅克尔数据证明</h2><p>这是利用哈希算法将一组数据创建为一棵哈希树结构，用于验证数据完整性的一种结构，同时也应用在了轻量级钱包中。不同的区块链系统对梅克尔树的应用不尽相同，比特币中是二叉梅克尔树，比较简单，通过交易事务的哈希值两两配合生成一棵树，以太坊这种就复杂的多了，称之为梅克尔.帕特里夏树，这里暂时不赘述。</p>\n<h2 id=\"可编程脚本合约\"><a href=\"#可编程脚本合约\" class=\"headerlink\" title=\"可编程脚本合约\"></a>可编程脚本合约</h2><p>什么叫合约？就是一组约定的规则，例如银行的结算系统，小明转账100给小王，在这个过程中，银系统就会根据一组规则自动执行，规则包含如检测小明的密码是否正确，余额是否足够，小王的账号是否正确，检测通过则分别更改两者的账户余额并写入事务日志。是的，这就是合约的意思了，当然，如果范围再广泛些，各种商业合约也都是这么个意思，因此可编程脚本合约也没什么好稀奇的，如果将这种编程合约放到区块链的环境中，比较有趣了，看两个特点：</p>\n<p>第一个，区块链系统是无中新的分布式网络，没有边界</p>\n<p>第二个，区块链系统通过一系列的技术实现了可信任网络</p>\n<p>加起来，就是无边界的可信任网络，在这样的网络中执行既定的合约，成本低而且安全，比特币在本质上也是属于这种脚本合约，只不过在比特币软件中，合约中处理的事情是比特币的转账</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"什么是区块链\"><a href=\"#什么是区块链\" class=\"headerlink\" title=\"什么是区块链\"></a>什么是区块链</h1><p>区块链是一个分布式的，去中心化的，点对点的，不可篡改的，共享账本系统。</p>","more":"<p><img src=\"/images/blockchain/blockchain.png\" alt=\"jvm_struct2\"></p>\n<h1 id=\"区块链架构\"><a href=\"#区块链架构\" class=\"headerlink\" title=\"区块链架构\"></a>区块链架构</h1><p>区块链整体架构上划分为网络层、共识层、数据层、智能合约层和应用层。共识层和数据层之间的联系比较密切，需要“通力合作”完成数据的存取。</p>\n<ul>\n<li>网络层，几乎都是基于P2P的网络，它主要完成节点之间的交互和数据块的传输。</li>\n<li>共识层，提供在不可信、分布式环境中的共识协议，通过它保证节点之间的数据一致性。</li>\n<li>数据层，提供数据保存的数据结构，它要承担防篡改的任务，所以技术上用了区块链表、Hash、Merkle Tree来实现。</li>\n<li>智能合约层，相当于数据访问接口，对区块链上的数据读写都是通过智能合约进行的，任何人的数据读写动作都是被明确定义的。</li>\n<li>应用层，各种各样的应用程序。</li>\n</ul>\n<p><img src=\"/images/blockchain/arch.png\" alt=\"jvm_struct2\"></p>\n<h1 id=\"区块链和比特币的关系\"><a href=\"#区块链和比特币的关系\" class=\"headerlink\" title=\"区块链和比特币的关系\"></a>区块链和比特币的关系</h1><p>每个区块数据由谁来记录或者说打包，是可以设置一个游戏规则的，比如说掷骰子，大家约定谁能连续3次掷出6，那就让他来记这个数据，为了补偿 一下他的劳动投入，奖励给他一些收益，<br>比特币正是使用了这样的原理来不断的发行新的比特币出来，奖励给打包的那个人的比特币就是新发行的比特币。</p>\n<h1 id=\"挖矿和区块链\"><a href=\"#挖矿和区块链\" class=\"headerlink\" title=\"挖矿和区块链\"></a>挖矿和区块链</h1><p>作为一个“数据库应用”比特币必须要“做点什么”。于是它就设计了一个小游戏环节——挖矿。游戏设计师中本聪在他大作《比特币：一种点对点式的电子现金系统》详细讲述的设计内幕和游戏方法。</p>\n<h1 id=\"区块链的技术组合\"><a href=\"#区块链的技术组合\" class=\"headerlink\" title=\"区块链的技术组合\"></a>区块链的技术组合</h1><h2 id=\"公开密钥算法\"><a href=\"#公开密钥算法\" class=\"headerlink\" title=\"公开密钥算法\"></a>公开密钥算法</h2><p>属于计算机密码学里传统的技术，公开密钥算法是一种不对称的加密算法，拥有两个密钥，可以互相加解密，通常其中的一个密钥是公开的称之为公钥，另外一个密钥是保密的称之为私钥</p>\n<h2 id=\"哈希算法\"><a href=\"#哈希算法\" class=\"headerlink\" title=\"哈希算法\"></a>哈希算法</h2><p>也是属于计算机密码学中传统的技术，应用就更广泛了，主要用来对一段数据进行计算，得出一个摘要信息，通俗点说就是给一段数据生成1个身份证号；不同的消息生成的摘要数据是不一样的（某些抗碰撞能力弱的哈希算法可能在这里面会有些问题，但是使用广泛的一些知名的哈希算法，发生碰撞的概率很低），相当于给⼀段数据生成了一个身份证号这么个意思，在区块链系统中，哈希算法的使用很多，例如如区块与区块之间，就是通过区块头的哈希关联起来的，在区块中的每一笔交易事务也都会生成一个哈希值作为交易易数据的ID，通过这些身份证号可以方便的检索或者关联区块，也能方便的指定某一笔交易事务。 </p>\n<h2 id=\"网络共识算法\"><a href=\"#网络共识算法\" class=\"headerlink\" title=\"网络共识算法\"></a>网络共识算法</h2><p>在很久前就有计算机科学家研究过，并且提出过一些模型，如拜占庭容错算法之类，比特币、以太坊这些使用的是一种工作量证明算法，其它的一些区块链系统有使用其他各种衍生的算法，算法的原理都很简单，就是约一个规则，通过共同执行这个规则，让每个分布式的节点数据都保持最终一致；</p>\n<h2 id=\"梅克尔数据证明\"><a href=\"#梅克尔数据证明\" class=\"headerlink\" title=\"梅克尔数据证明\"></a>梅克尔数据证明</h2><p>这是利用哈希算法将一组数据创建为一棵哈希树结构，用于验证数据完整性的一种结构，同时也应用在了轻量级钱包中。不同的区块链系统对梅克尔树的应用不尽相同，比特币中是二叉梅克尔树，比较简单，通过交易事务的哈希值两两配合生成一棵树，以太坊这种就复杂的多了，称之为梅克尔.帕特里夏树，这里暂时不赘述。</p>\n<h2 id=\"可编程脚本合约\"><a href=\"#可编程脚本合约\" class=\"headerlink\" title=\"可编程脚本合约\"></a>可编程脚本合约</h2><p>什么叫合约？就是一组约定的规则，例如银行的结算系统，小明转账100给小王，在这个过程中，银系统就会根据一组规则自动执行，规则包含如检测小明的密码是否正确，余额是否足够，小王的账号是否正确，检测通过则分别更改两者的账户余额并写入事务日志。是的，这就是合约的意思了，当然，如果范围再广泛些，各种商业合约也都是这么个意思，因此可编程脚本合约也没什么好稀奇的，如果将这种编程合约放到区块链的环境中，比较有趣了，看两个特点：</p>\n<p>第一个，区块链系统是无中新的分布式网络，没有边界</p>\n<p>第二个，区块链系统通过一系列的技术实现了可信任网络</p>\n<p>加起来，就是无边界的可信任网络，在这样的网络中执行既定的合约，成本低而且安全，比特币在本质上也是属于这种脚本合约，只不过在比特币软件中，合约中处理的事情是比特币的转账</p>"},{"title":"二分查找真的不简单","author":"James","date":"2015-04-09T07:19:00.000Z","_content":"\n# 简介\n\n二分查找法： 在一个有序数组中，取数组中的中间值和要找的值进行比较，当要查找的值大于中间值，则在右边的区间继续取一个中间值和要比较的数进行比较。当找查找的值小于中间值时则反之，直至最后要查找的值和中间值相同，则说明找到该值。\n\n一般而言，对于包含n个元素的有序列表，用二分查找最多需要`㏒₂n`步，而简单查找最多需要n步。\n\n# 问题 \n\n编写二分查找法的代码看似简单，其实是很容易出错的，你必须注意各种边界条件的处理，例如数组是空的，或者数组只有一个元素等等。别说你会出错，很多正规出版的算法书在讲解二分查找法时，他们给出的代码也是有错误的，据统计在美国出版的二十多本不同的讲算法的书中，只有五本对二分查找的代码实现是正确的。\n\n\n\n# show code\n\n## 递归二分查找\n\n```java\nInteger binarySearch(Integer[] arrs, Integer val, Integer lo, Integer hi) {\n        if(lo > hi) return -1;\n        Integer mid = (hi + lo) / 2;\n        if (val > arrs[mid]) return binarySearch(arrs, val, mid + 1, hi);\n        else if (val < arrs[mid]) return binarySearch(arrs, val, lo, mid - 1);\n        return mid;\n}\n```\n\n## 非递归\n\n```java\nInteger binarySearchV1(Integer[] arrs, Integer val, Integer lo, Integer hi) {\n        while(hi >= lo){\n            //low + high 是会溢出的。只要这个数组我们开的足够大\n            //Integer mid = (hi + lo) / 2;\n            Integer mid = ((hi - lo) >> 2) + lo;\n            if (val > arrs[mid]) lo = mid + 1;\n            else if (val < arrs[mid]) hi = mid - 1;\n            else return mid;\n        }\n        return -1;\n}\n```\n\n# 易错点\n\n- *死循环*: 在做的是整数运算，整除2了之后，对于奇数和偶数的行为还不一样，很有可能有些情况下我们并没有减小取值范围，而形成死循环\n- 退出条件。到底什么时候我们才觉得我们找不到呢\n- 差1错误。我们的左端点应该是当前可能区间的最小范围，那么右端点是最大范围呢，还是最大范围+1呢。我们取了中间值之后，在缩小区间时，有没有保持左右端点的这个假设的一致性呢？\n\n# 扩展思考\n\n## 二分查找还有改进的空间吗?\n\n可以细微的评定下上面非递归版本的比较次数,假设以7个有序数列为例，图中能够清晰的看到查找一个元素成功或者失败需要比较次数。\n\n![binary](/images/binarysearch/example1.png)\n\n\n\n先看成功的情况：分别为所有次数相加除以元素个数 :(2+3+4+4+5+5+6)29/7≈4+\n\n再看失败的情况:上图中虚线框中为失败的比较次数:(3+4+4+5+4+5+5+6)36/8=4.5\n\n故而可以得出平均查找长度均大致为O(1.5·㏒₂n)。\n\n可以发现向左和向右分支前的比较次数不想等。向左分支前只需要比较一次，而向右分支则需要比较两次；由此可以发现虽然递归深度是均衡的，但是转向成本不均衡。\n\n是不是可以通过调整递归深度的不均衡，对转向成本的不均衡进行补偿呢。\n\n### Fibonacci查找\n\n先看一段代码\n\n```java\nInteger fibSearch(Integer[] arrs, Integer val, Integer lo, Integer hi) {\n    \tFib fibs = Fib.create(hi - lo) //创建一个Fib数列 logn(hi-lo)\n        while(hi >= lo){\n            while( hi - lo < fib.get() ) fib.prev();//通过向前的顺序查找确定轴点\n            //Integer mid = (hi + lo) / 2;\n            Integer mid = lo + fib.get() - 1 //黄金比例切分\n            if (val > arrs[mid]) lo = mid + 1;\n            else if (val < arrs[mid]) hi = mid - 1;\n            else return mid;\n        }\n        return -1;\n}\n```\n\n还是以7个有序数列为例，看看FIb查找元素的比较次数\n\n![binary](/images/binarysearch/example2.png)\n\n平均成功查找比较次数=(2+3+4+4+5+5+5) / 7 = 28 / 7 = 4.00\n\n平均失败查找比较次数=(4+5+4+4+5+4+5+4) / 8 = 35 / 8 = 4.38\n\n跟上面的比较次数想比是不是有所优化。\n\n普通二分查找和FIb数列查找的不同其实就是选择轴点， 二分对应轴点=0.5;FIb查找对应抽点=0.6180399...所谓的黄金分割。\n\n### 二分查找再优化\n\n既然之前二分查找版本左右分支的转向代价是不平衡的，那么有办法能够做成平衡的吗?\n\n比如只做一次比较，所有分支只有2个方向，而不是3个方向。\n\n```java\nInteger binarySearchV1(Integer[] arrs, Integer val, Integer lo, Integer hi) {\n        while(1 < hi - lo ){//查找宽度缩短至1时，算法才会终止\n            Integer mid = ((hi - lo) >> 2) + lo;//还是以中点为轴点\n            val < arrs[mid] ? hi = mi : lo = mi//每次比较都只有2个方向\n        }\n        return (val == arrs[lo]) ? lo : -1;\n}\n```\n\n但是相对于之前的版本，由于无论如何都需要比较完所有转向，所以最好的情况下更坏（例如第一次就能比配到需要查找的元素，之前版本是O(1)， 而优化的版本需要O(logn)），但是更坏的情况变好(之前的版本需要 1.5*logn，而优化版本只需要logn)。\n\n","source":"_posts/binarysearch.md","raw":"title: 二分查找真的不简单\nauthor: James\ntags:\n  - 二分查找\ncategories:\n  - 算法\ndate: 2015-04-09 15:19:00\n---\n\n# 简介\n\n二分查找法： 在一个有序数组中，取数组中的中间值和要找的值进行比较，当要查找的值大于中间值，则在右边的区间继续取一个中间值和要比较的数进行比较。当找查找的值小于中间值时则反之，直至最后要查找的值和中间值相同，则说明找到该值。\n\n一般而言，对于包含n个元素的有序列表，用二分查找最多需要`㏒₂n`步，而简单查找最多需要n步。\n\n# 问题 \n\n编写二分查找法的代码看似简单，其实是很容易出错的，你必须注意各种边界条件的处理，例如数组是空的，或者数组只有一个元素等等。别说你会出错，很多正规出版的算法书在讲解二分查找法时，他们给出的代码也是有错误的，据统计在美国出版的二十多本不同的讲算法的书中，只有五本对二分查找的代码实现是正确的。\n\n\n\n# show code\n\n## 递归二分查找\n\n```java\nInteger binarySearch(Integer[] arrs, Integer val, Integer lo, Integer hi) {\n        if(lo > hi) return -1;\n        Integer mid = (hi + lo) / 2;\n        if (val > arrs[mid]) return binarySearch(arrs, val, mid + 1, hi);\n        else if (val < arrs[mid]) return binarySearch(arrs, val, lo, mid - 1);\n        return mid;\n}\n```\n\n## 非递归\n\n```java\nInteger binarySearchV1(Integer[] arrs, Integer val, Integer lo, Integer hi) {\n        while(hi >= lo){\n            //low + high 是会溢出的。只要这个数组我们开的足够大\n            //Integer mid = (hi + lo) / 2;\n            Integer mid = ((hi - lo) >> 2) + lo;\n            if (val > arrs[mid]) lo = mid + 1;\n            else if (val < arrs[mid]) hi = mid - 1;\n            else return mid;\n        }\n        return -1;\n}\n```\n\n# 易错点\n\n- *死循环*: 在做的是整数运算，整除2了之后，对于奇数和偶数的行为还不一样，很有可能有些情况下我们并没有减小取值范围，而形成死循环\n- 退出条件。到底什么时候我们才觉得我们找不到呢\n- 差1错误。我们的左端点应该是当前可能区间的最小范围，那么右端点是最大范围呢，还是最大范围+1呢。我们取了中间值之后，在缩小区间时，有没有保持左右端点的这个假设的一致性呢？\n\n# 扩展思考\n\n## 二分查找还有改进的空间吗?\n\n可以细微的评定下上面非递归版本的比较次数,假设以7个有序数列为例，图中能够清晰的看到查找一个元素成功或者失败需要比较次数。\n\n![binary](/images/binarysearch/example1.png)\n\n\n\n先看成功的情况：分别为所有次数相加除以元素个数 :(2+3+4+4+5+5+6)29/7≈4+\n\n再看失败的情况:上图中虚线框中为失败的比较次数:(3+4+4+5+4+5+5+6)36/8=4.5\n\n故而可以得出平均查找长度均大致为O(1.5·㏒₂n)。\n\n可以发现向左和向右分支前的比较次数不想等。向左分支前只需要比较一次，而向右分支则需要比较两次；由此可以发现虽然递归深度是均衡的，但是转向成本不均衡。\n\n是不是可以通过调整递归深度的不均衡，对转向成本的不均衡进行补偿呢。\n\n### Fibonacci查找\n\n先看一段代码\n\n```java\nInteger fibSearch(Integer[] arrs, Integer val, Integer lo, Integer hi) {\n    \tFib fibs = Fib.create(hi - lo) //创建一个Fib数列 logn(hi-lo)\n        while(hi >= lo){\n            while( hi - lo < fib.get() ) fib.prev();//通过向前的顺序查找确定轴点\n            //Integer mid = (hi + lo) / 2;\n            Integer mid = lo + fib.get() - 1 //黄金比例切分\n            if (val > arrs[mid]) lo = mid + 1;\n            else if (val < arrs[mid]) hi = mid - 1;\n            else return mid;\n        }\n        return -1;\n}\n```\n\n还是以7个有序数列为例，看看FIb查找元素的比较次数\n\n![binary](/images/binarysearch/example2.png)\n\n平均成功查找比较次数=(2+3+4+4+5+5+5) / 7 = 28 / 7 = 4.00\n\n平均失败查找比较次数=(4+5+4+4+5+4+5+4) / 8 = 35 / 8 = 4.38\n\n跟上面的比较次数想比是不是有所优化。\n\n普通二分查找和FIb数列查找的不同其实就是选择轴点， 二分对应轴点=0.5;FIb查找对应抽点=0.6180399...所谓的黄金分割。\n\n### 二分查找再优化\n\n既然之前二分查找版本左右分支的转向代价是不平衡的，那么有办法能够做成平衡的吗?\n\n比如只做一次比较，所有分支只有2个方向，而不是3个方向。\n\n```java\nInteger binarySearchV1(Integer[] arrs, Integer val, Integer lo, Integer hi) {\n        while(1 < hi - lo ){//查找宽度缩短至1时，算法才会终止\n            Integer mid = ((hi - lo) >> 2) + lo;//还是以中点为轴点\n            val < arrs[mid] ? hi = mi : lo = mi//每次比较都只有2个方向\n        }\n        return (val == arrs[lo]) ? lo : -1;\n}\n```\n\n但是相对于之前的版本，由于无论如何都需要比较完所有转向，所以最好的情况下更坏（例如第一次就能比配到需要查找的元素，之前版本是O(1)， 而优化的版本需要O(logn)），但是更坏的情况变好(之前的版本需要 1.5*logn，而优化版本只需要logn)。\n\n","slug":"binarysearch","published":1,"updated":"2018-04-18T09:27:41.501Z","_id":"cjfrwqk1s0000wckcf06oqq6q","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>二分查找法： 在一个有序数组中，取数组中的中间值和要找的值进行比较，当要查找的值大于中间值，则在右边的区间继续取一个中间值和要比较的数进行比较。当找查找的值小于中间值时则反之，直至最后要查找的值和中间值相同，则说明找到该值。</p>\n<p>一般而言，对于包含n个元素的有序列表，用二分查找最多需要<code>㏒₂n</code>步，而简单查找最多需要n步。</p>\n<h1 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h1><p>编写二分查找法的代码看似简单，其实是很容易出错的，你必须注意各种边界条件的处理，例如数组是空的，或者数组只有一个元素等等。别说你会出错，很多正规出版的算法书在讲解二分查找法时，他们给出的代码也是有错误的，据统计在美国出版的二十多本不同的讲算法的书中，只有五本对二分查找的代码实现是正确的。</p>\n<h1 id=\"show-code\"><a href=\"#show-code\" class=\"headerlink\" title=\"show code\"></a>show code</h1><h2 id=\"递归二分查找\"><a href=\"#递归二分查找\" class=\"headerlink\" title=\"递归二分查找\"></a>递归二分查找</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Integer <span class=\"title\">binarySearch</span><span class=\"params\">(Integer[] arrs, Integer val, Integer lo, Integer hi)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(lo &gt; hi) <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">        Integer mid = (hi + lo) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (val &gt; arrs[mid]) <span class=\"keyword\">return</span> binarySearch(arrs, val, mid + <span class=\"number\">1</span>, hi);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (val &lt; arrs[mid]) <span class=\"keyword\">return</span> binarySearch(arrs, val, lo, mid - <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"非递归\"><a href=\"#非递归\" class=\"headerlink\" title=\"非递归\"></a>非递归</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Integer <span class=\"title\">binarySearchV1</span><span class=\"params\">(Integer[] arrs, Integer val, Integer lo, Integer hi)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(hi &gt;= lo)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//low + high 是会溢出的。只要这个数组我们开的足够大</span></span><br><span class=\"line\">            <span class=\"comment\">//Integer mid = (hi + lo) / 2;</span></span><br><span class=\"line\">            Integer mid = ((hi - lo) &gt;&gt; <span class=\"number\">2</span>) + lo;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (val &gt; arrs[mid]) lo = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (val &lt; arrs[mid]) hi = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"易错点\"><a href=\"#易错点\" class=\"headerlink\" title=\"易错点\"></a>易错点</h1><ul>\n<li><em>死循环</em>: 在做的是整数运算，整除2了之后，对于奇数和偶数的行为还不一样，很有可能有些情况下我们并没有减小取值范围，而形成死循环</li>\n<li>退出条件。到底什么时候我们才觉得我们找不到呢</li>\n<li>差1错误。我们的左端点应该是当前可能区间的最小范围，那么右端点是最大范围呢，还是最大范围+1呢。我们取了中间值之后，在缩小区间时，有没有保持左右端点的这个假设的一致性呢？</li>\n</ul>\n<h1 id=\"扩展思考\"><a href=\"#扩展思考\" class=\"headerlink\" title=\"扩展思考\"></a>扩展思考</h1><h2 id=\"二分查找还有改进的空间吗\"><a href=\"#二分查找还有改进的空间吗\" class=\"headerlink\" title=\"二分查找还有改进的空间吗?\"></a>二分查找还有改进的空间吗?</h2><p>可以细微的评定下上面非递归版本的比较次数,假设以7个有序数列为例，图中能够清晰的看到查找一个元素成功或者失败需要比较次数。</p>\n<p><img src=\"/images/binarysearch/example1.png\" alt=\"binary\"></p>\n<p>先看成功的情况：分别为所有次数相加除以元素个数 :(2+3+4+4+5+5+6)29/7≈4+</p>\n<p>再看失败的情况:上图中虚线框中为失败的比较次数:(3+4+4+5+4+5+5+6)36/8=4.5</p>\n<p>故而可以得出平均查找长度均大致为O(1.5·㏒₂n)。</p>\n<p>可以发现向左和向右分支前的比较次数不想等。向左分支前只需要比较一次，而向右分支则需要比较两次；由此可以发现虽然递归深度是均衡的，但是转向成本不均衡。</p>\n<p>是不是可以通过调整递归深度的不均衡，对转向成本的不均衡进行补偿呢。</p>\n<h3 id=\"Fibonacci查找\"><a href=\"#Fibonacci查找\" class=\"headerlink\" title=\"Fibonacci查找\"></a>Fibonacci查找</h3><p>先看一段代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Integer <span class=\"title\">fibSearch</span><span class=\"params\">(Integer[] arrs, Integer val, Integer lo, Integer hi)</span> </span>&#123;</span><br><span class=\"line\">    \tFib fibs = Fib.create(hi - lo) <span class=\"comment\">//创建一个Fib数列 logn(hi-lo)</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(hi &gt;= lo)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>( hi - lo &lt; fib.get() ) fib.prev();<span class=\"comment\">//通过向前的顺序查找确定轴点</span></span><br><span class=\"line\">            <span class=\"comment\">//Integer mid = (hi + lo) / 2;</span></span><br><span class=\"line\">            Integer mid = lo + fib.get() - <span class=\"number\">1</span> <span class=\"comment\">//黄金比例切分</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (val &gt; arrs[mid]) lo = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (val &lt; arrs[mid]) hi = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>还是以7个有序数列为例，看看FIb查找元素的比较次数</p>\n<p><img src=\"/images/binarysearch/example2.png\" alt=\"binary\"></p>\n<p>平均成功查找比较次数=(2+3+4+4+5+5+5) / 7 = 28 / 7 = 4.00</p>\n<p>平均失败查找比较次数=(4+5+4+4+5+4+5+4) / 8 = 35 / 8 = 4.38</p>\n<p>跟上面的比较次数想比是不是有所优化。</p>\n<p>普通二分查找和FIb数列查找的不同其实就是选择轴点， 二分对应轴点=0.5;FIb查找对应抽点=0.6180399…所谓的黄金分割。</p>\n<h3 id=\"二分查找再优化\"><a href=\"#二分查找再优化\" class=\"headerlink\" title=\"二分查找再优化\"></a>二分查找再优化</h3><p>既然之前二分查找版本左右分支的转向代价是不平衡的，那么有办法能够做成平衡的吗?</p>\n<p>比如只做一次比较，所有分支只有2个方向，而不是3个方向。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Integer <span class=\"title\">binarySearchV1</span><span class=\"params\">(Integer[] arrs, Integer val, Integer lo, Integer hi)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"number\">1</span> &lt; hi - lo )&#123;<span class=\"comment\">//查找宽度缩短至1时，算法才会终止</span></span><br><span class=\"line\">            Integer mid = ((hi - lo) &gt;&gt; <span class=\"number\">2</span>) + lo;<span class=\"comment\">//还是以中点为轴点</span></span><br><span class=\"line\">            val &lt; arrs[mid] ? hi = mi : lo = mi<span class=\"comment\">//每次比较都只有2个方向</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (val == arrs[lo]) ? lo : -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是相对于之前的版本，由于无论如何都需要比较完所有转向，所以最好的情况下更坏（例如第一次就能比配到需要查找的元素，之前版本是O(1)， 而优化的版本需要O(logn)），但是更坏的情况变好(之前的版本需要 1.5*logn，而优化版本只需要logn)。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>二分查找法： 在一个有序数组中，取数组中的中间值和要找的值进行比较，当要查找的值大于中间值，则在右边的区间继续取一个中间值和要比较的数进行比较。当找查找的值小于中间值时则反之，直至最后要查找的值和中间值相同，则说明找到该值。</p>\n<p>一般而言，对于包含n个元素的有序列表，用二分查找最多需要<code>㏒₂n</code>步，而简单查找最多需要n步。</p>\n<h1 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h1><p>编写二分查找法的代码看似简单，其实是很容易出错的，你必须注意各种边界条件的处理，例如数组是空的，或者数组只有一个元素等等。别说你会出错，很多正规出版的算法书在讲解二分查找法时，他们给出的代码也是有错误的，据统计在美国出版的二十多本不同的讲算法的书中，只有五本对二分查找的代码实现是正确的。</p>\n<h1 id=\"show-code\"><a href=\"#show-code\" class=\"headerlink\" title=\"show code\"></a>show code</h1><h2 id=\"递归二分查找\"><a href=\"#递归二分查找\" class=\"headerlink\" title=\"递归二分查找\"></a>递归二分查找</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Integer <span class=\"title\">binarySearch</span><span class=\"params\">(Integer[] arrs, Integer val, Integer lo, Integer hi)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(lo &gt; hi) <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">        Integer mid = (hi + lo) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (val &gt; arrs[mid]) <span class=\"keyword\">return</span> binarySearch(arrs, val, mid + <span class=\"number\">1</span>, hi);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (val &lt; arrs[mid]) <span class=\"keyword\">return</span> binarySearch(arrs, val, lo, mid - <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"非递归\"><a href=\"#非递归\" class=\"headerlink\" title=\"非递归\"></a>非递归</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Integer <span class=\"title\">binarySearchV1</span><span class=\"params\">(Integer[] arrs, Integer val, Integer lo, Integer hi)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(hi &gt;= lo)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//low + high 是会溢出的。只要这个数组我们开的足够大</span></span><br><span class=\"line\">            <span class=\"comment\">//Integer mid = (hi + lo) / 2;</span></span><br><span class=\"line\">            Integer mid = ((hi - lo) &gt;&gt; <span class=\"number\">2</span>) + lo;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (val &gt; arrs[mid]) lo = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (val &lt; arrs[mid]) hi = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"易错点\"><a href=\"#易错点\" class=\"headerlink\" title=\"易错点\"></a>易错点</h1><ul>\n<li><em>死循环</em>: 在做的是整数运算，整除2了之后，对于奇数和偶数的行为还不一样，很有可能有些情况下我们并没有减小取值范围，而形成死循环</li>\n<li>退出条件。到底什么时候我们才觉得我们找不到呢</li>\n<li>差1错误。我们的左端点应该是当前可能区间的最小范围，那么右端点是最大范围呢，还是最大范围+1呢。我们取了中间值之后，在缩小区间时，有没有保持左右端点的这个假设的一致性呢？</li>\n</ul>\n<h1 id=\"扩展思考\"><a href=\"#扩展思考\" class=\"headerlink\" title=\"扩展思考\"></a>扩展思考</h1><h2 id=\"二分查找还有改进的空间吗\"><a href=\"#二分查找还有改进的空间吗\" class=\"headerlink\" title=\"二分查找还有改进的空间吗?\"></a>二分查找还有改进的空间吗?</h2><p>可以细微的评定下上面非递归版本的比较次数,假设以7个有序数列为例，图中能够清晰的看到查找一个元素成功或者失败需要比较次数。</p>\n<p><img src=\"/images/binarysearch/example1.png\" alt=\"binary\"></p>\n<p>先看成功的情况：分别为所有次数相加除以元素个数 :(2+3+4+4+5+5+6)29/7≈4+</p>\n<p>再看失败的情况:上图中虚线框中为失败的比较次数:(3+4+4+5+4+5+5+6)36/8=4.5</p>\n<p>故而可以得出平均查找长度均大致为O(1.5·㏒₂n)。</p>\n<p>可以发现向左和向右分支前的比较次数不想等。向左分支前只需要比较一次，而向右分支则需要比较两次；由此可以发现虽然递归深度是均衡的，但是转向成本不均衡。</p>\n<p>是不是可以通过调整递归深度的不均衡，对转向成本的不均衡进行补偿呢。</p>\n<h3 id=\"Fibonacci查找\"><a href=\"#Fibonacci查找\" class=\"headerlink\" title=\"Fibonacci查找\"></a>Fibonacci查找</h3><p>先看一段代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Integer <span class=\"title\">fibSearch</span><span class=\"params\">(Integer[] arrs, Integer val, Integer lo, Integer hi)</span> </span>&#123;</span><br><span class=\"line\">    \tFib fibs = Fib.create(hi - lo) <span class=\"comment\">//创建一个Fib数列 logn(hi-lo)</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(hi &gt;= lo)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>( hi - lo &lt; fib.get() ) fib.prev();<span class=\"comment\">//通过向前的顺序查找确定轴点</span></span><br><span class=\"line\">            <span class=\"comment\">//Integer mid = (hi + lo) / 2;</span></span><br><span class=\"line\">            Integer mid = lo + fib.get() - <span class=\"number\">1</span> <span class=\"comment\">//黄金比例切分</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (val &gt; arrs[mid]) lo = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (val &lt; arrs[mid]) hi = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>还是以7个有序数列为例，看看FIb查找元素的比较次数</p>\n<p><img src=\"/images/binarysearch/example2.png\" alt=\"binary\"></p>\n<p>平均成功查找比较次数=(2+3+4+4+5+5+5) / 7 = 28 / 7 = 4.00</p>\n<p>平均失败查找比较次数=(4+5+4+4+5+4+5+4) / 8 = 35 / 8 = 4.38</p>\n<p>跟上面的比较次数想比是不是有所优化。</p>\n<p>普通二分查找和FIb数列查找的不同其实就是选择轴点， 二分对应轴点=0.5;FIb查找对应抽点=0.6180399…所谓的黄金分割。</p>\n<h3 id=\"二分查找再优化\"><a href=\"#二分查找再优化\" class=\"headerlink\" title=\"二分查找再优化\"></a>二分查找再优化</h3><p>既然之前二分查找版本左右分支的转向代价是不平衡的，那么有办法能够做成平衡的吗?</p>\n<p>比如只做一次比较，所有分支只有2个方向，而不是3个方向。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Integer <span class=\"title\">binarySearchV1</span><span class=\"params\">(Integer[] arrs, Integer val, Integer lo, Integer hi)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"number\">1</span> &lt; hi - lo )&#123;<span class=\"comment\">//查找宽度缩短至1时，算法才会终止</span></span><br><span class=\"line\">            Integer mid = ((hi - lo) &gt;&gt; <span class=\"number\">2</span>) + lo;<span class=\"comment\">//还是以中点为轴点</span></span><br><span class=\"line\">            val &lt; arrs[mid] ? hi = mi : lo = mi<span class=\"comment\">//每次比较都只有2个方向</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (val == arrs[lo]) ? lo : -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是相对于之前的版本，由于无论如何都需要比较完所有转向，所以最好的情况下更坏（例如第一次就能比配到需要查找的元素，之前版本是O(1)， 而优化的版本需要O(logn)），但是更坏的情况变好(之前的版本需要 1.5*logn，而优化版本只需要logn)。</p>\n"},{"title":"探索 ConcurrentHashMap","author":"James","date":"2013-08-20T09:06:00.000Z","_content":"\n# 简介\n\nConcurrentHashMap 是 util.concurrent 包的重要成员。本文将结合 Java 内存模型，分析 JDK 源代码，探索 ConcurrentHashMap 高并发的具体实现机制。\n\n<!-- more -->\n\n# 结构分析\n\nConcurrentHashMap 类中包含两个静态内部类 HashEntry 和 Segment。HashEntry 用来封装映射表的键 / 值对；Segment 用来充当锁的角色，每个 Segment 对象守护整个散列映射表的若干个桶。每个桶是由若干个 HashEntry 对象链接起来的链表。一个 ConcurrentHashMap 实例中包含由若干个 Segment 对象组成的数组。*声明*: 以下源码是针对 `JDK 1.6`\n\n## ConcurrentHashMap 类\n\nConcurrentHashMap 在默认并发级别会创建包含 16 个 Segment 对象的数组。每个 Segment 的成员对象 table 包含若干个散列表的桶。每个桶是由 HashEntry 链接起来的一个链表。如果键能均匀散列，每个 Segment 大约守护整个散列表中桶总数的 1/16。\n\n```java\npublic class ConcurrentHashMap<K, V> extends AbstractMap<K, V> \n       implements ConcurrentMap<K, V>, Serializable { \n \n   /** \n    * 散列映射表的默认初始容量为 16，即初始默认为 16 个桶\n    * 在构造函数中没有指定这个参数时，使用本参数\n    */ \n   static final     int DEFAULT_INITIAL_CAPACITY= 16; \n \n   /** \n    * 散列映射表的默认装载因子为 0.75，该值是 table 中包含的 HashEntry 元素的个数与\n* table 数组长度的比值\n    * 当 table 中包含的 HashEntry 元素的个数超过了 table 数组的长度与装载因子的乘积时，\n* 将触发 再散列\n    * 在构造函数中没有指定这个参数时，使用本参数\n    */ \n   static final float DEFAULT_LOAD_FACTOR= 0.75f; \n \n   /** \n    * 散列表的默认并发级别为 16。该值表示当前更新线程的估计数\n    * 在构造函数中没有指定这个参数时，使用本参数\n    */ \n   static final int DEFAULT_CONCURRENCY_LEVEL= 16; \n \n   /** \n    * segments 的掩码值\n    * key 的散列码的高位用来选择具体的 segment \n    */ \n   final int segmentMask; \n \n   /** \n    * 偏移量\n    */ \n   final int segmentShift; \n \n   /** \n    * 由 Segment 对象组成的数组\n    */ \n   final Segment<K,V>[] segments; \n \n   /** \n    * 创建一个带有指定初始容量、加载因子和并发级别的新的空映射。\n    */ \n   public ConcurrentHashMap(int initialCapacity, \n                            float loadFactor, int concurrencyLevel) { \n       if(!(loadFactor > 0) || initialCapacity < 0 || \nconcurrencyLevel <= 0) \n           throw new IllegalArgumentException(); \n \n       if(concurrencyLevel > MAX_SEGMENTS) \n           concurrencyLevel = MAX_SEGMENTS; \n \n       // 寻找最佳匹配参数（不小于给定参数的最接近的 2 次幂） \n       int sshift = 0; \n       int ssize = 1; \n       while(ssize < concurrencyLevel) { \n           ++sshift; \n           ssize <<= 1; \n       } \n       segmentShift = 32 - sshift;       // 偏移量值\n       segmentMask = ssize - 1;           // 掩码值 \n       this.segments = Segment.newArray(ssize);   // 创建数组\n \n       if (initialCapacity > MAXIMUM_CAPACITY) \n           initialCapacity = MAXIMUM_CAPACITY; \n       int c = initialCapacity / ssize; \n       if(c * ssize < initialCapacity) \n           ++c; \n       int cap = 1; \n       while(cap < c) \n           cap <<= 1; \n \n       // 依次遍历每个数组元素\n       for(int i = 0; i < this.segments.length; ++i) \n           // 初始化每个数组元素引用的 Segment 对象\nthis.segments[i] = new Segment<K,V>(cap, loadFactor); \n   } \n \n   /** \n    * 创建一个带有默认初始容量 (16)、默认加载因子 (0.75) 和 默认并发级别 (16) \n * 的空散列映射表。\n    */ \n   public ConcurrentHashMap() { \n       // 使用三个默认参数，调用上面重载的构造函数来创建空散列映射表\nthis(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL); \n}\n```\n\n结构示意图：\n\n![ConcurrentHashMap](/images/concurrentHashMap/image005.jpg)\n\n## HashEntry 类\n\nHashEntry 用来封装散列映射表中的键值对。在 HashEntry 类中，key，hash 和 next 域都被声明为 final 型，value 域被声明为 volatile 型。\n\n```java\nstatic final class HashEntry<K,V> { \n       final K key;                       // 声明 key 为 final 型\n       final int hash;                   // 声明 hash 值为 final 型 \n       volatile V value;                 // 声明 value 为 volatile 型\n       final HashEntry<K,V> next;      // 声明 next 为 final 型 \n \n       HashEntry(K key, int hash, HashEntry<K,V> next, V value) { \n           this.key = key; \n           this.hash = hash; \n           this.next = next; \n           this.value = value; \n       } \n}\n```\n\n在 ConcurrentHashMap 中，在散列时如果产生“碰撞”，将采用“分离链接法”来处理“碰撞”：把“碰撞”的 HashEntry 对象链接成一个链表。由于 HashEntry 的 next 域为 final 型，所以新节点只能在链表的表头处插入。\n\n## Segment 类\n\nSegment 类继承于 ReentrantLock 类，从而使得 Segment 对象能充当锁的角色。每个 Segment 对象用来守护其（成员对象 table 中）包含的若干个桶。\n\ntable 是一个由 HashEntry 对象组成的数组。table 数组的每一个数组成员就是散列映射表的一个桶。\n\ncount 变量是一个计数器，它表示每个 Segment 对象管理的 table 数组（若干个 HashEntry 组成的链表）包含的 HashEntry 对象的个数。每一个 Segment 对象都有一个 count 对象来表示本 Segment 中包含的 HashEntry 对象的总数。注意，之所以在每个 Segment 对象中包含一个计数器，而不是在 `ConcurrentHashMap 中使用全局的计数器，是为了避免出现“热点域”而影响 ConcurrentHashMap 的并发性。`\n\n```java\nstatic final class Segment<K,V> extends ReentrantLock implements Serializable { \n       /** \n        * 在本 segment 范围内，包含的 HashEntry 元素的个数\n        * 该变量被声明为 volatile 型\n        */ \n       transient volatile int count; \n \n       /** \n        * table 被更新的次数\n        */ \n       transient int modCount; \n \n       /** \n        * 当 table 中包含的 HashEntry 元素的个数超过本变量值时，触发 table 的再散列\n        */ \n       transient int threshold; \n \n       /** \n        * table 是由 HashEntry 对象组成的数组\n        * 如果散列时发生碰撞，碰撞的 HashEntry 对象就以链表的形式链接成一个链表\n        * table 数组的数组成员代表散列映射表的一个桶\n        * 每个 table 守护整个 ConcurrentHashMap 包含桶总数的一部分\n        * 如果并发级别为 16，table 则守护 ConcurrentHashMap 包含的桶总数的 1/16 \n        */ \n       transient volatile HashEntry<K,V>[] table; \n \n       /** \n        * 装载因子\n        */ \n       final float loadFactor; \n \n       Segment(int initialCapacity, float lf) { \n           loadFactor = lf; \n           setTable(HashEntry.<K,V>newArray(initialCapacity)); \n       } \n \n       /** \n        * 设置 table 引用到这个新生成的 HashEntry 数组\n        * 只能在持有锁或构造函数中调用本方法\n        */ \n       void setTable(HashEntry<K,V>[] newTable) { \n           // 计算临界阀值为新数组的长度与装载因子的乘积\n           threshold = (int)(newTable.length * loadFactor); \n           table = newTable; \n       } \n \n       /** \n        * 根据 key 的散列值，找到 table 中对应的那个桶（table 数组的某个数组成员）\n        */ \n       HashEntry<K,V> getFirst(int hash) { \n           HashEntry<K,V>[] tab = table; \n           // 把散列值与 table 数组长度减 1 的值相“与”，\n// 得到散列值对应的 table 数组的下标\n           // 然后返回 table 数组中此下标对应的 HashEntry 元素\n           return tab[hash & (tab.length - 1)]; \n       } \n}\n```\n\n插入三个节点后 Segment 的结构示意图：\n\n![Segment](/images/concurrentHashMap/image004.jpg)\n\n## Put 方法的实现\n\n1.根据 key 计算出对应的 hash 值：\n\n```java\npublic V put(K key, V value) { \n       if (value == null)          //ConcurrentHashMap 中不允许用 null 作为映射值\n           throw new NullPointerException(); \n       int hash = hash(key.hashCode());        // 计算键对应的散列码\n       // 根据散列码找到对应的 Segment \n       return segmentFor(hash).put(key, hash, value, false); \n}\n```\n\n2.根据 hash 值找到对应的 Segment:\n\n```java\n/** \n    * 使用 key 的散列码来得到 segments 数组中对应的 Segment \n    */ \nfinal Segment<K,V> segmentFor(int hash) { \n   // 将散列值右移 segmentShift 个位，并在高位填充 0 \n   // 然后把得到的值与 segmentMask 相“与”\n// 从而得到 hash 值对应的 segments 数组的下标值\n// 最后根据下标值返回散列码对应的 Segment 对象\n       return segments[(hash >>> segmentShift) & segmentMask]; \n}\n```\n\n3.在 Segment 中执行具体的 put 操作\n\n```java\nV put(K key, int hash, V value, boolean onlyIfAbsent) { \n           lock();  // 加锁，这里是锁定某个 Segment 对象而非整个 ConcurrentHashMap \n           try { \n               int c = count; \n \n               if (c++ > threshold)     // 如果超过再散列的阈值\n                   rehash();              // 执行再散列，table 数组的长度将扩充一倍\n \n               HashEntry<K,V>[] tab = table; \n               // 把散列码值与 table 数组的长度减 1 的值相“与”\n               // 得到该散列码对应的 table 数组的下标值\n               int index = hash & (tab.length - 1); \n               // 找到散列码对应的具体的那个桶\n               HashEntry<K,V> first = tab[index]; \n \n               HashEntry<K,V> e = first; \n               while (e != null && (e.hash != hash || !key.equals(e.key))) \n                   e = e.next; \n \n               V oldValue; \n               if (e != null) {            // 如果键 / 值对以经存在\n                   oldValue = e.value; \n                   if (!onlyIfAbsent) \n                       e.value = value;    // 设置 value 值\n               } \n               else {                        // 键 / 值对不存在 \n                   oldValue = null; \n                   ++modCount;         // 要添加新节点到链表中，所以 modCont 要加 1  \n                   // 创建新节点，并添加到链表的头部 \n                   tab[index] = new HashEntry<K,V>(key, hash, first, value); \n                   count = c;               // 写 count 变量\n               } \n               return oldValue; \n           } finally { \n               unlock();                     // 解锁\n           } \n       }\n```\n\n加锁操作是针对（键的 hash 值对应的）某个具体的 Segment，锁定的是该 Segment 而不是整个 ConcurrentHashMap`。因为插入键 / 值对操作只是在这个 Segment 包含的某个桶中完成，不需要锁定整个`ConcurrentHashMap。`此时，其他写线程对另外 15 个`Segment 的加锁并不会因为当前线程对这个 Segment 的加锁而阻塞。同时，所有读线程几乎不会因本线程的加锁而阻塞（除非读线程刚好读到这个 Segment 中某个 `HashEntry 的 value 域的值为 null，此时需要加锁后重新读取该值`）。\n\n相比较于 `HashTable 和由同步包装器包装的 HashMap``每次只能有一个线程执行读或写操作，`ConcurrentHashMap 在并发访问性能上有了质的提高。*在理想状态下*，ConcurrentHashMap 可以支持 16 个线程执行并发写操作（如果并发级别设置为 16），及任意数量线程的读操作。\n\n# 总结\n\nConcurrentHashMap 是一个并发散列映射表的实现，它允许完全并发的读取，并且支持给定数量的并发更新。相比于 `HashTable 和`用同步包装器包装的 HashMap（Collections.synchronizedMap(new HashMap())），ConcurrentHashMap 拥有更高的并发性。在 `HashTable 和由同步包装器包装的 HashMap 中，使用一个全局的锁来同步不同线程间的并发访问。同一时间点，只能有一个线程持有锁，也就是说在同一时间点，只能有一个线程能访问容器。这虽然保证多线程间的安全并发访问，但同时也导致对容器的访问变成``*串行化*``的了。`\n\n在使用锁来协调多线程间并发访问的模式下，减小对锁的竞争可以有效提高并发性。有两种方式可以减小对锁的竞争：\n\n1. 减小请求 同一个锁的 频率。\n2. 减少持有锁的 时间。\n\nConcurrentHashMap 的高并发性主要来自于三个方面：\n\n1. 用分离锁实现多个线程间的更深层次的共享访问。\n2. 用 HashEntery 对象的不变性来降低执行读操作的线程在遍历链表期间对加锁的需求。\n3. 通过对同一个 Volatile 变量的写 / 读访问，协调不同线程间读 / 写操作的内存可见性。\n\n使用分离锁，减小了请求 *同一个锁*的频率。\n\n通过 HashEntery 对象的不变性及对同一个 Volatile 变量的读 / 写来协调内存可见性，使得 读操作大多数时候不需要加锁就能成功获取到需要的值。由于散列映射表在实际应用中大多数操作都是成功的 读操作，所以 2 和 3 既可以减少请求同一个锁的频率，也可以有效减少持有锁的时间。\n\n通过减小请求同一个锁的频率和尽量减少持有锁的时间 `，使得 ConcurrentHashMap 的并发性相对于 HashTable 和`用同步包装器包装的 HashMap`有了质的提高。`\n\n","source":"_posts/ConcurrentHashMap.md","raw":"title: 探索 ConcurrentHashMap\nauthor: James\ntags:\n  - ConcurrentHashMap\ncategories:\n  - 语言\ndate: 2013-08-20 17:06:00\n---\n\n# 简介\n\nConcurrentHashMap 是 util.concurrent 包的重要成员。本文将结合 Java 内存模型，分析 JDK 源代码，探索 ConcurrentHashMap 高并发的具体实现机制。\n\n<!-- more -->\n\n# 结构分析\n\nConcurrentHashMap 类中包含两个静态内部类 HashEntry 和 Segment。HashEntry 用来封装映射表的键 / 值对；Segment 用来充当锁的角色，每个 Segment 对象守护整个散列映射表的若干个桶。每个桶是由若干个 HashEntry 对象链接起来的链表。一个 ConcurrentHashMap 实例中包含由若干个 Segment 对象组成的数组。*声明*: 以下源码是针对 `JDK 1.6`\n\n## ConcurrentHashMap 类\n\nConcurrentHashMap 在默认并发级别会创建包含 16 个 Segment 对象的数组。每个 Segment 的成员对象 table 包含若干个散列表的桶。每个桶是由 HashEntry 链接起来的一个链表。如果键能均匀散列，每个 Segment 大约守护整个散列表中桶总数的 1/16。\n\n```java\npublic class ConcurrentHashMap<K, V> extends AbstractMap<K, V> \n       implements ConcurrentMap<K, V>, Serializable { \n \n   /** \n    * 散列映射表的默认初始容量为 16，即初始默认为 16 个桶\n    * 在构造函数中没有指定这个参数时，使用本参数\n    */ \n   static final     int DEFAULT_INITIAL_CAPACITY= 16; \n \n   /** \n    * 散列映射表的默认装载因子为 0.75，该值是 table 中包含的 HashEntry 元素的个数与\n* table 数组长度的比值\n    * 当 table 中包含的 HashEntry 元素的个数超过了 table 数组的长度与装载因子的乘积时，\n* 将触发 再散列\n    * 在构造函数中没有指定这个参数时，使用本参数\n    */ \n   static final float DEFAULT_LOAD_FACTOR= 0.75f; \n \n   /** \n    * 散列表的默认并发级别为 16。该值表示当前更新线程的估计数\n    * 在构造函数中没有指定这个参数时，使用本参数\n    */ \n   static final int DEFAULT_CONCURRENCY_LEVEL= 16; \n \n   /** \n    * segments 的掩码值\n    * key 的散列码的高位用来选择具体的 segment \n    */ \n   final int segmentMask; \n \n   /** \n    * 偏移量\n    */ \n   final int segmentShift; \n \n   /** \n    * 由 Segment 对象组成的数组\n    */ \n   final Segment<K,V>[] segments; \n \n   /** \n    * 创建一个带有指定初始容量、加载因子和并发级别的新的空映射。\n    */ \n   public ConcurrentHashMap(int initialCapacity, \n                            float loadFactor, int concurrencyLevel) { \n       if(!(loadFactor > 0) || initialCapacity < 0 || \nconcurrencyLevel <= 0) \n           throw new IllegalArgumentException(); \n \n       if(concurrencyLevel > MAX_SEGMENTS) \n           concurrencyLevel = MAX_SEGMENTS; \n \n       // 寻找最佳匹配参数（不小于给定参数的最接近的 2 次幂） \n       int sshift = 0; \n       int ssize = 1; \n       while(ssize < concurrencyLevel) { \n           ++sshift; \n           ssize <<= 1; \n       } \n       segmentShift = 32 - sshift;       // 偏移量值\n       segmentMask = ssize - 1;           // 掩码值 \n       this.segments = Segment.newArray(ssize);   // 创建数组\n \n       if (initialCapacity > MAXIMUM_CAPACITY) \n           initialCapacity = MAXIMUM_CAPACITY; \n       int c = initialCapacity / ssize; \n       if(c * ssize < initialCapacity) \n           ++c; \n       int cap = 1; \n       while(cap < c) \n           cap <<= 1; \n \n       // 依次遍历每个数组元素\n       for(int i = 0; i < this.segments.length; ++i) \n           // 初始化每个数组元素引用的 Segment 对象\nthis.segments[i] = new Segment<K,V>(cap, loadFactor); \n   } \n \n   /** \n    * 创建一个带有默认初始容量 (16)、默认加载因子 (0.75) 和 默认并发级别 (16) \n * 的空散列映射表。\n    */ \n   public ConcurrentHashMap() { \n       // 使用三个默认参数，调用上面重载的构造函数来创建空散列映射表\nthis(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL); \n}\n```\n\n结构示意图：\n\n![ConcurrentHashMap](/images/concurrentHashMap/image005.jpg)\n\n## HashEntry 类\n\nHashEntry 用来封装散列映射表中的键值对。在 HashEntry 类中，key，hash 和 next 域都被声明为 final 型，value 域被声明为 volatile 型。\n\n```java\nstatic final class HashEntry<K,V> { \n       final K key;                       // 声明 key 为 final 型\n       final int hash;                   // 声明 hash 值为 final 型 \n       volatile V value;                 // 声明 value 为 volatile 型\n       final HashEntry<K,V> next;      // 声明 next 为 final 型 \n \n       HashEntry(K key, int hash, HashEntry<K,V> next, V value) { \n           this.key = key; \n           this.hash = hash; \n           this.next = next; \n           this.value = value; \n       } \n}\n```\n\n在 ConcurrentHashMap 中，在散列时如果产生“碰撞”，将采用“分离链接法”来处理“碰撞”：把“碰撞”的 HashEntry 对象链接成一个链表。由于 HashEntry 的 next 域为 final 型，所以新节点只能在链表的表头处插入。\n\n## Segment 类\n\nSegment 类继承于 ReentrantLock 类，从而使得 Segment 对象能充当锁的角色。每个 Segment 对象用来守护其（成员对象 table 中）包含的若干个桶。\n\ntable 是一个由 HashEntry 对象组成的数组。table 数组的每一个数组成员就是散列映射表的一个桶。\n\ncount 变量是一个计数器，它表示每个 Segment 对象管理的 table 数组（若干个 HashEntry 组成的链表）包含的 HashEntry 对象的个数。每一个 Segment 对象都有一个 count 对象来表示本 Segment 中包含的 HashEntry 对象的总数。注意，之所以在每个 Segment 对象中包含一个计数器，而不是在 `ConcurrentHashMap 中使用全局的计数器，是为了避免出现“热点域”而影响 ConcurrentHashMap 的并发性。`\n\n```java\nstatic final class Segment<K,V> extends ReentrantLock implements Serializable { \n       /** \n        * 在本 segment 范围内，包含的 HashEntry 元素的个数\n        * 该变量被声明为 volatile 型\n        */ \n       transient volatile int count; \n \n       /** \n        * table 被更新的次数\n        */ \n       transient int modCount; \n \n       /** \n        * 当 table 中包含的 HashEntry 元素的个数超过本变量值时，触发 table 的再散列\n        */ \n       transient int threshold; \n \n       /** \n        * table 是由 HashEntry 对象组成的数组\n        * 如果散列时发生碰撞，碰撞的 HashEntry 对象就以链表的形式链接成一个链表\n        * table 数组的数组成员代表散列映射表的一个桶\n        * 每个 table 守护整个 ConcurrentHashMap 包含桶总数的一部分\n        * 如果并发级别为 16，table 则守护 ConcurrentHashMap 包含的桶总数的 1/16 \n        */ \n       transient volatile HashEntry<K,V>[] table; \n \n       /** \n        * 装载因子\n        */ \n       final float loadFactor; \n \n       Segment(int initialCapacity, float lf) { \n           loadFactor = lf; \n           setTable(HashEntry.<K,V>newArray(initialCapacity)); \n       } \n \n       /** \n        * 设置 table 引用到这个新生成的 HashEntry 数组\n        * 只能在持有锁或构造函数中调用本方法\n        */ \n       void setTable(HashEntry<K,V>[] newTable) { \n           // 计算临界阀值为新数组的长度与装载因子的乘积\n           threshold = (int)(newTable.length * loadFactor); \n           table = newTable; \n       } \n \n       /** \n        * 根据 key 的散列值，找到 table 中对应的那个桶（table 数组的某个数组成员）\n        */ \n       HashEntry<K,V> getFirst(int hash) { \n           HashEntry<K,V>[] tab = table; \n           // 把散列值与 table 数组长度减 1 的值相“与”，\n// 得到散列值对应的 table 数组的下标\n           // 然后返回 table 数组中此下标对应的 HashEntry 元素\n           return tab[hash & (tab.length - 1)]; \n       } \n}\n```\n\n插入三个节点后 Segment 的结构示意图：\n\n![Segment](/images/concurrentHashMap/image004.jpg)\n\n## Put 方法的实现\n\n1.根据 key 计算出对应的 hash 值：\n\n```java\npublic V put(K key, V value) { \n       if (value == null)          //ConcurrentHashMap 中不允许用 null 作为映射值\n           throw new NullPointerException(); \n       int hash = hash(key.hashCode());        // 计算键对应的散列码\n       // 根据散列码找到对应的 Segment \n       return segmentFor(hash).put(key, hash, value, false); \n}\n```\n\n2.根据 hash 值找到对应的 Segment:\n\n```java\n/** \n    * 使用 key 的散列码来得到 segments 数组中对应的 Segment \n    */ \nfinal Segment<K,V> segmentFor(int hash) { \n   // 将散列值右移 segmentShift 个位，并在高位填充 0 \n   // 然后把得到的值与 segmentMask 相“与”\n// 从而得到 hash 值对应的 segments 数组的下标值\n// 最后根据下标值返回散列码对应的 Segment 对象\n       return segments[(hash >>> segmentShift) & segmentMask]; \n}\n```\n\n3.在 Segment 中执行具体的 put 操作\n\n```java\nV put(K key, int hash, V value, boolean onlyIfAbsent) { \n           lock();  // 加锁，这里是锁定某个 Segment 对象而非整个 ConcurrentHashMap \n           try { \n               int c = count; \n \n               if (c++ > threshold)     // 如果超过再散列的阈值\n                   rehash();              // 执行再散列，table 数组的长度将扩充一倍\n \n               HashEntry<K,V>[] tab = table; \n               // 把散列码值与 table 数组的长度减 1 的值相“与”\n               // 得到该散列码对应的 table 数组的下标值\n               int index = hash & (tab.length - 1); \n               // 找到散列码对应的具体的那个桶\n               HashEntry<K,V> first = tab[index]; \n \n               HashEntry<K,V> e = first; \n               while (e != null && (e.hash != hash || !key.equals(e.key))) \n                   e = e.next; \n \n               V oldValue; \n               if (e != null) {            // 如果键 / 值对以经存在\n                   oldValue = e.value; \n                   if (!onlyIfAbsent) \n                       e.value = value;    // 设置 value 值\n               } \n               else {                        // 键 / 值对不存在 \n                   oldValue = null; \n                   ++modCount;         // 要添加新节点到链表中，所以 modCont 要加 1  \n                   // 创建新节点，并添加到链表的头部 \n                   tab[index] = new HashEntry<K,V>(key, hash, first, value); \n                   count = c;               // 写 count 变量\n               } \n               return oldValue; \n           } finally { \n               unlock();                     // 解锁\n           } \n       }\n```\n\n加锁操作是针对（键的 hash 值对应的）某个具体的 Segment，锁定的是该 Segment 而不是整个 ConcurrentHashMap`。因为插入键 / 值对操作只是在这个 Segment 包含的某个桶中完成，不需要锁定整个`ConcurrentHashMap。`此时，其他写线程对另外 15 个`Segment 的加锁并不会因为当前线程对这个 Segment 的加锁而阻塞。同时，所有读线程几乎不会因本线程的加锁而阻塞（除非读线程刚好读到这个 Segment 中某个 `HashEntry 的 value 域的值为 null，此时需要加锁后重新读取该值`）。\n\n相比较于 `HashTable 和由同步包装器包装的 HashMap``每次只能有一个线程执行读或写操作，`ConcurrentHashMap 在并发访问性能上有了质的提高。*在理想状态下*，ConcurrentHashMap 可以支持 16 个线程执行并发写操作（如果并发级别设置为 16），及任意数量线程的读操作。\n\n# 总结\n\nConcurrentHashMap 是一个并发散列映射表的实现，它允许完全并发的读取，并且支持给定数量的并发更新。相比于 `HashTable 和`用同步包装器包装的 HashMap（Collections.synchronizedMap(new HashMap())），ConcurrentHashMap 拥有更高的并发性。在 `HashTable 和由同步包装器包装的 HashMap 中，使用一个全局的锁来同步不同线程间的并发访问。同一时间点，只能有一个线程持有锁，也就是说在同一时间点，只能有一个线程能访问容器。这虽然保证多线程间的安全并发访问，但同时也导致对容器的访问变成``*串行化*``的了。`\n\n在使用锁来协调多线程间并发访问的模式下，减小对锁的竞争可以有效提高并发性。有两种方式可以减小对锁的竞争：\n\n1. 减小请求 同一个锁的 频率。\n2. 减少持有锁的 时间。\n\nConcurrentHashMap 的高并发性主要来自于三个方面：\n\n1. 用分离锁实现多个线程间的更深层次的共享访问。\n2. 用 HashEntery 对象的不变性来降低执行读操作的线程在遍历链表期间对加锁的需求。\n3. 通过对同一个 Volatile 变量的写 / 读访问，协调不同线程间读 / 写操作的内存可见性。\n\n使用分离锁，减小了请求 *同一个锁*的频率。\n\n通过 HashEntery 对象的不变性及对同一个 Volatile 变量的读 / 写来协调内存可见性，使得 读操作大多数时候不需要加锁就能成功获取到需要的值。由于散列映射表在实际应用中大多数操作都是成功的 读操作，所以 2 和 3 既可以减少请求同一个锁的频率，也可以有效减少持有锁的时间。\n\n通过减小请求同一个锁的频率和尽量减少持有锁的时间 `，使得 ConcurrentHashMap 的并发性相对于 HashTable 和`用同步包装器包装的 HashMap`有了质的提高。`\n\n","slug":"ConcurrentHashMap","published":1,"updated":"2018-04-20T10:18:31.417Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgiyu41q000048kc7hmxes7v","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>ConcurrentHashMap 是 util.concurrent 包的重要成员。本文将结合 Java 内存模型，分析 JDK 源代码，探索 ConcurrentHashMap 高并发的具体实现机制。</p>\n<a id=\"more\"></a>\n<h1 id=\"结构分析\"><a href=\"#结构分析\" class=\"headerlink\" title=\"结构分析\"></a>结构分析</h1><p>ConcurrentHashMap 类中包含两个静态内部类 HashEntry 和 Segment。HashEntry 用来封装映射表的键 / 值对；Segment 用来充当锁的角色，每个 Segment 对象守护整个散列映射表的若干个桶。每个桶是由若干个 HashEntry 对象链接起来的链表。一个 ConcurrentHashMap 实例中包含由若干个 Segment 对象组成的数组。<em>声明</em>: 以下源码是针对 <code>JDK 1.6</code></p>\n<h2 id=\"ConcurrentHashMap-类\"><a href=\"#ConcurrentHashMap-类\" class=\"headerlink\" title=\"ConcurrentHashMap 类\"></a>ConcurrentHashMap 类</h2><p>ConcurrentHashMap 在默认并发级别会创建包含 16 个 Segment 对象的数组。每个 Segment 的成员对象 table 包含若干个散列表的桶。每个桶是由 HashEntry 链接起来的一个链表。如果键能均匀散列，每个 Segment 大约守护整个散列表中桶总数的 1/16。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcurrentHashMap</span>&lt;<span class=\"title\">K</span>, <span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AbstractMap</span>&lt;<span class=\"title\">K</span>, <span class=\"title\">V</span>&gt; </span></span><br><span class=\"line\"><span class=\"class\">       <span class=\"keyword\">implements</span> <span class=\"title\">ConcurrentMap</span>&lt;<span class=\"title\">K</span>, <span class=\"title\">V</span>&gt;, <span class=\"title\">Serializable</span> </span>&#123; </span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * 散列映射表的默认初始容量为 16，即初始默认为 16 个桶</span></span><br><span class=\"line\"><span class=\"comment\">    * 在构造函数中没有指定这个参数时，使用本参数</span></span><br><span class=\"line\"><span class=\"comment\">    */</span> </span><br><span class=\"line\">   <span class=\"keyword\">static</span> <span class=\"keyword\">final</span>     <span class=\"keyword\">int</span> DEFAULT_INITIAL_CAPACITY= <span class=\"number\">16</span>; </span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * 散列映射表的默认装载因子为 0.75，该值是 table 中包含的 HashEntry 元素的个数与</span></span><br><span class=\"line\"><span class=\"comment\">* table 数组长度的比值</span></span><br><span class=\"line\"><span class=\"comment\">    * 当 table 中包含的 HashEntry 元素的个数超过了 table 数组的长度与装载因子的乘积时，</span></span><br><span class=\"line\"><span class=\"comment\">* 将触发 再散列</span></span><br><span class=\"line\"><span class=\"comment\">    * 在构造函数中没有指定这个参数时，使用本参数</span></span><br><span class=\"line\"><span class=\"comment\">    */</span> </span><br><span class=\"line\">   <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> DEFAULT_LOAD_FACTOR= <span class=\"number\">0.75f</span>; </span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * 散列表的默认并发级别为 16。该值表示当前更新线程的估计数</span></span><br><span class=\"line\"><span class=\"comment\">    * 在构造函数中没有指定这个参数时，使用本参数</span></span><br><span class=\"line\"><span class=\"comment\">    */</span> </span><br><span class=\"line\">   <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_CONCURRENCY_LEVEL= <span class=\"number\">16</span>; </span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * segments 的掩码值</span></span><br><span class=\"line\"><span class=\"comment\">    * key 的散列码的高位用来选择具体的 segment </span></span><br><span class=\"line\"><span class=\"comment\">    */</span> </span><br><span class=\"line\">   <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> segmentMask; </span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * 偏移量</span></span><br><span class=\"line\"><span class=\"comment\">    */</span> </span><br><span class=\"line\">   <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> segmentShift; </span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * 由 Segment 对象组成的数组</span></span><br><span class=\"line\"><span class=\"comment\">    */</span> </span><br><span class=\"line\">   <span class=\"keyword\">final</span> Segment&lt;K,V&gt;[] segments; </span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * 创建一个带有指定初始容量、加载因子和并发级别的新的空映射。</span></span><br><span class=\"line\"><span class=\"comment\">    */</span> </span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ConcurrentHashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                            <span class=\"keyword\">float</span> loadFactor, <span class=\"keyword\">int</span> concurrencyLevel)</span> </span>&#123; </span><br><span class=\"line\">       <span class=\"keyword\">if</span>(!(loadFactor &gt; <span class=\"number\">0</span>) || initialCapacity &lt; <span class=\"number\">0</span> || </span><br><span class=\"line\">concurrencyLevel &lt;= <span class=\"number\">0</span>) </span><br><span class=\"line\">           <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(); </span><br><span class=\"line\"> </span><br><span class=\"line\">       <span class=\"keyword\">if</span>(concurrencyLevel &gt; MAX_SEGMENTS) </span><br><span class=\"line\">           concurrencyLevel = MAX_SEGMENTS; </span><br><span class=\"line\"> </span><br><span class=\"line\">       <span class=\"comment\">// 寻找最佳匹配参数（不小于给定参数的最接近的 2 次幂） </span></span><br><span class=\"line\">       <span class=\"keyword\">int</span> sshift = <span class=\"number\">0</span>; </span><br><span class=\"line\">       <span class=\"keyword\">int</span> ssize = <span class=\"number\">1</span>; </span><br><span class=\"line\">       <span class=\"keyword\">while</span>(ssize &lt; concurrencyLevel) &#123; </span><br><span class=\"line\">           ++sshift; </span><br><span class=\"line\">           ssize &lt;&lt;= <span class=\"number\">1</span>; </span><br><span class=\"line\">       &#125; </span><br><span class=\"line\">       segmentShift = <span class=\"number\">32</span> - sshift;       <span class=\"comment\">// 偏移量值</span></span><br><span class=\"line\">       segmentMask = ssize - <span class=\"number\">1</span>;           <span class=\"comment\">// 掩码值 </span></span><br><span class=\"line\">       <span class=\"keyword\">this</span>.segments = Segment.newArray(ssize);   <span class=\"comment\">// 创建数组</span></span><br><span class=\"line\"> </span><br><span class=\"line\">       <span class=\"keyword\">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY) </span><br><span class=\"line\">           initialCapacity = MAXIMUM_CAPACITY; </span><br><span class=\"line\">       <span class=\"keyword\">int</span> c = initialCapacity / ssize; </span><br><span class=\"line\">       <span class=\"keyword\">if</span>(c * ssize &lt; initialCapacity) </span><br><span class=\"line\">           ++c; </span><br><span class=\"line\">       <span class=\"keyword\">int</span> cap = <span class=\"number\">1</span>; </span><br><span class=\"line\">       <span class=\"keyword\">while</span>(cap &lt; c) </span><br><span class=\"line\">           cap &lt;&lt;= <span class=\"number\">1</span>; </span><br><span class=\"line\"> </span><br><span class=\"line\">       <span class=\"comment\">// 依次遍历每个数组元素</span></span><br><span class=\"line\">       <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">this</span>.segments.length; ++i) </span><br><span class=\"line\">           <span class=\"comment\">// 初始化每个数组元素引用的 Segment 对象</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.segments[i] = <span class=\"keyword\">new</span> Segment&lt;K,V&gt;(cap, loadFactor); </span><br><span class=\"line\">   &#125; </span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * 创建一个带有默认初始容量 (16)、默认加载因子 (0.75) 和 默认并发级别 (16) </span></span><br><span class=\"line\"><span class=\"comment\"> * 的空散列映射表。</span></span><br><span class=\"line\"><span class=\"comment\">    */</span> </span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ConcurrentHashMap</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">       <span class=\"comment\">// 使用三个默认参数，调用上面重载的构造函数来创建空散列映射表</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结构示意图：</p>\n<p><img src=\"/images/concurrentHashMap/image005.jpg\" alt=\"ConcurrentHashMap\"></p>\n<h2 id=\"HashEntry-类\"><a href=\"#HashEntry-类\" class=\"headerlink\" title=\"HashEntry 类\"></a>HashEntry 类</h2><p>HashEntry 用来封装散列映射表中的键值对。在 HashEntry 类中，key，hash 和 next 域都被声明为 final 型，value 域被声明为 volatile 型。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashEntry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123; </span><br><span class=\"line\">       <span class=\"keyword\">final</span> K key;                       <span class=\"comment\">// 声明 key 为 final 型</span></span><br><span class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> hash;                   <span class=\"comment\">// 声明 hash 值为 final 型 </span></span><br><span class=\"line\">       <span class=\"keyword\">volatile</span> V value;                 <span class=\"comment\">// 声明 value 为 volatile 型</span></span><br><span class=\"line\">       <span class=\"keyword\">final</span> HashEntry&lt;K,V&gt; next;      <span class=\"comment\">// 声明 next 为 final 型 </span></span><br><span class=\"line\"> </span><br><span class=\"line\">       HashEntry(K key, <span class=\"keyword\">int</span> hash, HashEntry&lt;K,V&gt; next, V value) &#123; </span><br><span class=\"line\">           <span class=\"keyword\">this</span>.key = key; </span><br><span class=\"line\">           <span class=\"keyword\">this</span>.hash = hash; </span><br><span class=\"line\">           <span class=\"keyword\">this</span>.next = next; </span><br><span class=\"line\">           <span class=\"keyword\">this</span>.value = value; </span><br><span class=\"line\">       &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 ConcurrentHashMap 中，在散列时如果产生“碰撞”，将采用“分离链接法”来处理“碰撞”：把“碰撞”的 HashEntry 对象链接成一个链表。由于 HashEntry 的 next 域为 final 型，所以新节点只能在链表的表头处插入。</p>\n<h2 id=\"Segment-类\"><a href=\"#Segment-类\" class=\"headerlink\" title=\"Segment 类\"></a>Segment 类</h2><p>Segment 类继承于 ReentrantLock 类，从而使得 Segment 对象能充当锁的角色。每个 Segment 对象用来守护其（成员对象 table 中）包含的若干个桶。</p>\n<p>table 是一个由 HashEntry 对象组成的数组。table 数组的每一个数组成员就是散列映射表的一个桶。</p>\n<p>count 变量是一个计数器，它表示每个 Segment 对象管理的 table 数组（若干个 HashEntry 组成的链表）包含的 HashEntry 对象的个数。每一个 Segment 对象都有一个 count 对象来表示本 Segment 中包含的 HashEntry 对象的总数。注意，之所以在每个 Segment 对象中包含一个计数器，而不是在 <code>ConcurrentHashMap 中使用全局的计数器，是为了避免出现“热点域”而影响 ConcurrentHashMap 的并发性。</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Segment</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">ReentrantLock</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span> </span>&#123; </span><br><span class=\"line\">       <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">        * 在本 segment 范围内，包含的 HashEntry 元素的个数</span></span><br><span class=\"line\"><span class=\"comment\">        * 该变量被声明为 volatile 型</span></span><br><span class=\"line\"><span class=\"comment\">        */</span> </span><br><span class=\"line\">       <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> count; </span><br><span class=\"line\"> </span><br><span class=\"line\">       <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">        * table 被更新的次数</span></span><br><span class=\"line\"><span class=\"comment\">        */</span> </span><br><span class=\"line\">       <span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> modCount; </span><br><span class=\"line\"> </span><br><span class=\"line\">       <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">        * 当 table 中包含的 HashEntry 元素的个数超过本变量值时，触发 table 的再散列</span></span><br><span class=\"line\"><span class=\"comment\">        */</span> </span><br><span class=\"line\">       <span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> threshold; </span><br><span class=\"line\"> </span><br><span class=\"line\">       <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">        * table 是由 HashEntry 对象组成的数组</span></span><br><span class=\"line\"><span class=\"comment\">        * 如果散列时发生碰撞，碰撞的 HashEntry 对象就以链表的形式链接成一个链表</span></span><br><span class=\"line\"><span class=\"comment\">        * table 数组的数组成员代表散列映射表的一个桶</span></span><br><span class=\"line\"><span class=\"comment\">        * 每个 table 守护整个 ConcurrentHashMap 包含桶总数的一部分</span></span><br><span class=\"line\"><span class=\"comment\">        * 如果并发级别为 16，table 则守护 ConcurrentHashMap 包含的桶总数的 1/16 </span></span><br><span class=\"line\"><span class=\"comment\">        */</span> </span><br><span class=\"line\">       <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> HashEntry&lt;K,V&gt;[] table; </span><br><span class=\"line\"> </span><br><span class=\"line\">       <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">        * 装载因子</span></span><br><span class=\"line\"><span class=\"comment\">        */</span> </span><br><span class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> loadFactor; </span><br><span class=\"line\"> </span><br><span class=\"line\">       Segment(<span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">float</span> lf) &#123; </span><br><span class=\"line\">           loadFactor = lf; </span><br><span class=\"line\">           setTable(HashEntry.&lt;K,V&gt;newArray(initialCapacity)); </span><br><span class=\"line\">       &#125; </span><br><span class=\"line\"> </span><br><span class=\"line\">       <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">        * 设置 table 引用到这个新生成的 HashEntry 数组</span></span><br><span class=\"line\"><span class=\"comment\">        * 只能在持有锁或构造函数中调用本方法</span></span><br><span class=\"line\"><span class=\"comment\">        */</span> </span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setTable</span><span class=\"params\">(HashEntry&lt;K,V&gt;[] newTable)</span> </span>&#123; </span><br><span class=\"line\">           <span class=\"comment\">// 计算临界阀值为新数组的长度与装载因子的乘积</span></span><br><span class=\"line\">           threshold = (<span class=\"keyword\">int</span>)(newTable.length * loadFactor); </span><br><span class=\"line\">           table = newTable; </span><br><span class=\"line\">       &#125; </span><br><span class=\"line\"> </span><br><span class=\"line\">       <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">        * 根据 key 的散列值，找到 table 中对应的那个桶（table 数组的某个数组成员）</span></span><br><span class=\"line\"><span class=\"comment\">        */</span> </span><br><span class=\"line\">       <span class=\"function\">HashEntry&lt;K,V&gt; <span class=\"title\">getFirst</span><span class=\"params\">(<span class=\"keyword\">int</span> hash)</span> </span>&#123; </span><br><span class=\"line\">           HashEntry&lt;K,V&gt;[] tab = table; </span><br><span class=\"line\">           <span class=\"comment\">// 把散列值与 table 数组长度减 1 的值相“与”，</span></span><br><span class=\"line\"><span class=\"comment\">// 得到散列值对应的 table 数组的下标</span></span><br><span class=\"line\">           <span class=\"comment\">// 然后返回 table 数组中此下标对应的 HashEntry 元素</span></span><br><span class=\"line\">           <span class=\"keyword\">return</span> tab[hash &amp; (tab.length - <span class=\"number\">1</span>)]; </span><br><span class=\"line\">       &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>插入三个节点后 Segment 的结构示意图：</p>\n<p><img src=\"/images/concurrentHashMap/image004.jpg\" alt=\"Segment\"></p>\n<h2 id=\"Put-方法的实现\"><a href=\"#Put-方法的实现\" class=\"headerlink\" title=\"Put 方法的实现\"></a>Put 方法的实现</h2><p>1.根据 key 计算出对应的 hash 值：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123; </span><br><span class=\"line\">       <span class=\"keyword\">if</span> (value == <span class=\"keyword\">null</span>)          <span class=\"comment\">//ConcurrentHashMap 中不允许用 null 作为映射值</span></span><br><span class=\"line\">           <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(); </span><br><span class=\"line\">       <span class=\"keyword\">int</span> hash = hash(key.hashCode());        <span class=\"comment\">// 计算键对应的散列码</span></span><br><span class=\"line\">       <span class=\"comment\">// 根据散列码找到对应的 Segment </span></span><br><span class=\"line\">       <span class=\"keyword\">return</span> segmentFor(hash).put(key, hash, value, <span class=\"keyword\">false</span>); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2.根据 hash 值找到对应的 Segment:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * 使用 key 的散列码来得到 segments 数组中对应的 Segment </span></span><br><span class=\"line\"><span class=\"comment\">    */</span> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Segment&lt;K,V&gt; <span class=\"title\">segmentFor</span><span class=\"params\">(<span class=\"keyword\">int</span> hash)</span> </span>&#123; </span><br><span class=\"line\">   <span class=\"comment\">// 将散列值右移 segmentShift 个位，并在高位填充 0 </span></span><br><span class=\"line\">   <span class=\"comment\">// 然后把得到的值与 segmentMask 相“与”</span></span><br><span class=\"line\"><span class=\"comment\">// 从而得到 hash 值对应的 segments 数组的下标值</span></span><br><span class=\"line\"><span class=\"comment\">// 最后根据下标值返回散列码对应的 Segment 对象</span></span><br><span class=\"line\">       <span class=\"keyword\">return</span> segments[(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask]; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>3.在 Segment 中执行具体的 put 操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">V <span class=\"title\">put</span><span class=\"params\">(K key, <span class=\"keyword\">int</span> hash, V value, <span class=\"keyword\">boolean</span> onlyIfAbsent)</span> </span>&#123; </span><br><span class=\"line\">           lock();  <span class=\"comment\">// 加锁，这里是锁定某个 Segment 对象而非整个 ConcurrentHashMap </span></span><br><span class=\"line\">           <span class=\"keyword\">try</span> &#123; </span><br><span class=\"line\">               <span class=\"keyword\">int</span> c = count; </span><br><span class=\"line\"> </span><br><span class=\"line\">               <span class=\"keyword\">if</span> (c++ &gt; threshold)     <span class=\"comment\">// 如果超过再散列的阈值</span></span><br><span class=\"line\">                   rehash();              <span class=\"comment\">// 执行再散列，table 数组的长度将扩充一倍</span></span><br><span class=\"line\"> </span><br><span class=\"line\">               HashEntry&lt;K,V&gt;[] tab = table; </span><br><span class=\"line\">               <span class=\"comment\">// 把散列码值与 table 数组的长度减 1 的值相“与”</span></span><br><span class=\"line\">               <span class=\"comment\">// 得到该散列码对应的 table 数组的下标值</span></span><br><span class=\"line\">               <span class=\"keyword\">int</span> index = hash &amp; (tab.length - <span class=\"number\">1</span>); </span><br><span class=\"line\">               <span class=\"comment\">// 找到散列码对应的具体的那个桶</span></span><br><span class=\"line\">               HashEntry&lt;K,V&gt; first = tab[index]; </span><br><span class=\"line\"> </span><br><span class=\"line\">               HashEntry&lt;K,V&gt; e = first; </span><br><span class=\"line\">               <span class=\"keyword\">while</span> (e != <span class=\"keyword\">null</span> &amp;&amp; (e.hash != hash || !key.equals(e.key))) </span><br><span class=\"line\">                   e = e.next; </span><br><span class=\"line\"> </span><br><span class=\"line\">               V oldValue; </span><br><span class=\"line\">               <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123;            <span class=\"comment\">// 如果键 / 值对以经存在</span></span><br><span class=\"line\">                   oldValue = e.value; </span><br><span class=\"line\">                   <span class=\"keyword\">if</span> (!onlyIfAbsent) </span><br><span class=\"line\">                       e.value = value;    <span class=\"comment\">// 设置 value 值</span></span><br><span class=\"line\">               &#125; </span><br><span class=\"line\">               <span class=\"keyword\">else</span> &#123;                        <span class=\"comment\">// 键 / 值对不存在 </span></span><br><span class=\"line\">                   oldValue = <span class=\"keyword\">null</span>; </span><br><span class=\"line\">                   ++modCount;         <span class=\"comment\">// 要添加新节点到链表中，所以 modCont 要加 1  </span></span><br><span class=\"line\">                   <span class=\"comment\">// 创建新节点，并添加到链表的头部 </span></span><br><span class=\"line\">                   tab[index] = <span class=\"keyword\">new</span> HashEntry&lt;K,V&gt;(key, hash, first, value); </span><br><span class=\"line\">                   count = c;               <span class=\"comment\">// 写 count 变量</span></span><br><span class=\"line\">               &#125; </span><br><span class=\"line\">               <span class=\"keyword\">return</span> oldValue; </span><br><span class=\"line\">           &#125; <span class=\"keyword\">finally</span> &#123; </span><br><span class=\"line\">               unlock();                     <span class=\"comment\">// 解锁</span></span><br><span class=\"line\">           &#125; </span><br><span class=\"line\">       &#125;</span><br></pre></td></tr></table></figure>\n<p>加锁操作是针对（键的 hash 值对应的）某个具体的 Segment，锁定的是该 Segment 而不是整个 ConcurrentHashMap<code>。因为插入键 / 值对操作只是在这个 Segment 包含的某个桶中完成，不需要锁定整个</code>ConcurrentHashMap。<code>此时，其他写线程对另外 15 个</code>Segment 的加锁并不会因为当前线程对这个 Segment 的加锁而阻塞。同时，所有读线程几乎不会因本线程的加锁而阻塞（除非读线程刚好读到这个 Segment 中某个 <code>HashEntry 的 value 域的值为 null，此时需要加锁后重新读取该值</code>）。</p>\n<p>相比较于 <code>HashTable 和由同步包装器包装的 HashMap`</code>每次只能有一个线程执行读或写操作，`ConcurrentHashMap 在并发访问性能上有了质的提高。<em>在理想状态下</em>，ConcurrentHashMap 可以支持 16 个线程执行并发写操作（如果并发级别设置为 16），及任意数量线程的读操作。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>ConcurrentHashMap 是一个并发散列映射表的实现，它允许完全并发的读取，并且支持给定数量的并发更新。相比于 <code>HashTable 和</code>用同步包装器包装的 HashMap（Collections.synchronizedMap(new HashMap())），ConcurrentHashMap 拥有更高的并发性。在 <code>HashTable 和由同步包装器包装的 HashMap 中，使用一个全局的锁来同步不同线程间的并发访问。同一时间点，只能有一个线程持有锁，也就是说在同一时间点，只能有一个线程能访问容器。这虽然保证多线程间的安全并发访问，但同时也导致对容器的访问变成`</code><em>串行化</em><code></code>的了。`</p>\n<p>在使用锁来协调多线程间并发访问的模式下，减小对锁的竞争可以有效提高并发性。有两种方式可以减小对锁的竞争：</p>\n<ol>\n<li>减小请求 同一个锁的 频率。</li>\n<li>减少持有锁的 时间。</li>\n</ol>\n<p>ConcurrentHashMap 的高并发性主要来自于三个方面：</p>\n<ol>\n<li>用分离锁实现多个线程间的更深层次的共享访问。</li>\n<li>用 HashEntery 对象的不变性来降低执行读操作的线程在遍历链表期间对加锁的需求。</li>\n<li>通过对同一个 Volatile 变量的写 / 读访问，协调不同线程间读 / 写操作的内存可见性。</li>\n</ol>\n<p>使用分离锁，减小了请求 <em>同一个锁</em>的频率。</p>\n<p>通过 HashEntery 对象的不变性及对同一个 Volatile 变量的读 / 写来协调内存可见性，使得 读操作大多数时候不需要加锁就能成功获取到需要的值。由于散列映射表在实际应用中大多数操作都是成功的 读操作，所以 2 和 3 既可以减少请求同一个锁的频率，也可以有效减少持有锁的时间。</p>\n<p>通过减小请求同一个锁的频率和尽量减少持有锁的时间 <code>，使得 ConcurrentHashMap 的并发性相对于 HashTable 和</code>用同步包装器包装的 HashMap<code>有了质的提高。</code></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>ConcurrentHashMap 是 util.concurrent 包的重要成员。本文将结合 Java 内存模型，分析 JDK 源代码，探索 ConcurrentHashMap 高并发的具体实现机制。</p>","more":"<h1 id=\"结构分析\"><a href=\"#结构分析\" class=\"headerlink\" title=\"结构分析\"></a>结构分析</h1><p>ConcurrentHashMap 类中包含两个静态内部类 HashEntry 和 Segment。HashEntry 用来封装映射表的键 / 值对；Segment 用来充当锁的角色，每个 Segment 对象守护整个散列映射表的若干个桶。每个桶是由若干个 HashEntry 对象链接起来的链表。一个 ConcurrentHashMap 实例中包含由若干个 Segment 对象组成的数组。<em>声明</em>: 以下源码是针对 <code>JDK 1.6</code></p>\n<h2 id=\"ConcurrentHashMap-类\"><a href=\"#ConcurrentHashMap-类\" class=\"headerlink\" title=\"ConcurrentHashMap 类\"></a>ConcurrentHashMap 类</h2><p>ConcurrentHashMap 在默认并发级别会创建包含 16 个 Segment 对象的数组。每个 Segment 的成员对象 table 包含若干个散列表的桶。每个桶是由 HashEntry 链接起来的一个链表。如果键能均匀散列，每个 Segment 大约守护整个散列表中桶总数的 1/16。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcurrentHashMap</span>&lt;<span class=\"title\">K</span>, <span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AbstractMap</span>&lt;<span class=\"title\">K</span>, <span class=\"title\">V</span>&gt; </span></span><br><span class=\"line\"><span class=\"class\">       <span class=\"keyword\">implements</span> <span class=\"title\">ConcurrentMap</span>&lt;<span class=\"title\">K</span>, <span class=\"title\">V</span>&gt;, <span class=\"title\">Serializable</span> </span>&#123; </span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * 散列映射表的默认初始容量为 16，即初始默认为 16 个桶</span></span><br><span class=\"line\"><span class=\"comment\">    * 在构造函数中没有指定这个参数时，使用本参数</span></span><br><span class=\"line\"><span class=\"comment\">    */</span> </span><br><span class=\"line\">   <span class=\"keyword\">static</span> <span class=\"keyword\">final</span>     <span class=\"keyword\">int</span> DEFAULT_INITIAL_CAPACITY= <span class=\"number\">16</span>; </span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * 散列映射表的默认装载因子为 0.75，该值是 table 中包含的 HashEntry 元素的个数与</span></span><br><span class=\"line\"><span class=\"comment\">* table 数组长度的比值</span></span><br><span class=\"line\"><span class=\"comment\">    * 当 table 中包含的 HashEntry 元素的个数超过了 table 数组的长度与装载因子的乘积时，</span></span><br><span class=\"line\"><span class=\"comment\">* 将触发 再散列</span></span><br><span class=\"line\"><span class=\"comment\">    * 在构造函数中没有指定这个参数时，使用本参数</span></span><br><span class=\"line\"><span class=\"comment\">    */</span> </span><br><span class=\"line\">   <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> DEFAULT_LOAD_FACTOR= <span class=\"number\">0.75f</span>; </span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * 散列表的默认并发级别为 16。该值表示当前更新线程的估计数</span></span><br><span class=\"line\"><span class=\"comment\">    * 在构造函数中没有指定这个参数时，使用本参数</span></span><br><span class=\"line\"><span class=\"comment\">    */</span> </span><br><span class=\"line\">   <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_CONCURRENCY_LEVEL= <span class=\"number\">16</span>; </span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * segments 的掩码值</span></span><br><span class=\"line\"><span class=\"comment\">    * key 的散列码的高位用来选择具体的 segment </span></span><br><span class=\"line\"><span class=\"comment\">    */</span> </span><br><span class=\"line\">   <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> segmentMask; </span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * 偏移量</span></span><br><span class=\"line\"><span class=\"comment\">    */</span> </span><br><span class=\"line\">   <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> segmentShift; </span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * 由 Segment 对象组成的数组</span></span><br><span class=\"line\"><span class=\"comment\">    */</span> </span><br><span class=\"line\">   <span class=\"keyword\">final</span> Segment&lt;K,V&gt;[] segments; </span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * 创建一个带有指定初始容量、加载因子和并发级别的新的空映射。</span></span><br><span class=\"line\"><span class=\"comment\">    */</span> </span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ConcurrentHashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                            <span class=\"keyword\">float</span> loadFactor, <span class=\"keyword\">int</span> concurrencyLevel)</span> </span>&#123; </span><br><span class=\"line\">       <span class=\"keyword\">if</span>(!(loadFactor &gt; <span class=\"number\">0</span>) || initialCapacity &lt; <span class=\"number\">0</span> || </span><br><span class=\"line\">concurrencyLevel &lt;= <span class=\"number\">0</span>) </span><br><span class=\"line\">           <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(); </span><br><span class=\"line\"> </span><br><span class=\"line\">       <span class=\"keyword\">if</span>(concurrencyLevel &gt; MAX_SEGMENTS) </span><br><span class=\"line\">           concurrencyLevel = MAX_SEGMENTS; </span><br><span class=\"line\"> </span><br><span class=\"line\">       <span class=\"comment\">// 寻找最佳匹配参数（不小于给定参数的最接近的 2 次幂） </span></span><br><span class=\"line\">       <span class=\"keyword\">int</span> sshift = <span class=\"number\">0</span>; </span><br><span class=\"line\">       <span class=\"keyword\">int</span> ssize = <span class=\"number\">1</span>; </span><br><span class=\"line\">       <span class=\"keyword\">while</span>(ssize &lt; concurrencyLevel) &#123; </span><br><span class=\"line\">           ++sshift; </span><br><span class=\"line\">           ssize &lt;&lt;= <span class=\"number\">1</span>; </span><br><span class=\"line\">       &#125; </span><br><span class=\"line\">       segmentShift = <span class=\"number\">32</span> - sshift;       <span class=\"comment\">// 偏移量值</span></span><br><span class=\"line\">       segmentMask = ssize - <span class=\"number\">1</span>;           <span class=\"comment\">// 掩码值 </span></span><br><span class=\"line\">       <span class=\"keyword\">this</span>.segments = Segment.newArray(ssize);   <span class=\"comment\">// 创建数组</span></span><br><span class=\"line\"> </span><br><span class=\"line\">       <span class=\"keyword\">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY) </span><br><span class=\"line\">           initialCapacity = MAXIMUM_CAPACITY; </span><br><span class=\"line\">       <span class=\"keyword\">int</span> c = initialCapacity / ssize; </span><br><span class=\"line\">       <span class=\"keyword\">if</span>(c * ssize &lt; initialCapacity) </span><br><span class=\"line\">           ++c; </span><br><span class=\"line\">       <span class=\"keyword\">int</span> cap = <span class=\"number\">1</span>; </span><br><span class=\"line\">       <span class=\"keyword\">while</span>(cap &lt; c) </span><br><span class=\"line\">           cap &lt;&lt;= <span class=\"number\">1</span>; </span><br><span class=\"line\"> </span><br><span class=\"line\">       <span class=\"comment\">// 依次遍历每个数组元素</span></span><br><span class=\"line\">       <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">this</span>.segments.length; ++i) </span><br><span class=\"line\">           <span class=\"comment\">// 初始化每个数组元素引用的 Segment 对象</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.segments[i] = <span class=\"keyword\">new</span> Segment&lt;K,V&gt;(cap, loadFactor); </span><br><span class=\"line\">   &#125; </span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * 创建一个带有默认初始容量 (16)、默认加载因子 (0.75) 和 默认并发级别 (16) </span></span><br><span class=\"line\"><span class=\"comment\"> * 的空散列映射表。</span></span><br><span class=\"line\"><span class=\"comment\">    */</span> </span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ConcurrentHashMap</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">       <span class=\"comment\">// 使用三个默认参数，调用上面重载的构造函数来创建空散列映射表</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结构示意图：</p>\n<p><img src=\"/images/concurrentHashMap/image005.jpg\" alt=\"ConcurrentHashMap\"></p>\n<h2 id=\"HashEntry-类\"><a href=\"#HashEntry-类\" class=\"headerlink\" title=\"HashEntry 类\"></a>HashEntry 类</h2><p>HashEntry 用来封装散列映射表中的键值对。在 HashEntry 类中，key，hash 和 next 域都被声明为 final 型，value 域被声明为 volatile 型。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashEntry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123; </span><br><span class=\"line\">       <span class=\"keyword\">final</span> K key;                       <span class=\"comment\">// 声明 key 为 final 型</span></span><br><span class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> hash;                   <span class=\"comment\">// 声明 hash 值为 final 型 </span></span><br><span class=\"line\">       <span class=\"keyword\">volatile</span> V value;                 <span class=\"comment\">// 声明 value 为 volatile 型</span></span><br><span class=\"line\">       <span class=\"keyword\">final</span> HashEntry&lt;K,V&gt; next;      <span class=\"comment\">// 声明 next 为 final 型 </span></span><br><span class=\"line\"> </span><br><span class=\"line\">       HashEntry(K key, <span class=\"keyword\">int</span> hash, HashEntry&lt;K,V&gt; next, V value) &#123; </span><br><span class=\"line\">           <span class=\"keyword\">this</span>.key = key; </span><br><span class=\"line\">           <span class=\"keyword\">this</span>.hash = hash; </span><br><span class=\"line\">           <span class=\"keyword\">this</span>.next = next; </span><br><span class=\"line\">           <span class=\"keyword\">this</span>.value = value; </span><br><span class=\"line\">       &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 ConcurrentHashMap 中，在散列时如果产生“碰撞”，将采用“分离链接法”来处理“碰撞”：把“碰撞”的 HashEntry 对象链接成一个链表。由于 HashEntry 的 next 域为 final 型，所以新节点只能在链表的表头处插入。</p>\n<h2 id=\"Segment-类\"><a href=\"#Segment-类\" class=\"headerlink\" title=\"Segment 类\"></a>Segment 类</h2><p>Segment 类继承于 ReentrantLock 类，从而使得 Segment 对象能充当锁的角色。每个 Segment 对象用来守护其（成员对象 table 中）包含的若干个桶。</p>\n<p>table 是一个由 HashEntry 对象组成的数组。table 数组的每一个数组成员就是散列映射表的一个桶。</p>\n<p>count 变量是一个计数器，它表示每个 Segment 对象管理的 table 数组（若干个 HashEntry 组成的链表）包含的 HashEntry 对象的个数。每一个 Segment 对象都有一个 count 对象来表示本 Segment 中包含的 HashEntry 对象的总数。注意，之所以在每个 Segment 对象中包含一个计数器，而不是在 <code>ConcurrentHashMap 中使用全局的计数器，是为了避免出现“热点域”而影响 ConcurrentHashMap 的并发性。</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Segment</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">ReentrantLock</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span> </span>&#123; </span><br><span class=\"line\">       <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">        * 在本 segment 范围内，包含的 HashEntry 元素的个数</span></span><br><span class=\"line\"><span class=\"comment\">        * 该变量被声明为 volatile 型</span></span><br><span class=\"line\"><span class=\"comment\">        */</span> </span><br><span class=\"line\">       <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> count; </span><br><span class=\"line\"> </span><br><span class=\"line\">       <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">        * table 被更新的次数</span></span><br><span class=\"line\"><span class=\"comment\">        */</span> </span><br><span class=\"line\">       <span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> modCount; </span><br><span class=\"line\"> </span><br><span class=\"line\">       <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">        * 当 table 中包含的 HashEntry 元素的个数超过本变量值时，触发 table 的再散列</span></span><br><span class=\"line\"><span class=\"comment\">        */</span> </span><br><span class=\"line\">       <span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> threshold; </span><br><span class=\"line\"> </span><br><span class=\"line\">       <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">        * table 是由 HashEntry 对象组成的数组</span></span><br><span class=\"line\"><span class=\"comment\">        * 如果散列时发生碰撞，碰撞的 HashEntry 对象就以链表的形式链接成一个链表</span></span><br><span class=\"line\"><span class=\"comment\">        * table 数组的数组成员代表散列映射表的一个桶</span></span><br><span class=\"line\"><span class=\"comment\">        * 每个 table 守护整个 ConcurrentHashMap 包含桶总数的一部分</span></span><br><span class=\"line\"><span class=\"comment\">        * 如果并发级别为 16，table 则守护 ConcurrentHashMap 包含的桶总数的 1/16 </span></span><br><span class=\"line\"><span class=\"comment\">        */</span> </span><br><span class=\"line\">       <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> HashEntry&lt;K,V&gt;[] table; </span><br><span class=\"line\"> </span><br><span class=\"line\">       <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">        * 装载因子</span></span><br><span class=\"line\"><span class=\"comment\">        */</span> </span><br><span class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> loadFactor; </span><br><span class=\"line\"> </span><br><span class=\"line\">       Segment(<span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">float</span> lf) &#123; </span><br><span class=\"line\">           loadFactor = lf; </span><br><span class=\"line\">           setTable(HashEntry.&lt;K,V&gt;newArray(initialCapacity)); </span><br><span class=\"line\">       &#125; </span><br><span class=\"line\"> </span><br><span class=\"line\">       <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">        * 设置 table 引用到这个新生成的 HashEntry 数组</span></span><br><span class=\"line\"><span class=\"comment\">        * 只能在持有锁或构造函数中调用本方法</span></span><br><span class=\"line\"><span class=\"comment\">        */</span> </span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setTable</span><span class=\"params\">(HashEntry&lt;K,V&gt;[] newTable)</span> </span>&#123; </span><br><span class=\"line\">           <span class=\"comment\">// 计算临界阀值为新数组的长度与装载因子的乘积</span></span><br><span class=\"line\">           threshold = (<span class=\"keyword\">int</span>)(newTable.length * loadFactor); </span><br><span class=\"line\">           table = newTable; </span><br><span class=\"line\">       &#125; </span><br><span class=\"line\"> </span><br><span class=\"line\">       <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">        * 根据 key 的散列值，找到 table 中对应的那个桶（table 数组的某个数组成员）</span></span><br><span class=\"line\"><span class=\"comment\">        */</span> </span><br><span class=\"line\">       <span class=\"function\">HashEntry&lt;K,V&gt; <span class=\"title\">getFirst</span><span class=\"params\">(<span class=\"keyword\">int</span> hash)</span> </span>&#123; </span><br><span class=\"line\">           HashEntry&lt;K,V&gt;[] tab = table; </span><br><span class=\"line\">           <span class=\"comment\">// 把散列值与 table 数组长度减 1 的值相“与”，</span></span><br><span class=\"line\"><span class=\"comment\">// 得到散列值对应的 table 数组的下标</span></span><br><span class=\"line\">           <span class=\"comment\">// 然后返回 table 数组中此下标对应的 HashEntry 元素</span></span><br><span class=\"line\">           <span class=\"keyword\">return</span> tab[hash &amp; (tab.length - <span class=\"number\">1</span>)]; </span><br><span class=\"line\">       &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>插入三个节点后 Segment 的结构示意图：</p>\n<p><img src=\"/images/concurrentHashMap/image004.jpg\" alt=\"Segment\"></p>\n<h2 id=\"Put-方法的实现\"><a href=\"#Put-方法的实现\" class=\"headerlink\" title=\"Put 方法的实现\"></a>Put 方法的实现</h2><p>1.根据 key 计算出对应的 hash 值：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123; </span><br><span class=\"line\">       <span class=\"keyword\">if</span> (value == <span class=\"keyword\">null</span>)          <span class=\"comment\">//ConcurrentHashMap 中不允许用 null 作为映射值</span></span><br><span class=\"line\">           <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(); </span><br><span class=\"line\">       <span class=\"keyword\">int</span> hash = hash(key.hashCode());        <span class=\"comment\">// 计算键对应的散列码</span></span><br><span class=\"line\">       <span class=\"comment\">// 根据散列码找到对应的 Segment </span></span><br><span class=\"line\">       <span class=\"keyword\">return</span> segmentFor(hash).put(key, hash, value, <span class=\"keyword\">false</span>); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2.根据 hash 值找到对应的 Segment:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * 使用 key 的散列码来得到 segments 数组中对应的 Segment </span></span><br><span class=\"line\"><span class=\"comment\">    */</span> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Segment&lt;K,V&gt; <span class=\"title\">segmentFor</span><span class=\"params\">(<span class=\"keyword\">int</span> hash)</span> </span>&#123; </span><br><span class=\"line\">   <span class=\"comment\">// 将散列值右移 segmentShift 个位，并在高位填充 0 </span></span><br><span class=\"line\">   <span class=\"comment\">// 然后把得到的值与 segmentMask 相“与”</span></span><br><span class=\"line\"><span class=\"comment\">// 从而得到 hash 值对应的 segments 数组的下标值</span></span><br><span class=\"line\"><span class=\"comment\">// 最后根据下标值返回散列码对应的 Segment 对象</span></span><br><span class=\"line\">       <span class=\"keyword\">return</span> segments[(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask]; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>3.在 Segment 中执行具体的 put 操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">V <span class=\"title\">put</span><span class=\"params\">(K key, <span class=\"keyword\">int</span> hash, V value, <span class=\"keyword\">boolean</span> onlyIfAbsent)</span> </span>&#123; </span><br><span class=\"line\">           lock();  <span class=\"comment\">// 加锁，这里是锁定某个 Segment 对象而非整个 ConcurrentHashMap </span></span><br><span class=\"line\">           <span class=\"keyword\">try</span> &#123; </span><br><span class=\"line\">               <span class=\"keyword\">int</span> c = count; </span><br><span class=\"line\"> </span><br><span class=\"line\">               <span class=\"keyword\">if</span> (c++ &gt; threshold)     <span class=\"comment\">// 如果超过再散列的阈值</span></span><br><span class=\"line\">                   rehash();              <span class=\"comment\">// 执行再散列，table 数组的长度将扩充一倍</span></span><br><span class=\"line\"> </span><br><span class=\"line\">               HashEntry&lt;K,V&gt;[] tab = table; </span><br><span class=\"line\">               <span class=\"comment\">// 把散列码值与 table 数组的长度减 1 的值相“与”</span></span><br><span class=\"line\">               <span class=\"comment\">// 得到该散列码对应的 table 数组的下标值</span></span><br><span class=\"line\">               <span class=\"keyword\">int</span> index = hash &amp; (tab.length - <span class=\"number\">1</span>); </span><br><span class=\"line\">               <span class=\"comment\">// 找到散列码对应的具体的那个桶</span></span><br><span class=\"line\">               HashEntry&lt;K,V&gt; first = tab[index]; </span><br><span class=\"line\"> </span><br><span class=\"line\">               HashEntry&lt;K,V&gt; e = first; </span><br><span class=\"line\">               <span class=\"keyword\">while</span> (e != <span class=\"keyword\">null</span> &amp;&amp; (e.hash != hash || !key.equals(e.key))) </span><br><span class=\"line\">                   e = e.next; </span><br><span class=\"line\"> </span><br><span class=\"line\">               V oldValue; </span><br><span class=\"line\">               <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123;            <span class=\"comment\">// 如果键 / 值对以经存在</span></span><br><span class=\"line\">                   oldValue = e.value; </span><br><span class=\"line\">                   <span class=\"keyword\">if</span> (!onlyIfAbsent) </span><br><span class=\"line\">                       e.value = value;    <span class=\"comment\">// 设置 value 值</span></span><br><span class=\"line\">               &#125; </span><br><span class=\"line\">               <span class=\"keyword\">else</span> &#123;                        <span class=\"comment\">// 键 / 值对不存在 </span></span><br><span class=\"line\">                   oldValue = <span class=\"keyword\">null</span>; </span><br><span class=\"line\">                   ++modCount;         <span class=\"comment\">// 要添加新节点到链表中，所以 modCont 要加 1  </span></span><br><span class=\"line\">                   <span class=\"comment\">// 创建新节点，并添加到链表的头部 </span></span><br><span class=\"line\">                   tab[index] = <span class=\"keyword\">new</span> HashEntry&lt;K,V&gt;(key, hash, first, value); </span><br><span class=\"line\">                   count = c;               <span class=\"comment\">// 写 count 变量</span></span><br><span class=\"line\">               &#125; </span><br><span class=\"line\">               <span class=\"keyword\">return</span> oldValue; </span><br><span class=\"line\">           &#125; <span class=\"keyword\">finally</span> &#123; </span><br><span class=\"line\">               unlock();                     <span class=\"comment\">// 解锁</span></span><br><span class=\"line\">           &#125; </span><br><span class=\"line\">       &#125;</span><br></pre></td></tr></table></figure>\n<p>加锁操作是针对（键的 hash 值对应的）某个具体的 Segment，锁定的是该 Segment 而不是整个 ConcurrentHashMap<code>。因为插入键 / 值对操作只是在这个 Segment 包含的某个桶中完成，不需要锁定整个</code>ConcurrentHashMap。<code>此时，其他写线程对另外 15 个</code>Segment 的加锁并不会因为当前线程对这个 Segment 的加锁而阻塞。同时，所有读线程几乎不会因本线程的加锁而阻塞（除非读线程刚好读到这个 Segment 中某个 <code>HashEntry 的 value 域的值为 null，此时需要加锁后重新读取该值</code>）。</p>\n<p>相比较于 <code>HashTable 和由同步包装器包装的 HashMap`</code>每次只能有一个线程执行读或写操作，`ConcurrentHashMap 在并发访问性能上有了质的提高。<em>在理想状态下</em>，ConcurrentHashMap 可以支持 16 个线程执行并发写操作（如果并发级别设置为 16），及任意数量线程的读操作。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>ConcurrentHashMap 是一个并发散列映射表的实现，它允许完全并发的读取，并且支持给定数量的并发更新。相比于 <code>HashTable 和</code>用同步包装器包装的 HashMap（Collections.synchronizedMap(new HashMap())），ConcurrentHashMap 拥有更高的并发性。在 <code>HashTable 和由同步包装器包装的 HashMap 中，使用一个全局的锁来同步不同线程间的并发访问。同一时间点，只能有一个线程持有锁，也就是说在同一时间点，只能有一个线程能访问容器。这虽然保证多线程间的安全并发访问，但同时也导致对容器的访问变成`</code><em>串行化</em><code></code>的了。`</p>\n<p>在使用锁来协调多线程间并发访问的模式下，减小对锁的竞争可以有效提高并发性。有两种方式可以减小对锁的竞争：</p>\n<ol>\n<li>减小请求 同一个锁的 频率。</li>\n<li>减少持有锁的 时间。</li>\n</ol>\n<p>ConcurrentHashMap 的高并发性主要来自于三个方面：</p>\n<ol>\n<li>用分离锁实现多个线程间的更深层次的共享访问。</li>\n<li>用 HashEntery 对象的不变性来降低执行读操作的线程在遍历链表期间对加锁的需求。</li>\n<li>通过对同一个 Volatile 变量的写 / 读访问，协调不同线程间读 / 写操作的内存可见性。</li>\n</ol>\n<p>使用分离锁，减小了请求 <em>同一个锁</em>的频率。</p>\n<p>通过 HashEntery 对象的不变性及对同一个 Volatile 变量的读 / 写来协调内存可见性，使得 读操作大多数时候不需要加锁就能成功获取到需要的值。由于散列映射表在实际应用中大多数操作都是成功的 读操作，所以 2 和 3 既可以减少请求同一个锁的频率，也可以有效减少持有锁的时间。</p>\n<p>通过减小请求同一个锁的频率和尽量减少持有锁的时间 <code>，使得 ConcurrentHashMap 的并发性相对于 HashTable 和</code>用同步包装器包装的 HashMap<code>有了质的提高。</code></p>"},{"title":"基于Redis分布式锁","author":"James","date":"2017-05-08T02:21:00.000Z","_content":"\n# 关于分布式锁\n\n分布式环境下，数据一致性问题一直是一个比较重要的话题，而又不同于单进程的情况。分布式与单机情况下最大的不同在于其不是多线程而是多进程。多线程由于可以共享堆内存，因此可以简单的采取内存作为标记存储位置。而进程之间甚至可能都不在同一台物理机上，因此需要将标记存储在一个所有进程都能看到的地方。\n\n<!-- more -->\n\n## 常见分布式锁方案\n\n- 基于数据库实现分布式锁  \n- 基于缓存的锁实现方案，如 redis\n- 基于Zookeeper实现分布式锁 \n\n本文将讨论第二种方式，基于Redis实现分布式锁。 \n\n# 基于Redis的实现\n\n## 可靠性\n\n1. **排他性**：任意时刻只能一个客户端自有其锁\n2. **避免死锁** ：如果某个持有锁的客户端发生异常，而不能主动释放锁，其他客户端也能获得锁\n3. **容错性**：大部分节点能够正常运行，就能保证加锁和释放 \n\n\n\n## 思路\n\n使用redis的SETNX实现分布式锁，多个进程执行以下Redis命令： \n\n```bash\nSETNX lock.id <current Unix time + lock timeout + 1>\n```\n\nSETNX是将 key 的值设为 value，当且仅当 key 不存在。若给定的 key 已经存在，则 SETNX 不做任何动作。   \n\n- 返回1，说明该进程获得锁，SETNX将键 lock.id 的值设置为锁的超时时间，当前时间 +加上锁的有效时间。 \n- 返回0，说明其他进程已经获得了锁，进程不能进入临界区。进程可以在一个循环中不断地尝试 SETNX 操作，以获得锁。\n\n\n\n## 实现方式1\n\n获得锁\n\n```java\n    public void lock(Integer sec) throws Exception{\n        Boolean lock = Boolean.FALSE;\n        Long curr = System.currentTimeMillis();//TODO 需要每个实例自己生成过期时间，要求多个客户端之间需要时间同步\n        Long timeout = sec * LOCK_TIME_MILLIS;\n        Long timestamp = curr + timeout;\n        Long blockTime = timeout;\n        while(!lock){\n            // SETNX方式尝试获得锁\n            lock = mainRedis.opsForValue().setIfAbsent(lock_key, timestamp.toString());\n            if(lock){\n                //设置失效时间\n                mainRedis.expire(lock_key, timeout, TimeUnit.MILLISECONDS);//设置超时\n                lock_value = timestamp.toString();\n                return;\n            }\n            //超过重试次数unlock 此步骤避免超时设置失败导致异常\n            blockTime -= WAIT_TIME_MILLIS;\n            if( blockTime <= 0 ){\n                String lock_value = mainRedis.opsForValue().get(lock_key);\n                if(lock_value != null && Long.valueOf(lock_value) < curr)//TODO 时间不同步，可能导致误解锁\n                    mainRedis.delete(lock_key);//TODO 非原子操作，可能导致误解锁.需借鉴lua脚本执行的方式\n            }\n            Thread.sleep(WAIT_TIME_MILLIS);\"+blockTime);\n        }\n    }\n```\n\n- lock_key来当锁。\n- timestamp作为value,在解锁的时候能有依据。\n- SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作。\n-  timeout 为过期时间，超时判断\n- blockTime  避免超时设置失败导致异常,当重试获得锁次数达到时候解锁\n\n释放锁\n\n```java\n  public void unlock(){\n        mainRedis.execute(new RedisCallback<Boolean>() {\n            @Override\n            public Boolean doInRedis(RedisConnection connection) throws DataAccessException {\n                connection.watch(lock_key_bytes);//redis事务,防止此时key超时，其他实例获得新锁被误删除\n                String alive_lock_value = KeyUtils.decode(connection.get(lock_key_bytes));\n                connection.multi();\n                //对比value是否为当前线程\n                if (alive_lock_value != null && lock_value.equals(alive_lock_value)){\n                    connection.del(lock_key_bytes);\n                }\n                return connection.exec() != null;\n            }\n        });\n    }\n```\n\n## 实现方式2\n\n最新版本jedis 解决获取锁设置失效时间原子问题，下面代码仅供参考:\n\n```java\npublic boolean lock(String key, String request, int blockTime) throws InterruptedException {\n\n        while (blockTime >= 0) {\n\n            String result = this.jedis.set(lockPrefix + key, request, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, 10 * TIME);\n            if (LOCK_MSG.equals(result)) {\n                return true;\n            }\n            blockTime -= sleepTime;\n\n            Thread.sleep(sleepTime);\n        }\n        return false;\n}\n```\n\n\n\n## 实现方式3\n\n设置Reids key超时时候可以用lua脚本达到原子操作。Redis如何实现的原子操作的呢?\n\nRedis 使用单个 Lua 解释器去运行所有脚本，并且 Redis 也保证脚本会以原子性(atomic)的方式执行：当某个脚本正在运行的时候，不会有其他脚本或 Redis 命令被执行。 \n\n# 总结\n\n至此一个基于 Redis 的分布式锁完成，但是依然有些问题。\n\n- 需要每个实例自己生成过期时间，要求多个客户端之间需要时间同步。\n- 设置key超时时候可以用lua脚本达到原子操作。或者用新版本jedis包。\n- 就算 Redis 是集群部署的，如果每个节点都只是 master 没有 slave，那么 master 宕机时该节点上的所有 key  在那一时刻都相当于是释放锁了，这样也会出现并发问题。就算是有 slave 节点，但如果在数据同步到 salve 之前 master  宕机也是会出现上面的问题。\n\n感兴趣的朋友还可以参考 [Redisson](https://github.com/redisson/redisson) 的实现。","source":"_posts/RedisLock.md","raw":"title: 基于Redis分布式锁\nauthor: James\ntags:\n  - redis\n  - lock\ncategories:\n  - 架构\ndate: 2017-05-08 10:21:00\n---\n\n# 关于分布式锁\n\n分布式环境下，数据一致性问题一直是一个比较重要的话题，而又不同于单进程的情况。分布式与单机情况下最大的不同在于其不是多线程而是多进程。多线程由于可以共享堆内存，因此可以简单的采取内存作为标记存储位置。而进程之间甚至可能都不在同一台物理机上，因此需要将标记存储在一个所有进程都能看到的地方。\n\n<!-- more -->\n\n## 常见分布式锁方案\n\n- 基于数据库实现分布式锁  \n- 基于缓存的锁实现方案，如 redis\n- 基于Zookeeper实现分布式锁 \n\n本文将讨论第二种方式，基于Redis实现分布式锁。 \n\n# 基于Redis的实现\n\n## 可靠性\n\n1. **排他性**：任意时刻只能一个客户端自有其锁\n2. **避免死锁** ：如果某个持有锁的客户端发生异常，而不能主动释放锁，其他客户端也能获得锁\n3. **容错性**：大部分节点能够正常运行，就能保证加锁和释放 \n\n\n\n## 思路\n\n使用redis的SETNX实现分布式锁，多个进程执行以下Redis命令： \n\n```bash\nSETNX lock.id <current Unix time + lock timeout + 1>\n```\n\nSETNX是将 key 的值设为 value，当且仅当 key 不存在。若给定的 key 已经存在，则 SETNX 不做任何动作。   \n\n- 返回1，说明该进程获得锁，SETNX将键 lock.id 的值设置为锁的超时时间，当前时间 +加上锁的有效时间。 \n- 返回0，说明其他进程已经获得了锁，进程不能进入临界区。进程可以在一个循环中不断地尝试 SETNX 操作，以获得锁。\n\n\n\n## 实现方式1\n\n获得锁\n\n```java\n    public void lock(Integer sec) throws Exception{\n        Boolean lock = Boolean.FALSE;\n        Long curr = System.currentTimeMillis();//TODO 需要每个实例自己生成过期时间，要求多个客户端之间需要时间同步\n        Long timeout = sec * LOCK_TIME_MILLIS;\n        Long timestamp = curr + timeout;\n        Long blockTime = timeout;\n        while(!lock){\n            // SETNX方式尝试获得锁\n            lock = mainRedis.opsForValue().setIfAbsent(lock_key, timestamp.toString());\n            if(lock){\n                //设置失效时间\n                mainRedis.expire(lock_key, timeout, TimeUnit.MILLISECONDS);//设置超时\n                lock_value = timestamp.toString();\n                return;\n            }\n            //超过重试次数unlock 此步骤避免超时设置失败导致异常\n            blockTime -= WAIT_TIME_MILLIS;\n            if( blockTime <= 0 ){\n                String lock_value = mainRedis.opsForValue().get(lock_key);\n                if(lock_value != null && Long.valueOf(lock_value) < curr)//TODO 时间不同步，可能导致误解锁\n                    mainRedis.delete(lock_key);//TODO 非原子操作，可能导致误解锁.需借鉴lua脚本执行的方式\n            }\n            Thread.sleep(WAIT_TIME_MILLIS);\"+blockTime);\n        }\n    }\n```\n\n- lock_key来当锁。\n- timestamp作为value,在解锁的时候能有依据。\n- SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作。\n-  timeout 为过期时间，超时判断\n- blockTime  避免超时设置失败导致异常,当重试获得锁次数达到时候解锁\n\n释放锁\n\n```java\n  public void unlock(){\n        mainRedis.execute(new RedisCallback<Boolean>() {\n            @Override\n            public Boolean doInRedis(RedisConnection connection) throws DataAccessException {\n                connection.watch(lock_key_bytes);//redis事务,防止此时key超时，其他实例获得新锁被误删除\n                String alive_lock_value = KeyUtils.decode(connection.get(lock_key_bytes));\n                connection.multi();\n                //对比value是否为当前线程\n                if (alive_lock_value != null && lock_value.equals(alive_lock_value)){\n                    connection.del(lock_key_bytes);\n                }\n                return connection.exec() != null;\n            }\n        });\n    }\n```\n\n## 实现方式2\n\n最新版本jedis 解决获取锁设置失效时间原子问题，下面代码仅供参考:\n\n```java\npublic boolean lock(String key, String request, int blockTime) throws InterruptedException {\n\n        while (blockTime >= 0) {\n\n            String result = this.jedis.set(lockPrefix + key, request, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, 10 * TIME);\n            if (LOCK_MSG.equals(result)) {\n                return true;\n            }\n            blockTime -= sleepTime;\n\n            Thread.sleep(sleepTime);\n        }\n        return false;\n}\n```\n\n\n\n## 实现方式3\n\n设置Reids key超时时候可以用lua脚本达到原子操作。Redis如何实现的原子操作的呢?\n\nRedis 使用单个 Lua 解释器去运行所有脚本，并且 Redis 也保证脚本会以原子性(atomic)的方式执行：当某个脚本正在运行的时候，不会有其他脚本或 Redis 命令被执行。 \n\n# 总结\n\n至此一个基于 Redis 的分布式锁完成，但是依然有些问题。\n\n- 需要每个实例自己生成过期时间，要求多个客户端之间需要时间同步。\n- 设置key超时时候可以用lua脚本达到原子操作。或者用新版本jedis包。\n- 就算 Redis 是集群部署的，如果每个节点都只是 master 没有 slave，那么 master 宕机时该节点上的所有 key  在那一时刻都相当于是释放锁了，这样也会出现并发问题。就算是有 slave 节点，但如果在数据同步到 salve 之前 master  宕机也是会出现上面的问题。\n\n感兴趣的朋友还可以参考 [Redisson](https://github.com/redisson/redisson) 的实现。","slug":"RedisLock","published":1,"updated":"2018-05-28T06:42:57.786Z","_id":"cjh09eio80000okkcjzywyj48","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"关于分布式锁\"><a href=\"#关于分布式锁\" class=\"headerlink\" title=\"关于分布式锁\"></a>关于分布式锁</h1><p>分布式环境下，数据一致性问题一直是一个比较重要的话题，而又不同于单进程的情况。分布式与单机情况下最大的不同在于其不是多线程而是多进程。多线程由于可以共享堆内存，因此可以简单的采取内存作为标记存储位置。而进程之间甚至可能都不在同一台物理机上，因此需要将标记存储在一个所有进程都能看到的地方。</p>\n<a id=\"more\"></a>\n<h2 id=\"常见分布式锁方案\"><a href=\"#常见分布式锁方案\" class=\"headerlink\" title=\"常见分布式锁方案\"></a>常见分布式锁方案</h2><ul>\n<li>基于数据库实现分布式锁  </li>\n<li>基于缓存的锁实现方案，如 redis</li>\n<li>基于Zookeeper实现分布式锁 </li>\n</ul>\n<p>本文将讨论第二种方式，基于Redis实现分布式锁。 </p>\n<h1 id=\"基于Redis的实现\"><a href=\"#基于Redis的实现\" class=\"headerlink\" title=\"基于Redis的实现\"></a>基于Redis的实现</h1><h2 id=\"可靠性\"><a href=\"#可靠性\" class=\"headerlink\" title=\"可靠性\"></a>可靠性</h2><ol>\n<li><strong>排他性</strong>：任意时刻只能一个客户端自有其锁</li>\n<li><strong>避免死锁</strong> ：如果某个持有锁的客户端发生异常，而不能主动释放锁，其他客户端也能获得锁</li>\n<li><strong>容错性</strong>：大部分节点能够正常运行，就能保证加锁和释放 </li>\n</ol>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>使用redis的SETNX实现分布式锁，多个进程执行以下Redis命令： </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SETNX lock.id &lt;current Unix time + lock timeout + 1&gt;</span><br></pre></td></tr></table></figure>\n<p>SETNX是将 key 的值设为 value，当且仅当 key 不存在。若给定的 key 已经存在，则 SETNX 不做任何动作。   </p>\n<ul>\n<li>返回1，说明该进程获得锁，SETNX将键 lock.id 的值设置为锁的超时时间，当前时间 +加上锁的有效时间。 </li>\n<li>返回0，说明其他进程已经获得了锁，进程不能进入临界区。进程可以在一个循环中不断地尝试 SETNX 操作，以获得锁。</li>\n</ul>\n<h2 id=\"实现方式1\"><a href=\"#实现方式1\" class=\"headerlink\" title=\"实现方式1\"></a>实现方式1</h2><p>获得锁</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">(Integer sec)</span> <span class=\"keyword\">throws</span> Exception</span>&#123;</span><br><span class=\"line\">    Boolean lock = Boolean.FALSE;</span><br><span class=\"line\">    Long curr = System.currentTimeMillis();<span class=\"comment\">//TODO 需要每个实例自己生成过期时间，要求多个客户端之间需要时间同步</span></span><br><span class=\"line\">    Long timeout = sec * LOCK_TIME_MILLIS;</span><br><span class=\"line\">    Long timestamp = curr + timeout;</span><br><span class=\"line\">    Long blockTime = timeout;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!lock)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// SETNX方式尝试获得锁</span></span><br><span class=\"line\">        lock = mainRedis.opsForValue().setIfAbsent(lock_key, timestamp.toString());</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(lock)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//设置失效时间</span></span><br><span class=\"line\">            mainRedis.expire(lock_key, timeout, TimeUnit.MILLISECONDS);<span class=\"comment\">//设置超时</span></span><br><span class=\"line\">            lock_value = timestamp.toString();</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//超过重试次数unlock 此步骤避免超时设置失败导致异常</span></span><br><span class=\"line\">        blockTime -= WAIT_TIME_MILLIS;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>( blockTime &lt;= <span class=\"number\">0</span> )&#123;</span><br><span class=\"line\">            String lock_value = mainRedis.opsForValue().get(lock_key);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(lock_value != <span class=\"keyword\">null</span> &amp;&amp; Long.valueOf(lock_value) &lt; curr)<span class=\"comment\">//TODO 时间不同步，可能导致误解锁</span></span><br><span class=\"line\">                mainRedis.delete(lock_key);<span class=\"comment\">//TODO 非原子操作，可能导致误解锁.需借鉴lua脚本执行的方式</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Thread.sleep(WAIT_TIME_MILLIS);<span class=\"string\">\"+blockTime);</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>lock_key来当锁。</li>\n<li>timestamp作为value,在解锁的时候能有依据。</li>\n<li>SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作。</li>\n<li>timeout 为过期时间，超时判断</li>\n<li>blockTime  避免超时设置失败导致异常,当重试获得锁次数达到时候解锁</li>\n</ul>\n<p>释放锁</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">unlock</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">      mainRedis.execute(<span class=\"keyword\">new</span> RedisCallback&lt;Boolean&gt;() &#123;</span><br><span class=\"line\">          <span class=\"meta\">@Override</span></span><br><span class=\"line\">          <span class=\"function\"><span class=\"keyword\">public</span> Boolean <span class=\"title\">doInRedis</span><span class=\"params\">(RedisConnection connection)</span> <span class=\"keyword\">throws</span> DataAccessException </span>&#123;</span><br><span class=\"line\">              connection.watch(lock_key_bytes);<span class=\"comment\">//redis事务,防止此时key超时，其他实例获得新锁被误删除</span></span><br><span class=\"line\">              String alive_lock_value = KeyUtils.decode(connection.get(lock_key_bytes));</span><br><span class=\"line\">              connection.multi();</span><br><span class=\"line\">              <span class=\"comment\">//对比value是否为当前线程</span></span><br><span class=\"line\">              <span class=\"keyword\">if</span> (alive_lock_value != <span class=\"keyword\">null</span> &amp;&amp; lock_value.equals(alive_lock_value))&#123;</span><br><span class=\"line\">                  connection.del(lock_key_bytes);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> connection.exec() != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"实现方式2\"><a href=\"#实现方式2\" class=\"headerlink\" title=\"实现方式2\"></a>实现方式2</h2><p>最新版本jedis 解决获取锁设置失效时间原子问题，下面代码仅供参考:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">lock</span><span class=\"params\">(String key, String request, <span class=\"keyword\">int</span> blockTime)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (blockTime &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            String result = <span class=\"keyword\">this</span>.jedis.set(lockPrefix + key, request, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, <span class=\"number\">10</span> * TIME);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (LOCK_MSG.equals(result)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            blockTime -= sleepTime;</span><br><span class=\"line\"></span><br><span class=\"line\">            Thread.sleep(sleepTime);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"实现方式3\"><a href=\"#实现方式3\" class=\"headerlink\" title=\"实现方式3\"></a>实现方式3</h2><p>设置Reids key超时时候可以用lua脚本达到原子操作。Redis如何实现的原子操作的呢?</p>\n<p>Redis 使用单个 Lua 解释器去运行所有脚本，并且 Redis 也保证脚本会以原子性(atomic)的方式执行：当某个脚本正在运行的时候，不会有其他脚本或 Redis 命令被执行。 </p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>至此一个基于 Redis 的分布式锁完成，但是依然有些问题。</p>\n<ul>\n<li>需要每个实例自己生成过期时间，要求多个客户端之间需要时间同步。</li>\n<li>设置key超时时候可以用lua脚本达到原子操作。或者用新版本jedis包。</li>\n<li>就算 Redis 是集群部署的，如果每个节点都只是 master 没有 slave，那么 master 宕机时该节点上的所有 key  在那一时刻都相当于是释放锁了，这样也会出现并发问题。就算是有 slave 节点，但如果在数据同步到 salve 之前 master  宕机也是会出现上面的问题。</li>\n</ul>\n<p>感兴趣的朋友还可以参考 <a href=\"https://github.com/redisson/redisson\" target=\"_blank\" rel=\"noopener\">Redisson</a> 的实现。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"关于分布式锁\"><a href=\"#关于分布式锁\" class=\"headerlink\" title=\"关于分布式锁\"></a>关于分布式锁</h1><p>分布式环境下，数据一致性问题一直是一个比较重要的话题，而又不同于单进程的情况。分布式与单机情况下最大的不同在于其不是多线程而是多进程。多线程由于可以共享堆内存，因此可以简单的采取内存作为标记存储位置。而进程之间甚至可能都不在同一台物理机上，因此需要将标记存储在一个所有进程都能看到的地方。</p>","more":"<h2 id=\"常见分布式锁方案\"><a href=\"#常见分布式锁方案\" class=\"headerlink\" title=\"常见分布式锁方案\"></a>常见分布式锁方案</h2><ul>\n<li>基于数据库实现分布式锁  </li>\n<li>基于缓存的锁实现方案，如 redis</li>\n<li>基于Zookeeper实现分布式锁 </li>\n</ul>\n<p>本文将讨论第二种方式，基于Redis实现分布式锁。 </p>\n<h1 id=\"基于Redis的实现\"><a href=\"#基于Redis的实现\" class=\"headerlink\" title=\"基于Redis的实现\"></a>基于Redis的实现</h1><h2 id=\"可靠性\"><a href=\"#可靠性\" class=\"headerlink\" title=\"可靠性\"></a>可靠性</h2><ol>\n<li><strong>排他性</strong>：任意时刻只能一个客户端自有其锁</li>\n<li><strong>避免死锁</strong> ：如果某个持有锁的客户端发生异常，而不能主动释放锁，其他客户端也能获得锁</li>\n<li><strong>容错性</strong>：大部分节点能够正常运行，就能保证加锁和释放 </li>\n</ol>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>使用redis的SETNX实现分布式锁，多个进程执行以下Redis命令： </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SETNX lock.id &lt;current Unix time + lock timeout + 1&gt;</span><br></pre></td></tr></table></figure>\n<p>SETNX是将 key 的值设为 value，当且仅当 key 不存在。若给定的 key 已经存在，则 SETNX 不做任何动作。   </p>\n<ul>\n<li>返回1，说明该进程获得锁，SETNX将键 lock.id 的值设置为锁的超时时间，当前时间 +加上锁的有效时间。 </li>\n<li>返回0，说明其他进程已经获得了锁，进程不能进入临界区。进程可以在一个循环中不断地尝试 SETNX 操作，以获得锁。</li>\n</ul>\n<h2 id=\"实现方式1\"><a href=\"#实现方式1\" class=\"headerlink\" title=\"实现方式1\"></a>实现方式1</h2><p>获得锁</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">(Integer sec)</span> <span class=\"keyword\">throws</span> Exception</span>&#123;</span><br><span class=\"line\">    Boolean lock = Boolean.FALSE;</span><br><span class=\"line\">    Long curr = System.currentTimeMillis();<span class=\"comment\">//TODO 需要每个实例自己生成过期时间，要求多个客户端之间需要时间同步</span></span><br><span class=\"line\">    Long timeout = sec * LOCK_TIME_MILLIS;</span><br><span class=\"line\">    Long timestamp = curr + timeout;</span><br><span class=\"line\">    Long blockTime = timeout;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!lock)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// SETNX方式尝试获得锁</span></span><br><span class=\"line\">        lock = mainRedis.opsForValue().setIfAbsent(lock_key, timestamp.toString());</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(lock)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//设置失效时间</span></span><br><span class=\"line\">            mainRedis.expire(lock_key, timeout, TimeUnit.MILLISECONDS);<span class=\"comment\">//设置超时</span></span><br><span class=\"line\">            lock_value = timestamp.toString();</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//超过重试次数unlock 此步骤避免超时设置失败导致异常</span></span><br><span class=\"line\">        blockTime -= WAIT_TIME_MILLIS;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>( blockTime &lt;= <span class=\"number\">0</span> )&#123;</span><br><span class=\"line\">            String lock_value = mainRedis.opsForValue().get(lock_key);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(lock_value != <span class=\"keyword\">null</span> &amp;&amp; Long.valueOf(lock_value) &lt; curr)<span class=\"comment\">//TODO 时间不同步，可能导致误解锁</span></span><br><span class=\"line\">                mainRedis.delete(lock_key);<span class=\"comment\">//TODO 非原子操作，可能导致误解锁.需借鉴lua脚本执行的方式</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Thread.sleep(WAIT_TIME_MILLIS);<span class=\"string\">\"+blockTime);</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>lock_key来当锁。</li>\n<li>timestamp作为value,在解锁的时候能有依据。</li>\n<li>SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作。</li>\n<li>timeout 为过期时间，超时判断</li>\n<li>blockTime  避免超时设置失败导致异常,当重试获得锁次数达到时候解锁</li>\n</ul>\n<p>释放锁</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">unlock</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">      mainRedis.execute(<span class=\"keyword\">new</span> RedisCallback&lt;Boolean&gt;() &#123;</span><br><span class=\"line\">          <span class=\"meta\">@Override</span></span><br><span class=\"line\">          <span class=\"function\"><span class=\"keyword\">public</span> Boolean <span class=\"title\">doInRedis</span><span class=\"params\">(RedisConnection connection)</span> <span class=\"keyword\">throws</span> DataAccessException </span>&#123;</span><br><span class=\"line\">              connection.watch(lock_key_bytes);<span class=\"comment\">//redis事务,防止此时key超时，其他实例获得新锁被误删除</span></span><br><span class=\"line\">              String alive_lock_value = KeyUtils.decode(connection.get(lock_key_bytes));</span><br><span class=\"line\">              connection.multi();</span><br><span class=\"line\">              <span class=\"comment\">//对比value是否为当前线程</span></span><br><span class=\"line\">              <span class=\"keyword\">if</span> (alive_lock_value != <span class=\"keyword\">null</span> &amp;&amp; lock_value.equals(alive_lock_value))&#123;</span><br><span class=\"line\">                  connection.del(lock_key_bytes);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> connection.exec() != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"实现方式2\"><a href=\"#实现方式2\" class=\"headerlink\" title=\"实现方式2\"></a>实现方式2</h2><p>最新版本jedis 解决获取锁设置失效时间原子问题，下面代码仅供参考:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">lock</span><span class=\"params\">(String key, String request, <span class=\"keyword\">int</span> blockTime)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (blockTime &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            String result = <span class=\"keyword\">this</span>.jedis.set(lockPrefix + key, request, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, <span class=\"number\">10</span> * TIME);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (LOCK_MSG.equals(result)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            blockTime -= sleepTime;</span><br><span class=\"line\"></span><br><span class=\"line\">            Thread.sleep(sleepTime);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"实现方式3\"><a href=\"#实现方式3\" class=\"headerlink\" title=\"实现方式3\"></a>实现方式3</h2><p>设置Reids key超时时候可以用lua脚本达到原子操作。Redis如何实现的原子操作的呢?</p>\n<p>Redis 使用单个 Lua 解释器去运行所有脚本，并且 Redis 也保证脚本会以原子性(atomic)的方式执行：当某个脚本正在运行的时候，不会有其他脚本或 Redis 命令被执行。 </p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>至此一个基于 Redis 的分布式锁完成，但是依然有些问题。</p>\n<ul>\n<li>需要每个实例自己生成过期时间，要求多个客户端之间需要时间同步。</li>\n<li>设置key超时时候可以用lua脚本达到原子操作。或者用新版本jedis包。</li>\n<li>就算 Redis 是集群部署的，如果每个节点都只是 master 没有 slave，那么 master 宕机时该节点上的所有 key  在那一时刻都相当于是释放锁了，这样也会出现并发问题。就算是有 slave 节点，但如果在数据同步到 salve 之前 master  宕机也是会出现上面的问题。</li>\n</ul>\n<p>感兴趣的朋友还可以参考 <a href=\"https://github.com/redisson/redisson\" target=\"_blank\" rel=\"noopener\">Redisson</a> 的实现。</p>"},{"title":"快速排序了解下","author":"James","date":"2015-05-17T02:03:00.000Z","_content":"\n# 前言\n\n排序算法可能是应用最广泛的算法了，它的特点是简单、适用于不同的输入数据并且在一般的应用中比其他的排序算法要快。快速排序采用的也是分治思想，但是与归并排序不同的是快速排序是原地排序并不需要使用辅助数组能节省更多的内存资源。 \n\n<!-- more -->\n\n# 基本算法\n\n快速排序是将一个数组分成两个子数组，并将两个子数组独立的排序。数组的切分与归并排序有很大的不同，快速排序是找出一个元素作为基准，然后确定这个基准元素在数组中的位置，在这个过程中使基准左边的元素都不大于它右边的元素都不小于它。快速排序就是递归的调用切分的方法来完成排序的。 \n\n## 切分的方式\n\n快速排序中最重要的就是步骤就是将小于等于中轴元素的放到中轴元素的左边，将大于中轴元素的放到中轴元素的右边，我们暂时把这个步骤定义为切分。而剩下的步骤就是进行递归而已，递归的边界条件为数组的元素个数小于等于1。以首元素作为中轴，看看常见的切分方式。 \n\n\n\n```java\n/* * 递归调用 * lo, hi用于跟踪递归进度 */ \npublic static void sort(char[] src, int lo, int hi) { \n    if (lo >= hi) return ; \n    int splitIndex = partition(src, lo, hi); \n    //切分 \n    sort(src, lo, splitIndex - 1); \n    sort(src, splitIndex + 1, hi); \n}\n\n/* * 快速排序的核心 * 用段落的第一个元素作为切分的标准 \n 将小于它的都放在左部分，大于它的都放在右部分  \n 从左到右找大的，从右到左找小的，做交换 \n * 最后找到最靠右的小于标准元素的元素与标准元素进行交换 \n */ \npublic static int partition(char[] src, int lo, int hi) { \n    int base = src[lo]; \n    int l = lo, h = hi + 1; \n    while (true) { \n        while (src[++l] < base) \n            if (l == hi) break; \n        while (src[--h] > base) \n            if (h == lo) break; if (l < h) \n                exchange(src, l, h); else break; \n    } /* * 这里的h换成l-1都可以，表示左侧部分最右的一个元素 */ \n    exchange(src, lo, h); return h; \n}\n```\n\n# 提高性能 \n\n在小数组排序的时候我们可以将快速排序替换为插入排序，这样会进一步提升快速排序的性能，改进后的代码像下面这样 \n\n```java\npublic static void sort(char[] src, int lo, int hi) { \n    if (lo >= hi) return ; \n    if((hi - lo +1) < 10) {\n        insertionSort(arr,low, high);\n        return;\n    }\n    int splitIndex = partition(src, lo, hi); \n    //切分 \n    sort(src, lo, splitIndex - 1); \n    sort(src, splitIndex + 1, hi); \n}\n```\n\n# 再提升\n\n在实际应用中，我们很少会处理无重复元素的数组，经常会遇到含有大量重复元素的数组，而我们之前的基础排序算法对于重复的元素仍对其进行比较和大量的交换，这显然是没有必要的，在其中我们便可以发现巨大的优化潜力，在特定的情况下将线性对数级别的性能进一步改进。 \n\n## 三向切分\n\n之前的算法是将数组分为两个部分，小于基准元素和大于基准元素，三向切分将数组分为三个部分：小于、等于和大于基准元素。所以我们需要更多的指针跟踪（lo, lt, i, gt, hi），我们让**a[ lo ... lt - 1 ]**存储小于基准元素的元素，**a[ lt ... i - 1]**存储等于基准元素的元素，**a[ i ... gt ]**存储未访问到、未确定大小的元素，**a[ gt + 1 ... hi ]**存储大于基准元素的元素。\n\n```java\npublic static void sort(char[] arr, int lo, int hi) { \n    int n = hi - lo + 1; // 当子数组的长度为 8 时，调用插入排序 \n    if (n <= CUTOFF) { insertionSort(arr, lo, hi); return; } \n    // 调用三取样切分 \n    int m = median3(arr, lo, lo + n / 2, hi); \n    exchange(arr, m, lo); \n    int lt = lo; int gt = hi;\n    int v = arr[lo]; \n    int i = lo;\n    while (i <= gt) { \n        // arr[i] < v，交换 arr[lt] & arr[i]，将 lt & i 加一 \n        if (arr[i] < v) { exchange(arr, lt++, i++); } \n        // arr[i] > v，交换 arr[gt] & arr[i]，将 gt 减一 else\n        if (arr[i] > v) { exchange(arr, i, gt--); } \n        // arr[i] == v，将 i 加一 \n        else { \n            i++; \n        } \n    } \n    // arr[lo...lt-1] < v = arr[lt...gt] < arr[gt+1...hi] \n    sort(arr, lo, lt - 1); \n    sort(arr, gt + 1, hi); \n}\n\n// 取 arr[i] arr[j] arr[k] 三个元素值的中间元素的下标 \nprivate static int median3(char[] arr, int i, int j, int k) { \n    return (less(arr[i], arr[j]) ? \n            (less(arr[j], arr[k]) ? j : less(arr[i], arr[k]) ? k : i) : \t\t\t\t\t(less(arr[k], arr[j]) ? j : less(arr[k], arr[i]) ? k : i)); \n}\n\n```\n\n\n\n# 快速排序的优势\n\n相对于那些**初级排序算法**（插入排序、选择排序等），快速排序的优势不用多说，平均情况的线性对数级别比平方级别在性能上要好太多。而最差情况的平方级别完全可以通过随机化避免。\n\n相对于**归并排序**。在空间上，归并排序的劣势显露无疑，归并排序需要线性级别的空间，所以只需要对数级别的空间。在时间上，上面已经进行了详细讨论，三向切分快速排序在实际应用中的性能优于归并排序很多。\n\n相对于**堆排序**。堆排序在时间和空间上都有非常好的效果，但是它总是跳跃式地访问元素，无法利用缓存，而快速排序总会顺序地访问元素，可以利用缓存。而缓存对于性能的提升是非常有用的。\n\n快速排序的内循环中的指令很少，运行时间的增长数量级为~cNlgN，并且三向切分的快速排序对于实际应用中可能出现的某些分布的输入变成了线性级别，这使得其他的排序算法望而却步。","source":"_posts/quicksort.md","raw":"title: 快速排序了解下\nauthor: James\ntags:\n  - 快速排序\ncategories:\n  - 算法\ndate: 2015-05-17 10:03:00\n---\n\n# 前言\n\n排序算法可能是应用最广泛的算法了，它的特点是简单、适用于不同的输入数据并且在一般的应用中比其他的排序算法要快。快速排序采用的也是分治思想，但是与归并排序不同的是快速排序是原地排序并不需要使用辅助数组能节省更多的内存资源。 \n\n<!-- more -->\n\n# 基本算法\n\n快速排序是将一个数组分成两个子数组，并将两个子数组独立的排序。数组的切分与归并排序有很大的不同，快速排序是找出一个元素作为基准，然后确定这个基准元素在数组中的位置，在这个过程中使基准左边的元素都不大于它右边的元素都不小于它。快速排序就是递归的调用切分的方法来完成排序的。 \n\n## 切分的方式\n\n快速排序中最重要的就是步骤就是将小于等于中轴元素的放到中轴元素的左边，将大于中轴元素的放到中轴元素的右边，我们暂时把这个步骤定义为切分。而剩下的步骤就是进行递归而已，递归的边界条件为数组的元素个数小于等于1。以首元素作为中轴，看看常见的切分方式。 \n\n\n\n```java\n/* * 递归调用 * lo, hi用于跟踪递归进度 */ \npublic static void sort(char[] src, int lo, int hi) { \n    if (lo >= hi) return ; \n    int splitIndex = partition(src, lo, hi); \n    //切分 \n    sort(src, lo, splitIndex - 1); \n    sort(src, splitIndex + 1, hi); \n}\n\n/* * 快速排序的核心 * 用段落的第一个元素作为切分的标准 \n 将小于它的都放在左部分，大于它的都放在右部分  \n 从左到右找大的，从右到左找小的，做交换 \n * 最后找到最靠右的小于标准元素的元素与标准元素进行交换 \n */ \npublic static int partition(char[] src, int lo, int hi) { \n    int base = src[lo]; \n    int l = lo, h = hi + 1; \n    while (true) { \n        while (src[++l] < base) \n            if (l == hi) break; \n        while (src[--h] > base) \n            if (h == lo) break; if (l < h) \n                exchange(src, l, h); else break; \n    } /* * 这里的h换成l-1都可以，表示左侧部分最右的一个元素 */ \n    exchange(src, lo, h); return h; \n}\n```\n\n# 提高性能 \n\n在小数组排序的时候我们可以将快速排序替换为插入排序，这样会进一步提升快速排序的性能，改进后的代码像下面这样 \n\n```java\npublic static void sort(char[] src, int lo, int hi) { \n    if (lo >= hi) return ; \n    if((hi - lo +1) < 10) {\n        insertionSort(arr,low, high);\n        return;\n    }\n    int splitIndex = partition(src, lo, hi); \n    //切分 \n    sort(src, lo, splitIndex - 1); \n    sort(src, splitIndex + 1, hi); \n}\n```\n\n# 再提升\n\n在实际应用中，我们很少会处理无重复元素的数组，经常会遇到含有大量重复元素的数组，而我们之前的基础排序算法对于重复的元素仍对其进行比较和大量的交换，这显然是没有必要的，在其中我们便可以发现巨大的优化潜力，在特定的情况下将线性对数级别的性能进一步改进。 \n\n## 三向切分\n\n之前的算法是将数组分为两个部分，小于基准元素和大于基准元素，三向切分将数组分为三个部分：小于、等于和大于基准元素。所以我们需要更多的指针跟踪（lo, lt, i, gt, hi），我们让**a[ lo ... lt - 1 ]**存储小于基准元素的元素，**a[ lt ... i - 1]**存储等于基准元素的元素，**a[ i ... gt ]**存储未访问到、未确定大小的元素，**a[ gt + 1 ... hi ]**存储大于基准元素的元素。\n\n```java\npublic static void sort(char[] arr, int lo, int hi) { \n    int n = hi - lo + 1; // 当子数组的长度为 8 时，调用插入排序 \n    if (n <= CUTOFF) { insertionSort(arr, lo, hi); return; } \n    // 调用三取样切分 \n    int m = median3(arr, lo, lo + n / 2, hi); \n    exchange(arr, m, lo); \n    int lt = lo; int gt = hi;\n    int v = arr[lo]; \n    int i = lo;\n    while (i <= gt) { \n        // arr[i] < v，交换 arr[lt] & arr[i]，将 lt & i 加一 \n        if (arr[i] < v) { exchange(arr, lt++, i++); } \n        // arr[i] > v，交换 arr[gt] & arr[i]，将 gt 减一 else\n        if (arr[i] > v) { exchange(arr, i, gt--); } \n        // arr[i] == v，将 i 加一 \n        else { \n            i++; \n        } \n    } \n    // arr[lo...lt-1] < v = arr[lt...gt] < arr[gt+1...hi] \n    sort(arr, lo, lt - 1); \n    sort(arr, gt + 1, hi); \n}\n\n// 取 arr[i] arr[j] arr[k] 三个元素值的中间元素的下标 \nprivate static int median3(char[] arr, int i, int j, int k) { \n    return (less(arr[i], arr[j]) ? \n            (less(arr[j], arr[k]) ? j : less(arr[i], arr[k]) ? k : i) : \t\t\t\t\t(less(arr[k], arr[j]) ? j : less(arr[k], arr[i]) ? k : i)); \n}\n\n```\n\n\n\n# 快速排序的优势\n\n相对于那些**初级排序算法**（插入排序、选择排序等），快速排序的优势不用多说，平均情况的线性对数级别比平方级别在性能上要好太多。而最差情况的平方级别完全可以通过随机化避免。\n\n相对于**归并排序**。在空间上，归并排序的劣势显露无疑，归并排序需要线性级别的空间，所以只需要对数级别的空间。在时间上，上面已经进行了详细讨论，三向切分快速排序在实际应用中的性能优于归并排序很多。\n\n相对于**堆排序**。堆排序在时间和空间上都有非常好的效果，但是它总是跳跃式地访问元素，无法利用缓存，而快速排序总会顺序地访问元素，可以利用缓存。而缓存对于性能的提升是非常有用的。\n\n快速排序的内循环中的指令很少，运行时间的增长数量级为~cNlgN，并且三向切分的快速排序对于实际应用中可能出现的某些分布的输入变成了线性级别，这使得其他的排序算法望而却步。","slug":"quicksort","published":1,"updated":"2018-05-21T02:11:47.308Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjhfm7sm90000g4kcwhc9ghfu","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>排序算法可能是应用最广泛的算法了，它的特点是简单、适用于不同的输入数据并且在一般的应用中比其他的排序算法要快。快速排序采用的也是分治思想，但是与归并排序不同的是快速排序是原地排序并不需要使用辅助数组能节省更多的内存资源。 </p>\n<a id=\"more\"></a>\n<h1 id=\"基本算法\"><a href=\"#基本算法\" class=\"headerlink\" title=\"基本算法\"></a>基本算法</h1><p>快速排序是将一个数组分成两个子数组，并将两个子数组独立的排序。数组的切分与归并排序有很大的不同，快速排序是找出一个元素作为基准，然后确定这个基准元素在数组中的位置，在这个过程中使基准左边的元素都不大于它右边的元素都不小于它。快速排序就是递归的调用切分的方法来完成排序的。 </p>\n<h2 id=\"切分的方式\"><a href=\"#切分的方式\" class=\"headerlink\" title=\"切分的方式\"></a>切分的方式</h2><p>快速排序中最重要的就是步骤就是将小于等于中轴元素的放到中轴元素的左边，将大于中轴元素的放到中轴元素的右边，我们暂时把这个步骤定义为切分。而剩下的步骤就是进行递归而已，递归的边界条件为数组的元素个数小于等于1。以首元素作为中轴，看看常见的切分方式。 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* * 递归调用 * lo, hi用于跟踪递归进度 */</span> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(<span class=\"keyword\">char</span>[] src, <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi)</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lo &gt;= hi) <span class=\"keyword\">return</span> ; </span><br><span class=\"line\">    <span class=\"keyword\">int</span> splitIndex = partition(src, lo, hi); </span><br><span class=\"line\">    <span class=\"comment\">//切分 </span></span><br><span class=\"line\">    sort(src, lo, splitIndex - <span class=\"number\">1</span>); </span><br><span class=\"line\">    sort(src, splitIndex + <span class=\"number\">1</span>, hi); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* * 快速排序的核心 * 用段落的第一个元素作为切分的标准 </span></span><br><span class=\"line\"><span class=\"comment\"> 将小于它的都放在左部分，大于它的都放在右部分  </span></span><br><span class=\"line\"><span class=\"comment\"> 从左到右找大的，从右到左找小的，做交换 </span></span><br><span class=\"line\"><span class=\"comment\"> * 最后找到最靠右的小于标准元素的元素与标准元素进行交换 </span></span><br><span class=\"line\"><span class=\"comment\"> */</span> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">partition</span><span class=\"params\">(<span class=\"keyword\">char</span>[] src, <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi)</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">int</span> base = src[lo]; </span><br><span class=\"line\">    <span class=\"keyword\">int</span> l = lo, h = hi + <span class=\"number\">1</span>; </span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123; </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (src[++l] &lt; base) </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (l == hi) <span class=\"keyword\">break</span>; </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (src[--h] &gt; base) </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (h == lo) <span class=\"keyword\">break</span>; <span class=\"keyword\">if</span> (l &lt; h) </span><br><span class=\"line\">                exchange(src, l, h); <span class=\"keyword\">else</span> <span class=\"keyword\">break</span>; </span><br><span class=\"line\">    &#125; <span class=\"comment\">/* * 这里的h换成l-1都可以，表示左侧部分最右的一个元素 */</span> </span><br><span class=\"line\">    exchange(src, lo, h); <span class=\"keyword\">return</span> h; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"提高性能\"><a href=\"#提高性能\" class=\"headerlink\" title=\"提高性能\"></a>提高性能</h1><p>在小数组排序的时候我们可以将快速排序替换为插入排序，这样会进一步提升快速排序的性能，改进后的代码像下面这样 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(<span class=\"keyword\">char</span>[] src, <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi)</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lo &gt;= hi) <span class=\"keyword\">return</span> ; </span><br><span class=\"line\">    <span class=\"keyword\">if</span>((hi - lo +<span class=\"number\">1</span>) &lt; <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">        insertionSort(arr,low, high);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> splitIndex = partition(src, lo, hi); </span><br><span class=\"line\">    <span class=\"comment\">//切分 </span></span><br><span class=\"line\">    sort(src, lo, splitIndex - <span class=\"number\">1</span>); </span><br><span class=\"line\">    sort(src, splitIndex + <span class=\"number\">1</span>, hi); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"再提升\"><a href=\"#再提升\" class=\"headerlink\" title=\"再提升\"></a>再提升</h1><p>在实际应用中，我们很少会处理无重复元素的数组，经常会遇到含有大量重复元素的数组，而我们之前的基础排序算法对于重复的元素仍对其进行比较和大量的交换，这显然是没有必要的，在其中我们便可以发现巨大的优化潜力，在特定的情况下将线性对数级别的性能进一步改进。 </p>\n<h2 id=\"三向切分\"><a href=\"#三向切分\" class=\"headerlink\" title=\"三向切分\"></a>三向切分</h2><p>之前的算法是将数组分为两个部分，小于基准元素和大于基准元素，三向切分将数组分为三个部分：小于、等于和大于基准元素。所以我们需要更多的指针跟踪（lo, lt, i, gt, hi），我们让<strong>a[ lo … lt - 1 ]</strong>存储小于基准元素的元素，<strong>a[ lt … i - 1]</strong>存储等于基准元素的元素，<strong>a[ i … gt ]</strong>存储未访问到、未确定大小的元素，<strong>a[ gt + 1 … hi ]</strong>存储大于基准元素的元素。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(<span class=\"keyword\">char</span>[] arr, <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi)</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = hi - lo + <span class=\"number\">1</span>; <span class=\"comment\">// 当子数组的长度为 8 时，调用插入排序 </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &lt;= CUTOFF) &#123; insertionSort(arr, lo, hi); <span class=\"keyword\">return</span>; &#125; </span><br><span class=\"line\">    <span class=\"comment\">// 调用三取样切分 </span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> m = median3(arr, lo, lo + n / <span class=\"number\">2</span>, hi); </span><br><span class=\"line\">    exchange(arr, m, lo); </span><br><span class=\"line\">    <span class=\"keyword\">int</span> lt = lo; <span class=\"keyword\">int</span> gt = hi;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> v = arr[lo]; </span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = lo;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt;= gt) &#123; </span><br><span class=\"line\">        <span class=\"comment\">// arr[i] &lt; v，交换 arr[lt] &amp; arr[i]，将 lt &amp; i 加一 </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr[i] &lt; v) &#123; exchange(arr, lt++, i++); &#125; </span><br><span class=\"line\">        <span class=\"comment\">// arr[i] &gt; v，交换 arr[gt] &amp; arr[i]，将 gt 减一 else</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr[i] &gt; v) &#123; exchange(arr, i, gt--); &#125; </span><br><span class=\"line\">        <span class=\"comment\">// arr[i] == v，将 i 加一 </span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">            i++; </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"comment\">// arr[lo...lt-1] &lt; v = arr[lt...gt] &lt; arr[gt+1...hi] </span></span><br><span class=\"line\">    sort(arr, lo, lt - <span class=\"number\">1</span>); </span><br><span class=\"line\">    sort(arr, gt + <span class=\"number\">1</span>, hi); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 取 arr[i] arr[j] arr[k] 三个元素值的中间元素的下标 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">median3</span><span class=\"params\">(<span class=\"keyword\">char</span>[] arr, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j, <span class=\"keyword\">int</span> k)</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> (less(arr[i], arr[j]) ? </span><br><span class=\"line\">            (less(arr[j], arr[k]) ? j : less(arr[i], arr[k]) ? k : i) : \t\t\t\t\t(less(arr[k], arr[j]) ? j : less(arr[k], arr[i]) ? k : i)); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"快速排序的优势\"><a href=\"#快速排序的优势\" class=\"headerlink\" title=\"快速排序的优势\"></a>快速排序的优势</h1><p>相对于那些<strong>初级排序算法</strong>（插入排序、选择排序等），快速排序的优势不用多说，平均情况的线性对数级别比平方级别在性能上要好太多。而最差情况的平方级别完全可以通过随机化避免。</p>\n<p>相对于<strong>归并排序</strong>。在空间上，归并排序的劣势显露无疑，归并排序需要线性级别的空间，所以只需要对数级别的空间。在时间上，上面已经进行了详细讨论，三向切分快速排序在实际应用中的性能优于归并排序很多。</p>\n<p>相对于<strong>堆排序</strong>。堆排序在时间和空间上都有非常好的效果，但是它总是跳跃式地访问元素，无法利用缓存，而快速排序总会顺序地访问元素，可以利用缓存。而缓存对于性能的提升是非常有用的。</p>\n<p>快速排序的内循环中的指令很少，运行时间的增长数量级为~cNlgN，并且三向切分的快速排序对于实际应用中可能出现的某些分布的输入变成了线性级别，这使得其他的排序算法望而却步。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>排序算法可能是应用最广泛的算法了，它的特点是简单、适用于不同的输入数据并且在一般的应用中比其他的排序算法要快。快速排序采用的也是分治思想，但是与归并排序不同的是快速排序是原地排序并不需要使用辅助数组能节省更多的内存资源。 </p>","more":"<h1 id=\"基本算法\"><a href=\"#基本算法\" class=\"headerlink\" title=\"基本算法\"></a>基本算法</h1><p>快速排序是将一个数组分成两个子数组，并将两个子数组独立的排序。数组的切分与归并排序有很大的不同，快速排序是找出一个元素作为基准，然后确定这个基准元素在数组中的位置，在这个过程中使基准左边的元素都不大于它右边的元素都不小于它。快速排序就是递归的调用切分的方法来完成排序的。 </p>\n<h2 id=\"切分的方式\"><a href=\"#切分的方式\" class=\"headerlink\" title=\"切分的方式\"></a>切分的方式</h2><p>快速排序中最重要的就是步骤就是将小于等于中轴元素的放到中轴元素的左边，将大于中轴元素的放到中轴元素的右边，我们暂时把这个步骤定义为切分。而剩下的步骤就是进行递归而已，递归的边界条件为数组的元素个数小于等于1。以首元素作为中轴，看看常见的切分方式。 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* * 递归调用 * lo, hi用于跟踪递归进度 */</span> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(<span class=\"keyword\">char</span>[] src, <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi)</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lo &gt;= hi) <span class=\"keyword\">return</span> ; </span><br><span class=\"line\">    <span class=\"keyword\">int</span> splitIndex = partition(src, lo, hi); </span><br><span class=\"line\">    <span class=\"comment\">//切分 </span></span><br><span class=\"line\">    sort(src, lo, splitIndex - <span class=\"number\">1</span>); </span><br><span class=\"line\">    sort(src, splitIndex + <span class=\"number\">1</span>, hi); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* * 快速排序的核心 * 用段落的第一个元素作为切分的标准 </span></span><br><span class=\"line\"><span class=\"comment\"> 将小于它的都放在左部分，大于它的都放在右部分  </span></span><br><span class=\"line\"><span class=\"comment\"> 从左到右找大的，从右到左找小的，做交换 </span></span><br><span class=\"line\"><span class=\"comment\"> * 最后找到最靠右的小于标准元素的元素与标准元素进行交换 </span></span><br><span class=\"line\"><span class=\"comment\"> */</span> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">partition</span><span class=\"params\">(<span class=\"keyword\">char</span>[] src, <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi)</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">int</span> base = src[lo]; </span><br><span class=\"line\">    <span class=\"keyword\">int</span> l = lo, h = hi + <span class=\"number\">1</span>; </span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123; </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (src[++l] &lt; base) </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (l == hi) <span class=\"keyword\">break</span>; </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (src[--h] &gt; base) </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (h == lo) <span class=\"keyword\">break</span>; <span class=\"keyword\">if</span> (l &lt; h) </span><br><span class=\"line\">                exchange(src, l, h); <span class=\"keyword\">else</span> <span class=\"keyword\">break</span>; </span><br><span class=\"line\">    &#125; <span class=\"comment\">/* * 这里的h换成l-1都可以，表示左侧部分最右的一个元素 */</span> </span><br><span class=\"line\">    exchange(src, lo, h); <span class=\"keyword\">return</span> h; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"提高性能\"><a href=\"#提高性能\" class=\"headerlink\" title=\"提高性能\"></a>提高性能</h1><p>在小数组排序的时候我们可以将快速排序替换为插入排序，这样会进一步提升快速排序的性能，改进后的代码像下面这样 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(<span class=\"keyword\">char</span>[] src, <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi)</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lo &gt;= hi) <span class=\"keyword\">return</span> ; </span><br><span class=\"line\">    <span class=\"keyword\">if</span>((hi - lo +<span class=\"number\">1</span>) &lt; <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">        insertionSort(arr,low, high);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> splitIndex = partition(src, lo, hi); </span><br><span class=\"line\">    <span class=\"comment\">//切分 </span></span><br><span class=\"line\">    sort(src, lo, splitIndex - <span class=\"number\">1</span>); </span><br><span class=\"line\">    sort(src, splitIndex + <span class=\"number\">1</span>, hi); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"再提升\"><a href=\"#再提升\" class=\"headerlink\" title=\"再提升\"></a>再提升</h1><p>在实际应用中，我们很少会处理无重复元素的数组，经常会遇到含有大量重复元素的数组，而我们之前的基础排序算法对于重复的元素仍对其进行比较和大量的交换，这显然是没有必要的，在其中我们便可以发现巨大的优化潜力，在特定的情况下将线性对数级别的性能进一步改进。 </p>\n<h2 id=\"三向切分\"><a href=\"#三向切分\" class=\"headerlink\" title=\"三向切分\"></a>三向切分</h2><p>之前的算法是将数组分为两个部分，小于基准元素和大于基准元素，三向切分将数组分为三个部分：小于、等于和大于基准元素。所以我们需要更多的指针跟踪（lo, lt, i, gt, hi），我们让<strong>a[ lo … lt - 1 ]</strong>存储小于基准元素的元素，<strong>a[ lt … i - 1]</strong>存储等于基准元素的元素，<strong>a[ i … gt ]</strong>存储未访问到、未确定大小的元素，<strong>a[ gt + 1 … hi ]</strong>存储大于基准元素的元素。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(<span class=\"keyword\">char</span>[] arr, <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi)</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = hi - lo + <span class=\"number\">1</span>; <span class=\"comment\">// 当子数组的长度为 8 时，调用插入排序 </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &lt;= CUTOFF) &#123; insertionSort(arr, lo, hi); <span class=\"keyword\">return</span>; &#125; </span><br><span class=\"line\">    <span class=\"comment\">// 调用三取样切分 </span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> m = median3(arr, lo, lo + n / <span class=\"number\">2</span>, hi); </span><br><span class=\"line\">    exchange(arr, m, lo); </span><br><span class=\"line\">    <span class=\"keyword\">int</span> lt = lo; <span class=\"keyword\">int</span> gt = hi;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> v = arr[lo]; </span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = lo;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt;= gt) &#123; </span><br><span class=\"line\">        <span class=\"comment\">// arr[i] &lt; v，交换 arr[lt] &amp; arr[i]，将 lt &amp; i 加一 </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr[i] &lt; v) &#123; exchange(arr, lt++, i++); &#125; </span><br><span class=\"line\">        <span class=\"comment\">// arr[i] &gt; v，交换 arr[gt] &amp; arr[i]，将 gt 减一 else</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr[i] &gt; v) &#123; exchange(arr, i, gt--); &#125; </span><br><span class=\"line\">        <span class=\"comment\">// arr[i] == v，将 i 加一 </span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">            i++; </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"comment\">// arr[lo...lt-1] &lt; v = arr[lt...gt] &lt; arr[gt+1...hi] </span></span><br><span class=\"line\">    sort(arr, lo, lt - <span class=\"number\">1</span>); </span><br><span class=\"line\">    sort(arr, gt + <span class=\"number\">1</span>, hi); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 取 arr[i] arr[j] arr[k] 三个元素值的中间元素的下标 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">median3</span><span class=\"params\">(<span class=\"keyword\">char</span>[] arr, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j, <span class=\"keyword\">int</span> k)</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> (less(arr[i], arr[j]) ? </span><br><span class=\"line\">            (less(arr[j], arr[k]) ? j : less(arr[i], arr[k]) ? k : i) : \t\t\t\t\t(less(arr[k], arr[j]) ? j : less(arr[k], arr[i]) ? k : i)); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"快速排序的优势\"><a href=\"#快速排序的优势\" class=\"headerlink\" title=\"快速排序的优势\"></a>快速排序的优势</h1><p>相对于那些<strong>初级排序算法</strong>（插入排序、选择排序等），快速排序的优势不用多说，平均情况的线性对数级别比平方级别在性能上要好太多。而最差情况的平方级别完全可以通过随机化避免。</p>\n<p>相对于<strong>归并排序</strong>。在空间上，归并排序的劣势显露无疑，归并排序需要线性级别的空间，所以只需要对数级别的空间。在时间上，上面已经进行了详细讨论，三向切分快速排序在实际应用中的性能优于归并排序很多。</p>\n<p>相对于<strong>堆排序</strong>。堆排序在时间和空间上都有非常好的效果，但是它总是跳跃式地访问元素，无法利用缓存，而快速排序总会顺序地访问元素，可以利用缓存。而缓存对于性能的提升是非常有用的。</p>\n<p>快速排序的内循环中的指令很少，运行时间的增长数量级为~cNlgN，并且三向切分的快速排序对于实际应用中可能出现的某些分布的输入变成了线性级别，这使得其他的排序算法望而却步。</p>"},{"title":"高并发限流探究","author":"James","date":"2017-07-22T06:00:00.000Z","_content":"\n# 前言\n\n**在开发高并发系统时，有三把利器用来保护系统：缓存、降级和限流**。那么何为限流呢？通过对并发访问/请求进行限速，或者对一个时间窗口内的请求进行限速来保护系统，一旦达到限制速率则可以拒绝服务、排队或等待、降级等处理 。通过限流，我们可以很好地控制系统的qps，防止客户端对于接口的滥用，保护服务器的资源， 从而达到保护系统的目的。本文主要介绍几种限流的方式。 \n\n<!-- more -->\n\n# 常见限流算法\n\n计数器、滑动窗口、漏桶、令牌。 \n\n## 计数器\n\n计数器法是限流算法里最简单也是最容易实现的一种算法。比如我们规定，对于A接口来说，我们1分钟的访问次数不能超过100个。那么我们可以这么做：在一开始的时候，我们可以设置一个计数器counter，每当一个请求过来的时候，counter就加1，如果counter的值大于100并且该请求与第一个请求的间隔时间还在1分钟之内，那么说明请求数过多；如果该请求与第一个请求的间隔时间大于1分钟，且counter的值还在限流范围内，那么就重置counter。\n\n```java\nclass Counter{\n    public long timeStamp = System.currentTimeMillis();\n    public int reqCount = 0;\n    public final int limit = 10; // 时间窗口内最大请求数\n    public final long interval = 10; // 时间窗口ms\n    public boolean tryAcquire() {\n        long now = System.currentTimeMillis();\n        if (now < timeStamp + interval) {\n            // 在时间窗口内\n            reqCount++;\n            // 判断当前时间窗口内是否超过最大请求控制数\n            return reqCount <= limit;\n        }\n        else {\n            timeStamp = now;\n            // 超时后重置\n            reqCount = 0;\n            return true;\n        }\n    }\n}\n```\n\n此算法很简单，很多情况下也很实用，但有个问题就是临界问题。假设时间间隔为1分钟不能超过100个请求，如果0~58秒都没有请求，而是在最后一秒钟瞬间发送100个请求。那么由开始我们设置的每分钟100请求平均每秒1.7个请求变成了每秒100个请求，超过了我们的速率限制。\n\n## 滑动窗口\n\n滑动窗口，又称rolling window。为了解决这个问题，我们引入了滑动窗口算法。 \n\n滑动窗口算法对固定的时间片进行划分，并随着时间的流逝进行移动，这样就巧妙的避开了计数器的临界点问题。也就是说这些固定数量的可以移动的格子，将会进行计数判断阀值，因此格子的数量影响着滑动窗口算法的精度。 \n\n## 漏桶\n\n虽然滑动窗口有效避免了时间临界点的问题，但是依然有时间片的概念，而漏桶算法在这方面比滑动窗口而言，更加先进。\n有一个固定的桶，进水的速率是不确定的，但是出水的速率是恒定的，当水满的时候是会溢出的。\n\n![](/images/ratelimit/a1.png)\n\n```java\nclass LeakyBucket {\n    public long timeStamp = System.currentTimeMillis();\n    public int capacity = 10; // 桶的容量\n    public int rate = 10; // 水漏出的速度\n    public long water = 0; // 当前水量(当前累积请求数)\n    public boolean tryAcquire() {\n        long now = System.currentTimeMillis();\n        water = Math.max(0, water - (now - timeStamp) * rate); // 先执行漏水，计算剩余水量\n        timeStamp = now;\n        if ((water + 1) < capacity) {\n            // 尝试加水,并且水还未满\n            water += 1;\n            return true;\n        }\n        else {\n            // 水满，拒绝加水\n            return false;\n        }\n    }\n}\n```\n\n## 令牌桶\n\n令牌桶算法：有一个固定容量的桶，开始的时候是空的，然后token以一个固定速率放入桶内，如果桶已经满了则丢弃，每当一个请求过来时会尝试从桶中移除一个token，如果没有令牌则无法通过。\n\n![](/images/ratelimit/a2.png)\n\n下面为简单的伪代码实现\n\n```java\nclass TokenBucket {\n    public long timeStamp = System.currentTimeMillis();\n    public int capacity = 100; // 桶的容量\n    public int rate = 10; // 令牌放入速度\n    public long tokens = 0; // 当前令牌数量\n    public boolean tryAcquire() {\n        long now = System.currentTimeMillis();\n        // 先添加令牌\n        tokens = Math.min(capacity, tokens + (now - timeStamp) * rate);\n        timeStamp = now;\n        if (tokens < 1) {\n            // 若不到1个令牌,则拒绝\n            return false;\n        }\n        else {\n            // 还有令牌，领取令牌\n            tokens -= 1;\n            return true;\n        }\n    }\n}\n```\n\ngoogle开源工具包guava提供了限流工具类RateLimiter，该类基于“令牌桶算法” \n\n我们只需要告诉RateLimiter系统限制的QPS是多少，那么RateLimiter将以这个速度往桶里面放入令牌，然后请求的时候，通过tryAcquire()方法向RateLimiter获取许可（令牌）。 \n\n```java\n class GuavaLimiter{\n     private RateLimiter rateLimiter  = RateLimiter.create(10);//qps 每秒的请求速率\n\n     public boolean tryAcquire() {\n         return rateLimiter.tryAcquire(0, TimeUnit.MILLISECONDS);//尝试获取令牌\n     }\n }\n```\n\n## 局限性\n\n1. 以上的RateLimiter只能应用于单进程，多进程间协同控制便无能为力\n2.  RateLimiter能够处理突发请求(预消费)，这里rest接口调用频率限制是固定的，不需要更不能使用预消费能力，否则将会导致接口调用失败\n\n\n\n## 基于Redis的实现\n\n参考Guava RateLimiter实现思路，不同的是，Guava将令牌桶数据存放于对象（内存）中，这里讲令牌桶数据存放在redis中。可以参考此文章[基于redis的分布式RateLimiter(限流)实现](https://segmentfault.com/a/1190000012947169?_blank)\n\n\n\n# 总结\n\n## 计数器/滑动窗口\n\n计数器算法是最简单的算法，可以看成是滑动窗口的低精度实现。滑动窗口由于需要存储多份的计数器（每一个格子存一份），所以滑动窗口在实现上需要更多的存储空间。也就是说，如果滑动窗口的精度越高，需要的存储空间就越大。\n\n## 漏桶算法/令牌桶算法\n\n漏桶算法和令牌桶算法最明显的区别是令牌桶算法允许流量一定程度的突发。因为默认的令牌桶算法，取走token是不需要耗费时间的，也就是说，假设桶内有100个token时，那么可以瞬间允许100个请求通过。\n\n令牌桶算法由于实现简单，且允许某些流量的突发，对用户友好，所以被业界采用地较多。当然我们需要具体情况具体分析，只有最合适的算法，没有最优的算法。","source":"_posts/rate_limit.md","raw":"title: 高并发限流探究\nauthor: James\ntags:\n  - 接口限流\ncategories:\n  - 架构\ndate: 2017-07-22 14:00:00\n---\n\n# 前言\n\n**在开发高并发系统时，有三把利器用来保护系统：缓存、降级和限流**。那么何为限流呢？通过对并发访问/请求进行限速，或者对一个时间窗口内的请求进行限速来保护系统，一旦达到限制速率则可以拒绝服务、排队或等待、降级等处理 。通过限流，我们可以很好地控制系统的qps，防止客户端对于接口的滥用，保护服务器的资源， 从而达到保护系统的目的。本文主要介绍几种限流的方式。 \n\n<!-- more -->\n\n# 常见限流算法\n\n计数器、滑动窗口、漏桶、令牌。 \n\n## 计数器\n\n计数器法是限流算法里最简单也是最容易实现的一种算法。比如我们规定，对于A接口来说，我们1分钟的访问次数不能超过100个。那么我们可以这么做：在一开始的时候，我们可以设置一个计数器counter，每当一个请求过来的时候，counter就加1，如果counter的值大于100并且该请求与第一个请求的间隔时间还在1分钟之内，那么说明请求数过多；如果该请求与第一个请求的间隔时间大于1分钟，且counter的值还在限流范围内，那么就重置counter。\n\n```java\nclass Counter{\n    public long timeStamp = System.currentTimeMillis();\n    public int reqCount = 0;\n    public final int limit = 10; // 时间窗口内最大请求数\n    public final long interval = 10; // 时间窗口ms\n    public boolean tryAcquire() {\n        long now = System.currentTimeMillis();\n        if (now < timeStamp + interval) {\n            // 在时间窗口内\n            reqCount++;\n            // 判断当前时间窗口内是否超过最大请求控制数\n            return reqCount <= limit;\n        }\n        else {\n            timeStamp = now;\n            // 超时后重置\n            reqCount = 0;\n            return true;\n        }\n    }\n}\n```\n\n此算法很简单，很多情况下也很实用，但有个问题就是临界问题。假设时间间隔为1分钟不能超过100个请求，如果0~58秒都没有请求，而是在最后一秒钟瞬间发送100个请求。那么由开始我们设置的每分钟100请求平均每秒1.7个请求变成了每秒100个请求，超过了我们的速率限制。\n\n## 滑动窗口\n\n滑动窗口，又称rolling window。为了解决这个问题，我们引入了滑动窗口算法。 \n\n滑动窗口算法对固定的时间片进行划分，并随着时间的流逝进行移动，这样就巧妙的避开了计数器的临界点问题。也就是说这些固定数量的可以移动的格子，将会进行计数判断阀值，因此格子的数量影响着滑动窗口算法的精度。 \n\n## 漏桶\n\n虽然滑动窗口有效避免了时间临界点的问题，但是依然有时间片的概念，而漏桶算法在这方面比滑动窗口而言，更加先进。\n有一个固定的桶，进水的速率是不确定的，但是出水的速率是恒定的，当水满的时候是会溢出的。\n\n![](/images/ratelimit/a1.png)\n\n```java\nclass LeakyBucket {\n    public long timeStamp = System.currentTimeMillis();\n    public int capacity = 10; // 桶的容量\n    public int rate = 10; // 水漏出的速度\n    public long water = 0; // 当前水量(当前累积请求数)\n    public boolean tryAcquire() {\n        long now = System.currentTimeMillis();\n        water = Math.max(0, water - (now - timeStamp) * rate); // 先执行漏水，计算剩余水量\n        timeStamp = now;\n        if ((water + 1) < capacity) {\n            // 尝试加水,并且水还未满\n            water += 1;\n            return true;\n        }\n        else {\n            // 水满，拒绝加水\n            return false;\n        }\n    }\n}\n```\n\n## 令牌桶\n\n令牌桶算法：有一个固定容量的桶，开始的时候是空的，然后token以一个固定速率放入桶内，如果桶已经满了则丢弃，每当一个请求过来时会尝试从桶中移除一个token，如果没有令牌则无法通过。\n\n![](/images/ratelimit/a2.png)\n\n下面为简单的伪代码实现\n\n```java\nclass TokenBucket {\n    public long timeStamp = System.currentTimeMillis();\n    public int capacity = 100; // 桶的容量\n    public int rate = 10; // 令牌放入速度\n    public long tokens = 0; // 当前令牌数量\n    public boolean tryAcquire() {\n        long now = System.currentTimeMillis();\n        // 先添加令牌\n        tokens = Math.min(capacity, tokens + (now - timeStamp) * rate);\n        timeStamp = now;\n        if (tokens < 1) {\n            // 若不到1个令牌,则拒绝\n            return false;\n        }\n        else {\n            // 还有令牌，领取令牌\n            tokens -= 1;\n            return true;\n        }\n    }\n}\n```\n\ngoogle开源工具包guava提供了限流工具类RateLimiter，该类基于“令牌桶算法” \n\n我们只需要告诉RateLimiter系统限制的QPS是多少，那么RateLimiter将以这个速度往桶里面放入令牌，然后请求的时候，通过tryAcquire()方法向RateLimiter获取许可（令牌）。 \n\n```java\n class GuavaLimiter{\n     private RateLimiter rateLimiter  = RateLimiter.create(10);//qps 每秒的请求速率\n\n     public boolean tryAcquire() {\n         return rateLimiter.tryAcquire(0, TimeUnit.MILLISECONDS);//尝试获取令牌\n     }\n }\n```\n\n## 局限性\n\n1. 以上的RateLimiter只能应用于单进程，多进程间协同控制便无能为力\n2.  RateLimiter能够处理突发请求(预消费)，这里rest接口调用频率限制是固定的，不需要更不能使用预消费能力，否则将会导致接口调用失败\n\n\n\n## 基于Redis的实现\n\n参考Guava RateLimiter实现思路，不同的是，Guava将令牌桶数据存放于对象（内存）中，这里讲令牌桶数据存放在redis中。可以参考此文章[基于redis的分布式RateLimiter(限流)实现](https://segmentfault.com/a/1190000012947169?_blank)\n\n\n\n# 总结\n\n## 计数器/滑动窗口\n\n计数器算法是最简单的算法，可以看成是滑动窗口的低精度实现。滑动窗口由于需要存储多份的计数器（每一个格子存一份），所以滑动窗口在实现上需要更多的存储空间。也就是说，如果滑动窗口的精度越高，需要的存储空间就越大。\n\n## 漏桶算法/令牌桶算法\n\n漏桶算法和令牌桶算法最明显的区别是令牌桶算法允许流量一定程度的突发。因为默认的令牌桶算法，取走token是不需要耗费时间的，也就是说，假设桶内有100个token时，那么可以瞬间允许100个请求通过。\n\n令牌桶算法由于实现简单，且允许某些流量的突发，对用户友好，所以被业界采用地较多。当然我们需要具体情况具体分析，只有最合适的算法，没有最优的算法。","slug":"rate_limit","published":1,"updated":"2018-05-25T02:57:26.601Z","_id":"cjhld56ix0000uokcgq9i94vx","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p><strong>在开发高并发系统时，有三把利器用来保护系统：缓存、降级和限流</strong>。那么何为限流呢？通过对并发访问/请求进行限速，或者对一个时间窗口内的请求进行限速来保护系统，一旦达到限制速率则可以拒绝服务、排队或等待、降级等处理 。通过限流，我们可以很好地控制系统的qps，防止客户端对于接口的滥用，保护服务器的资源， 从而达到保护系统的目的。本文主要介绍几种限流的方式。 </p>\n<a id=\"more\"></a>\n<h1 id=\"常见限流算法\"><a href=\"#常见限流算法\" class=\"headerlink\" title=\"常见限流算法\"></a>常见限流算法</h1><p>计数器、滑动窗口、漏桶、令牌。 </p>\n<h2 id=\"计数器\"><a href=\"#计数器\" class=\"headerlink\" title=\"计数器\"></a>计数器</h2><p>计数器法是限流算法里最简单也是最容易实现的一种算法。比如我们规定，对于A接口来说，我们1分钟的访问次数不能超过100个。那么我们可以这么做：在一开始的时候，我们可以设置一个计数器counter，每当一个请求过来的时候，counter就加1，如果counter的值大于100并且该请求与第一个请求的间隔时间还在1分钟之内，那么说明请求数过多；如果该请求与第一个请求的间隔时间大于1分钟，且counter的值还在限流范围内，那么就重置counter。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Counter</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">long</span> timeStamp = System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> reqCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> limit = <span class=\"number\">10</span>; <span class=\"comment\">// 时间窗口内最大请求数</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> interval = <span class=\"number\">10</span>; <span class=\"comment\">// 时间窗口ms</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> now = System.currentTimeMillis();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (now &lt; timeStamp + interval) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 在时间窗口内</span></span><br><span class=\"line\">            reqCount++;</span><br><span class=\"line\">            <span class=\"comment\">// 判断当前时间窗口内是否超过最大请求控制数</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> reqCount &lt;= limit;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            timeStamp = now;</span><br><span class=\"line\">            <span class=\"comment\">// 超时后重置</span></span><br><span class=\"line\">            reqCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此算法很简单，很多情况下也很实用，但有个问题就是临界问题。假设时间间隔为1分钟不能超过100个请求，如果0~58秒都没有请求，而是在最后一秒钟瞬间发送100个请求。那么由开始我们设置的每分钟100请求平均每秒1.7个请求变成了每秒100个请求，超过了我们的速率限制。</p>\n<h2 id=\"滑动窗口\"><a href=\"#滑动窗口\" class=\"headerlink\" title=\"滑动窗口\"></a>滑动窗口</h2><p>滑动窗口，又称rolling window。为了解决这个问题，我们引入了滑动窗口算法。 </p>\n<p>滑动窗口算法对固定的时间片进行划分，并随着时间的流逝进行移动，这样就巧妙的避开了计数器的临界点问题。也就是说这些固定数量的可以移动的格子，将会进行计数判断阀值，因此格子的数量影响着滑动窗口算法的精度。 </p>\n<h2 id=\"漏桶\"><a href=\"#漏桶\" class=\"headerlink\" title=\"漏桶\"></a>漏桶</h2><p>虽然滑动窗口有效避免了时间临界点的问题，但是依然有时间片的概念，而漏桶算法在这方面比滑动窗口而言，更加先进。<br>有一个固定的桶，进水的速率是不确定的，但是出水的速率是恒定的，当水满的时候是会溢出的。</p>\n<p><img src=\"/images/ratelimit/a1.png\" alt=\"\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LeakyBucket</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">long</span> timeStamp = System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> capacity = <span class=\"number\">10</span>; <span class=\"comment\">// 桶的容量</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> rate = <span class=\"number\">10</span>; <span class=\"comment\">// 水漏出的速度</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">long</span> water = <span class=\"number\">0</span>; <span class=\"comment\">// 当前水量(当前累积请求数)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> now = System.currentTimeMillis();</span><br><span class=\"line\">        water = Math.max(<span class=\"number\">0</span>, water - (now - timeStamp) * rate); <span class=\"comment\">// 先执行漏水，计算剩余水量</span></span><br><span class=\"line\">        timeStamp = now;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((water + <span class=\"number\">1</span>) &lt; capacity) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 尝试加水,并且水还未满</span></span><br><span class=\"line\">            water += <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 水满，拒绝加水</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"令牌桶\"><a href=\"#令牌桶\" class=\"headerlink\" title=\"令牌桶\"></a>令牌桶</h2><p>令牌桶算法：有一个固定容量的桶，开始的时候是空的，然后token以一个固定速率放入桶内，如果桶已经满了则丢弃，每当一个请求过来时会尝试从桶中移除一个token，如果没有令牌则无法通过。</p>\n<p><img src=\"/images/ratelimit/a2.png\" alt=\"\"></p>\n<p>下面为简单的伪代码实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TokenBucket</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">long</span> timeStamp = System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> capacity = <span class=\"number\">100</span>; <span class=\"comment\">// 桶的容量</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> rate = <span class=\"number\">10</span>; <span class=\"comment\">// 令牌放入速度</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">long</span> tokens = <span class=\"number\">0</span>; <span class=\"comment\">// 当前令牌数量</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> now = System.currentTimeMillis();</span><br><span class=\"line\">        <span class=\"comment\">// 先添加令牌</span></span><br><span class=\"line\">        tokens = Math.min(capacity, tokens + (now - timeStamp) * rate);</span><br><span class=\"line\">        timeStamp = now;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tokens &lt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 若不到1个令牌,则拒绝</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 还有令牌，领取令牌</span></span><br><span class=\"line\">            tokens -= <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>google开源工具包guava提供了限流工具类RateLimiter，该类基于“令牌桶算法” </p>\n<p>我们只需要告诉RateLimiter系统限制的QPS是多少，那么RateLimiter将以这个速度往桶里面放入令牌，然后请求的时候，通过tryAcquire()方法向RateLimiter获取许可（令牌）。 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GuavaLimiter</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> RateLimiter rateLimiter  = RateLimiter.create(<span class=\"number\">10</span>);<span class=\"comment\">//qps 每秒的请求速率</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> rateLimiter.tryAcquire(<span class=\"number\">0</span>, TimeUnit.MILLISECONDS);<span class=\"comment\">//尝试获取令牌</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"局限性\"><a href=\"#局限性\" class=\"headerlink\" title=\"局限性\"></a>局限性</h2><ol>\n<li>以上的RateLimiter只能应用于单进程，多进程间协同控制便无能为力</li>\n<li>RateLimiter能够处理突发请求(预消费)，这里rest接口调用频率限制是固定的，不需要更不能使用预消费能力，否则将会导致接口调用失败</li>\n</ol>\n<h2 id=\"基于Redis的实现\"><a href=\"#基于Redis的实现\" class=\"headerlink\" title=\"基于Redis的实现\"></a>基于Redis的实现</h2><p>参考Guava RateLimiter实现思路，不同的是，Guava将令牌桶数据存放于对象（内存）中，这里讲令牌桶数据存放在redis中。可以参考此文章<a href=\"https://segmentfault.com/a/1190000012947169?_blank\" target=\"_blank\" rel=\"noopener\">基于redis的分布式RateLimiter(限流)实现</a></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><h2 id=\"计数器-滑动窗口\"><a href=\"#计数器-滑动窗口\" class=\"headerlink\" title=\"计数器/滑动窗口\"></a>计数器/滑动窗口</h2><p>计数器算法是最简单的算法，可以看成是滑动窗口的低精度实现。滑动窗口由于需要存储多份的计数器（每一个格子存一份），所以滑动窗口在实现上需要更多的存储空间。也就是说，如果滑动窗口的精度越高，需要的存储空间就越大。</p>\n<h2 id=\"漏桶算法-令牌桶算法\"><a href=\"#漏桶算法-令牌桶算法\" class=\"headerlink\" title=\"漏桶算法/令牌桶算法\"></a>漏桶算法/令牌桶算法</h2><p>漏桶算法和令牌桶算法最明显的区别是令牌桶算法允许流量一定程度的突发。因为默认的令牌桶算法，取走token是不需要耗费时间的，也就是说，假设桶内有100个token时，那么可以瞬间允许100个请求通过。</p>\n<p>令牌桶算法由于实现简单，且允许某些流量的突发，对用户友好，所以被业界采用地较多。当然我们需要具体情况具体分析，只有最合适的算法，没有最优的算法。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p><strong>在开发高并发系统时，有三把利器用来保护系统：缓存、降级和限流</strong>。那么何为限流呢？通过对并发访问/请求进行限速，或者对一个时间窗口内的请求进行限速来保护系统，一旦达到限制速率则可以拒绝服务、排队或等待、降级等处理 。通过限流，我们可以很好地控制系统的qps，防止客户端对于接口的滥用，保护服务器的资源， 从而达到保护系统的目的。本文主要介绍几种限流的方式。 </p>","more":"<h1 id=\"常见限流算法\"><a href=\"#常见限流算法\" class=\"headerlink\" title=\"常见限流算法\"></a>常见限流算法</h1><p>计数器、滑动窗口、漏桶、令牌。 </p>\n<h2 id=\"计数器\"><a href=\"#计数器\" class=\"headerlink\" title=\"计数器\"></a>计数器</h2><p>计数器法是限流算法里最简单也是最容易实现的一种算法。比如我们规定，对于A接口来说，我们1分钟的访问次数不能超过100个。那么我们可以这么做：在一开始的时候，我们可以设置一个计数器counter，每当一个请求过来的时候，counter就加1，如果counter的值大于100并且该请求与第一个请求的间隔时间还在1分钟之内，那么说明请求数过多；如果该请求与第一个请求的间隔时间大于1分钟，且counter的值还在限流范围内，那么就重置counter。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Counter</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">long</span> timeStamp = System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> reqCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> limit = <span class=\"number\">10</span>; <span class=\"comment\">// 时间窗口内最大请求数</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> interval = <span class=\"number\">10</span>; <span class=\"comment\">// 时间窗口ms</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> now = System.currentTimeMillis();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (now &lt; timeStamp + interval) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 在时间窗口内</span></span><br><span class=\"line\">            reqCount++;</span><br><span class=\"line\">            <span class=\"comment\">// 判断当前时间窗口内是否超过最大请求控制数</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> reqCount &lt;= limit;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            timeStamp = now;</span><br><span class=\"line\">            <span class=\"comment\">// 超时后重置</span></span><br><span class=\"line\">            reqCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此算法很简单，很多情况下也很实用，但有个问题就是临界问题。假设时间间隔为1分钟不能超过100个请求，如果0~58秒都没有请求，而是在最后一秒钟瞬间发送100个请求。那么由开始我们设置的每分钟100请求平均每秒1.7个请求变成了每秒100个请求，超过了我们的速率限制。</p>\n<h2 id=\"滑动窗口\"><a href=\"#滑动窗口\" class=\"headerlink\" title=\"滑动窗口\"></a>滑动窗口</h2><p>滑动窗口，又称rolling window。为了解决这个问题，我们引入了滑动窗口算法。 </p>\n<p>滑动窗口算法对固定的时间片进行划分，并随着时间的流逝进行移动，这样就巧妙的避开了计数器的临界点问题。也就是说这些固定数量的可以移动的格子，将会进行计数判断阀值，因此格子的数量影响着滑动窗口算法的精度。 </p>\n<h2 id=\"漏桶\"><a href=\"#漏桶\" class=\"headerlink\" title=\"漏桶\"></a>漏桶</h2><p>虽然滑动窗口有效避免了时间临界点的问题，但是依然有时间片的概念，而漏桶算法在这方面比滑动窗口而言，更加先进。<br>有一个固定的桶，进水的速率是不确定的，但是出水的速率是恒定的，当水满的时候是会溢出的。</p>\n<p><img src=\"/images/ratelimit/a1.png\" alt=\"\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LeakyBucket</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">long</span> timeStamp = System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> capacity = <span class=\"number\">10</span>; <span class=\"comment\">// 桶的容量</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> rate = <span class=\"number\">10</span>; <span class=\"comment\">// 水漏出的速度</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">long</span> water = <span class=\"number\">0</span>; <span class=\"comment\">// 当前水量(当前累积请求数)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> now = System.currentTimeMillis();</span><br><span class=\"line\">        water = Math.max(<span class=\"number\">0</span>, water - (now - timeStamp) * rate); <span class=\"comment\">// 先执行漏水，计算剩余水量</span></span><br><span class=\"line\">        timeStamp = now;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((water + <span class=\"number\">1</span>) &lt; capacity) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 尝试加水,并且水还未满</span></span><br><span class=\"line\">            water += <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 水满，拒绝加水</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"令牌桶\"><a href=\"#令牌桶\" class=\"headerlink\" title=\"令牌桶\"></a>令牌桶</h2><p>令牌桶算法：有一个固定容量的桶，开始的时候是空的，然后token以一个固定速率放入桶内，如果桶已经满了则丢弃，每当一个请求过来时会尝试从桶中移除一个token，如果没有令牌则无法通过。</p>\n<p><img src=\"/images/ratelimit/a2.png\" alt=\"\"></p>\n<p>下面为简单的伪代码实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TokenBucket</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">long</span> timeStamp = System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> capacity = <span class=\"number\">100</span>; <span class=\"comment\">// 桶的容量</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> rate = <span class=\"number\">10</span>; <span class=\"comment\">// 令牌放入速度</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">long</span> tokens = <span class=\"number\">0</span>; <span class=\"comment\">// 当前令牌数量</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> now = System.currentTimeMillis();</span><br><span class=\"line\">        <span class=\"comment\">// 先添加令牌</span></span><br><span class=\"line\">        tokens = Math.min(capacity, tokens + (now - timeStamp) * rate);</span><br><span class=\"line\">        timeStamp = now;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tokens &lt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 若不到1个令牌,则拒绝</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 还有令牌，领取令牌</span></span><br><span class=\"line\">            tokens -= <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>google开源工具包guava提供了限流工具类RateLimiter，该类基于“令牌桶算法” </p>\n<p>我们只需要告诉RateLimiter系统限制的QPS是多少，那么RateLimiter将以这个速度往桶里面放入令牌，然后请求的时候，通过tryAcquire()方法向RateLimiter获取许可（令牌）。 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GuavaLimiter</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> RateLimiter rateLimiter  = RateLimiter.create(<span class=\"number\">10</span>);<span class=\"comment\">//qps 每秒的请求速率</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> rateLimiter.tryAcquire(<span class=\"number\">0</span>, TimeUnit.MILLISECONDS);<span class=\"comment\">//尝试获取令牌</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"局限性\"><a href=\"#局限性\" class=\"headerlink\" title=\"局限性\"></a>局限性</h2><ol>\n<li>以上的RateLimiter只能应用于单进程，多进程间协同控制便无能为力</li>\n<li>RateLimiter能够处理突发请求(预消费)，这里rest接口调用频率限制是固定的，不需要更不能使用预消费能力，否则将会导致接口调用失败</li>\n</ol>\n<h2 id=\"基于Redis的实现\"><a href=\"#基于Redis的实现\" class=\"headerlink\" title=\"基于Redis的实现\"></a>基于Redis的实现</h2><p>参考Guava RateLimiter实现思路，不同的是，Guava将令牌桶数据存放于对象（内存）中，这里讲令牌桶数据存放在redis中。可以参考此文章<a href=\"https://segmentfault.com/a/1190000012947169?_blank\" target=\"_blank\" rel=\"noopener\">基于redis的分布式RateLimiter(限流)实现</a></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><h2 id=\"计数器-滑动窗口\"><a href=\"#计数器-滑动窗口\" class=\"headerlink\" title=\"计数器/滑动窗口\"></a>计数器/滑动窗口</h2><p>计数器算法是最简单的算法，可以看成是滑动窗口的低精度实现。滑动窗口由于需要存储多份的计数器（每一个格子存一份），所以滑动窗口在实现上需要更多的存储空间。也就是说，如果滑动窗口的精度越高，需要的存储空间就越大。</p>\n<h2 id=\"漏桶算法-令牌桶算法\"><a href=\"#漏桶算法-令牌桶算法\" class=\"headerlink\" title=\"漏桶算法/令牌桶算法\"></a>漏桶算法/令牌桶算法</h2><p>漏桶算法和令牌桶算法最明显的区别是令牌桶算法允许流量一定程度的突发。因为默认的令牌桶算法，取走token是不需要耗费时间的，也就是说，假设桶内有100个token时，那么可以瞬间允许100个请求通过。</p>\n<p>令牌桶算法由于实现简单，且允许某些流量的突发，对用户友好，所以被业界采用地较多。当然我们需要具体情况具体分析，只有最合适的算法，没有最优的算法。</p>"},{"title":"深入ThreadLocal","author":"James","date":"2014-06-05T01:54:00.000Z","_content":"\n# 前言\n\nThreadlocal是什么？它一个线程的本地变量副本，当工作在多线程的环境中每个线程中的对象使用Threadlocal维护变量。Threadlocal为每个线程分配一个独立的变量副本，所以线程都是独立访问和操作自己的副本不会影响到其他线程\n\n<!-- more -->\n\n# 原理\n\n## 看看源码\n\n在使用`ThreadLocal`时，首先创建`ThreadLocal`对象，然后再调用其`set(T)`、`T get()`方法 \n\n```java\npublic void set(T value) { \n    Thread t = Thread.currentThread(); \n    ThreadLocalMap map = getMap(t); \n    if (map != null) \n        map.set(this, value); \n    else createMap(t, value); \n}\n\n//返回Thread实例的threadLocals属性\nThreadLocalMap getMap(Thread t) {\n    return t.threadLocals;\n}\n```\n\n先拿到保存键值对的`ThreadLocalMap`对象实例`map`，如果`map`为空（第一次调用的时候`map`值为`null`），则去创建一个`ThreadLocalMap`对象并赋值给`map`，并把键值对保存到`map`中。 \n\n```java\npublic class Thread{\n    ...\n\tThreadLocal.ThreadLocalMap threadLocals = null\n}\n```\n\n每个线程引用的`ThreadLocal`副本值都是保存在当前线程`Thread`对象里面的。存储结构为`ThreadLocalMap`类型，`ThreadLocalMap`保存的键类型为`ThreadLocal`，值为`副本值`。 \n\n```java\npublic T get() { \n    Thread t = Thread.currentThread(); \n    ThreadLocalMap map = getMap(t); \n    if (map != null) { \n        ThreadLocalMap.Entry e = map.getEntry(this); \n        if (e != null) return (T)e.value; \n    } \n    return setInitialValue(); \n}\n\nThreadLocalMap getMap(Thread t) {\n    return t.threadLocals;\n}\n```\n\n当前线程`Thread`对象实例中保存的`ThreadLocalMap`对象`map`，然后从`map`中读取键为`this`（即`ThreadLocal`类实例）对应的值。 \n\n### ThreadLocalMap \n\n```java\nstatic class ThreadLocalMap {\n    static class Entry extends WeakReference<ThreadLocal> {\n        Object value; // 实际保存的值\n        Entry(ThreadLocal k, Object v) {\n            super(k);\n            value = v;\n        }\n    }\n    /**\n     * 哈希表初始大小，但是这个值无论怎么变化都必须是2的N次方\n     */\n    private static final int INITIAL_CAPACITY = 16;\n    /**\n     * 哈希表中实际存放对象的容器，该容器的大小也必须是2的幂数倍\n     */\n    private Entry[] table;\n    /**\n     * 表中Entry元素的数量\n     */\n    private int size = 0;\n\n    /**\n     * 哈希表的扩容阈值\n     */\n    private int threshold; // 默认值为0\n\n    private void setThreshold(int len) {\n        threshold = len * 2 / 3;\n    }\n    /**\n    * 并不是Thread被创建后就一定会创建一个新的ThreadLocalMap，\n    * 除非当前Thread真的用了ThreadLocal\n    * 并且赋值到ThreadLocal后才会创建一个ThreadLocalMap\n    */\n    ThreadLocalMap(ThreadLocal firstKey, Object firstValue) {\n        table = new Entry[INITIAL_CAPACITY];\n        int i = firstKey.threadLocalHashCode \n              & (INITIAL_CAPACITY - 1);\n        table[i] = new Entry(firstKey, firstValue);\n        size = 1;\n        setThreshold(INITIAL_CAPACITY);\n    }\n```\n\n1. 存放对象信息的表是一个数组。这类方式和HashMap有点像 \n2. 数组元素是一个**WeakReference（弱引用）**的实现;因为线程的执行时间可能很长，但是对应的ThreadLocal对象生成时间未必有线程的执行寿命那般长，在对应ThreadLocal对象由该线程作为根节点出发，逻辑上不可达时，就应该可以被GC，如果使用了强引用，该对象无法被成功GC，因此会带来内存泄露的问题 \n\n\n\n## 这样设计 why?\n\n我们的第一想法使用**全局ConcurrentMap结构**。在对应的`ThreadLocal`对象内维持一个本地变量表，以当前线程（使用Thread.currentThread()方法）作为key，查找对应的的本地变量（value值），那么这么设计存在什么问题呢？ \n\n第一，全局的ConcurrentMap表，这类数据结构虽然是一类分段式且线程安全的容器，但是这类容器仍然会有线程同步的的额外开销。\n\n第二，随着线程的销毁，原有的ConcurrentMap没有被回收，因此导致了内存泄露。\n\n\n\n# 总结\n\n1. ThreadLocal 通过隐式的在不同线程内创建独立实例副本避免了实例线程安全的问题 \n2. 每个线程持有一个 Map 并维护了 ThreadLocal 对象与具体实例的映射，该 Map 由于只被持有它的线程访问，故不存在线程安全以及锁的问题 \n3. ThreadLocalMap 的 Entry 对 ThreadLocal 的引用为弱引用，避免了 ThreadLocal 对象无法被回收的问题 \n4. ThreadLocal 适用于变量在线程间隔离且在方法间共享的场景 ","source":"_posts/ThreadLocal.md","raw":"title: 深入ThreadLocal\nauthor: James\ntags:\n  - ThreadLocal\ncategories:\n  - Java\ndate: 2014-06-05 09:54:00\n---\n\n# 前言\n\nThreadlocal是什么？它一个线程的本地变量副本，当工作在多线程的环境中每个线程中的对象使用Threadlocal维护变量。Threadlocal为每个线程分配一个独立的变量副本，所以线程都是独立访问和操作自己的副本不会影响到其他线程\n\n<!-- more -->\n\n# 原理\n\n## 看看源码\n\n在使用`ThreadLocal`时，首先创建`ThreadLocal`对象，然后再调用其`set(T)`、`T get()`方法 \n\n```java\npublic void set(T value) { \n    Thread t = Thread.currentThread(); \n    ThreadLocalMap map = getMap(t); \n    if (map != null) \n        map.set(this, value); \n    else createMap(t, value); \n}\n\n//返回Thread实例的threadLocals属性\nThreadLocalMap getMap(Thread t) {\n    return t.threadLocals;\n}\n```\n\n先拿到保存键值对的`ThreadLocalMap`对象实例`map`，如果`map`为空（第一次调用的时候`map`值为`null`），则去创建一个`ThreadLocalMap`对象并赋值给`map`，并把键值对保存到`map`中。 \n\n```java\npublic class Thread{\n    ...\n\tThreadLocal.ThreadLocalMap threadLocals = null\n}\n```\n\n每个线程引用的`ThreadLocal`副本值都是保存在当前线程`Thread`对象里面的。存储结构为`ThreadLocalMap`类型，`ThreadLocalMap`保存的键类型为`ThreadLocal`，值为`副本值`。 \n\n```java\npublic T get() { \n    Thread t = Thread.currentThread(); \n    ThreadLocalMap map = getMap(t); \n    if (map != null) { \n        ThreadLocalMap.Entry e = map.getEntry(this); \n        if (e != null) return (T)e.value; \n    } \n    return setInitialValue(); \n}\n\nThreadLocalMap getMap(Thread t) {\n    return t.threadLocals;\n}\n```\n\n当前线程`Thread`对象实例中保存的`ThreadLocalMap`对象`map`，然后从`map`中读取键为`this`（即`ThreadLocal`类实例）对应的值。 \n\n### ThreadLocalMap \n\n```java\nstatic class ThreadLocalMap {\n    static class Entry extends WeakReference<ThreadLocal> {\n        Object value; // 实际保存的值\n        Entry(ThreadLocal k, Object v) {\n            super(k);\n            value = v;\n        }\n    }\n    /**\n     * 哈希表初始大小，但是这个值无论怎么变化都必须是2的N次方\n     */\n    private static final int INITIAL_CAPACITY = 16;\n    /**\n     * 哈希表中实际存放对象的容器，该容器的大小也必须是2的幂数倍\n     */\n    private Entry[] table;\n    /**\n     * 表中Entry元素的数量\n     */\n    private int size = 0;\n\n    /**\n     * 哈希表的扩容阈值\n     */\n    private int threshold; // 默认值为0\n\n    private void setThreshold(int len) {\n        threshold = len * 2 / 3;\n    }\n    /**\n    * 并不是Thread被创建后就一定会创建一个新的ThreadLocalMap，\n    * 除非当前Thread真的用了ThreadLocal\n    * 并且赋值到ThreadLocal后才会创建一个ThreadLocalMap\n    */\n    ThreadLocalMap(ThreadLocal firstKey, Object firstValue) {\n        table = new Entry[INITIAL_CAPACITY];\n        int i = firstKey.threadLocalHashCode \n              & (INITIAL_CAPACITY - 1);\n        table[i] = new Entry(firstKey, firstValue);\n        size = 1;\n        setThreshold(INITIAL_CAPACITY);\n    }\n```\n\n1. 存放对象信息的表是一个数组。这类方式和HashMap有点像 \n2. 数组元素是一个**WeakReference（弱引用）**的实现;因为线程的执行时间可能很长，但是对应的ThreadLocal对象生成时间未必有线程的执行寿命那般长，在对应ThreadLocal对象由该线程作为根节点出发，逻辑上不可达时，就应该可以被GC，如果使用了强引用，该对象无法被成功GC，因此会带来内存泄露的问题 \n\n\n\n## 这样设计 why?\n\n我们的第一想法使用**全局ConcurrentMap结构**。在对应的`ThreadLocal`对象内维持一个本地变量表，以当前线程（使用Thread.currentThread()方法）作为key，查找对应的的本地变量（value值），那么这么设计存在什么问题呢？ \n\n第一，全局的ConcurrentMap表，这类数据结构虽然是一类分段式且线程安全的容器，但是这类容器仍然会有线程同步的的额外开销。\n\n第二，随着线程的销毁，原有的ConcurrentMap没有被回收，因此导致了内存泄露。\n\n\n\n# 总结\n\n1. ThreadLocal 通过隐式的在不同线程内创建独立实例副本避免了实例线程安全的问题 \n2. 每个线程持有一个 Map 并维护了 ThreadLocal 对象与具体实例的映射，该 Map 由于只被持有它的线程访问，故不存在线程安全以及锁的问题 \n3. ThreadLocalMap 的 Entry 对 ThreadLocal 的引用为弱引用，避免了 ThreadLocal 对象无法被回收的问题 \n4. ThreadLocal 适用于变量在线程间隔离且在方法间共享的场景 ","slug":"ThreadLocal","published":1,"updated":"2018-06-07T01:48:49.313Z","_id":"cji3vntwq0000zgkckv35utes","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>Threadlocal是什么？它一个线程的本地变量副本，当工作在多线程的环境中每个线程中的对象使用Threadlocal维护变量。Threadlocal为每个线程分配一个独立的变量副本，所以线程都是独立访问和操作自己的副本不会影响到其他线程</p>\n<a id=\"more\"></a>\n<h1 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h1><h2 id=\"看看源码\"><a href=\"#看看源码\" class=\"headerlink\" title=\"看看源码\"></a>看看源码</h2><p>在使用<code>ThreadLocal</code>时，首先创建<code>ThreadLocal</code>对象，然后再调用其<code>set(T)</code>、<code>T get()</code>方法 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(T value)</span> </span>&#123; </span><br><span class=\"line\">    Thread t = Thread.currentThread(); </span><br><span class=\"line\">    ThreadLocalMap map = getMap(t); </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>) </span><br><span class=\"line\">        map.set(<span class=\"keyword\">this</span>, value); </span><br><span class=\"line\">    <span class=\"keyword\">else</span> createMap(t, value); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//返回Thread实例的threadLocals属性</span></span><br><span class=\"line\"><span class=\"function\">ThreadLocalMap <span class=\"title\">getMap</span><span class=\"params\">(Thread t)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t.threadLocals;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>先拿到保存键值对的<code>ThreadLocalMap</code>对象实例<code>map</code>，如果<code>map</code>为空（第一次调用的时候<code>map</code>值为<code>null</code>），则去创建一个<code>ThreadLocalMap</code>对象并赋值给<code>map</code>，并把键值对保存到<code>map</code>中。 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Thread</span></span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">\tThreadLocal.ThreadLocalMap threadLocals = <span class=\"keyword\">null</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>每个线程引用的<code>ThreadLocal</code>副本值都是保存在当前线程<code>Thread</code>对象里面的。存储结构为<code>ThreadLocalMap</code>类型，<code>ThreadLocalMap</code>保存的键类型为<code>ThreadLocal</code>，值为<code>副本值</code>。 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">    Thread t = Thread.currentThread(); </span><br><span class=\"line\">    ThreadLocalMap map = getMap(t); </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>) &#123; </span><br><span class=\"line\">        ThreadLocalMap.Entry e = map.getEntry(<span class=\"keyword\">this</span>); </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> (T)e.value; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> setInitialValue(); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ThreadLocalMap <span class=\"title\">getMap</span><span class=\"params\">(Thread t)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t.threadLocals;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当前线程<code>Thread</code>对象实例中保存的<code>ThreadLocalMap</code>对象<code>map</code>，然后从<code>map</code>中读取键为<code>this</code>（即<code>ThreadLocal</code>类实例）对应的值。 </p>\n<h3 id=\"ThreadLocalMap\"><a href=\"#ThreadLocalMap\" class=\"headerlink\" title=\"ThreadLocalMap\"></a>ThreadLocalMap</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadLocalMap</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Entry</span> <span class=\"keyword\">extends</span> <span class=\"title\">WeakReference</span>&lt;<span class=\"title\">ThreadLocal</span>&gt; </span>&#123;</span><br><span class=\"line\">        Object value; <span class=\"comment\">// 实际保存的值</span></span><br><span class=\"line\">        Entry(ThreadLocal k, Object v) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>(k);</span><br><span class=\"line\">            value = v;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 哈希表初始大小，但是这个值无论怎么变化都必须是2的N次方</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> INITIAL_CAPACITY = <span class=\"number\">16</span>;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 哈希表中实际存放对象的容器，该容器的大小也必须是2的幂数倍</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Entry[] table;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 表中Entry元素的数量</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> size = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 哈希表的扩容阈值</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> threshold; <span class=\"comment\">// 默认值为0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">setThreshold</span><span class=\"params\">(<span class=\"keyword\">int</span> len)</span> </span>&#123;</span><br><span class=\"line\">        threshold = len * <span class=\"number\">2</span> / <span class=\"number\">3</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 并不是Thread被创建后就一定会创建一个新的ThreadLocalMap，</span></span><br><span class=\"line\"><span class=\"comment\">    * 除非当前Thread真的用了ThreadLocal</span></span><br><span class=\"line\"><span class=\"comment\">    * 并且赋值到ThreadLocal后才会创建一个ThreadLocalMap</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    ThreadLocalMap(ThreadLocal firstKey, Object firstValue) &#123;</span><br><span class=\"line\">        table = <span class=\"keyword\">new</span> Entry[INITIAL_CAPACITY];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = firstKey.threadLocalHashCode </span><br><span class=\"line\">              &amp; (INITIAL_CAPACITY - <span class=\"number\">1</span>);</span><br><span class=\"line\">        table[i] = <span class=\"keyword\">new</span> Entry(firstKey, firstValue);</span><br><span class=\"line\">        size = <span class=\"number\">1</span>;</span><br><span class=\"line\">        setThreshold(INITIAL_CAPACITY);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>存放对象信息的表是一个数组。这类方式和HashMap有点像 </li>\n<li>数组元素是一个<strong>WeakReference（弱引用）</strong>的实现;因为线程的执行时间可能很长，但是对应的ThreadLocal对象生成时间未必有线程的执行寿命那般长，在对应ThreadLocal对象由该线程作为根节点出发，逻辑上不可达时，就应该可以被GC，如果使用了强引用，该对象无法被成功GC，因此会带来内存泄露的问题 </li>\n</ol>\n<h2 id=\"这样设计-why\"><a href=\"#这样设计-why\" class=\"headerlink\" title=\"这样设计 why?\"></a>这样设计 why?</h2><p>我们的第一想法使用<strong>全局ConcurrentMap结构</strong>。在对应的<code>ThreadLocal</code>对象内维持一个本地变量表，以当前线程（使用Thread.currentThread()方法）作为key，查找对应的的本地变量（value值），那么这么设计存在什么问题呢？ </p>\n<p>第一，全局的ConcurrentMap表，这类数据结构虽然是一类分段式且线程安全的容器，但是这类容器仍然会有线程同步的的额外开销。</p>\n<p>第二，随着线程的销毁，原有的ConcurrentMap没有被回收，因此导致了内存泄露。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ol>\n<li>ThreadLocal 通过隐式的在不同线程内创建独立实例副本避免了实例线程安全的问题 </li>\n<li>每个线程持有一个 Map 并维护了 ThreadLocal 对象与具体实例的映射，该 Map 由于只被持有它的线程访问，故不存在线程安全以及锁的问题 </li>\n<li>ThreadLocalMap 的 Entry 对 ThreadLocal 的引用为弱引用，避免了 ThreadLocal 对象无法被回收的问题 </li>\n<li>ThreadLocal 适用于变量在线程间隔离且在方法间共享的场景 </li>\n</ol>\n","site":{"data":{}},"excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>Threadlocal是什么？它一个线程的本地变量副本，当工作在多线程的环境中每个线程中的对象使用Threadlocal维护变量。Threadlocal为每个线程分配一个独立的变量副本，所以线程都是独立访问和操作自己的副本不会影响到其他线程</p>","more":"<h1 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h1><h2 id=\"看看源码\"><a href=\"#看看源码\" class=\"headerlink\" title=\"看看源码\"></a>看看源码</h2><p>在使用<code>ThreadLocal</code>时，首先创建<code>ThreadLocal</code>对象，然后再调用其<code>set(T)</code>、<code>T get()</code>方法 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(T value)</span> </span>&#123; </span><br><span class=\"line\">    Thread t = Thread.currentThread(); </span><br><span class=\"line\">    ThreadLocalMap map = getMap(t); </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>) </span><br><span class=\"line\">        map.set(<span class=\"keyword\">this</span>, value); </span><br><span class=\"line\">    <span class=\"keyword\">else</span> createMap(t, value); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//返回Thread实例的threadLocals属性</span></span><br><span class=\"line\"><span class=\"function\">ThreadLocalMap <span class=\"title\">getMap</span><span class=\"params\">(Thread t)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t.threadLocals;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>先拿到保存键值对的<code>ThreadLocalMap</code>对象实例<code>map</code>，如果<code>map</code>为空（第一次调用的时候<code>map</code>值为<code>null</code>），则去创建一个<code>ThreadLocalMap</code>对象并赋值给<code>map</code>，并把键值对保存到<code>map</code>中。 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Thread</span></span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">\tThreadLocal.ThreadLocalMap threadLocals = <span class=\"keyword\">null</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>每个线程引用的<code>ThreadLocal</code>副本值都是保存在当前线程<code>Thread</code>对象里面的。存储结构为<code>ThreadLocalMap</code>类型，<code>ThreadLocalMap</code>保存的键类型为<code>ThreadLocal</code>，值为<code>副本值</code>。 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">    Thread t = Thread.currentThread(); </span><br><span class=\"line\">    ThreadLocalMap map = getMap(t); </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>) &#123; </span><br><span class=\"line\">        ThreadLocalMap.Entry e = map.getEntry(<span class=\"keyword\">this</span>); </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> (T)e.value; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> setInitialValue(); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ThreadLocalMap <span class=\"title\">getMap</span><span class=\"params\">(Thread t)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t.threadLocals;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当前线程<code>Thread</code>对象实例中保存的<code>ThreadLocalMap</code>对象<code>map</code>，然后从<code>map</code>中读取键为<code>this</code>（即<code>ThreadLocal</code>类实例）对应的值。 </p>\n<h3 id=\"ThreadLocalMap\"><a href=\"#ThreadLocalMap\" class=\"headerlink\" title=\"ThreadLocalMap\"></a>ThreadLocalMap</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadLocalMap</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Entry</span> <span class=\"keyword\">extends</span> <span class=\"title\">WeakReference</span>&lt;<span class=\"title\">ThreadLocal</span>&gt; </span>&#123;</span><br><span class=\"line\">        Object value; <span class=\"comment\">// 实际保存的值</span></span><br><span class=\"line\">        Entry(ThreadLocal k, Object v) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>(k);</span><br><span class=\"line\">            value = v;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 哈希表初始大小，但是这个值无论怎么变化都必须是2的N次方</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> INITIAL_CAPACITY = <span class=\"number\">16</span>;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 哈希表中实际存放对象的容器，该容器的大小也必须是2的幂数倍</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Entry[] table;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 表中Entry元素的数量</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> size = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 哈希表的扩容阈值</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> threshold; <span class=\"comment\">// 默认值为0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">setThreshold</span><span class=\"params\">(<span class=\"keyword\">int</span> len)</span> </span>&#123;</span><br><span class=\"line\">        threshold = len * <span class=\"number\">2</span> / <span class=\"number\">3</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 并不是Thread被创建后就一定会创建一个新的ThreadLocalMap，</span></span><br><span class=\"line\"><span class=\"comment\">    * 除非当前Thread真的用了ThreadLocal</span></span><br><span class=\"line\"><span class=\"comment\">    * 并且赋值到ThreadLocal后才会创建一个ThreadLocalMap</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    ThreadLocalMap(ThreadLocal firstKey, Object firstValue) &#123;</span><br><span class=\"line\">        table = <span class=\"keyword\">new</span> Entry[INITIAL_CAPACITY];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = firstKey.threadLocalHashCode </span><br><span class=\"line\">              &amp; (INITIAL_CAPACITY - <span class=\"number\">1</span>);</span><br><span class=\"line\">        table[i] = <span class=\"keyword\">new</span> Entry(firstKey, firstValue);</span><br><span class=\"line\">        size = <span class=\"number\">1</span>;</span><br><span class=\"line\">        setThreshold(INITIAL_CAPACITY);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>存放对象信息的表是一个数组。这类方式和HashMap有点像 </li>\n<li>数组元素是一个<strong>WeakReference（弱引用）</strong>的实现;因为线程的执行时间可能很长，但是对应的ThreadLocal对象生成时间未必有线程的执行寿命那般长，在对应ThreadLocal对象由该线程作为根节点出发，逻辑上不可达时，就应该可以被GC，如果使用了强引用，该对象无法被成功GC，因此会带来内存泄露的问题 </li>\n</ol>\n<h2 id=\"这样设计-why\"><a href=\"#这样设计-why\" class=\"headerlink\" title=\"这样设计 why?\"></a>这样设计 why?</h2><p>我们的第一想法使用<strong>全局ConcurrentMap结构</strong>。在对应的<code>ThreadLocal</code>对象内维持一个本地变量表，以当前线程（使用Thread.currentThread()方法）作为key，查找对应的的本地变量（value值），那么这么设计存在什么问题呢？ </p>\n<p>第一，全局的ConcurrentMap表，这类数据结构虽然是一类分段式且线程安全的容器，但是这类容器仍然会有线程同步的的额外开销。</p>\n<p>第二，随着线程的销毁，原有的ConcurrentMap没有被回收，因此导致了内存泄露。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ol>\n<li>ThreadLocal 通过隐式的在不同线程内创建独立实例副本避免了实例线程安全的问题 </li>\n<li>每个线程持有一个 Map 并维护了 ThreadLocal 对象与具体实例的映射，该 Map 由于只被持有它的线程访问，故不存在线程安全以及锁的问题 </li>\n<li>ThreadLocalMap 的 Entry 对 ThreadLocal 的引用为弱引用，避免了 ThreadLocal 对象无法被回收的问题 </li>\n<li>ThreadLocal 适用于变量在线程间隔离且在方法间共享的场景 </li>\n</ol>"},{"title":"Spring系列-AOP","author":"James","date":"2013-09-13T08:30:00.000Z","_content":"\n# 前言\n\nAOP（Aspect Orient Programming），一般称为面向切面编程，作为面向对象的一种补充，用于处理系统中分布于各个模块的横切关注点。 OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。这种散布在各处的无关的代码被称为横切（cross-cutting）代码，在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。AOP技术则恰恰相反，它利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即方面。所谓“方面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。\n\n <!-- more -->\n\n# 用途\n\n-  记录日志，在方法执行前后记录系统日志。 \n- 性能监控，在方法调用前后记录调用时间，方法执行太长或超时报警。 \n- 权限验证，方法执行前验证是否有权限执行当前方法，没有则抛出没有权限执行异常，由业务代码捕捉。 \n- 缓存代理，缓存某方法的返回值，下次执行该方法时，直接从缓存里获取。 \n\n # 术语\n\n- **Aspect（切面）**：一个关注点的模块化，这个关注点可以横切多个对象。\n- **Joinpoint （连接点）**：在程序执行过程中某个特点的点，例如某方法调用的时候或者处理异常的时候。\n- **Pointcut（切入点）**：匹配连接点的断言，通知和一个切入点表达式关联，满足这个切入点的连接点上运行。\n- **Advice（通知）**：在切面的某个特点的连接点\n  - 前置通知：在某连接点之前执行的通知，不能阻止连接点之前执行的流程\n  - 后置通知：在连接点完成执行后的通知。\n  - 环绕通知：包围一个连接点的通知，可以在方法调用的前后完成自定义的行为，可以选择是否继续执行连接点或者直接返回。\n  - 异常通知：在方法抛出异常退出时执行的通知。\n  - 最终通知：当某连接点退出的时候执行的通知。（不论是否正常返回还是异常）\n\n# Spring 的 Aop  \n\nSpring提供了两种方式来生成代理对象:  JDKProxy和Cglib，具体使用哪种方式生成由AopProxyFactory根据AdvisedSupport对象的配置来决定。默认的策略是如果目标类是接口，则使用JDK动态代理技术，否则使用Cglib来生成代理。 \n\n主要以下几个步骤： \n1. 定义普通业务组件。\n2. 定义切入点，一个切入点可能横切多个业务组件。\n3. 定义增强处理，增强处理就是在 AOP 框架为普通业务组件织入的处理动作。\n\n## 简单demo\n\n```java\n@Aspect\npublic class TransactionDemo {\n    @Pointcut(value = \"execution(* com.lijiao.core.service.*.*.*(..))\")\n    public void point() {\n    }\n\n    @Before(value = \"point()\")\n    public void before() {\n        System.out.println(\"transaction begin\");\n    }\n\n    @AfterReturning(value = \"point()\")\n    public void after() {\n        System.out.println(\"transaction commit\");\n    }\n\n    @Around(\"point()\")\n    public void around(ProceedingJoinPoint joinPoint) throws Throwable {\n        System.out.println(\"transaction begin\");\n        joinPoint.proceed();\n        System.out.println(\"transaction commit\");\n    }\n}\n\n```\n\n## 要点\n\n1. Spring 的 AOP 代理由 Spring 的 IoC 容器负责生成、管理，其依赖关系也由 IoC 容器负责管理。因此，AOP 代理可以直接使用容器中的其他 Bean 实例作为目标，这种关系可由 IoC 容器的依赖注入提供。 \n2. Spring提供了两种方式来生成代理对象: JDKProxy和Cglib，具体使用哪种方式生成由AopProxyFactory根据AdvisedSupport对象的配置来决定。默认的策略是如果目标类是接口，则使用JDK动态代理技术，否则使用Cglib来生成代理。\n\n\n\n*JDK动态代理*\n\n- JDK动态代理主要涉及到java.lang.reflect包中的两个类：Proxy和InvocationHandler。InvocationHandler是一个接口，通过实现该接口定义横切逻辑，并通过反射机制调用目标类的代码，动态将横切逻辑和业务逻辑编制在一起。\n- Proxy利用InvocationHandler动态创建一个符合某一接口的实例，生成目标类的代理对象。\n\n*CGLib动态代理*\n\n- CGLib全称为Code Generation Library，是一个强大的高性能，高质量的代码生成类库，可以在运行期扩展Java类与实现Java接口，CGLib封装了asm，可以再运行期动态生成新的class。和JDK动态代理相比较：JDK创建代理有一个限制，就是只能为接口创建代理实例，而对于没有通过接口定义业务方法的类，则可以通过CGLib创建动态代理。\n\n \n\n\n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n ","source":"_posts/Spring-AOP.md","raw":"title: Spring系列-AOP\nauthor: James\ntags:\n  - spring\n  - aop\ncategories:\n  - 框架\ndate: 2013-09-13 16:30:00\n---\n\n# 前言\n\nAOP（Aspect Orient Programming），一般称为面向切面编程，作为面向对象的一种补充，用于处理系统中分布于各个模块的横切关注点。 OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。这种散布在各处的无关的代码被称为横切（cross-cutting）代码，在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。AOP技术则恰恰相反，它利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即方面。所谓“方面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。\n\n <!-- more -->\n\n# 用途\n\n-  记录日志，在方法执行前后记录系统日志。 \n- 性能监控，在方法调用前后记录调用时间，方法执行太长或超时报警。 \n- 权限验证，方法执行前验证是否有权限执行当前方法，没有则抛出没有权限执行异常，由业务代码捕捉。 \n- 缓存代理，缓存某方法的返回值，下次执行该方法时，直接从缓存里获取。 \n\n # 术语\n\n- **Aspect（切面）**：一个关注点的模块化，这个关注点可以横切多个对象。\n- **Joinpoint （连接点）**：在程序执行过程中某个特点的点，例如某方法调用的时候或者处理异常的时候。\n- **Pointcut（切入点）**：匹配连接点的断言，通知和一个切入点表达式关联，满足这个切入点的连接点上运行。\n- **Advice（通知）**：在切面的某个特点的连接点\n  - 前置通知：在某连接点之前执行的通知，不能阻止连接点之前执行的流程\n  - 后置通知：在连接点完成执行后的通知。\n  - 环绕通知：包围一个连接点的通知，可以在方法调用的前后完成自定义的行为，可以选择是否继续执行连接点或者直接返回。\n  - 异常通知：在方法抛出异常退出时执行的通知。\n  - 最终通知：当某连接点退出的时候执行的通知。（不论是否正常返回还是异常）\n\n# Spring 的 Aop  \n\nSpring提供了两种方式来生成代理对象:  JDKProxy和Cglib，具体使用哪种方式生成由AopProxyFactory根据AdvisedSupport对象的配置来决定。默认的策略是如果目标类是接口，则使用JDK动态代理技术，否则使用Cglib来生成代理。 \n\n主要以下几个步骤： \n1. 定义普通业务组件。\n2. 定义切入点，一个切入点可能横切多个业务组件。\n3. 定义增强处理，增强处理就是在 AOP 框架为普通业务组件织入的处理动作。\n\n## 简单demo\n\n```java\n@Aspect\npublic class TransactionDemo {\n    @Pointcut(value = \"execution(* com.lijiao.core.service.*.*.*(..))\")\n    public void point() {\n    }\n\n    @Before(value = \"point()\")\n    public void before() {\n        System.out.println(\"transaction begin\");\n    }\n\n    @AfterReturning(value = \"point()\")\n    public void after() {\n        System.out.println(\"transaction commit\");\n    }\n\n    @Around(\"point()\")\n    public void around(ProceedingJoinPoint joinPoint) throws Throwable {\n        System.out.println(\"transaction begin\");\n        joinPoint.proceed();\n        System.out.println(\"transaction commit\");\n    }\n}\n\n```\n\n## 要点\n\n1. Spring 的 AOP 代理由 Spring 的 IoC 容器负责生成、管理，其依赖关系也由 IoC 容器负责管理。因此，AOP 代理可以直接使用容器中的其他 Bean 实例作为目标，这种关系可由 IoC 容器的依赖注入提供。 \n2. Spring提供了两种方式来生成代理对象: JDKProxy和Cglib，具体使用哪种方式生成由AopProxyFactory根据AdvisedSupport对象的配置来决定。默认的策略是如果目标类是接口，则使用JDK动态代理技术，否则使用Cglib来生成代理。\n\n\n\n*JDK动态代理*\n\n- JDK动态代理主要涉及到java.lang.reflect包中的两个类：Proxy和InvocationHandler。InvocationHandler是一个接口，通过实现该接口定义横切逻辑，并通过反射机制调用目标类的代码，动态将横切逻辑和业务逻辑编制在一起。\n- Proxy利用InvocationHandler动态创建一个符合某一接口的实例，生成目标类的代理对象。\n\n*CGLib动态代理*\n\n- CGLib全称为Code Generation Library，是一个强大的高性能，高质量的代码生成类库，可以在运行期扩展Java类与实现Java接口，CGLib封装了asm，可以再运行期动态生成新的class。和JDK动态代理相比较：JDK创建代理有一个限制，就是只能为接口创建代理实例，而对于没有通过接口定义业务方法的类，则可以通过CGLib创建动态代理。\n\n \n\n\n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n ","slug":"Spring-AOP","published":1,"updated":"2018-06-19T06:07:14.721Z","_id":"cjila9qrw0000o8kcgwt5n19a","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>AOP（Aspect Orient Programming），一般称为面向切面编程，作为面向对象的一种补充，用于处理系统中分布于各个模块的横切关注点。 OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。这种散布在各处的无关的代码被称为横切（cross-cutting）代码，在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。AOP技术则恰恰相反，它利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即方面。所谓“方面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。</p>\n <a id=\"more\"></a>\n<h1 id=\"用途\"><a href=\"#用途\" class=\"headerlink\" title=\"用途\"></a>用途</h1><ul>\n<li>记录日志，在方法执行前后记录系统日志。 </li>\n<li>性能监控，在方法调用前后记录调用时间，方法执行太长或超时报警。 </li>\n<li>权限验证，方法执行前验证是否有权限执行当前方法，没有则抛出没有权限执行异常，由业务代码捕捉。 </li>\n<li><p>缓存代理，缓存某方法的返回值，下次执行该方法时，直接从缓存里获取。 </p>\n<h1 id=\"术语\"><a href=\"#术语\" class=\"headerlink\" title=\"术语\"></a>术语</h1></li>\n<li><p><strong>Aspect（切面）</strong>：一个关注点的模块化，这个关注点可以横切多个对象。</p>\n</li>\n<li><strong>Joinpoint （连接点）</strong>：在程序执行过程中某个特点的点，例如某方法调用的时候或者处理异常的时候。</li>\n<li><strong>Pointcut（切入点）</strong>：匹配连接点的断言，通知和一个切入点表达式关联，满足这个切入点的连接点上运行。</li>\n<li><strong>Advice（通知）</strong>：在切面的某个特点的连接点<ul>\n<li>前置通知：在某连接点之前执行的通知，不能阻止连接点之前执行的流程</li>\n<li>后置通知：在连接点完成执行后的通知。</li>\n<li>环绕通知：包围一个连接点的通知，可以在方法调用的前后完成自定义的行为，可以选择是否继续执行连接点或者直接返回。</li>\n<li>异常通知：在方法抛出异常退出时执行的通知。</li>\n<li>最终通知：当某连接点退出的时候执行的通知。（不论是否正常返回还是异常）</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"Spring-的-Aop\"><a href=\"#Spring-的-Aop\" class=\"headerlink\" title=\"Spring 的 Aop\"></a>Spring 的 Aop</h1><p>Spring提供了两种方式来生成代理对象:  JDKProxy和Cglib，具体使用哪种方式生成由AopProxyFactory根据AdvisedSupport对象的配置来决定。默认的策略是如果目标类是接口，则使用JDK动态代理技术，否则使用Cglib来生成代理。 </p>\n<p>主要以下几个步骤： </p>\n<ol>\n<li>定义普通业务组件。</li>\n<li>定义切入点，一个切入点可能横切多个业务组件。</li>\n<li>定义增强处理，增强处理就是在 AOP 框架为普通业务组件织入的处理动作。</li>\n</ol>\n<h2 id=\"简单demo\"><a href=\"#简单demo\" class=\"headerlink\" title=\"简单demo\"></a>简单demo</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TransactionDemo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Pointcut</span>(value = <span class=\"string\">\"execution(* com.lijiao.core.service.*.*.*(..))\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">point</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Before</span>(value = <span class=\"string\">\"point()\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">before</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"transaction begin\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@AfterReturning</span>(value = <span class=\"string\">\"point()\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">after</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"transaction commit\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Around</span>(<span class=\"string\">\"point()\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">around</span><span class=\"params\">(ProceedingJoinPoint joinPoint)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"transaction begin\"</span>);</span><br><span class=\"line\">        joinPoint.proceed();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"transaction commit\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"要点\"><a href=\"#要点\" class=\"headerlink\" title=\"要点\"></a>要点</h2><ol>\n<li>Spring 的 AOP 代理由 Spring 的 IoC 容器负责生成、管理，其依赖关系也由 IoC 容器负责管理。因此，AOP 代理可以直接使用容器中的其他 Bean 实例作为目标，这种关系可由 IoC 容器的依赖注入提供。 </li>\n<li>Spring提供了两种方式来生成代理对象: JDKProxy和Cglib，具体使用哪种方式生成由AopProxyFactory根据AdvisedSupport对象的配置来决定。默认的策略是如果目标类是接口，则使用JDK动态代理技术，否则使用Cglib来生成代理。</li>\n</ol>\n<p><em>JDK动态代理</em></p>\n<ul>\n<li>JDK动态代理主要涉及到java.lang.reflect包中的两个类：Proxy和InvocationHandler。InvocationHandler是一个接口，通过实现该接口定义横切逻辑，并通过反射机制调用目标类的代码，动态将横切逻辑和业务逻辑编制在一起。</li>\n<li>Proxy利用InvocationHandler动态创建一个符合某一接口的实例，生成目标类的代理对象。</li>\n</ul>\n<p><em>CGLib动态代理</em></p>\n<ul>\n<li>CGLib全称为Code Generation Library，是一个强大的高性能，高质量的代码生成类库，可以在运行期扩展Java类与实现Java接口，CGLib封装了asm，可以再运行期动态生成新的class。和JDK动态代理相比较：JDK创建代理有一个限制，就是只能为接口创建代理实例，而对于没有通过接口定义业务方法的类，则可以通过CGLib创建动态代理。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>AOP（Aspect Orient Programming），一般称为面向切面编程，作为面向对象的一种补充，用于处理系统中分布于各个模块的横切关注点。 OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。这种散布在各处的无关的代码被称为横切（cross-cutting）代码，在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。AOP技术则恰恰相反，它利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即方面。所谓“方面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。</p>","more":"<h1 id=\"用途\"><a href=\"#用途\" class=\"headerlink\" title=\"用途\"></a>用途</h1><ul>\n<li>记录日志，在方法执行前后记录系统日志。 </li>\n<li>性能监控，在方法调用前后记录调用时间，方法执行太长或超时报警。 </li>\n<li>权限验证，方法执行前验证是否有权限执行当前方法，没有则抛出没有权限执行异常，由业务代码捕捉。 </li>\n<li><p>缓存代理，缓存某方法的返回值，下次执行该方法时，直接从缓存里获取。 </p>\n<h1 id=\"术语\"><a href=\"#术语\" class=\"headerlink\" title=\"术语\"></a>术语</h1></li>\n<li><p><strong>Aspect（切面）</strong>：一个关注点的模块化，这个关注点可以横切多个对象。</p>\n</li>\n<li><strong>Joinpoint （连接点）</strong>：在程序执行过程中某个特点的点，例如某方法调用的时候或者处理异常的时候。</li>\n<li><strong>Pointcut（切入点）</strong>：匹配连接点的断言，通知和一个切入点表达式关联，满足这个切入点的连接点上运行。</li>\n<li><strong>Advice（通知）</strong>：在切面的某个特点的连接点<ul>\n<li>前置通知：在某连接点之前执行的通知，不能阻止连接点之前执行的流程</li>\n<li>后置通知：在连接点完成执行后的通知。</li>\n<li>环绕通知：包围一个连接点的通知，可以在方法调用的前后完成自定义的行为，可以选择是否继续执行连接点或者直接返回。</li>\n<li>异常通知：在方法抛出异常退出时执行的通知。</li>\n<li>最终通知：当某连接点退出的时候执行的通知。（不论是否正常返回还是异常）</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"Spring-的-Aop\"><a href=\"#Spring-的-Aop\" class=\"headerlink\" title=\"Spring 的 Aop\"></a>Spring 的 Aop</h1><p>Spring提供了两种方式来生成代理对象:  JDKProxy和Cglib，具体使用哪种方式生成由AopProxyFactory根据AdvisedSupport对象的配置来决定。默认的策略是如果目标类是接口，则使用JDK动态代理技术，否则使用Cglib来生成代理。 </p>\n<p>主要以下几个步骤： </p>\n<ol>\n<li>定义普通业务组件。</li>\n<li>定义切入点，一个切入点可能横切多个业务组件。</li>\n<li>定义增强处理，增强处理就是在 AOP 框架为普通业务组件织入的处理动作。</li>\n</ol>\n<h2 id=\"简单demo\"><a href=\"#简单demo\" class=\"headerlink\" title=\"简单demo\"></a>简单demo</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TransactionDemo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Pointcut</span>(value = <span class=\"string\">\"execution(* com.lijiao.core.service.*.*.*(..))\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">point</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Before</span>(value = <span class=\"string\">\"point()\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">before</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"transaction begin\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@AfterReturning</span>(value = <span class=\"string\">\"point()\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">after</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"transaction commit\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Around</span>(<span class=\"string\">\"point()\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">around</span><span class=\"params\">(ProceedingJoinPoint joinPoint)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"transaction begin\"</span>);</span><br><span class=\"line\">        joinPoint.proceed();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"transaction commit\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"要点\"><a href=\"#要点\" class=\"headerlink\" title=\"要点\"></a>要点</h2><ol>\n<li>Spring 的 AOP 代理由 Spring 的 IoC 容器负责生成、管理，其依赖关系也由 IoC 容器负责管理。因此，AOP 代理可以直接使用容器中的其他 Bean 实例作为目标，这种关系可由 IoC 容器的依赖注入提供。 </li>\n<li>Spring提供了两种方式来生成代理对象: JDKProxy和Cglib，具体使用哪种方式生成由AopProxyFactory根据AdvisedSupport对象的配置来决定。默认的策略是如果目标类是接口，则使用JDK动态代理技术，否则使用Cglib来生成代理。</li>\n</ol>\n<p><em>JDK动态代理</em></p>\n<ul>\n<li>JDK动态代理主要涉及到java.lang.reflect包中的两个类：Proxy和InvocationHandler。InvocationHandler是一个接口，通过实现该接口定义横切逻辑，并通过反射机制调用目标类的代码，动态将横切逻辑和业务逻辑编制在一起。</li>\n<li>Proxy利用InvocationHandler动态创建一个符合某一接口的实例，生成目标类的代理对象。</li>\n</ul>\n<p><em>CGLib动态代理</em></p>\n<ul>\n<li>CGLib全称为Code Generation Library，是一个强大的高性能，高质量的代码生成类库，可以在运行期扩展Java类与实现Java接口，CGLib封装了asm，可以再运行期动态生成新的class。和JDK动态代理相比较：JDK创建代理有一个限制，就是只能为接口创建代理实例，而对于没有通过接口定义业务方法的类，则可以通过CGLib创建动态代理。</li>\n</ul>"},{"title":"Spring系列-IOC","author":"James","date":"2013-08-26T02:06:00.000Z","_content":"\n# 简介\n\nSpring 最重要的概念之一就是 IOC（Inversion of Control，控制倒转 ）,一起来分析下 Spring 的 IOC 容器。\n\n<!-- more -->\n\n# 为什么有IOC\n\nJava程序中的每个业务逻辑至少需要两个或以上的对象来协作完成。通常，每个对象在使用他的合作对象时，自己均要使用像new object  这样的语法来完成创建对象的工作。对象间的耦合度高了。而IOC的思想是：Spring容器来实现这些相互依赖对象的创建、协调工作，由它来负责控制对象的生命周期和对象间的关系。对象只需要关系业务逻辑本身就可以了。从这方面来说，对象如何得到他的协作对象的责任被反转了。\n\n# 原理\n\nIoC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的。\n\n> 通过DI，对象的依赖关系将由系统中负责协调各对象的第三方组件在创建对象的时候进行设定，对象无需自行创建或管理它们的依赖关系，依赖关系将被自动注入到需要它们的对象当中去 \n\n# spring IOC容器 \n\n- 原理就是通过Java的**反射技术**来实现的！通过反射我们可以获取类的所有信息(成员变量、类名等等等)！\n- 再通过配置文件(xml)或者注解来**描述**类与类之间的关系\n- 我们就可以通过这些配置信息和反射技术来**构建**出对应的对象和依赖关系了！\n\n## 初始化过程\n\n过程主要就是**读取XML资源，并解析，最终注册到Bean Factory中** \n\nBean的初始化过程： \n\n\n\n![](/images/spring-ioc/bean_init.jpg)\n\n**步骤** : \n\n1. BeanDefinitionReader**读取Resource所指向的配置文件资源**，然后解析配置文件。配置文件中每一个`<bean>`解析成一个**BeanDefinition对象**，并**保存**到BeanDefinitionRegistry中。\n2. 容器扫描BeanDefinitionRegistry中的BeanDefinition；调用InstantiationStrategy**进行Bean实例化的工作**；使用**BeanWrapper完成Bean属性的设置**工作 。\n3. 单例Bean缓存池：Spring 在DefaultSingletonBeanRegistry类中提供了一个用于缓存单实例 Bean 的**缓存器**，它是一个用HashMap实现的缓存器，单实例的Bean**以beanName为键保存在这个HashMap**中。 \n\n\n\n## ApplicationContext和BeanFactory \n\n- ApplicationContext会利用Java反射机制自动识别出配置文件中定义的BeanPostProcessor、 InstantiationAwareBeanPostProcesso 和BeanFactoryPostProcessor**后置器**，并**自动将它们注册到应用上**下文中。而BeanFactory需要在代码中通过**手工调用**`addBeanPostProcessor()`方法进行注册\n- ApplicationContext在**初始化**应用上下文的时候**就实例化所有单实例的Bean**。BeanFactory在初始化容器的时候并未实例化Bean，**直到**第一次访问某个Bean时**才**实例化目标Bean。 \n\n![](/images/spring-ioc/beanfactory.png)\n\n## bean的生命周期 \n\n1. Spring容器 从XML 文件中读取bean的定义，并实例化bean。\n2. Spring根据bean的定义填充所有的属性。\n3. 如果bean实现了BeanNameAware 接口，Spring 传递bean 的ID 到 setBeanName方法。\n4. 如果Bean 实现了 BeanFactoryAware 接口， Spring传递beanfactory 给setBeanFactory 方法。\n5. 如果有任何与bean相关联的BeanPostProcessors，Spring会在postProcesserBeforeInitialization()方法内调用它们。\n6. 如果bean实现IntializingBean了，调用它的afterPropertySet方法，如果bean声明了初始化方法，调用此初始化方法。\n7. 如果有BeanPostProcessors 和bean 关联，这些bean的postProcessAfterInitialization() 方法将被调用。\n8. 如果bean实现了 DisposableBean，它将调用destroy()方法。\n\n","source":"_posts/Spring系列-IOC.md","raw":"title: Spring系列-IOC\nauthor: James\ntags:\n  - spring\n  - ioc\ncategories:\n  - 框架\ndate: 2013-08-26 10:06:00\n---\n\n# 简介\n\nSpring 最重要的概念之一就是 IOC（Inversion of Control，控制倒转 ）,一起来分析下 Spring 的 IOC 容器。\n\n<!-- more -->\n\n# 为什么有IOC\n\nJava程序中的每个业务逻辑至少需要两个或以上的对象来协作完成。通常，每个对象在使用他的合作对象时，自己均要使用像new object  这样的语法来完成创建对象的工作。对象间的耦合度高了。而IOC的思想是：Spring容器来实现这些相互依赖对象的创建、协调工作，由它来负责控制对象的生命周期和对象间的关系。对象只需要关系业务逻辑本身就可以了。从这方面来说，对象如何得到他的协作对象的责任被反转了。\n\n# 原理\n\nIoC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的。\n\n> 通过DI，对象的依赖关系将由系统中负责协调各对象的第三方组件在创建对象的时候进行设定，对象无需自行创建或管理它们的依赖关系，依赖关系将被自动注入到需要它们的对象当中去 \n\n# spring IOC容器 \n\n- 原理就是通过Java的**反射技术**来实现的！通过反射我们可以获取类的所有信息(成员变量、类名等等等)！\n- 再通过配置文件(xml)或者注解来**描述**类与类之间的关系\n- 我们就可以通过这些配置信息和反射技术来**构建**出对应的对象和依赖关系了！\n\n## 初始化过程\n\n过程主要就是**读取XML资源，并解析，最终注册到Bean Factory中** \n\nBean的初始化过程： \n\n\n\n![](/images/spring-ioc/bean_init.jpg)\n\n**步骤** : \n\n1. BeanDefinitionReader**读取Resource所指向的配置文件资源**，然后解析配置文件。配置文件中每一个`<bean>`解析成一个**BeanDefinition对象**，并**保存**到BeanDefinitionRegistry中。\n2. 容器扫描BeanDefinitionRegistry中的BeanDefinition；调用InstantiationStrategy**进行Bean实例化的工作**；使用**BeanWrapper完成Bean属性的设置**工作 。\n3. 单例Bean缓存池：Spring 在DefaultSingletonBeanRegistry类中提供了一个用于缓存单实例 Bean 的**缓存器**，它是一个用HashMap实现的缓存器，单实例的Bean**以beanName为键保存在这个HashMap**中。 \n\n\n\n## ApplicationContext和BeanFactory \n\n- ApplicationContext会利用Java反射机制自动识别出配置文件中定义的BeanPostProcessor、 InstantiationAwareBeanPostProcesso 和BeanFactoryPostProcessor**后置器**，并**自动将它们注册到应用上**下文中。而BeanFactory需要在代码中通过**手工调用**`addBeanPostProcessor()`方法进行注册\n- ApplicationContext在**初始化**应用上下文的时候**就实例化所有单实例的Bean**。BeanFactory在初始化容器的时候并未实例化Bean，**直到**第一次访问某个Bean时**才**实例化目标Bean。 \n\n![](/images/spring-ioc/beanfactory.png)\n\n## bean的生命周期 \n\n1. Spring容器 从XML 文件中读取bean的定义，并实例化bean。\n2. Spring根据bean的定义填充所有的属性。\n3. 如果bean实现了BeanNameAware 接口，Spring 传递bean 的ID 到 setBeanName方法。\n4. 如果Bean 实现了 BeanFactoryAware 接口， Spring传递beanfactory 给setBeanFactory 方法。\n5. 如果有任何与bean相关联的BeanPostProcessors，Spring会在postProcesserBeforeInitialization()方法内调用它们。\n6. 如果bean实现IntializingBean了，调用它的afterPropertySet方法，如果bean声明了初始化方法，调用此初始化方法。\n7. 如果有BeanPostProcessors 和bean 关联，这些bean的postProcessAfterInitialization() 方法将被调用。\n8. 如果bean实现了 DisposableBean，它将调用destroy()方法。\n\n","slug":"Spring系列-IOC","published":1,"updated":"2018-07-02T02:41:10.095Z","_id":"cjizdddnb00000gkc33hnsx81","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>Spring 最重要的概念之一就是 IOC（Inversion of Control，控制倒转 ）,一起来分析下 Spring 的 IOC 容器。</p>\n<a id=\"more\"></a>\n<h1 id=\"为什么有IOC\"><a href=\"#为什么有IOC\" class=\"headerlink\" title=\"为什么有IOC\"></a>为什么有IOC</h1><p>Java程序中的每个业务逻辑至少需要两个或以上的对象来协作完成。通常，每个对象在使用他的合作对象时，自己均要使用像new object  这样的语法来完成创建对象的工作。对象间的耦合度高了。而IOC的思想是：Spring容器来实现这些相互依赖对象的创建、协调工作，由它来负责控制对象的生命周期和对象间的关系。对象只需要关系业务逻辑本身就可以了。从这方面来说，对象如何得到他的协作对象的责任被反转了。</p>\n<h1 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h1><p>IoC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的。</p>\n<blockquote>\n<p>通过DI，对象的依赖关系将由系统中负责协调各对象的第三方组件在创建对象的时候进行设定，对象无需自行创建或管理它们的依赖关系，依赖关系将被自动注入到需要它们的对象当中去 </p>\n</blockquote>\n<h1 id=\"spring-IOC容器\"><a href=\"#spring-IOC容器\" class=\"headerlink\" title=\"spring IOC容器\"></a>spring IOC容器</h1><ul>\n<li>原理就是通过Java的<strong>反射技术</strong>来实现的！通过反射我们可以获取类的所有信息(成员变量、类名等等等)！</li>\n<li>再通过配置文件(xml)或者注解来<strong>描述</strong>类与类之间的关系</li>\n<li>我们就可以通过这些配置信息和反射技术来<strong>构建</strong>出对应的对象和依赖关系了！</li>\n</ul>\n<h2 id=\"初始化过程\"><a href=\"#初始化过程\" class=\"headerlink\" title=\"初始化过程\"></a>初始化过程</h2><p>过程主要就是<strong>读取XML资源，并解析，最终注册到Bean Factory中</strong> </p>\n<p>Bean的初始化过程： </p>\n<p><img src=\"/images/spring-ioc/bean_init.jpg\" alt=\"\"></p>\n<p><strong>步骤</strong> : </p>\n<ol>\n<li>BeanDefinitionReader<strong>读取Resource所指向的配置文件资源</strong>，然后解析配置文件。配置文件中每一个<code>&lt;bean&gt;</code>解析成一个<strong>BeanDefinition对象</strong>，并<strong>保存</strong>到BeanDefinitionRegistry中。</li>\n<li>容器扫描BeanDefinitionRegistry中的BeanDefinition；调用InstantiationStrategy<strong>进行Bean实例化的工作</strong>；使用<strong>BeanWrapper完成Bean属性的设置</strong>工作 。</li>\n<li>单例Bean缓存池：Spring 在DefaultSingletonBeanRegistry类中提供了一个用于缓存单实例 Bean 的<strong>缓存器</strong>，它是一个用HashMap实现的缓存器，单实例的Bean<strong>以beanName为键保存在这个HashMap</strong>中。 </li>\n</ol>\n<h2 id=\"ApplicationContext和BeanFactory\"><a href=\"#ApplicationContext和BeanFactory\" class=\"headerlink\" title=\"ApplicationContext和BeanFactory\"></a>ApplicationContext和BeanFactory</h2><ul>\n<li>ApplicationContext会利用Java反射机制自动识别出配置文件中定义的BeanPostProcessor、 InstantiationAwareBeanPostProcesso 和BeanFactoryPostProcessor<strong>后置器</strong>，并<strong>自动将它们注册到应用上</strong>下文中。而BeanFactory需要在代码中通过<strong>手工调用</strong><code>addBeanPostProcessor()</code>方法进行注册</li>\n<li>ApplicationContext在<strong>初始化</strong>应用上下文的时候<strong>就实例化所有单实例的Bean</strong>。BeanFactory在初始化容器的时候并未实例化Bean，<strong>直到</strong>第一次访问某个Bean时<strong>才</strong>实例化目标Bean。 </li>\n</ul>\n<p><img src=\"/images/spring-ioc/beanfactory.png\" alt=\"\"></p>\n<h2 id=\"bean的生命周期\"><a href=\"#bean的生命周期\" class=\"headerlink\" title=\"bean的生命周期\"></a>bean的生命周期</h2><ol>\n<li>Spring容器 从XML 文件中读取bean的定义，并实例化bean。</li>\n<li>Spring根据bean的定义填充所有的属性。</li>\n<li>如果bean实现了BeanNameAware 接口，Spring 传递bean 的ID 到 setBeanName方法。</li>\n<li>如果Bean 实现了 BeanFactoryAware 接口， Spring传递beanfactory 给setBeanFactory 方法。</li>\n<li>如果有任何与bean相关联的BeanPostProcessors，Spring会在postProcesserBeforeInitialization()方法内调用它们。</li>\n<li>如果bean实现IntializingBean了，调用它的afterPropertySet方法，如果bean声明了初始化方法，调用此初始化方法。</li>\n<li>如果有BeanPostProcessors 和bean 关联，这些bean的postProcessAfterInitialization() 方法将被调用。</li>\n<li>如果bean实现了 DisposableBean，它将调用destroy()方法。</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>Spring 最重要的概念之一就是 IOC（Inversion of Control，控制倒转 ）,一起来分析下 Spring 的 IOC 容器。</p>","more":"<h1 id=\"为什么有IOC\"><a href=\"#为什么有IOC\" class=\"headerlink\" title=\"为什么有IOC\"></a>为什么有IOC</h1><p>Java程序中的每个业务逻辑至少需要两个或以上的对象来协作完成。通常，每个对象在使用他的合作对象时，自己均要使用像new object  这样的语法来完成创建对象的工作。对象间的耦合度高了。而IOC的思想是：Spring容器来实现这些相互依赖对象的创建、协调工作，由它来负责控制对象的生命周期和对象间的关系。对象只需要关系业务逻辑本身就可以了。从这方面来说，对象如何得到他的协作对象的责任被反转了。</p>\n<h1 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h1><p>IoC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的。</p>\n<blockquote>\n<p>通过DI，对象的依赖关系将由系统中负责协调各对象的第三方组件在创建对象的时候进行设定，对象无需自行创建或管理它们的依赖关系，依赖关系将被自动注入到需要它们的对象当中去 </p>\n</blockquote>\n<h1 id=\"spring-IOC容器\"><a href=\"#spring-IOC容器\" class=\"headerlink\" title=\"spring IOC容器\"></a>spring IOC容器</h1><ul>\n<li>原理就是通过Java的<strong>反射技术</strong>来实现的！通过反射我们可以获取类的所有信息(成员变量、类名等等等)！</li>\n<li>再通过配置文件(xml)或者注解来<strong>描述</strong>类与类之间的关系</li>\n<li>我们就可以通过这些配置信息和反射技术来<strong>构建</strong>出对应的对象和依赖关系了！</li>\n</ul>\n<h2 id=\"初始化过程\"><a href=\"#初始化过程\" class=\"headerlink\" title=\"初始化过程\"></a>初始化过程</h2><p>过程主要就是<strong>读取XML资源，并解析，最终注册到Bean Factory中</strong> </p>\n<p>Bean的初始化过程： </p>\n<p><img src=\"/images/spring-ioc/bean_init.jpg\" alt=\"\"></p>\n<p><strong>步骤</strong> : </p>\n<ol>\n<li>BeanDefinitionReader<strong>读取Resource所指向的配置文件资源</strong>，然后解析配置文件。配置文件中每一个<code>&lt;bean&gt;</code>解析成一个<strong>BeanDefinition对象</strong>，并<strong>保存</strong>到BeanDefinitionRegistry中。</li>\n<li>容器扫描BeanDefinitionRegistry中的BeanDefinition；调用InstantiationStrategy<strong>进行Bean实例化的工作</strong>；使用<strong>BeanWrapper完成Bean属性的设置</strong>工作 。</li>\n<li>单例Bean缓存池：Spring 在DefaultSingletonBeanRegistry类中提供了一个用于缓存单实例 Bean 的<strong>缓存器</strong>，它是一个用HashMap实现的缓存器，单实例的Bean<strong>以beanName为键保存在这个HashMap</strong>中。 </li>\n</ol>\n<h2 id=\"ApplicationContext和BeanFactory\"><a href=\"#ApplicationContext和BeanFactory\" class=\"headerlink\" title=\"ApplicationContext和BeanFactory\"></a>ApplicationContext和BeanFactory</h2><ul>\n<li>ApplicationContext会利用Java反射机制自动识别出配置文件中定义的BeanPostProcessor、 InstantiationAwareBeanPostProcesso 和BeanFactoryPostProcessor<strong>后置器</strong>，并<strong>自动将它们注册到应用上</strong>下文中。而BeanFactory需要在代码中通过<strong>手工调用</strong><code>addBeanPostProcessor()</code>方法进行注册</li>\n<li>ApplicationContext在<strong>初始化</strong>应用上下文的时候<strong>就实例化所有单实例的Bean</strong>。BeanFactory在初始化容器的时候并未实例化Bean，<strong>直到</strong>第一次访问某个Bean时<strong>才</strong>实例化目标Bean。 </li>\n</ul>\n<p><img src=\"/images/spring-ioc/beanfactory.png\" alt=\"\"></p>\n<h2 id=\"bean的生命周期\"><a href=\"#bean的生命周期\" class=\"headerlink\" title=\"bean的生命周期\"></a>bean的生命周期</h2><ol>\n<li>Spring容器 从XML 文件中读取bean的定义，并实例化bean。</li>\n<li>Spring根据bean的定义填充所有的属性。</li>\n<li>如果bean实现了BeanNameAware 接口，Spring 传递bean 的ID 到 setBeanName方法。</li>\n<li>如果Bean 实现了 BeanFactoryAware 接口， Spring传递beanfactory 给setBeanFactory 方法。</li>\n<li>如果有任何与bean相关联的BeanPostProcessors，Spring会在postProcesserBeforeInitialization()方法内调用它们。</li>\n<li>如果bean实现IntializingBean了，调用它的afterPropertySet方法，如果bean声明了初始化方法，调用此初始化方法。</li>\n<li>如果有BeanPostProcessors 和bean 关联，这些bean的postProcessAfterInitialization() 方法将被调用。</li>\n<li>如果bean实现了 DisposableBean，它将调用destroy()方法。</li>\n</ol>"},{"title":"Redis-经验谈","author":"James","date":"2016-03-06T02:15:00.000Z","_content":"\n# 前言\n\n本文主要是对Redis使用过程中遇到的问题进行总结。\n\n> Redis是使用 C 语言写成的 一个开源的，基于内存的结构化数据存储媒介，可以作为数据库、缓存服务或消息服务使用。Redis支持多种数据结构，包括字符串、哈希表、链表、集合、有序集合等。Redis具备LRU淘汰、事务实现、以及不同级别的硬盘持久化等能力，并且支持副本集和通过Redis Sentinel实现的高可用方案，同时还支持通过Redis Cluster实现的数据自动分片能力。\n\n<!-- more -->\n\n# 特点\n\nRedis的主要功能都基于单线程模型实现，也就是说Redis使用一个线程来服务所有的客户端请求，同时Redis采用了非阻塞式IO，并精细地优化各种命令的算法时间复杂度，这些信息意味着：\n\n- Redis是线程安全的（因为只有一个线程），其所有操作都是原子的，不会因并发产生数据异常。\n- Redis的速度非常快（因为使用非阻塞式IO，且大部分命令的算法时间复杂度都是O(1))。\n- 使用高耗时的Redis命令是很危险的，会占用唯一的一个线程的大量处理时间，导致所有的请求都被拖慢 。\n\n# 过期策略\n\n采用的 **定期删除+惰性删除** \n\n**定期删除**： redis默认每个100ms检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。 \n\n**惰性删除**： 也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。 \n\n**采用定期删除+惰性删除就完美了吗?** 考虑一种情况，如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。那么就应该采用**内存淘汰机制**。 \n\n# 淘汰策略 \n\n在32位OS中，Redis最大使用3GB的内存，在64位OS中则没有限制。\n\n1. **volatile-lru**：从已设置过期时间的数据集（淘汰上次使用时间最早的，且使用次数最少的key ）中挑选最近最少使用的数据淘汰\n2. **volatile-ttl**：从已设置过期时间的数据集中挑选将要过期的数据淘汰\n3. **volatile-random**：从已设置过期时间的数据集中任意选择数据淘汰\n4. **allkeys-lru**：从数据集中挑选最近最少使用的数据淘汰\n5. **allkeys-random**：从数据集中任意选择数据淘汰\n6. **no-enviction**（驱逐）：不进行数据淘汰\n\n\n\n# 持久化\n\nRedis提供了将数据定期自动持久化至硬盘的能力，包括RDB和AOF两种方案，两种方案分别有其长处和短板，可以配合起来同时运行，确保数据的稳定性。 \n\n## RDB\n\n采用RDB持久方式，Redis会定期保存数据快照至一个rbd文件中，并在启动时自动加载rdb文件，恢复之前保存的数据。 \n\n**优点：**\n\n- 对性能影响最小。如前文所述，Redis在保存RDB快照时会fork出子进程进行，几乎不影响Redis处理客户端请求的效率。\n- 每次快照会生成一个完整的数据快照文件，所以可以辅以其他手段保存多个时间点的快照（例如把每天0点的快照备份至其他存储媒介中），作为非常可靠的灾难恢复手段。\n- 使用RDB文件进行数据恢复比使用AOF要快很多。\n\n**缺点：**\n\n- 快照是定期生成的，所以在Redis crash时或多或少会丢失一部分数据。\n- 如果数据集非常大且CPU不够强（比如单核CPU），Redis在fork子进程时可能会消耗相对较长的时间（长至1秒），影响这期间的客户端请求。\n\n ## AOF\n\n采用AOF持久方式时，Redis会把每一个写请求都记录在一个日志文件里。在Redis重启时，会把AOF文件中记录的所有写操作顺序执行一遍，确保数据恢复到最新。 \n\nAOF提供了三种fsync配置，always/everysec/no，通过配置项[appendfsync]指定：\n\n- appendfsync no：不进行fsync，将flush文件的时机交给OS决定，速度最快。\n- appendfsync always：每写入一条日志就进行一次fsync操作，数据安全性最高，但速度最慢。\n- appendfsync everysec：折中的做法，交由后台线程每秒fsync一次。\n\n\n**优点：**\n\n- 最安全，在启用appendfsync always时，任何已写入的数据都不会丢失，使用在启用appendfsync everysec也至多只会丢失1秒的数据。\n- AOF文件在发生断电等问题时也不会损坏，即使出现了某条日志只写入了一半的情况，也可以使用redis-check-aof工具轻松修复。\n- AOF文件易读，可修改，在进行了某些错误的数据清除操作后，只要AOF文件没有rewrite，就可以把AOF文件备份出来，把错误的命令删除，然后恢复数据。\n\n**缺点**：\n- AOF文件通常比RDB文件更大。\n- 性能消耗比RDB高。\n- 数据恢复速度比RDB慢。\n\n# 数据类型\n\n- **String** 常规的set/get操作，value可以是String也可以是数字 \n- **hash** value存放的是结构化的对象 \n- **list** 使用List的数据结构 \n- **set** 类似Java set集合，存放的是不重复值的集合 \n- **sorted set** 权重参数score,集合中的元素能够按score进行排列。 \n\n# 事务\n\n通过MULTI和EXEC命令 \nRedis在接收到MULTI命令后便会开启一个事务，这之后的所有读写命令都会保存在队列中但并不执行，直到接收到EXEC命令后，Redis会把队列中的所有命令连续顺序执行，并以数组形式返回每个命令的返回结果。 \n\n**注意：Redis事务不支持回滚** \n\n## CAS\n\nRedis提供了WATCH命令与事务搭配使用，实现CAS乐观锁的机制。 \n\nWATCH的机制：在事务EXEC命令执行时，Redis会检查被WATCH的key，只有被WATCH的key从WATCH起始时至今没有发生过变更，EXEC才会被执行。如果WATCH的key在WATCH命令到EXEC命令之间发生过变化，则EXEC命令会返回失败。\n\n## Script\n\n通过EVAL与EVALSHA命令，可以让Redis执行LUA脚本。 Redis官方推荐使用LUA Script来代替事务 ，请参考官方文档  。[https://redis.io/commands/eval](https://link.jianshu.com/?t=https://redis.io/commands/eval) \n\n\n\n# Redis为什么这么快\n\n1. 纯内存操作 \n2. 单线程操作，避免了频繁的上下文切换 \n3. 采用了非阻塞**I/O多路复用机制** ，只有1个线程，通过跟踪每个I/O流的状态来管理多个I/O流 。\n\n# 实战问题\n\n## 数据库双写一致性问题\n\n一致性问题是分布式常见问题，还可以再分为最终一致性和强一致性。数据库和缓存双写，就必然会存在不一致的问题。如果对数据有强一致性要求，不能放缓存。**我们所做的一切，只能保证最终一致性。另外，我们所做的方案其实从根本上来说是降低不一致发生的概率**，无法完全避免。因此，有强一致性要求的数据，不能放缓存。 \n\n采取正确更新策略，先更新数据库，再删缓存。其次，因为可能存在删除缓存失败的问题，提供一个补偿措施即可，例如利用消息队列。 \n\n## 缓存穿透\n\n去请求缓存中不存在的数据，导致所有的请求压力都到数据库上，从而数据库连接异常或者崩溃。 \n\n1. 利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试 \n2. 采用异步更新策略，无论key是否取到值，都直接返回。value值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。需要做**缓存预热**(项目启动前，先加载缓存)操作。 \n3. 提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的key。迅速判断出，请求所携带的Key是否合法有效。如果不合法，则直接返回。 \n\n## **缓存雪崩** \n\n缓存同一时间大面积的失效，恰好这时候又来了一波请求，请求压力都到数据库上，从而导致数据库连接异常。 \n1. 给缓存的失效时间，加上一个随机值，避免集体失效。 \n2. 使用互斥锁，但是该方案可能会导致吞吐量明显下降了。 \n3.  采用双缓存，缓存A和缓存B。缓存A的失效时间为20分钟，缓存B不设失效时间 。\n\n## 并发竞争\n\nRedis为单进程单线程模式，采用队列模式将并发访问变为串行访问。\n\nRedis本身没有锁的概念，Redis对于多个客户端连接并不存在竞争，但是在Jedis客户端对Redis进行并发访问时会发生连接超时、数据转换错误、阻塞、客户端关闭连接等问题，这些问题均是由于客户端连接混乱造成。\n\n解决方法：\n\n1. 客户端角度，为保证每个客户端间正常有序与Redis进行通信，对连接进行池化，同时对客户端读写Redis操作采用内部锁synchronized。\n2. 服务器角度，利用setnx实现锁。\n\n当同时有多个子系统去set一个key。这时候可能会发生问题。\n\n1. redis事务机制, 如果是redis集群环境 ，这多个key不一定都存储在同一个redis-server上。该方案会失效。\n2. 分布式锁，利用setnx实现锁 \n3. 利用队列，将set方法变成串行访问。\n\n## 大量数据插入\n\n客户端执行大量数据插入时候，一个个的插入会有大量的时间浪费在每一个命令往返时间上。 \n\n可以使用Redis提供的pipelining功能来实现在一次交互中执行多条命令。\n\n# 常用应用场景\n\n- 排行榜类的应用，取TOP N操作，前面操作以时间为权重，这个是以某个条件为权重，比如按顶的次数排序计数器应用\n- 存储关系：比如社交关系，比如Tag等\n- 获取某段时间所有数据排重值，使用set，比如某段时间访问的用户ID，或者是客户端IP\n- 构建队列系统，List可以构建栈和队列，使用zset可以构建优先级队列\n\n# Redis与Memcached\n\n简单比较:\n\n![](/images/redis/redis-memcached.png)\n\n\n\n","source":"_posts/Redis-experience.md","raw":"title: Redis-经验谈\nauthor: James\ntags:\n  - redis\ncategories:\n  - 数据库\ndate: 2016-03-06 10:15:00\n---\n\n# 前言\n\n本文主要是对Redis使用过程中遇到的问题进行总结。\n\n> Redis是使用 C 语言写成的 一个开源的，基于内存的结构化数据存储媒介，可以作为数据库、缓存服务或消息服务使用。Redis支持多种数据结构，包括字符串、哈希表、链表、集合、有序集合等。Redis具备LRU淘汰、事务实现、以及不同级别的硬盘持久化等能力，并且支持副本集和通过Redis Sentinel实现的高可用方案，同时还支持通过Redis Cluster实现的数据自动分片能力。\n\n<!-- more -->\n\n# 特点\n\nRedis的主要功能都基于单线程模型实现，也就是说Redis使用一个线程来服务所有的客户端请求，同时Redis采用了非阻塞式IO，并精细地优化各种命令的算法时间复杂度，这些信息意味着：\n\n- Redis是线程安全的（因为只有一个线程），其所有操作都是原子的，不会因并发产生数据异常。\n- Redis的速度非常快（因为使用非阻塞式IO，且大部分命令的算法时间复杂度都是O(1))。\n- 使用高耗时的Redis命令是很危险的，会占用唯一的一个线程的大量处理时间，导致所有的请求都被拖慢 。\n\n# 过期策略\n\n采用的 **定期删除+惰性删除** \n\n**定期删除**： redis默认每个100ms检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。 \n\n**惰性删除**： 也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。 \n\n**采用定期删除+惰性删除就完美了吗?** 考虑一种情况，如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。那么就应该采用**内存淘汰机制**。 \n\n# 淘汰策略 \n\n在32位OS中，Redis最大使用3GB的内存，在64位OS中则没有限制。\n\n1. **volatile-lru**：从已设置过期时间的数据集（淘汰上次使用时间最早的，且使用次数最少的key ）中挑选最近最少使用的数据淘汰\n2. **volatile-ttl**：从已设置过期时间的数据集中挑选将要过期的数据淘汰\n3. **volatile-random**：从已设置过期时间的数据集中任意选择数据淘汰\n4. **allkeys-lru**：从数据集中挑选最近最少使用的数据淘汰\n5. **allkeys-random**：从数据集中任意选择数据淘汰\n6. **no-enviction**（驱逐）：不进行数据淘汰\n\n\n\n# 持久化\n\nRedis提供了将数据定期自动持久化至硬盘的能力，包括RDB和AOF两种方案，两种方案分别有其长处和短板，可以配合起来同时运行，确保数据的稳定性。 \n\n## RDB\n\n采用RDB持久方式，Redis会定期保存数据快照至一个rbd文件中，并在启动时自动加载rdb文件，恢复之前保存的数据。 \n\n**优点：**\n\n- 对性能影响最小。如前文所述，Redis在保存RDB快照时会fork出子进程进行，几乎不影响Redis处理客户端请求的效率。\n- 每次快照会生成一个完整的数据快照文件，所以可以辅以其他手段保存多个时间点的快照（例如把每天0点的快照备份至其他存储媒介中），作为非常可靠的灾难恢复手段。\n- 使用RDB文件进行数据恢复比使用AOF要快很多。\n\n**缺点：**\n\n- 快照是定期生成的，所以在Redis crash时或多或少会丢失一部分数据。\n- 如果数据集非常大且CPU不够强（比如单核CPU），Redis在fork子进程时可能会消耗相对较长的时间（长至1秒），影响这期间的客户端请求。\n\n ## AOF\n\n采用AOF持久方式时，Redis会把每一个写请求都记录在一个日志文件里。在Redis重启时，会把AOF文件中记录的所有写操作顺序执行一遍，确保数据恢复到最新。 \n\nAOF提供了三种fsync配置，always/everysec/no，通过配置项[appendfsync]指定：\n\n- appendfsync no：不进行fsync，将flush文件的时机交给OS决定，速度最快。\n- appendfsync always：每写入一条日志就进行一次fsync操作，数据安全性最高，但速度最慢。\n- appendfsync everysec：折中的做法，交由后台线程每秒fsync一次。\n\n\n**优点：**\n\n- 最安全，在启用appendfsync always时，任何已写入的数据都不会丢失，使用在启用appendfsync everysec也至多只会丢失1秒的数据。\n- AOF文件在发生断电等问题时也不会损坏，即使出现了某条日志只写入了一半的情况，也可以使用redis-check-aof工具轻松修复。\n- AOF文件易读，可修改，在进行了某些错误的数据清除操作后，只要AOF文件没有rewrite，就可以把AOF文件备份出来，把错误的命令删除，然后恢复数据。\n\n**缺点**：\n- AOF文件通常比RDB文件更大。\n- 性能消耗比RDB高。\n- 数据恢复速度比RDB慢。\n\n# 数据类型\n\n- **String** 常规的set/get操作，value可以是String也可以是数字 \n- **hash** value存放的是结构化的对象 \n- **list** 使用List的数据结构 \n- **set** 类似Java set集合，存放的是不重复值的集合 \n- **sorted set** 权重参数score,集合中的元素能够按score进行排列。 \n\n# 事务\n\n通过MULTI和EXEC命令 \nRedis在接收到MULTI命令后便会开启一个事务，这之后的所有读写命令都会保存在队列中但并不执行，直到接收到EXEC命令后，Redis会把队列中的所有命令连续顺序执行，并以数组形式返回每个命令的返回结果。 \n\n**注意：Redis事务不支持回滚** \n\n## CAS\n\nRedis提供了WATCH命令与事务搭配使用，实现CAS乐观锁的机制。 \n\nWATCH的机制：在事务EXEC命令执行时，Redis会检查被WATCH的key，只有被WATCH的key从WATCH起始时至今没有发生过变更，EXEC才会被执行。如果WATCH的key在WATCH命令到EXEC命令之间发生过变化，则EXEC命令会返回失败。\n\n## Script\n\n通过EVAL与EVALSHA命令，可以让Redis执行LUA脚本。 Redis官方推荐使用LUA Script来代替事务 ，请参考官方文档  。[https://redis.io/commands/eval](https://link.jianshu.com/?t=https://redis.io/commands/eval) \n\n\n\n# Redis为什么这么快\n\n1. 纯内存操作 \n2. 单线程操作，避免了频繁的上下文切换 \n3. 采用了非阻塞**I/O多路复用机制** ，只有1个线程，通过跟踪每个I/O流的状态来管理多个I/O流 。\n\n# 实战问题\n\n## 数据库双写一致性问题\n\n一致性问题是分布式常见问题，还可以再分为最终一致性和强一致性。数据库和缓存双写，就必然会存在不一致的问题。如果对数据有强一致性要求，不能放缓存。**我们所做的一切，只能保证最终一致性。另外，我们所做的方案其实从根本上来说是降低不一致发生的概率**，无法完全避免。因此，有强一致性要求的数据，不能放缓存。 \n\n采取正确更新策略，先更新数据库，再删缓存。其次，因为可能存在删除缓存失败的问题，提供一个补偿措施即可，例如利用消息队列。 \n\n## 缓存穿透\n\n去请求缓存中不存在的数据，导致所有的请求压力都到数据库上，从而数据库连接异常或者崩溃。 \n\n1. 利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试 \n2. 采用异步更新策略，无论key是否取到值，都直接返回。value值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。需要做**缓存预热**(项目启动前，先加载缓存)操作。 \n3. 提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的key。迅速判断出，请求所携带的Key是否合法有效。如果不合法，则直接返回。 \n\n## **缓存雪崩** \n\n缓存同一时间大面积的失效，恰好这时候又来了一波请求，请求压力都到数据库上，从而导致数据库连接异常。 \n1. 给缓存的失效时间，加上一个随机值，避免集体失效。 \n2. 使用互斥锁，但是该方案可能会导致吞吐量明显下降了。 \n3.  采用双缓存，缓存A和缓存B。缓存A的失效时间为20分钟，缓存B不设失效时间 。\n\n## 并发竞争\n\nRedis为单进程单线程模式，采用队列模式将并发访问变为串行访问。\n\nRedis本身没有锁的概念，Redis对于多个客户端连接并不存在竞争，但是在Jedis客户端对Redis进行并发访问时会发生连接超时、数据转换错误、阻塞、客户端关闭连接等问题，这些问题均是由于客户端连接混乱造成。\n\n解决方法：\n\n1. 客户端角度，为保证每个客户端间正常有序与Redis进行通信，对连接进行池化，同时对客户端读写Redis操作采用内部锁synchronized。\n2. 服务器角度，利用setnx实现锁。\n\n当同时有多个子系统去set一个key。这时候可能会发生问题。\n\n1. redis事务机制, 如果是redis集群环境 ，这多个key不一定都存储在同一个redis-server上。该方案会失效。\n2. 分布式锁，利用setnx实现锁 \n3. 利用队列，将set方法变成串行访问。\n\n## 大量数据插入\n\n客户端执行大量数据插入时候，一个个的插入会有大量的时间浪费在每一个命令往返时间上。 \n\n可以使用Redis提供的pipelining功能来实现在一次交互中执行多条命令。\n\n# 常用应用场景\n\n- 排行榜类的应用，取TOP N操作，前面操作以时间为权重，这个是以某个条件为权重，比如按顶的次数排序计数器应用\n- 存储关系：比如社交关系，比如Tag等\n- 获取某段时间所有数据排重值，使用set，比如某段时间访问的用户ID，或者是客户端IP\n- 构建队列系统，List可以构建栈和队列，使用zset可以构建优先级队列\n\n# Redis与Memcached\n\n简单比较:\n\n![](/images/redis/redis-memcached.png)\n\n\n\n","slug":"Redis-experience","published":1,"updated":"2018-07-20T01:52:04.006Z","_id":"cjjp5xnvm0000fgkcqgavuu3i","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>本文主要是对Redis使用过程中遇到的问题进行总结。</p>\n<blockquote>\n<p>Redis是使用 C 语言写成的 一个开源的，基于内存的结构化数据存储媒介，可以作为数据库、缓存服务或消息服务使用。Redis支持多种数据结构，包括字符串、哈希表、链表、集合、有序集合等。Redis具备LRU淘汰、事务实现、以及不同级别的硬盘持久化等能力，并且支持副本集和通过Redis Sentinel实现的高可用方案，同时还支持通过Redis Cluster实现的数据自动分片能力。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h1 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h1><p>Redis的主要功能都基于单线程模型实现，也就是说Redis使用一个线程来服务所有的客户端请求，同时Redis采用了非阻塞式IO，并精细地优化各种命令的算法时间复杂度，这些信息意味着：</p>\n<ul>\n<li>Redis是线程安全的（因为只有一个线程），其所有操作都是原子的，不会因并发产生数据异常。</li>\n<li>Redis的速度非常快（因为使用非阻塞式IO，且大部分命令的算法时间复杂度都是O(1))。</li>\n<li>使用高耗时的Redis命令是很危险的，会占用唯一的一个线程的大量处理时间，导致所有的请求都被拖慢 。</li>\n</ul>\n<h1 id=\"过期策略\"><a href=\"#过期策略\" class=\"headerlink\" title=\"过期策略\"></a>过期策略</h1><p>采用的 <strong>定期删除+惰性删除</strong> </p>\n<p><strong>定期删除</strong>： redis默认每个100ms检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。 </p>\n<p><strong>惰性删除</strong>： 也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。 </p>\n<p><strong>采用定期删除+惰性删除就完美了吗?</strong> 考虑一种情况，如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。那么就应该采用<strong>内存淘汰机制</strong>。 </p>\n<h1 id=\"淘汰策略\"><a href=\"#淘汰策略\" class=\"headerlink\" title=\"淘汰策略\"></a>淘汰策略</h1><p>在32位OS中，Redis最大使用3GB的内存，在64位OS中则没有限制。</p>\n<ol>\n<li><strong>volatile-lru</strong>：从已设置过期时间的数据集（淘汰上次使用时间最早的，且使用次数最少的key ）中挑选最近最少使用的数据淘汰</li>\n<li><strong>volatile-ttl</strong>：从已设置过期时间的数据集中挑选将要过期的数据淘汰</li>\n<li><strong>volatile-random</strong>：从已设置过期时间的数据集中任意选择数据淘汰</li>\n<li><strong>allkeys-lru</strong>：从数据集中挑选最近最少使用的数据淘汰</li>\n<li><strong>allkeys-random</strong>：从数据集中任意选择数据淘汰</li>\n<li><strong>no-enviction</strong>（驱逐）：不进行数据淘汰</li>\n</ol>\n<h1 id=\"持久化\"><a href=\"#持久化\" class=\"headerlink\" title=\"持久化\"></a>持久化</h1><p>Redis提供了将数据定期自动持久化至硬盘的能力，包括RDB和AOF两种方案，两种方案分别有其长处和短板，可以配合起来同时运行，确保数据的稳定性。 </p>\n<h2 id=\"RDB\"><a href=\"#RDB\" class=\"headerlink\" title=\"RDB\"></a>RDB</h2><p>采用RDB持久方式，Redis会定期保存数据快照至一个rbd文件中，并在启动时自动加载rdb文件，恢复之前保存的数据。 </p>\n<p><strong>优点：</strong></p>\n<ul>\n<li>对性能影响最小。如前文所述，Redis在保存RDB快照时会fork出子进程进行，几乎不影响Redis处理客户端请求的效率。</li>\n<li>每次快照会生成一个完整的数据快照文件，所以可以辅以其他手段保存多个时间点的快照（例如把每天0点的快照备份至其他存储媒介中），作为非常可靠的灾难恢复手段。</li>\n<li>使用RDB文件进行数据恢复比使用AOF要快很多。</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>快照是定期生成的，所以在Redis crash时或多或少会丢失一部分数据。</li>\n<li><p>如果数据集非常大且CPU不够强（比如单核CPU），Redis在fork子进程时可能会消耗相对较长的时间（长至1秒），影响这期间的客户端请求。</p>\n<h2 id=\"AOF\"><a href=\"#AOF\" class=\"headerlink\" title=\"AOF\"></a>AOF</h2></li>\n</ul>\n<p>采用AOF持久方式时，Redis会把每一个写请求都记录在一个日志文件里。在Redis重启时，会把AOF文件中记录的所有写操作顺序执行一遍，确保数据恢复到最新。 </p>\n<p>AOF提供了三种fsync配置，always/everysec/no，通过配置项[appendfsync]指定：</p>\n<ul>\n<li>appendfsync no：不进行fsync，将flush文件的时机交给OS决定，速度最快。</li>\n<li>appendfsync always：每写入一条日志就进行一次fsync操作，数据安全性最高，但速度最慢。</li>\n<li>appendfsync everysec：折中的做法，交由后台线程每秒fsync一次。</li>\n</ul>\n<p><strong>优点：</strong></p>\n<ul>\n<li>最安全，在启用appendfsync always时，任何已写入的数据都不会丢失，使用在启用appendfsync everysec也至多只会丢失1秒的数据。</li>\n<li>AOF文件在发生断电等问题时也不会损坏，即使出现了某条日志只写入了一半的情况，也可以使用redis-check-aof工具轻松修复。</li>\n<li>AOF文件易读，可修改，在进行了某些错误的数据清除操作后，只要AOF文件没有rewrite，就可以把AOF文件备份出来，把错误的命令删除，然后恢复数据。</li>\n</ul>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li>AOF文件通常比RDB文件更大。</li>\n<li>性能消耗比RDB高。</li>\n<li>数据恢复速度比RDB慢。</li>\n</ul>\n<h1 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h1><ul>\n<li><strong>String</strong> 常规的set/get操作，value可以是String也可以是数字 </li>\n<li><strong>hash</strong> value存放的是结构化的对象 </li>\n<li><strong>list</strong> 使用List的数据结构 </li>\n<li><strong>set</strong> 类似Java set集合，存放的是不重复值的集合 </li>\n<li><strong>sorted set</strong> 权重参数score,集合中的元素能够按score进行排列。 </li>\n</ul>\n<h1 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h1><p>通过MULTI和EXEC命令<br>Redis在接收到MULTI命令后便会开启一个事务，这之后的所有读写命令都会保存在队列中但并不执行，直到接收到EXEC命令后，Redis会把队列中的所有命令连续顺序执行，并以数组形式返回每个命令的返回结果。 </p>\n<p><strong>注意：Redis事务不支持回滚</strong> </p>\n<h2 id=\"CAS\"><a href=\"#CAS\" class=\"headerlink\" title=\"CAS\"></a>CAS</h2><p>Redis提供了WATCH命令与事务搭配使用，实现CAS乐观锁的机制。 </p>\n<p>WATCH的机制：在事务EXEC命令执行时，Redis会检查被WATCH的key，只有被WATCH的key从WATCH起始时至今没有发生过变更，EXEC才会被执行。如果WATCH的key在WATCH命令到EXEC命令之间发生过变化，则EXEC命令会返回失败。</p>\n<h2 id=\"Script\"><a href=\"#Script\" class=\"headerlink\" title=\"Script\"></a>Script</h2><p>通过EVAL与EVALSHA命令，可以让Redis执行LUA脚本。 Redis官方推荐使用LUA Script来代替事务 ，请参考官方文档  。<a href=\"https://link.jianshu.com/?t=https://redis.io/commands/eval\" target=\"_blank\" rel=\"noopener\">https://redis.io/commands/eval</a> </p>\n<h1 id=\"Redis为什么这么快\"><a href=\"#Redis为什么这么快\" class=\"headerlink\" title=\"Redis为什么这么快\"></a>Redis为什么这么快</h1><ol>\n<li>纯内存操作 </li>\n<li>单线程操作，避免了频繁的上下文切换 </li>\n<li>采用了非阻塞<strong>I/O多路复用机制</strong> ，只有1个线程，通过跟踪每个I/O流的状态来管理多个I/O流 。</li>\n</ol>\n<h1 id=\"实战问题\"><a href=\"#实战问题\" class=\"headerlink\" title=\"实战问题\"></a>实战问题</h1><h2 id=\"数据库双写一致性问题\"><a href=\"#数据库双写一致性问题\" class=\"headerlink\" title=\"数据库双写一致性问题\"></a>数据库双写一致性问题</h2><p>一致性问题是分布式常见问题，还可以再分为最终一致性和强一致性。数据库和缓存双写，就必然会存在不一致的问题。如果对数据有强一致性要求，不能放缓存。<strong>我们所做的一切，只能保证最终一致性。另外，我们所做的方案其实从根本上来说是降低不一致发生的概率</strong>，无法完全避免。因此，有强一致性要求的数据，不能放缓存。 </p>\n<p>采取正确更新策略，先更新数据库，再删缓存。其次，因为可能存在删除缓存失败的问题，提供一个补偿措施即可，例如利用消息队列。 </p>\n<h2 id=\"缓存穿透\"><a href=\"#缓存穿透\" class=\"headerlink\" title=\"缓存穿透\"></a>缓存穿透</h2><p>去请求缓存中不存在的数据，导致所有的请求压力都到数据库上，从而数据库连接异常或者崩溃。 </p>\n<ol>\n<li>利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试 </li>\n<li>采用异步更新策略，无论key是否取到值，都直接返回。value值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。需要做<strong>缓存预热</strong>(项目启动前，先加载缓存)操作。 </li>\n<li>提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的key。迅速判断出，请求所携带的Key是否合法有效。如果不合法，则直接返回。 </li>\n</ol>\n<h2 id=\"缓存雪崩\"><a href=\"#缓存雪崩\" class=\"headerlink\" title=\"缓存雪崩\"></a><strong>缓存雪崩</strong></h2><p>缓存同一时间大面积的失效，恰好这时候又来了一波请求，请求压力都到数据库上，从而导致数据库连接异常。 </p>\n<ol>\n<li>给缓存的失效时间，加上一个随机值，避免集体失效。 </li>\n<li>使用互斥锁，但是该方案可能会导致吞吐量明显下降了。 </li>\n<li>采用双缓存，缓存A和缓存B。缓存A的失效时间为20分钟，缓存B不设失效时间 。</li>\n</ol>\n<h2 id=\"并发竞争\"><a href=\"#并发竞争\" class=\"headerlink\" title=\"并发竞争\"></a>并发竞争</h2><p>Redis为单进程单线程模式，采用队列模式将并发访问变为串行访问。</p>\n<p>Redis本身没有锁的概念，Redis对于多个客户端连接并不存在竞争，但是在Jedis客户端对Redis进行并发访问时会发生连接超时、数据转换错误、阻塞、客户端关闭连接等问题，这些问题均是由于客户端连接混乱造成。</p>\n<p>解决方法：</p>\n<ol>\n<li>客户端角度，为保证每个客户端间正常有序与Redis进行通信，对连接进行池化，同时对客户端读写Redis操作采用内部锁synchronized。</li>\n<li>服务器角度，利用setnx实现锁。</li>\n</ol>\n<p>当同时有多个子系统去set一个key。这时候可能会发生问题。</p>\n<ol>\n<li>redis事务机制, 如果是redis集群环境 ，这多个key不一定都存储在同一个redis-server上。该方案会失效。</li>\n<li>分布式锁，利用setnx实现锁 </li>\n<li>利用队列，将set方法变成串行访问。</li>\n</ol>\n<h2 id=\"大量数据插入\"><a href=\"#大量数据插入\" class=\"headerlink\" title=\"大量数据插入\"></a>大量数据插入</h2><p>客户端执行大量数据插入时候，一个个的插入会有大量的时间浪费在每一个命令往返时间上。 </p>\n<p>可以使用Redis提供的pipelining功能来实现在一次交互中执行多条命令。</p>\n<h1 id=\"常用应用场景\"><a href=\"#常用应用场景\" class=\"headerlink\" title=\"常用应用场景\"></a>常用应用场景</h1><ul>\n<li>排行榜类的应用，取TOP N操作，前面操作以时间为权重，这个是以某个条件为权重，比如按顶的次数排序计数器应用</li>\n<li>存储关系：比如社交关系，比如Tag等</li>\n<li>获取某段时间所有数据排重值，使用set，比如某段时间访问的用户ID，或者是客户端IP</li>\n<li>构建队列系统，List可以构建栈和队列，使用zset可以构建优先级队列</li>\n</ul>\n<h1 id=\"Redis与Memcached\"><a href=\"#Redis与Memcached\" class=\"headerlink\" title=\"Redis与Memcached\"></a>Redis与Memcached</h1><p>简单比较:</p>\n<p><img src=\"/images/redis/redis-memcached.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>本文主要是对Redis使用过程中遇到的问题进行总结。</p>\n<blockquote>\n<p>Redis是使用 C 语言写成的 一个开源的，基于内存的结构化数据存储媒介，可以作为数据库、缓存服务或消息服务使用。Redis支持多种数据结构，包括字符串、哈希表、链表、集合、有序集合等。Redis具备LRU淘汰、事务实现、以及不同级别的硬盘持久化等能力，并且支持副本集和通过Redis Sentinel实现的高可用方案，同时还支持通过Redis Cluster实现的数据自动分片能力。</p>\n</blockquote>","more":"<h1 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h1><p>Redis的主要功能都基于单线程模型实现，也就是说Redis使用一个线程来服务所有的客户端请求，同时Redis采用了非阻塞式IO，并精细地优化各种命令的算法时间复杂度，这些信息意味着：</p>\n<ul>\n<li>Redis是线程安全的（因为只有一个线程），其所有操作都是原子的，不会因并发产生数据异常。</li>\n<li>Redis的速度非常快（因为使用非阻塞式IO，且大部分命令的算法时间复杂度都是O(1))。</li>\n<li>使用高耗时的Redis命令是很危险的，会占用唯一的一个线程的大量处理时间，导致所有的请求都被拖慢 。</li>\n</ul>\n<h1 id=\"过期策略\"><a href=\"#过期策略\" class=\"headerlink\" title=\"过期策略\"></a>过期策略</h1><p>采用的 <strong>定期删除+惰性删除</strong> </p>\n<p><strong>定期删除</strong>： redis默认每个100ms检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。 </p>\n<p><strong>惰性删除</strong>： 也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。 </p>\n<p><strong>采用定期删除+惰性删除就完美了吗?</strong> 考虑一种情况，如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。那么就应该采用<strong>内存淘汰机制</strong>。 </p>\n<h1 id=\"淘汰策略\"><a href=\"#淘汰策略\" class=\"headerlink\" title=\"淘汰策略\"></a>淘汰策略</h1><p>在32位OS中，Redis最大使用3GB的内存，在64位OS中则没有限制。</p>\n<ol>\n<li><strong>volatile-lru</strong>：从已设置过期时间的数据集（淘汰上次使用时间最早的，且使用次数最少的key ）中挑选最近最少使用的数据淘汰</li>\n<li><strong>volatile-ttl</strong>：从已设置过期时间的数据集中挑选将要过期的数据淘汰</li>\n<li><strong>volatile-random</strong>：从已设置过期时间的数据集中任意选择数据淘汰</li>\n<li><strong>allkeys-lru</strong>：从数据集中挑选最近最少使用的数据淘汰</li>\n<li><strong>allkeys-random</strong>：从数据集中任意选择数据淘汰</li>\n<li><strong>no-enviction</strong>（驱逐）：不进行数据淘汰</li>\n</ol>\n<h1 id=\"持久化\"><a href=\"#持久化\" class=\"headerlink\" title=\"持久化\"></a>持久化</h1><p>Redis提供了将数据定期自动持久化至硬盘的能力，包括RDB和AOF两种方案，两种方案分别有其长处和短板，可以配合起来同时运行，确保数据的稳定性。 </p>\n<h2 id=\"RDB\"><a href=\"#RDB\" class=\"headerlink\" title=\"RDB\"></a>RDB</h2><p>采用RDB持久方式，Redis会定期保存数据快照至一个rbd文件中，并在启动时自动加载rdb文件，恢复之前保存的数据。 </p>\n<p><strong>优点：</strong></p>\n<ul>\n<li>对性能影响最小。如前文所述，Redis在保存RDB快照时会fork出子进程进行，几乎不影响Redis处理客户端请求的效率。</li>\n<li>每次快照会生成一个完整的数据快照文件，所以可以辅以其他手段保存多个时间点的快照（例如把每天0点的快照备份至其他存储媒介中），作为非常可靠的灾难恢复手段。</li>\n<li>使用RDB文件进行数据恢复比使用AOF要快很多。</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>快照是定期生成的，所以在Redis crash时或多或少会丢失一部分数据。</li>\n<li><p>如果数据集非常大且CPU不够强（比如单核CPU），Redis在fork子进程时可能会消耗相对较长的时间（长至1秒），影响这期间的客户端请求。</p>\n<h2 id=\"AOF\"><a href=\"#AOF\" class=\"headerlink\" title=\"AOF\"></a>AOF</h2></li>\n</ul>\n<p>采用AOF持久方式时，Redis会把每一个写请求都记录在一个日志文件里。在Redis重启时，会把AOF文件中记录的所有写操作顺序执行一遍，确保数据恢复到最新。 </p>\n<p>AOF提供了三种fsync配置，always/everysec/no，通过配置项[appendfsync]指定：</p>\n<ul>\n<li>appendfsync no：不进行fsync，将flush文件的时机交给OS决定，速度最快。</li>\n<li>appendfsync always：每写入一条日志就进行一次fsync操作，数据安全性最高，但速度最慢。</li>\n<li>appendfsync everysec：折中的做法，交由后台线程每秒fsync一次。</li>\n</ul>\n<p><strong>优点：</strong></p>\n<ul>\n<li>最安全，在启用appendfsync always时，任何已写入的数据都不会丢失，使用在启用appendfsync everysec也至多只会丢失1秒的数据。</li>\n<li>AOF文件在发生断电等问题时也不会损坏，即使出现了某条日志只写入了一半的情况，也可以使用redis-check-aof工具轻松修复。</li>\n<li>AOF文件易读，可修改，在进行了某些错误的数据清除操作后，只要AOF文件没有rewrite，就可以把AOF文件备份出来，把错误的命令删除，然后恢复数据。</li>\n</ul>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li>AOF文件通常比RDB文件更大。</li>\n<li>性能消耗比RDB高。</li>\n<li>数据恢复速度比RDB慢。</li>\n</ul>\n<h1 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h1><ul>\n<li><strong>String</strong> 常规的set/get操作，value可以是String也可以是数字 </li>\n<li><strong>hash</strong> value存放的是结构化的对象 </li>\n<li><strong>list</strong> 使用List的数据结构 </li>\n<li><strong>set</strong> 类似Java set集合，存放的是不重复值的集合 </li>\n<li><strong>sorted set</strong> 权重参数score,集合中的元素能够按score进行排列。 </li>\n</ul>\n<h1 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h1><p>通过MULTI和EXEC命令<br>Redis在接收到MULTI命令后便会开启一个事务，这之后的所有读写命令都会保存在队列中但并不执行，直到接收到EXEC命令后，Redis会把队列中的所有命令连续顺序执行，并以数组形式返回每个命令的返回结果。 </p>\n<p><strong>注意：Redis事务不支持回滚</strong> </p>\n<h2 id=\"CAS\"><a href=\"#CAS\" class=\"headerlink\" title=\"CAS\"></a>CAS</h2><p>Redis提供了WATCH命令与事务搭配使用，实现CAS乐观锁的机制。 </p>\n<p>WATCH的机制：在事务EXEC命令执行时，Redis会检查被WATCH的key，只有被WATCH的key从WATCH起始时至今没有发生过变更，EXEC才会被执行。如果WATCH的key在WATCH命令到EXEC命令之间发生过变化，则EXEC命令会返回失败。</p>\n<h2 id=\"Script\"><a href=\"#Script\" class=\"headerlink\" title=\"Script\"></a>Script</h2><p>通过EVAL与EVALSHA命令，可以让Redis执行LUA脚本。 Redis官方推荐使用LUA Script来代替事务 ，请参考官方文档  。<a href=\"https://link.jianshu.com/?t=https://redis.io/commands/eval\" target=\"_blank\" rel=\"noopener\">https://redis.io/commands/eval</a> </p>\n<h1 id=\"Redis为什么这么快\"><a href=\"#Redis为什么这么快\" class=\"headerlink\" title=\"Redis为什么这么快\"></a>Redis为什么这么快</h1><ol>\n<li>纯内存操作 </li>\n<li>单线程操作，避免了频繁的上下文切换 </li>\n<li>采用了非阻塞<strong>I/O多路复用机制</strong> ，只有1个线程，通过跟踪每个I/O流的状态来管理多个I/O流 。</li>\n</ol>\n<h1 id=\"实战问题\"><a href=\"#实战问题\" class=\"headerlink\" title=\"实战问题\"></a>实战问题</h1><h2 id=\"数据库双写一致性问题\"><a href=\"#数据库双写一致性问题\" class=\"headerlink\" title=\"数据库双写一致性问题\"></a>数据库双写一致性问题</h2><p>一致性问题是分布式常见问题，还可以再分为最终一致性和强一致性。数据库和缓存双写，就必然会存在不一致的问题。如果对数据有强一致性要求，不能放缓存。<strong>我们所做的一切，只能保证最终一致性。另外，我们所做的方案其实从根本上来说是降低不一致发生的概率</strong>，无法完全避免。因此，有强一致性要求的数据，不能放缓存。 </p>\n<p>采取正确更新策略，先更新数据库，再删缓存。其次，因为可能存在删除缓存失败的问题，提供一个补偿措施即可，例如利用消息队列。 </p>\n<h2 id=\"缓存穿透\"><a href=\"#缓存穿透\" class=\"headerlink\" title=\"缓存穿透\"></a>缓存穿透</h2><p>去请求缓存中不存在的数据，导致所有的请求压力都到数据库上，从而数据库连接异常或者崩溃。 </p>\n<ol>\n<li>利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试 </li>\n<li>采用异步更新策略，无论key是否取到值，都直接返回。value值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。需要做<strong>缓存预热</strong>(项目启动前，先加载缓存)操作。 </li>\n<li>提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的key。迅速判断出，请求所携带的Key是否合法有效。如果不合法，则直接返回。 </li>\n</ol>\n<h2 id=\"缓存雪崩\"><a href=\"#缓存雪崩\" class=\"headerlink\" title=\"缓存雪崩\"></a><strong>缓存雪崩</strong></h2><p>缓存同一时间大面积的失效，恰好这时候又来了一波请求，请求压力都到数据库上，从而导致数据库连接异常。 </p>\n<ol>\n<li>给缓存的失效时间，加上一个随机值，避免集体失效。 </li>\n<li>使用互斥锁，但是该方案可能会导致吞吐量明显下降了。 </li>\n<li>采用双缓存，缓存A和缓存B。缓存A的失效时间为20分钟，缓存B不设失效时间 。</li>\n</ol>\n<h2 id=\"并发竞争\"><a href=\"#并发竞争\" class=\"headerlink\" title=\"并发竞争\"></a>并发竞争</h2><p>Redis为单进程单线程模式，采用队列模式将并发访问变为串行访问。</p>\n<p>Redis本身没有锁的概念，Redis对于多个客户端连接并不存在竞争，但是在Jedis客户端对Redis进行并发访问时会发生连接超时、数据转换错误、阻塞、客户端关闭连接等问题，这些问题均是由于客户端连接混乱造成。</p>\n<p>解决方法：</p>\n<ol>\n<li>客户端角度，为保证每个客户端间正常有序与Redis进行通信，对连接进行池化，同时对客户端读写Redis操作采用内部锁synchronized。</li>\n<li>服务器角度，利用setnx实现锁。</li>\n</ol>\n<p>当同时有多个子系统去set一个key。这时候可能会发生问题。</p>\n<ol>\n<li>redis事务机制, 如果是redis集群环境 ，这多个key不一定都存储在同一个redis-server上。该方案会失效。</li>\n<li>分布式锁，利用setnx实现锁 </li>\n<li>利用队列，将set方法变成串行访问。</li>\n</ol>\n<h2 id=\"大量数据插入\"><a href=\"#大量数据插入\" class=\"headerlink\" title=\"大量数据插入\"></a>大量数据插入</h2><p>客户端执行大量数据插入时候，一个个的插入会有大量的时间浪费在每一个命令往返时间上。 </p>\n<p>可以使用Redis提供的pipelining功能来实现在一次交互中执行多条命令。</p>\n<h1 id=\"常用应用场景\"><a href=\"#常用应用场景\" class=\"headerlink\" title=\"常用应用场景\"></a>常用应用场景</h1><ul>\n<li>排行榜类的应用，取TOP N操作，前面操作以时间为权重，这个是以某个条件为权重，比如按顶的次数排序计数器应用</li>\n<li>存储关系：比如社交关系，比如Tag等</li>\n<li>获取某段时间所有数据排重值，使用set，比如某段时间访问的用户ID，或者是客户端IP</li>\n<li>构建队列系统，List可以构建栈和队列，使用zset可以构建优先级队列</li>\n</ul>\n<h1 id=\"Redis与Memcached\"><a href=\"#Redis与Memcached\" class=\"headerlink\" title=\"Redis与Memcached\"></a>Redis与Memcached</h1><p>简单比较:</p>\n<p><img src=\"/images/redis/redis-memcached.png\" alt=\"\"></p>"},{"title":"JVM排查小记","author":"James","date":"2016-07-25T02:46:00.000Z","_content":"在生产环境中，我们经常遇到突发问题，无法用代码调试或者其他可视化工具去立马查看当前的运行状态和拿到错误信息，此时，借助Java自带的命令行工具以及相关dump分析工具以及一些小技巧，可以大大提升我们排查问题的效率。\n\n此篇博客主要是总结相关线上调试的一些经验\n<!-- more -->\n\n# CPU 突然飚高\n\n思路：首先找出 CPU 飚高的 Java 进程，可能服务器会有多个 JVM 进程。然后找到那个进程中的 “问题线程”，最后根据线程堆栈信息找到问题代码。最后对代码进行排查。\n\n1. 通过 top 命令找到 CPU 消耗最高的进程，记录进程 ID。\n\n   ![](/images/jvm_trouble/top.png)\n\n2. 再次通过 top -Hp [进程 ID] 找到 CPU 消耗最高的线程 ID.\n\n   ![](/images/jvm_trouble/thread.png)\n\n3. 通过 JDK 提供的 jstack 工具 dump 线程堆栈信息到指定文件中。具体命令：jstack -l [进程 ID] >jstack.log。\n4. 由于刚刚的线程 ID 是十进制的，而堆栈信息中的线程 ID 是16进制的，因此我们需要将10进制的转换成16进制的，并用这个线程 ID 在堆栈中查找。使用 printf “%x\\n” [十进制数字] ，可以将10进制转换成16进制。\n   通过刚刚转换的16进制数字从堆栈信息里找到对应的线程堆栈。就可以从该堆栈中看出端倪。\n\n# 内存问题\n内存管理一般容易发生两种情况: 一种是内存溢出了;一种是GC频繁\n\n1. java.lang.OutOfMemoryError: PermGen space ，说明是Java虚拟机对永久代Perm内存设置不够。\n2. java.lang.OutOfMemoryError: Java heap space，说明Java虚拟机的堆内存不足。\n   1. 可以通过参数-Xms、-Xmx来调整。 \n   2. 代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）。 \n\n## 排查方法:\n\n1. top命令：Linux命令。可以查看实时的内存使用情况。   \n2. jmap -histo:live [pid]，然后分析具体的对象数目和占用内存大小，从而定位代码。 \n3. jmap -dump:live,format=b,file=xxx.dump [pid]，然后利用可视化工具(MAT，Jprofile，jvisualvm 等分析是否存在内存泄漏。 \n4. 提前对Java程序加上参数打印dump文件 `-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=./`\n5. GC 的优化有2个维度，一是频率，二是时长。 首先看频率，如果 YGC 超过5秒一次，甚至更长，说明系统内存过大，应该缩小容量，如果频率很高，说明 Eden 区过小，可以将 Eden 区增大，但整个新生代的容量应该在堆的 30% - 40%之间，eden，from 和 to 的比例应该在 8：1：1左右，这个比例可根据对象晋升的大小进行调整。\n\n# 常用命令\n\n- **jps**: 显示系统内所有的JVM进程 \n\n- **jstat**: 用于监控虚拟机运行状态信息。它可以显示本地或者远程虚拟机进程的内存、垃圾收集、JIT编译 \n  option：选项\n  - `-class`\n    监视类的装载/卸载数量、总空间以及类装载所耗时间；\n  - `-gc`\n    监视java heap情况，包括eden区和两个survivor区、old区、永久区等的容量，已用空间和GC时间等信息；\n  - `-gccapacity`\n    监视内容与`-gc`基本是一致的，`-gccapacity`的输出包括heap各个区域使用到的最大最小空间；\n  - `gcutil`\n    监视内容同样与`-gc`基本一致，`-gcutil`的输出主要是heap各个区域使用空间占总空间百分比；\n  - `gccause`\n    与`-gcutil`功能一致，但是会额外输出导致上一次gc的原因；\n  - `gcnew`\n    监视young区gc情况；\n  - `gcnewcapacity`\n    监视内容与`-gcnew`基本相同，`-gcnewcapacity`的输出包括使用到的最大最小空间；\n  - `-gcold`\n    监视old区gc情况；\n  - `-gcoldcapacity`\n    监视内容与`-gcold`基本相同，`-gcoldcapacity`的输出包括使用到的最大最小空间；\n  - `-gcpermcapacity`\n    输出永久代使用到的最大最小空间；\n\n- **jmap**: 用于生成堆内存快照（heapdump或者dump文件） \n\n- **jstack**: 生成虚拟机当前时刻的线程快照 \n\n","source":"_posts/JVM排查小记.md","raw":"title: JVM排查小记\nauthor: James\ntags:\n  - JVM\ncategories:\n  - Java\ndate: 2016-07-25 10:46:00\n---\n在生产环境中，我们经常遇到突发问题，无法用代码调试或者其他可视化工具去立马查看当前的运行状态和拿到错误信息，此时，借助Java自带的命令行工具以及相关dump分析工具以及一些小技巧，可以大大提升我们排查问题的效率。\n\n此篇博客主要是总结相关线上调试的一些经验\n<!-- more -->\n\n# CPU 突然飚高\n\n思路：首先找出 CPU 飚高的 Java 进程，可能服务器会有多个 JVM 进程。然后找到那个进程中的 “问题线程”，最后根据线程堆栈信息找到问题代码。最后对代码进行排查。\n\n1. 通过 top 命令找到 CPU 消耗最高的进程，记录进程 ID。\n\n   ![](/images/jvm_trouble/top.png)\n\n2. 再次通过 top -Hp [进程 ID] 找到 CPU 消耗最高的线程 ID.\n\n   ![](/images/jvm_trouble/thread.png)\n\n3. 通过 JDK 提供的 jstack 工具 dump 线程堆栈信息到指定文件中。具体命令：jstack -l [进程 ID] >jstack.log。\n4. 由于刚刚的线程 ID 是十进制的，而堆栈信息中的线程 ID 是16进制的，因此我们需要将10进制的转换成16进制的，并用这个线程 ID 在堆栈中查找。使用 printf “%x\\n” [十进制数字] ，可以将10进制转换成16进制。\n   通过刚刚转换的16进制数字从堆栈信息里找到对应的线程堆栈。就可以从该堆栈中看出端倪。\n\n# 内存问题\n内存管理一般容易发生两种情况: 一种是内存溢出了;一种是GC频繁\n\n1. java.lang.OutOfMemoryError: PermGen space ，说明是Java虚拟机对永久代Perm内存设置不够。\n2. java.lang.OutOfMemoryError: Java heap space，说明Java虚拟机的堆内存不足。\n   1. 可以通过参数-Xms、-Xmx来调整。 \n   2. 代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）。 \n\n## 排查方法:\n\n1. top命令：Linux命令。可以查看实时的内存使用情况。   \n2. jmap -histo:live [pid]，然后分析具体的对象数目和占用内存大小，从而定位代码。 \n3. jmap -dump:live,format=b,file=xxx.dump [pid]，然后利用可视化工具(MAT，Jprofile，jvisualvm 等分析是否存在内存泄漏。 \n4. 提前对Java程序加上参数打印dump文件 `-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=./`\n5. GC 的优化有2个维度，一是频率，二是时长。 首先看频率，如果 YGC 超过5秒一次，甚至更长，说明系统内存过大，应该缩小容量，如果频率很高，说明 Eden 区过小，可以将 Eden 区增大，但整个新生代的容量应该在堆的 30% - 40%之间，eden，from 和 to 的比例应该在 8：1：1左右，这个比例可根据对象晋升的大小进行调整。\n\n# 常用命令\n\n- **jps**: 显示系统内所有的JVM进程 \n\n- **jstat**: 用于监控虚拟机运行状态信息。它可以显示本地或者远程虚拟机进程的内存、垃圾收集、JIT编译 \n  option：选项\n  - `-class`\n    监视类的装载/卸载数量、总空间以及类装载所耗时间；\n  - `-gc`\n    监视java heap情况，包括eden区和两个survivor区、old区、永久区等的容量，已用空间和GC时间等信息；\n  - `-gccapacity`\n    监视内容与`-gc`基本是一致的，`-gccapacity`的输出包括heap各个区域使用到的最大最小空间；\n  - `gcutil`\n    监视内容同样与`-gc`基本一致，`-gcutil`的输出主要是heap各个区域使用空间占总空间百分比；\n  - `gccause`\n    与`-gcutil`功能一致，但是会额外输出导致上一次gc的原因；\n  - `gcnew`\n    监视young区gc情况；\n  - `gcnewcapacity`\n    监视内容与`-gcnew`基本相同，`-gcnewcapacity`的输出包括使用到的最大最小空间；\n  - `-gcold`\n    监视old区gc情况；\n  - `-gcoldcapacity`\n    监视内容与`-gcold`基本相同，`-gcoldcapacity`的输出包括使用到的最大最小空间；\n  - `-gcpermcapacity`\n    输出永久代使用到的最大最小空间；\n\n- **jmap**: 用于生成堆内存快照（heapdump或者dump文件） \n\n- **jstack**: 生成虚拟机当前时刻的线程快照 \n\n","slug":"JVM排查小记","published":1,"updated":"2018-07-27T01:37:14.541Z","_id":"cjk0j5y4o0000k8kc1hxkvfcr","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在生产环境中，我们经常遇到突发问题，无法用代码调试或者其他可视化工具去立马查看当前的运行状态和拿到错误信息，此时，借助Java自带的命令行工具以及相关dump分析工具以及一些小技巧，可以大大提升我们排查问题的效率。</p>\n<p>此篇博客主要是总结相关线上调试的一些经验<br><a id=\"more\"></a></p>\n<h1 id=\"CPU-突然飚高\"><a href=\"#CPU-突然飚高\" class=\"headerlink\" title=\"CPU 突然飚高\"></a>CPU 突然飚高</h1><p>思路：首先找出 CPU 飚高的 Java 进程，可能服务器会有多个 JVM 进程。然后找到那个进程中的 “问题线程”，最后根据线程堆栈信息找到问题代码。最后对代码进行排查。</p>\n<ol>\n<li><p>通过 top 命令找到 CPU 消耗最高的进程，记录进程 ID。</p>\n<p><img src=\"/images/jvm_trouble/top.png\" alt=\"\"></p>\n</li>\n<li><p>再次通过 top -Hp [进程 ID] 找到 CPU 消耗最高的线程 ID.</p>\n<p><img src=\"/images/jvm_trouble/thread.png\" alt=\"\"></p>\n</li>\n<li><p>通过 JDK 提供的 jstack 工具 dump 线程堆栈信息到指定文件中。具体命令：jstack -l [进程 ID] &gt;jstack.log。</p>\n</li>\n<li>由于刚刚的线程 ID 是十进制的，而堆栈信息中的线程 ID 是16进制的，因此我们需要将10进制的转换成16进制的，并用这个线程 ID 在堆栈中查找。使用 printf “%x\\n” [十进制数字] ，可以将10进制转换成16进制。<br>通过刚刚转换的16进制数字从堆栈信息里找到对应的线程堆栈。就可以从该堆栈中看出端倪。</li>\n</ol>\n<h1 id=\"内存问题\"><a href=\"#内存问题\" class=\"headerlink\" title=\"内存问题\"></a>内存问题</h1><p>内存管理一般容易发生两种情况: 一种是内存溢出了;一种是GC频繁</p>\n<ol>\n<li>java.lang.OutOfMemoryError: PermGen space ，说明是Java虚拟机对永久代Perm内存设置不够。</li>\n<li>java.lang.OutOfMemoryError: Java heap space，说明Java虚拟机的堆内存不足。<ol>\n<li>可以通过参数-Xms、-Xmx来调整。 </li>\n<li>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）。 </li>\n</ol>\n</li>\n</ol>\n<h2 id=\"排查方法\"><a href=\"#排查方法\" class=\"headerlink\" title=\"排查方法:\"></a>排查方法:</h2><ol>\n<li>top命令：Linux命令。可以查看实时的内存使用情况。   </li>\n<li>jmap -histo:live [pid]，然后分析具体的对象数目和占用内存大小，从而定位代码。 </li>\n<li>jmap -dump:live,format=b,file=xxx.dump [pid]，然后利用可视化工具(MAT，Jprofile，jvisualvm 等分析是否存在内存泄漏。 </li>\n<li>提前对Java程序加上参数打印dump文件 <code>-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=./</code></li>\n<li>GC 的优化有2个维度，一是频率，二是时长。 首先看频率，如果 YGC 超过5秒一次，甚至更长，说明系统内存过大，应该缩小容量，如果频率很高，说明 Eden 区过小，可以将 Eden 区增大，但整个新生代的容量应该在堆的 30% - 40%之间，eden，from 和 to 的比例应该在 8：1：1左右，这个比例可根据对象晋升的大小进行调整。</li>\n</ol>\n<h1 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h1><ul>\n<li><p><strong>jps</strong>: 显示系统内所有的JVM进程 </p>\n</li>\n<li><p><strong>jstat</strong>: 用于监控虚拟机运行状态信息。它可以显示本地或者远程虚拟机进程的内存、垃圾收集、JIT编译<br>option：选项</p>\n<ul>\n<li><code>-class</code><br>监视类的装载/卸载数量、总空间以及类装载所耗时间；</li>\n<li><code>-gc</code><br>监视java heap情况，包括eden区和两个survivor区、old区、永久区等的容量，已用空间和GC时间等信息；</li>\n<li><code>-gccapacity</code><br>监视内容与<code>-gc</code>基本是一致的，<code>-gccapacity</code>的输出包括heap各个区域使用到的最大最小空间；</li>\n<li><code>gcutil</code><br>监视内容同样与<code>-gc</code>基本一致，<code>-gcutil</code>的输出主要是heap各个区域使用空间占总空间百分比；</li>\n<li><code>gccause</code><br>与<code>-gcutil</code>功能一致，但是会额外输出导致上一次gc的原因；</li>\n<li><code>gcnew</code><br>监视young区gc情况；</li>\n<li><code>gcnewcapacity</code><br>监视内容与<code>-gcnew</code>基本相同，<code>-gcnewcapacity</code>的输出包括使用到的最大最小空间；</li>\n<li><code>-gcold</code><br>监视old区gc情况；</li>\n<li><code>-gcoldcapacity</code><br>监视内容与<code>-gcold</code>基本相同，<code>-gcoldcapacity</code>的输出包括使用到的最大最小空间；</li>\n<li><code>-gcpermcapacity</code><br>输出永久代使用到的最大最小空间；</li>\n</ul>\n</li>\n<li><p><strong>jmap</strong>: 用于生成堆内存快照（heapdump或者dump文件） </p>\n</li>\n<li><p><strong>jstack</strong>: 生成虚拟机当前时刻的线程快照 </p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>在生产环境中，我们经常遇到突发问题，无法用代码调试或者其他可视化工具去立马查看当前的运行状态和拿到错误信息，此时，借助Java自带的命令行工具以及相关dump分析工具以及一些小技巧，可以大大提升我们排查问题的效率。</p>\n<p>此篇博客主要是总结相关线上调试的一些经验<br>","more":"</p>\n<h1 id=\"CPU-突然飚高\"><a href=\"#CPU-突然飚高\" class=\"headerlink\" title=\"CPU 突然飚高\"></a>CPU 突然飚高</h1><p>思路：首先找出 CPU 飚高的 Java 进程，可能服务器会有多个 JVM 进程。然后找到那个进程中的 “问题线程”，最后根据线程堆栈信息找到问题代码。最后对代码进行排查。</p>\n<ol>\n<li><p>通过 top 命令找到 CPU 消耗最高的进程，记录进程 ID。</p>\n<p><img src=\"/images/jvm_trouble/top.png\" alt=\"\"></p>\n</li>\n<li><p>再次通过 top -Hp [进程 ID] 找到 CPU 消耗最高的线程 ID.</p>\n<p><img src=\"/images/jvm_trouble/thread.png\" alt=\"\"></p>\n</li>\n<li><p>通过 JDK 提供的 jstack 工具 dump 线程堆栈信息到指定文件中。具体命令：jstack -l [进程 ID] &gt;jstack.log。</p>\n</li>\n<li>由于刚刚的线程 ID 是十进制的，而堆栈信息中的线程 ID 是16进制的，因此我们需要将10进制的转换成16进制的，并用这个线程 ID 在堆栈中查找。使用 printf “%x\\n” [十进制数字] ，可以将10进制转换成16进制。<br>通过刚刚转换的16进制数字从堆栈信息里找到对应的线程堆栈。就可以从该堆栈中看出端倪。</li>\n</ol>\n<h1 id=\"内存问题\"><a href=\"#内存问题\" class=\"headerlink\" title=\"内存问题\"></a>内存问题</h1><p>内存管理一般容易发生两种情况: 一种是内存溢出了;一种是GC频繁</p>\n<ol>\n<li>java.lang.OutOfMemoryError: PermGen space ，说明是Java虚拟机对永久代Perm内存设置不够。</li>\n<li>java.lang.OutOfMemoryError: Java heap space，说明Java虚拟机的堆内存不足。<ol>\n<li>可以通过参数-Xms、-Xmx来调整。 </li>\n<li>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）。 </li>\n</ol>\n</li>\n</ol>\n<h2 id=\"排查方法\"><a href=\"#排查方法\" class=\"headerlink\" title=\"排查方法:\"></a>排查方法:</h2><ol>\n<li>top命令：Linux命令。可以查看实时的内存使用情况。   </li>\n<li>jmap -histo:live [pid]，然后分析具体的对象数目和占用内存大小，从而定位代码。 </li>\n<li>jmap -dump:live,format=b,file=xxx.dump [pid]，然后利用可视化工具(MAT，Jprofile，jvisualvm 等分析是否存在内存泄漏。 </li>\n<li>提前对Java程序加上参数打印dump文件 <code>-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=./</code></li>\n<li>GC 的优化有2个维度，一是频率，二是时长。 首先看频率，如果 YGC 超过5秒一次，甚至更长，说明系统内存过大，应该缩小容量，如果频率很高，说明 Eden 区过小，可以将 Eden 区增大，但整个新生代的容量应该在堆的 30% - 40%之间，eden，from 和 to 的比例应该在 8：1：1左右，这个比例可根据对象晋升的大小进行调整。</li>\n</ol>\n<h1 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h1><ul>\n<li><p><strong>jps</strong>: 显示系统内所有的JVM进程 </p>\n</li>\n<li><p><strong>jstat</strong>: 用于监控虚拟机运行状态信息。它可以显示本地或者远程虚拟机进程的内存、垃圾收集、JIT编译<br>option：选项</p>\n<ul>\n<li><code>-class</code><br>监视类的装载/卸载数量、总空间以及类装载所耗时间；</li>\n<li><code>-gc</code><br>监视java heap情况，包括eden区和两个survivor区、old区、永久区等的容量，已用空间和GC时间等信息；</li>\n<li><code>-gccapacity</code><br>监视内容与<code>-gc</code>基本是一致的，<code>-gccapacity</code>的输出包括heap各个区域使用到的最大最小空间；</li>\n<li><code>gcutil</code><br>监视内容同样与<code>-gc</code>基本一致，<code>-gcutil</code>的输出主要是heap各个区域使用空间占总空间百分比；</li>\n<li><code>gccause</code><br>与<code>-gcutil</code>功能一致，但是会额外输出导致上一次gc的原因；</li>\n<li><code>gcnew</code><br>监视young区gc情况；</li>\n<li><code>gcnewcapacity</code><br>监视内容与<code>-gcnew</code>基本相同，<code>-gcnewcapacity</code>的输出包括使用到的最大最小空间；</li>\n<li><code>-gcold</code><br>监视old区gc情况；</li>\n<li><code>-gcoldcapacity</code><br>监视内容与<code>-gcold</code>基本相同，<code>-gcoldcapacity</code>的输出包括使用到的最大最小空间；</li>\n<li><code>-gcpermcapacity</code><br>输出永久代使用到的最大最小空间；</li>\n</ul>\n</li>\n<li><p><strong>jmap</strong>: 用于生成堆内存快照（heapdump或者dump文件） </p>\n</li>\n<li><p><strong>jstack</strong>: 生成虚拟机当前时刻的线程快照 </p>\n</li>\n</ul>"},{"title":"CAS-原理","author":"James","date":"2016-08-30T03:37:00.000Z","_content":"# 什么是 CAS\n\nCAS （compareAndSwap），中文翻译过来叫做比较交换，一种无锁原子算法。过程是这样：它包含 3 个参数 （V，E，N），V表示要更新变量的值，E表示预期值，N表示新值。仅当 V值等于E值时，才会将V的值设为N，如果V值和E值不同，则说明已经有其他线程做两个更新，则当前线程则什么都不做。最后返回当前V的真实值。\n\n<!-- more -->\n\n# 为什么会出现CAS\n\n我们平时在编发编程的时候，经常会遇到如下的情况；比如多线程对变量进行修改，同时只能有一个线程进入同步块修改变量的值\n\n```java\nvoid synchronized  modify(int b){\n  a = a + b；\n}\n```\n\n如果上面的代码不加同步关键字synchronized 的话，会出现线程安全的问题；但是加了锁之后又会消耗性能-获取锁，释放锁，等待和阻塞都会消耗性能。那么有没有办法做到不加锁？\n\n我们来分析下上面的代码\n\n1. 线程读取a的值\n2. 然后将a和b相加\n3. 最后赋值给a\n\n当多线程的情况下，会出现问题：两个线程同时访问a，获取a的值，并同时对a加上b的值，然后同时赋值给a。\n\n这样可能会导致 a 的值只增加了一次b，但实际上我们想加 2次b。\n\n仔细思考，问题可能出在给a赋值操作的时候，a的值其实已经改变了，那有有没有办法在赋值的时候判断当前a变了是否已经被其他线程改变了呢，例如:\n\n ```java\nvoid modify(int b) {\n    int expect = a;\n   \tint c = a + b;\n    compareAndSwap(a, expect, c)；\n}\n\nboolean compareAndSwap(int expect ,int c ){\n       if (a == backup) {\n           a = c;\n           return true;\n       }\n    return false;\n}\n ```\n\n我们是不是可以先备份a的值，然后对a进行计算，最后比较a的值和期待值是否一致，如果a没有被其他线程修改过，这时候能够进行修改。这里是伪代码，上述方法中有多步操作，并不是原子操作。\n\n# 实现原理 \n\n当多个线程同时使用CAS 操作一个变量时，只有一个线程会胜出，并成功更新，其余均会失败。失败的线程不会挂起，仅是被告知失败，并且允许再次尝试，当然也允许实现的线程放弃操作。基于这样的原理，CAS 操作即使没有锁，也可以发现其他线程对当前线程的干扰。\n\n与锁相比，使用CAS会使程序看起来更加复杂一些，但由于其非阻塞的，它对死锁问题天生免疫，并且，线程间的相互影响也非常小。更为重要的是，使用无锁的方式完全没有锁竞争带来的系统开销，也没有线程间频繁调度带来的开销，因此，他要比基于锁的方式拥有更优越的性能。\n\n# 底层原理\n\n通过CPU底层指令实现的 \n\n1.处理器自动保证基本内存操作的原子性\n   处理器会自动保证基本的内存操作的原子性。处理器保证从系统内存当中读取或者写入一个字节是原子的，意思是当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址。 但是复杂的内存操作处理器不能自动保证其原子性，比如跨总线宽度，跨多个缓存行，跨页表的访问。但是处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性。 \n\n2.使用总线锁保证原子性\n   总线锁定其实就是处理器使用了总线锁，所谓总线锁就是使用处理器提供的一个 LOCK# 信号，当一个处理器咋总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。 \n\n3.使用缓存锁保证原子性\n   通过缓存锁定来保证原子性。 所谓 缓存锁定 是指内存区域如果被缓存在处理器的缓存行中，并且在Lock 操作期间被锁定，那么当他执行锁操作写回到内存时，处理器不在总线上声言 LOCK# 信号，而时修改内部的内存地址，并允许他的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改两个以上处理器缓存的内存区域数据（这里和 volatile 的可见性原理相同），当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效。 \n\n   注意：有两种情况下处理器不会使用缓存锁定。\n   1. 当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行时，则处理器会调用**总线锁定**。\n   2. 有些处理器不支持缓存锁定，对于 Intel 486 和 Pentium 处理器，就是锁定的内存区域在处理器的缓存行也会调用总线锁定。\n\n\n\n# Java中的CAS\n\nJava提供了 java.util.concurrent.atomic 包，该包下所有的类都是原子操做，我们重点看下*AtomicInteger*  这个类。找到该类的*compareAndSet*方法，也就是比较并且设置。我们看看该方法实现： \n\n```java\npublic final boolean compareAndSet(int expect, int update) {\n    return unsafe.compareAndSwapInt(this, valueOffset, expect, update);\n}\n```\n该方法调用了 unsafe 类的 compareAndSwapInt方法，有几个参数，一个是该变量的内存地址，一个是期望值，一个是更新值，一个是对象自身。完全符合我们之前CAS 的定义。\n\n再往下寻找我们发现 Unsafe的`compareAndSwapInt` 是 Native 的方法： 是借助C来调用CPU底层指令实现的。 \n\n## unsafe 是什么 \n该类在 rt.jar 包中，是 sun.misc 包下。并且都是 class 文件，注释都没有，符合他的名字：不安全。\n我们能构造他吗？不能，除非反射。\n下载一个 OpenJdk 的源码继续向下探索，我们发现在 `/jdk9u/hotspot/src/share/vm/unsafe.cpp` 中有这样的代码\n\n```c++\n{CC \"compareAndSetInt\",   CC \"(\" OBJ \"J\"\"I\"\"I\"\")Z\",  FN_PTR(Unsafe_CompareAndSetInt)}\n```\n\n这个涉及到，JNI 的调用 搜索 `Unsafe_CompareAndSetInt`后发现:\n\n```C++\nUNSAFE_ENTRY(jboolean, Unsafe_CompareAndSetInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x)) {\n  oop p = JNIHandles::resolve(obj);\n  jint* addr = (jint *)index_oop_from_field_offset_long(p, offset);\n\n  return (jint)(Atomic::cmpxchg(x, addr, e)) == e;\n} UNSAFE_END\n```\n\n核心**Atomic::cmpxchg **,针对不同的操作系统,JVM 对于 Atomic::cmpxchg 应该有不同的实现.\n`cmpxchgl` 就是汇编版的“比较并交换”。 \n\n总结:\n- java 的 cas 利用的的是 unsafe 这个类提供的 cas 操作。\n- unsafe 的cas 依赖了的是 jvm 针对不同的操作系统实现的 Atomic::cmpxchg\n- Atomic::cmpxchg 的实现使用了汇编的 cas 操作，并使用 cpu 硬件提供的 lock信号保证其原子性\n\n# CAS缺点\n\n1. **ABA问题 **因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。\n2. **循环时间长开销大 ** 自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。 \n3. **只能保证一个共享变量的原子操作** 当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性。在 java.util.concurrent.atomic 包中，就有 AtomicReference 来保证引用的原子性。","source":"_posts/CAS.md","raw":"title: CAS-原理\nauthor: James\ntags:\n  - CAS\ncategories:\n  - 并发\ndate: 2016-08-30 11:37:00\n---\n# 什么是 CAS\n\nCAS （compareAndSwap），中文翻译过来叫做比较交换，一种无锁原子算法。过程是这样：它包含 3 个参数 （V，E，N），V表示要更新变量的值，E表示预期值，N表示新值。仅当 V值等于E值时，才会将V的值设为N，如果V值和E值不同，则说明已经有其他线程做两个更新，则当前线程则什么都不做。最后返回当前V的真实值。\n\n<!-- more -->\n\n# 为什么会出现CAS\n\n我们平时在编发编程的时候，经常会遇到如下的情况；比如多线程对变量进行修改，同时只能有一个线程进入同步块修改变量的值\n\n```java\nvoid synchronized  modify(int b){\n  a = a + b；\n}\n```\n\n如果上面的代码不加同步关键字synchronized 的话，会出现线程安全的问题；但是加了锁之后又会消耗性能-获取锁，释放锁，等待和阻塞都会消耗性能。那么有没有办法做到不加锁？\n\n我们来分析下上面的代码\n\n1. 线程读取a的值\n2. 然后将a和b相加\n3. 最后赋值给a\n\n当多线程的情况下，会出现问题：两个线程同时访问a，获取a的值，并同时对a加上b的值，然后同时赋值给a。\n\n这样可能会导致 a 的值只增加了一次b，但实际上我们想加 2次b。\n\n仔细思考，问题可能出在给a赋值操作的时候，a的值其实已经改变了，那有有没有办法在赋值的时候判断当前a变了是否已经被其他线程改变了呢，例如:\n\n ```java\nvoid modify(int b) {\n    int expect = a;\n   \tint c = a + b;\n    compareAndSwap(a, expect, c)；\n}\n\nboolean compareAndSwap(int expect ,int c ){\n       if (a == backup) {\n           a = c;\n           return true;\n       }\n    return false;\n}\n ```\n\n我们是不是可以先备份a的值，然后对a进行计算，最后比较a的值和期待值是否一致，如果a没有被其他线程修改过，这时候能够进行修改。这里是伪代码，上述方法中有多步操作，并不是原子操作。\n\n# 实现原理 \n\n当多个线程同时使用CAS 操作一个变量时，只有一个线程会胜出，并成功更新，其余均会失败。失败的线程不会挂起，仅是被告知失败，并且允许再次尝试，当然也允许实现的线程放弃操作。基于这样的原理，CAS 操作即使没有锁，也可以发现其他线程对当前线程的干扰。\n\n与锁相比，使用CAS会使程序看起来更加复杂一些，但由于其非阻塞的，它对死锁问题天生免疫，并且，线程间的相互影响也非常小。更为重要的是，使用无锁的方式完全没有锁竞争带来的系统开销，也没有线程间频繁调度带来的开销，因此，他要比基于锁的方式拥有更优越的性能。\n\n# 底层原理\n\n通过CPU底层指令实现的 \n\n1.处理器自动保证基本内存操作的原子性\n   处理器会自动保证基本的内存操作的原子性。处理器保证从系统内存当中读取或者写入一个字节是原子的，意思是当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址。 但是复杂的内存操作处理器不能自动保证其原子性，比如跨总线宽度，跨多个缓存行，跨页表的访问。但是处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性。 \n\n2.使用总线锁保证原子性\n   总线锁定其实就是处理器使用了总线锁，所谓总线锁就是使用处理器提供的一个 LOCK# 信号，当一个处理器咋总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。 \n\n3.使用缓存锁保证原子性\n   通过缓存锁定来保证原子性。 所谓 缓存锁定 是指内存区域如果被缓存在处理器的缓存行中，并且在Lock 操作期间被锁定，那么当他执行锁操作写回到内存时，处理器不在总线上声言 LOCK# 信号，而时修改内部的内存地址，并允许他的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改两个以上处理器缓存的内存区域数据（这里和 volatile 的可见性原理相同），当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效。 \n\n   注意：有两种情况下处理器不会使用缓存锁定。\n   1. 当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行时，则处理器会调用**总线锁定**。\n   2. 有些处理器不支持缓存锁定，对于 Intel 486 和 Pentium 处理器，就是锁定的内存区域在处理器的缓存行也会调用总线锁定。\n\n\n\n# Java中的CAS\n\nJava提供了 java.util.concurrent.atomic 包，该包下所有的类都是原子操做，我们重点看下*AtomicInteger*  这个类。找到该类的*compareAndSet*方法，也就是比较并且设置。我们看看该方法实现： \n\n```java\npublic final boolean compareAndSet(int expect, int update) {\n    return unsafe.compareAndSwapInt(this, valueOffset, expect, update);\n}\n```\n该方法调用了 unsafe 类的 compareAndSwapInt方法，有几个参数，一个是该变量的内存地址，一个是期望值，一个是更新值，一个是对象自身。完全符合我们之前CAS 的定义。\n\n再往下寻找我们发现 Unsafe的`compareAndSwapInt` 是 Native 的方法： 是借助C来调用CPU底层指令实现的。 \n\n## unsafe 是什么 \n该类在 rt.jar 包中，是 sun.misc 包下。并且都是 class 文件，注释都没有，符合他的名字：不安全。\n我们能构造他吗？不能，除非反射。\n下载一个 OpenJdk 的源码继续向下探索，我们发现在 `/jdk9u/hotspot/src/share/vm/unsafe.cpp` 中有这样的代码\n\n```c++\n{CC \"compareAndSetInt\",   CC \"(\" OBJ \"J\"\"I\"\"I\"\")Z\",  FN_PTR(Unsafe_CompareAndSetInt)}\n```\n\n这个涉及到，JNI 的调用 搜索 `Unsafe_CompareAndSetInt`后发现:\n\n```C++\nUNSAFE_ENTRY(jboolean, Unsafe_CompareAndSetInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x)) {\n  oop p = JNIHandles::resolve(obj);\n  jint* addr = (jint *)index_oop_from_field_offset_long(p, offset);\n\n  return (jint)(Atomic::cmpxchg(x, addr, e)) == e;\n} UNSAFE_END\n```\n\n核心**Atomic::cmpxchg **,针对不同的操作系统,JVM 对于 Atomic::cmpxchg 应该有不同的实现.\n`cmpxchgl` 就是汇编版的“比较并交换”。 \n\n总结:\n- java 的 cas 利用的的是 unsafe 这个类提供的 cas 操作。\n- unsafe 的cas 依赖了的是 jvm 针对不同的操作系统实现的 Atomic::cmpxchg\n- Atomic::cmpxchg 的实现使用了汇编的 cas 操作，并使用 cpu 硬件提供的 lock信号保证其原子性\n\n# CAS缺点\n\n1. **ABA问题 **因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。\n2. **循环时间长开销大 ** 自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。 \n3. **只能保证一个共享变量的原子操作** 当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性。在 java.util.concurrent.atomic 包中，就有 AtomicReference 来保证引用的原子性。","slug":"CAS","published":1,"updated":"2018-08-02T03:37:51.542Z","_id":"cjk7q5jrq0000v4kcw3iamwy2","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"什么是-CAS\"><a href=\"#什么是-CAS\" class=\"headerlink\" title=\"什么是 CAS\"></a>什么是 CAS</h1><p>CAS （compareAndSwap），中文翻译过来叫做比较交换，一种无锁原子算法。过程是这样：它包含 3 个参数 （V，E，N），V表示要更新变量的值，E表示预期值，N表示新值。仅当 V值等于E值时，才会将V的值设为N，如果V值和E值不同，则说明已经有其他线程做两个更新，则当前线程则什么都不做。最后返回当前V的真实值。</p>\n<a id=\"more\"></a>\n<h1 id=\"为什么会出现CAS\"><a href=\"#为什么会出现CAS\" class=\"headerlink\" title=\"为什么会出现CAS\"></a>为什么会出现CAS</h1><p>我们平时在编发编程的时候，经常会遇到如下的情况；比如多线程对变量进行修改，同时只能有一个线程进入同步块修改变量的值</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"keyword\">synchronized</span>  <span class=\"title\">modify</span><span class=\"params\">(<span class=\"keyword\">int</span> b)</span></span>&#123;</span><br><span class=\"line\">  a = a + b；</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果上面的代码不加同步关键字synchronized 的话，会出现线程安全的问题；但是加了锁之后又会消耗性能-获取锁，释放锁，等待和阻塞都会消耗性能。那么有没有办法做到不加锁？</p>\n<p>我们来分析下上面的代码</p>\n<ol>\n<li>线程读取a的值</li>\n<li>然后将a和b相加</li>\n<li>最后赋值给a</li>\n</ol>\n<p>当多线程的情况下，会出现问题：两个线程同时访问a，获取a的值，并同时对a加上b的值，然后同时赋值给a。</p>\n<p>这样可能会导致 a 的值只增加了一次b，但实际上我们想加 2次b。</p>\n<p>仔细思考，问题可能出在给a赋值操作的时候，a的值其实已经改变了，那有有没有办法在赋值的时候判断当前a变了是否已经被其他线程改变了呢，例如:</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">modify</span><span class=\"params\">(<span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> expect = a;</span><br><span class=\"line\">   \t<span class=\"keyword\">int</span> c = a + b;</span><br><span class=\"line\">    compareAndSwap(a, expect, c)；</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">compareAndSwap</span><span class=\"params\">(<span class=\"keyword\">int</span> expect ,<span class=\"keyword\">int</span> c )</span></span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (a == backup) &#123;</span><br><span class=\"line\">           a = c;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们是不是可以先备份a的值，然后对a进行计算，最后比较a的值和期待值是否一致，如果a没有被其他线程修改过，这时候能够进行修改。这里是伪代码，上述方法中有多步操作，并不是原子操作。</p>\n<h1 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h1><p>当多个线程同时使用CAS 操作一个变量时，只有一个线程会胜出，并成功更新，其余均会失败。失败的线程不会挂起，仅是被告知失败，并且允许再次尝试，当然也允许实现的线程放弃操作。基于这样的原理，CAS 操作即使没有锁，也可以发现其他线程对当前线程的干扰。</p>\n<p>与锁相比，使用CAS会使程序看起来更加复杂一些，但由于其非阻塞的，它对死锁问题天生免疫，并且，线程间的相互影响也非常小。更为重要的是，使用无锁的方式完全没有锁竞争带来的系统开销，也没有线程间频繁调度带来的开销，因此，他要比基于锁的方式拥有更优越的性能。</p>\n<h1 id=\"底层原理\"><a href=\"#底层原理\" class=\"headerlink\" title=\"底层原理\"></a>底层原理</h1><p>通过CPU底层指令实现的 </p>\n<p>1.处理器自动保证基本内存操作的原子性<br>   处理器会自动保证基本的内存操作的原子性。处理器保证从系统内存当中读取或者写入一个字节是原子的，意思是当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址。 但是复杂的内存操作处理器不能自动保证其原子性，比如跨总线宽度，跨多个缓存行，跨页表的访问。但是处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性。 </p>\n<p>2.使用总线锁保证原子性<br>   总线锁定其实就是处理器使用了总线锁，所谓总线锁就是使用处理器提供的一个 LOCK# 信号，当一个处理器咋总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。 </p>\n<p>3.使用缓存锁保证原子性<br>   通过缓存锁定来保证原子性。 所谓 缓存锁定 是指内存区域如果被缓存在处理器的缓存行中，并且在Lock 操作期间被锁定，那么当他执行锁操作写回到内存时，处理器不在总线上声言 LOCK# 信号，而时修改内部的内存地址，并允许他的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改两个以上处理器缓存的内存区域数据（这里和 volatile 的可见性原理相同），当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效。 </p>\n<p>   注意：有两种情况下处理器不会使用缓存锁定。</p>\n<ol>\n<li>当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行时，则处理器会调用<strong>总线锁定</strong>。</li>\n<li>有些处理器不支持缓存锁定，对于 Intel 486 和 Pentium 处理器，就是锁定的内存区域在处理器的缓存行也会调用总线锁定。</li>\n</ol>\n<h1 id=\"Java中的CAS\"><a href=\"#Java中的CAS\" class=\"headerlink\" title=\"Java中的CAS\"></a>Java中的CAS</h1><p>Java提供了 java.util.concurrent.atomic 包，该包下所有的类都是原子操做，我们重点看下<em>AtomicInteger</em>  这个类。找到该类的<em>compareAndSet</em>方法，也就是比较并且设置。我们看看该方法实现： </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">compareAndSet</span><span class=\"params\">(<span class=\"keyword\">int</span> expect, <span class=\"keyword\">int</span> update)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> unsafe.compareAndSwapInt(<span class=\"keyword\">this</span>, valueOffset, expect, update);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该方法调用了 unsafe 类的 compareAndSwapInt方法，有几个参数，一个是该变量的内存地址，一个是期望值，一个是更新值，一个是对象自身。完全符合我们之前CAS 的定义。</p>\n<p>再往下寻找我们发现 Unsafe的<code>compareAndSwapInt</code> 是 Native 的方法： 是借助C来调用CPU底层指令实现的。 </p>\n<h2 id=\"unsafe-是什么\"><a href=\"#unsafe-是什么\" class=\"headerlink\" title=\"unsafe 是什么\"></a>unsafe 是什么</h2><p>该类在 rt.jar 包中，是 sun.misc 包下。并且都是 class 文件，注释都没有，符合他的名字：不安全。<br>我们能构造他吗？不能，除非反射。<br>下载一个 OpenJdk 的源码继续向下探索，我们发现在 <code>/jdk9u/hotspot/src/share/vm/unsafe.cpp</code> 中有这样的代码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;CC <span class=\"string\">\"compareAndSetInt\"</span>,   CC <span class=\"string\">\"(\"</span> OBJ <span class=\"string\">\"J\"</span><span class=\"string\">\"I\"</span><span class=\"string\">\"I\"</span><span class=\"string\">\")Z\"</span>,  FN_PTR(Unsafe_CompareAndSetInt)&#125;</span><br></pre></td></tr></table></figure>\n<p>这个涉及到，JNI 的调用 搜索 <code>Unsafe_CompareAndSetInt</code>后发现:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSetInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x)) &#123;</span><br><span class=\"line\">  oop p = JNIHandles::resolve(obj);</span><br><span class=\"line\">  jint* addr = (jint *)index_oop_from_field_offset_long(p, offset);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (jint)(Atomic::cmpxchg(x, addr, e)) == e;</span><br><span class=\"line\">&#125; UNSAFE_END</span><br></pre></td></tr></table></figure>\n<p>核心<strong>Atomic::cmpxchg </strong>,针对不同的操作系统,JVM 对于 Atomic::cmpxchg 应该有不同的实现.<br><code>cmpxchgl</code> 就是汇编版的“比较并交换”。 </p>\n<p>总结:</p>\n<ul>\n<li>java 的 cas 利用的的是 unsafe 这个类提供的 cas 操作。</li>\n<li>unsafe 的cas 依赖了的是 jvm 针对不同的操作系统实现的 Atomic::cmpxchg</li>\n<li>Atomic::cmpxchg 的实现使用了汇编的 cas 操作，并使用 cpu 硬件提供的 lock信号保证其原子性</li>\n</ul>\n<h1 id=\"CAS缺点\"><a href=\"#CAS缺点\" class=\"headerlink\" title=\"CAS缺点\"></a>CAS缺点</h1><ol>\n<li><strong>ABA问题 </strong>因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。</li>\n<li><strong>循环时间长开销大 </strong> 自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。 </li>\n<li><strong>只能保证一个共享变量的原子操作</strong> 当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性。在 java.util.concurrent.atomic 包中，就有 AtomicReference 来保证引用的原子性。</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h1 id=\"什么是-CAS\"><a href=\"#什么是-CAS\" class=\"headerlink\" title=\"什么是 CAS\"></a>什么是 CAS</h1><p>CAS （compareAndSwap），中文翻译过来叫做比较交换，一种无锁原子算法。过程是这样：它包含 3 个参数 （V，E，N），V表示要更新变量的值，E表示预期值，N表示新值。仅当 V值等于E值时，才会将V的值设为N，如果V值和E值不同，则说明已经有其他线程做两个更新，则当前线程则什么都不做。最后返回当前V的真实值。</p>","more":"<h1 id=\"为什么会出现CAS\"><a href=\"#为什么会出现CAS\" class=\"headerlink\" title=\"为什么会出现CAS\"></a>为什么会出现CAS</h1><p>我们平时在编发编程的时候，经常会遇到如下的情况；比如多线程对变量进行修改，同时只能有一个线程进入同步块修改变量的值</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"keyword\">synchronized</span>  <span class=\"title\">modify</span><span class=\"params\">(<span class=\"keyword\">int</span> b)</span></span>&#123;</span><br><span class=\"line\">  a = a + b；</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果上面的代码不加同步关键字synchronized 的话，会出现线程安全的问题；但是加了锁之后又会消耗性能-获取锁，释放锁，等待和阻塞都会消耗性能。那么有没有办法做到不加锁？</p>\n<p>我们来分析下上面的代码</p>\n<ol>\n<li>线程读取a的值</li>\n<li>然后将a和b相加</li>\n<li>最后赋值给a</li>\n</ol>\n<p>当多线程的情况下，会出现问题：两个线程同时访问a，获取a的值，并同时对a加上b的值，然后同时赋值给a。</p>\n<p>这样可能会导致 a 的值只增加了一次b，但实际上我们想加 2次b。</p>\n<p>仔细思考，问题可能出在给a赋值操作的时候，a的值其实已经改变了，那有有没有办法在赋值的时候判断当前a变了是否已经被其他线程改变了呢，例如:</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">modify</span><span class=\"params\">(<span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> expect = a;</span><br><span class=\"line\">   \t<span class=\"keyword\">int</span> c = a + b;</span><br><span class=\"line\">    compareAndSwap(a, expect, c)；</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">compareAndSwap</span><span class=\"params\">(<span class=\"keyword\">int</span> expect ,<span class=\"keyword\">int</span> c )</span></span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (a == backup) &#123;</span><br><span class=\"line\">           a = c;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们是不是可以先备份a的值，然后对a进行计算，最后比较a的值和期待值是否一致，如果a没有被其他线程修改过，这时候能够进行修改。这里是伪代码，上述方法中有多步操作，并不是原子操作。</p>\n<h1 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h1><p>当多个线程同时使用CAS 操作一个变量时，只有一个线程会胜出，并成功更新，其余均会失败。失败的线程不会挂起，仅是被告知失败，并且允许再次尝试，当然也允许实现的线程放弃操作。基于这样的原理，CAS 操作即使没有锁，也可以发现其他线程对当前线程的干扰。</p>\n<p>与锁相比，使用CAS会使程序看起来更加复杂一些，但由于其非阻塞的，它对死锁问题天生免疫，并且，线程间的相互影响也非常小。更为重要的是，使用无锁的方式完全没有锁竞争带来的系统开销，也没有线程间频繁调度带来的开销，因此，他要比基于锁的方式拥有更优越的性能。</p>\n<h1 id=\"底层原理\"><a href=\"#底层原理\" class=\"headerlink\" title=\"底层原理\"></a>底层原理</h1><p>通过CPU底层指令实现的 </p>\n<p>1.处理器自动保证基本内存操作的原子性<br>   处理器会自动保证基本的内存操作的原子性。处理器保证从系统内存当中读取或者写入一个字节是原子的，意思是当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址。 但是复杂的内存操作处理器不能自动保证其原子性，比如跨总线宽度，跨多个缓存行，跨页表的访问。但是处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性。 </p>\n<p>2.使用总线锁保证原子性<br>   总线锁定其实就是处理器使用了总线锁，所谓总线锁就是使用处理器提供的一个 LOCK# 信号，当一个处理器咋总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。 </p>\n<p>3.使用缓存锁保证原子性<br>   通过缓存锁定来保证原子性。 所谓 缓存锁定 是指内存区域如果被缓存在处理器的缓存行中，并且在Lock 操作期间被锁定，那么当他执行锁操作写回到内存时，处理器不在总线上声言 LOCK# 信号，而时修改内部的内存地址，并允许他的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改两个以上处理器缓存的内存区域数据（这里和 volatile 的可见性原理相同），当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效。 </p>\n<p>   注意：有两种情况下处理器不会使用缓存锁定。</p>\n<ol>\n<li>当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行时，则处理器会调用<strong>总线锁定</strong>。</li>\n<li>有些处理器不支持缓存锁定，对于 Intel 486 和 Pentium 处理器，就是锁定的内存区域在处理器的缓存行也会调用总线锁定。</li>\n</ol>\n<h1 id=\"Java中的CAS\"><a href=\"#Java中的CAS\" class=\"headerlink\" title=\"Java中的CAS\"></a>Java中的CAS</h1><p>Java提供了 java.util.concurrent.atomic 包，该包下所有的类都是原子操做，我们重点看下<em>AtomicInteger</em>  这个类。找到该类的<em>compareAndSet</em>方法，也就是比较并且设置。我们看看该方法实现： </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">compareAndSet</span><span class=\"params\">(<span class=\"keyword\">int</span> expect, <span class=\"keyword\">int</span> update)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> unsafe.compareAndSwapInt(<span class=\"keyword\">this</span>, valueOffset, expect, update);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该方法调用了 unsafe 类的 compareAndSwapInt方法，有几个参数，一个是该变量的内存地址，一个是期望值，一个是更新值，一个是对象自身。完全符合我们之前CAS 的定义。</p>\n<p>再往下寻找我们发现 Unsafe的<code>compareAndSwapInt</code> 是 Native 的方法： 是借助C来调用CPU底层指令实现的。 </p>\n<h2 id=\"unsafe-是什么\"><a href=\"#unsafe-是什么\" class=\"headerlink\" title=\"unsafe 是什么\"></a>unsafe 是什么</h2><p>该类在 rt.jar 包中，是 sun.misc 包下。并且都是 class 文件，注释都没有，符合他的名字：不安全。<br>我们能构造他吗？不能，除非反射。<br>下载一个 OpenJdk 的源码继续向下探索，我们发现在 <code>/jdk9u/hotspot/src/share/vm/unsafe.cpp</code> 中有这样的代码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;CC <span class=\"string\">\"compareAndSetInt\"</span>,   CC <span class=\"string\">\"(\"</span> OBJ <span class=\"string\">\"J\"</span><span class=\"string\">\"I\"</span><span class=\"string\">\"I\"</span><span class=\"string\">\")Z\"</span>,  FN_PTR(Unsafe_CompareAndSetInt)&#125;</span><br></pre></td></tr></table></figure>\n<p>这个涉及到，JNI 的调用 搜索 <code>Unsafe_CompareAndSetInt</code>后发现:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSetInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x)) &#123;</span><br><span class=\"line\">  oop p = JNIHandles::resolve(obj);</span><br><span class=\"line\">  jint* addr = (jint *)index_oop_from_field_offset_long(p, offset);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (jint)(Atomic::cmpxchg(x, addr, e)) == e;</span><br><span class=\"line\">&#125; UNSAFE_END</span><br></pre></td></tr></table></figure>\n<p>核心<strong>Atomic::cmpxchg </strong>,针对不同的操作系统,JVM 对于 Atomic::cmpxchg 应该有不同的实现.<br><code>cmpxchgl</code> 就是汇编版的“比较并交换”。 </p>\n<p>总结:</p>\n<ul>\n<li>java 的 cas 利用的的是 unsafe 这个类提供的 cas 操作。</li>\n<li>unsafe 的cas 依赖了的是 jvm 针对不同的操作系统实现的 Atomic::cmpxchg</li>\n<li>Atomic::cmpxchg 的实现使用了汇编的 cas 操作，并使用 cpu 硬件提供的 lock信号保证其原子性</li>\n</ul>\n<h1 id=\"CAS缺点\"><a href=\"#CAS缺点\" class=\"headerlink\" title=\"CAS缺点\"></a>CAS缺点</h1><ol>\n<li><strong>ABA问题 </strong>因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。</li>\n<li><strong>循环时间长开销大 </strong> 自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。 </li>\n<li><strong>只能保证一个共享变量的原子操作</strong> 当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性。在 java.util.concurrent.atomic 包中，就有 AtomicReference 来保证引用的原子性。</li>\n</ol>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjefa5bot000a6skc44xvg46r","category_id":"cjefa5boh00056skch6ssboy5","_id":"cjefa5bpe000g6skcahz6qnc0"},{"post_id":"cjefa5bo100026skcf0id5b8s","category_id":"cjefa5boh00056skch6ssboy5","_id":"cjefa5bpj000k6skc2m7ugiid"},{"post_id":"cjefa5bp9000e6skck12h91o0","category_id":"cjefa5boh00056skch6ssboy5","_id":"cjefa5bpl000m6skchs0ufqc9"},{"post_id":"cjefa5boa00046skc6qmw3y60","category_id":"cjefa5boh00056skch6ssboy5","_id":"cjefa5bpq000q6skccpoiejx5"},{"post_id":"cjefa5bpc000f6skc0u681bhw","category_id":"cjefa5boh00056skch6ssboy5","_id":"cjefa5bpr000s6skch3hx7dgf"},{"post_id":"cjefa5bp3000b6skcds3fuch6","category_id":"cjefa5bpm000n6skcy7e486jl","_id":"cjefa5bpt000v6skc06kgnnmq"},{"post_id":"cjehtoy8e0000dskcy7b2r8bt","category_id":"cjefa5boh00056skch6ssboy5","_id":"cjehtoy8v0003dskcwayamgbo"},{"post_id":"cjf26kpq40000mokcup8o4tke","category_id":"cjefa5bpm000n6skcy7e486jl","_id":"cjf26kpqj0002mokcz03yglqb"},{"post_id":"cjfktbq2f0000w0kc4cs6a9ev","category_id":"cjfktbq2p0001w0kc5gqcdado","_id":"cjfktbq2z0004w0kcj5ua70ce"},{"post_id":"cjfrwqk1s0000wckcf06oqq6q","category_id":"cjfrwqk2f0001wckcf0yvcysy","_id":"cjfrwqk2p0004wckcoq53pthe"},{"post_id":"cjgiyu41q000048kc7hmxes7v","category_id":"cjefa5boh00056skch6ssboy5","_id":"cjgiyu424000248kcgsscea0u"},{"post_id":"cjh09eio80000okkcjzywyj48","category_id":"cjh09eiol0001okkcnedll8dc","_id":"cjh09eios0005okkczuirjirk"},{"post_id":"cjhfm7sm90000g4kcwhc9ghfu","category_id":"cjfrwqk2f0001wckcf0yvcysy","_id":"cjhfm7smm0002g4kcv0dcnskj"},{"post_id":"cjhld56ix0000uokcgq9i94vx","category_id":"cjh09eiol0001okkcnedll8dc","_id":"cjhld56jb0002uokcabfhn5jx"},{"post_id":"cji3vntwq0000zgkckv35utes","category_id":"cji3vntwz0001zgkcac7r3ujv","_id":"cji3vntx60004zgkcuxjivlcy"},{"post_id":"cjila9qrw0000o8kcgwt5n19a","category_id":"cjila9qs30001o8kcr88vcqpj","_id":"cjila9qsb0004o8kcy51a2k0h"},{"post_id":"cjizdddnb00000gkc33hnsx81","category_id":"cjila9qs30001o8kcr88vcqpj","_id":"cjizdddnn00020gkcp6q79ggm"},{"post_id":"cjjp5xnvm0000fgkcqgavuu3i","category_id":"cjjp5xnvv0001fgkc2eui6n11","_id":"cjjp5xnw20003fgkcdntp1tb3"},{"post_id":"cjk0j5y4o0000k8kc1hxkvfcr","category_id":"cji3vntwz0001zgkcac7r3ujv","_id":"cjk0j5y530002k8kc30k48iv8"},{"post_id":"cjk7q5jrq0000v4kcw3iamwy2","category_id":"cjk7q5js20001v4kcczrbi5jk","_id":"cjk7q5jsb0004v4kc0xb6blg9"}],"PostTag":[{"post_id":"cjefa5bp9000e6skck12h91o0","tag_id":"cjefa5bok00066skcilltmbh6","_id":"cjefa5bpi000j6skcbfhkrr2g"},{"post_id":"cjefa5bo100026skcf0id5b8s","tag_id":"cjefa5bok00066skcilltmbh6","_id":"cjefa5bpk000l6skcbh0zxkbl"},{"post_id":"cjefa5bo100026skcf0id5b8s","tag_id":"cjefa5bp6000d6skc2dsyj8t8","_id":"cjefa5bpp000p6skc6bxa6xg9"},{"post_id":"cjefa5boa00046skc6qmw3y60","tag_id":"cjefa5bok00066skcilltmbh6","_id":"cjefa5bpr000r6skc894itrll"},{"post_id":"cjefa5bot000a6skc44xvg46r","tag_id":"cjefa5bpt000w6skcpdwqfwqb","_id":"cjefa5bpx00106skcz4nruek2"},{"post_id":"cjefa5bp3000b6skcds3fuch6","tag_id":"cjefa5bpw000z6skceoeltg72","_id":"cjefa5bpy00126skc2igwzi4z"},{"post_id":"cjefa5bpc000f6skc0u681bhw","tag_id":"cjefa5bpx00116skcgdb963xf","_id":"cjefa5bq000146skc6vqie65t"},{"post_id":"cjefa5bpc000f6skc0u681bhw","tag_id":"cjefa5bpt000w6skcpdwqfwqb","_id":"cjefa5bq000156skc7zguyqgk"},{"post_id":"cjehtoy8e0000dskcy7b2r8bt","tag_id":"cjefa5bpo000o6skcoezmwr0p","_id":"cjehtoy8t0001dskcuz2kn12h"},{"post_id":"cjehtoy8e0000dskcy7b2r8bt","tag_id":"cjefa5bps000t6skc3pnit5e2","_id":"cjehtoy8u0002dskcb601mkid"},{"post_id":"cjf26kpq40000mokcup8o4tke","tag_id":"cjf26kpqe0001mokcakruchqs","_id":"cjf26kpql0003mokc8yrwpm0o"},{"post_id":"cjfktbq2f0000w0kc4cs6a9ev","tag_id":"cjfktbq2w0002w0kc55wyqj5h","_id":"cjfktbq2y0003w0kcx520isrn"},{"post_id":"cjfrwqk1s0000wckcf06oqq6q","tag_id":"cjfrwqk2n0003wckcemxx14a6","_id":"cjfrwqk2r0006wckc8hgquki1"},{"post_id":"cjgiyu41q000048kc7hmxes7v","tag_id":"cjgiyu41z000148kc6r4cv97s","_id":"cjgiyu426000348kcixseyxii"},{"post_id":"cjh09eio80000okkcjzywyj48","tag_id":"cjh09eioo0002okkcnsw2wcah","_id":"cjh09eior0003okkck4tyshcu"},{"post_id":"cjh09eio80000okkcjzywyj48","tag_id":"cjefa5bps000t6skc3pnit5e2","_id":"cjh09eios0004okkcre6rigln"},{"post_id":"cjhfm7sm90000g4kcwhc9ghfu","tag_id":"cjhfm7smi0001g4kczre5f3h6","_id":"cjhfm7smo0003g4kc356qlx42"},{"post_id":"cjhld56ix0000uokcgq9i94vx","tag_id":"cjhld56j60001uokcsba1p32l","_id":"cjhld56je0003uokczfwowndu"},{"post_id":"cji3vntwq0000zgkckv35utes","tag_id":"cji3vntx30002zgkcx7rzhil0","_id":"cji3vntx50003zgkc0kiep4xu"},{"post_id":"cjila9qrw0000o8kcgwt5n19a","tag_id":"cjila9qs80002o8kce8lzfnkn","_id":"cjila9qsd0005o8kcnxz5brzt"},{"post_id":"cjila9qrw0000o8kcgwt5n19a","tag_id":"cjila9qsa0003o8kco41sa59o","_id":"cjila9qse0006o8kcafzemiin"},{"post_id":"cjizdddnb00000gkc33hnsx81","tag_id":"cjila9qs80002o8kce8lzfnkn","_id":"cjizdddnp00030gkcz3pm3j4r"},{"post_id":"cjizdddnb00000gkc33hnsx81","tag_id":"cjizdddnj00010gkcetv0omui","_id":"cjizdddnq00040gkctaanqzof"},{"post_id":"cjjp5xnvm0000fgkcqgavuu3i","tag_id":"cjh09eioo0002okkcnsw2wcah","_id":"cjjp5xnvz0002fgkcc7fp36rc"},{"post_id":"cjk0j5y4o0000k8kc1hxkvfcr","tag_id":"cjk0j5y4x0001k8kc48gq5z2n","_id":"cjk0j5y540003k8kcomv2pudk"},{"post_id":"cjk7q5jrq0000v4kcw3iamwy2","tag_id":"cjk7q5js70002v4kc1v9tnw5h","_id":"cjk7q5js90003v4kcg2oqmcmr"}],"Tag":[{"name":"Java","_id":"cjefa5bok00066skcilltmbh6"},{"name":"GC","_id":"cjefa5bp6000d6skc2dsyj8t8"},{"name":"synchronized","_id":"cjefa5bpo000o6skcoezmwr0p"},{"name":"lock","_id":"cjefa5bps000t6skc3pnit5e2"},{"name":"java","_id":"cjefa5bpt000w6skcpdwqfwqb"},{"name":"threadpool","_id":"cjefa5bpw000z6skceoeltg72"},{"name":"jvm","_id":"cjefa5bpx00116skcgdb963xf"},{"name":"docker","_id":"cjf26kpqe0001mokcakruchqs"},{"name":"区块链","_id":"cjfktbq2w0002w0kc55wyqj5h"},{"name":"查找","_id":"cjfrwqk2l0002wckcmvxq33no"},{"name":"二分查找","_id":"cjfrwqk2n0003wckcemxx14a6"},{"name":"ConcurrentHashMap","_id":"cjgiyu41z000148kc6r4cv97s"},{"name":"redis","_id":"cjh09eioo0002okkcnsw2wcah"},{"name":"快速排序","_id":"cjhfm7smi0001g4kczre5f3h6"},{"name":"接口限流","_id":"cjhld56j60001uokcsba1p32l"},{"name":"ThreadLocal","_id":"cji3vntx30002zgkcx7rzhil0"},{"name":"spring","_id":"cjila9qs80002o8kce8lzfnkn"},{"name":"aop","_id":"cjila9qsa0003o8kco41sa59o"},{"name":"ioc","_id":"cjizdddnj00010gkcetv0omui"},{"name":"JVM","_id":"cjk0j5y4x0001k8kc48gq5z2n"},{"name":"CAS","_id":"cjk7q5js70002v4kc1v9tnw5h"}]}}