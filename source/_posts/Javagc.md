title: Java垃圾回收探究
author: James
tags:
  - Java
  - GC
categories:
  - 语言
date: 2013-06-01 14:09:00
---

# 介绍

Java的内存分配与回收全部由JVM垃圾回收进程自动完成。与C语言不同，Java开发者不需要自己编写代码实现垃圾回收。本文主要通过几个方面来探索Java垃圾回收

1. 什么时候需要垃圾回收
2. 垃圾回收算法有哪些
3. 垃圾回收器如何工作

<!-- more -->

# 内存的分配

根据分析[JVM内存](/language/jvm_memory/)我们得知**堆**内存是主要用来保存运行时的对象实例,所以我们主要关注点就集中在堆内存。

J在JVM的堆内存空间中分为年老代和年轻代。将大量（据统计差不多90%以上）创建了没多久就会消亡的对象存储在年轻代，而年老代中存放生命周期长久的实例对象。

![heap](/images/jvm/jvm_heap.jpg)

1.新生代（Young Generation）

2.老年代（Old Generation）实例将从S1提升到Tenured（终身代）

3.久代（Permanent Generation）包含类、方法等细节的元信息



# 垃圾回收的条件

如何判定对象是否存活的？

## 根搜索算法

思路: 通过一系列的名为`GC Roots`的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到`GC Roots`没有任何引用链相连时，则证明此对象是不可用的。

`GC Roots` 的对象包括下面几种:

1. 虚拟机栈（栈帧中的本地变量表）中的引用的对象。
2. 方法区中的类静态属性引用的对象。
3. 方法区中的常量引用的对象。
4. 本地方法栈中JNI（Native方法）的引用的对象。

# 回收算法

## 引用计数法

引用计数是垃圾收集器中的早期策略。在这种方法中，堆中每个对象实例都有一个引用计数。当一个对象被创建时，且将该对象实例分配给一个变量，该变量计数设置为1。当任何其它变量被赋值为这个对象的引用时，计数加1（a = b,则b引用的对象实例的计数器+1），但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数器减1。任何引用计数器为0的对象实例可以被当作垃圾收集。当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器减1。**缺点**是无法检测出循环引用。如父对象有一个对子对象的引用，子对象反过来引用父对象。这样，他们的引用计数永远不可能为0.

## 标记-清除算法

标记-清除算法采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象进行回收。此算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片。

## 标记-整理算法

标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往空闲空间移动，并更新对应的指针。标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。

## 复制算法

该算法的提出是为了克服句柄的开销和解决堆碎片的垃圾回收。它开始时把堆分成 一个对象 面和多个空闲面， 程序从对象面为对象分配空间，当对象满了，基于copying算法的垃圾 收集就从根集中扫描活动对象，并将每个 活动对象复制到空闲面(使得活动对象所占的内存之间没有空闲洞)，这样空闲面变成了对象面，原来的对象面变成了空闲面，程序会在新的对象面中分配内存。



# 回收策略

在JVM中**不同的对象的生命周期是不一样的**。因此，不同生命周期的对象可以采取不同的回收算法，以便提高回收效率。

## **年轻代（Young Generation）** 复制算法

1. 所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。
2. 新生代内存按照8:1:1的比例分为一个eden区和两个survivor(survivor0,survivor1)区。大部分对象在Eden区中生成。回收时先将eden区存活对象复制到一个survivor0区，然后清空eden区，当这个survivor0区也存放满了时，则将eden区和survivor0区存活对象复制到另一个survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后将survivor0区和survivor1区交换，即保持survivor1区为空， 如此往复。
3. 当survivor1区不足以存放 eden和survivor0的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次Full GC，也就是新生代、老年代都进行回收。
4. 新生代发生的GC也叫做Minor GC，MinorGC发生频率比较高(不一定等Eden区满了才触发)。

## **年老代（Old Generation）**标记-整理算法

1. 在年轻代中经历了N次垃圾回收后仍然存活的对象(`MaxTenuringThreshold`控制进入老年前生存次数)，会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。
2. 年老代内存比新生代大很多(大概比例是1:2)，当老年代内存满时触发Major GC即Full GC，Full GC发生频率比较低，老年代对象存活时间比较长，存活率标记高。

## **持久代（Permanent Generation）**

​	用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate 等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。

# 垃圾收集器

新生代收集器使用的收集器：Serial、PraNew、Parallel Scavenge

老年代收集器使用的收集器：Serial Old、Parallel Old、CMS



## **Serial收集器（复制算法)**

新生代单线程收集器，标记和清理都是单线程，优点是简单高效。

## **Serial Old收集器(标记-整理算法)**

老年代单线程收集器，Serial收集器的老年代版本。

## **ParNew收集器(停止-复制算法)　**

新生代收集器，可以认为是Serial收集器的多线程版本,在多核CPU环境下有着比Serial更好的表现。

## **Parallel Scavenge收集器(停止-复制算法)**

并行收集器，追求高吞吐量，高效利用CPU。吞吐量一般为99%， 吞吐量= 用户线程时间/(用户线程时间+GC线程时间)。适合后台应用等对交互相应要求不高的场景。

## **Parallel Old收集器(停止-复制算法)**

Parallel Scavenge收集器的老年代版本，并行收集器，吞吐量优先

## **CMS(Concurrent Mark Sweep)收集器（标记-清理算法）**

高并发、低停顿，追求最短GC回收停顿时间，cpu占用比较高，响应时间快，停顿时间短，多核cpu 追求高响应时间的选择

## G1垃圾回收器

G1垃圾回收器适用于堆内存很大的情况，他将堆内存分割成不同的区域，并且并发的对其进行垃圾回收。G1也可以在回收内存之后对剩余的堆内存空间进行压缩。并发扫描标记垃圾回收器在STW情况下压缩内存。G1垃圾回收会优先选择第一块垃圾最多的区域

通过JVM参数 `–XX:+UseG1GC` 使用G1垃圾回收器

# 常用JVM参数配置

- **-Xmn**设置Young的空间大小
- **-XX:NewRatio= 3** 为Tenured:Young的初始尺寸比例（设置了大小就不再设置此值），此时Young占用整个HeapSize的1/4大小
- **-XX:SurvivorRatio= 6**：为Eden:Survivor比例大小，此时一个Survivor占用Young的1/8大小，而Eden占用3/4大小。
- **-XX:MaxTenuringThreshold=3**：一般一个对象在Young经过多少次GC后会被移动到OLD区。
- **-XX:+UseParNewGC**：对Yong区域启用并行回收算法。
- **-XX:+UseConcMarkSweepGC** 启动并发GC，一般针对Tenured区域。



# 实战问题

常见的OOM现象有以下几种：

1. heapSize溢出：**java.lang.OutOfMemoryError：**java heap space

   这个需要设置Java虚拟机的内存情况

2. PermSize溢出：**java.lang.OutOfMemoryError：**PermGen space

   需要设置Perm相关参数以及检查内存中的常量情况，jdk1.7中的常量池移到了堆中。

3. 栈内存溢出错误：**StackOverflowError**

   通常都是程序的问题，JVM对栈帧的大小设置已经很大了，比如递归

4. native Thread溢出，注意线程Stack的大小，以及本身操作系统的限制。