title: 聊聊TCP
author: James
tags:
  - tcp
categories:
  - 网络
date: 2019-06-25 11:50:00

---

我们作为研发，多少在工作中会涉猎到网络传输这块。 故而这次是整理下TCP的一些核心知识点。为一名开发者来说，尽管有那么多的基础设施(框架、组件)帮我们屏蔽了这些细节。当我仍然认为了解它的一些基本原理必有些裨益，尤其是当我们在分布式环境上或者网络上遇到一些棘手问题时，一些原理性的知识可能会让你快速找到答案。

<!-- more -->

# 简介

TCP 是传输层的协议，全称是叫做 **Transmission Control Protocol**，这个协议在 IETF **RFC 793** 进行了定义。
在互联网产生之前，我们的电脑都是相互独立的，每台机器都有着自己的操作系统并保持着自己的运行。
于是，为了将这些电脑连接起来，并能够基于一种**"通道"的形式**进行数据、资源的传输及交互，IETF 制定了 TCP 协议。

在学习计算机网络课程的时候，都会提到两种网络模型，如下：

![](/images/tcp/module.png)

- **OSI 模型**: 全称为 Open System Interconnection

  即开放系统互联模型，这个是由 ISO(International Organization for Standardization) 国际标准化组织提出的。 它主要是用来解决当时各个网络技术供应商在协议上无法统一的问题，通过将整个网络体系结构抽象为 7层，从最底层的物理层、数据链路层一直到最上面的应用层都做了定义。

- **TCP/IP**: 即 TCP/IP Protocol Suite(协议套件)是一个以TCP协议和IP协议为核心的通信模型，该模型采用协议堆栈的方式来实现许多通信协议，并将通讯体系抽象为4层。 TCP/IP 模型最早发源于美国国防部（缩写为DoD）的ARPA网项目，此后就交由IETF组织来维护。

![](/images/tcp/tcp-ip.png)

# TCP 协议

TCP 是整个 TCP/IP 协议族中最重要的传输层协议，它定义了一种面向连接的、可靠的、基于流的传输方式。
HTTP 是基于 TCP 的，所以说 TCP 是整个互联网的协议其一并不为过。
同时，我们在使用 HTTP 协议实现应用系统间的交互时，也经常免不了会与 TCP 打上交道。因此有必要了解一些基本机制。

## 特点

- 首先，TCP 是**基于连接**的，也就是在进行数据传输之前，客户端与服务端(或者说是通信的双方)需要先建立一个可信的连接。 在数据传输结束后，再通过一种协定的方式断开连接，由通信的双方释放资源。这里涉及到的，就是常说的**"三次握手"、"四次挥手"**
- 其次，TCP 是**可靠**的，它定义了一种数据包的"超时重传机制"，简单说，就是每一个数据包在发送出去后的都会等待一个响应。 如果指定时间内没有收到响应，由发送方进行一定次数的重传来保证数据的可靠传输。
- 最后，TCP 是**基于流**的，这是指在传输数据时应用层不需要关注数据包的边界，TCP在数据传输时会自动根据网络环境将数据进行**缓冲、分组、合并**。 这点跟基于报文的协议(UDP)是截然不同的。当然，基于流的传输也保证了数据收发的有序性，因此每个数据包都附带上一个属于当前连接的序列号。



# TCP 的数据包

## TCP 的报文格式

![](/images/tcp/tcp-bw.png)

包括了：

**源端口** 表明发送端所使用的端口号，用于目标主机回应。

**目的端口** 表明要连接的目标主机的端口号。

**序号** 表明发送的数据包的顺序，一般为上次发送包中的顺序号+1。 若该数据包是整个TCP连接中的第一个包(SYN包)，则该值是随机生成的。

**确认号** 表明本端TCP已经接收到的数据，其值表示期待对端发送的下一个字节的序号。 实际上告诉对方，在这个序号减1以前的字节已正确接收。 若该数据包是整个TCP连接中的第一个包(SYN包)，则确认号一般为0。

**数据偏移** 表示以32位(4字节)为单位的TCP分组头的总长度(首部长度)，用于确定用户数据区的起始位置。 在没有可变内容的情况下，TCP头部的大小为20字节，对应该值为5。

**标志位** 紧急标志位(URG)：开启时表明此数据包处于紧急状态应该优先处理 确认标志位(ACK)：开启时表明确认号有效，否则忽略确认号 推送标志位(PSH)：开启时表明应该尽快交付给应用进程，而不必等到缓存区填满才推送，比如 telnet 的场景 复位标志位(RST)：开启时表明TCP连接出现连接出现错误，数据包非法拒绝连接 同步标志位(SYN)：开启时表明连接建立的标志 终止标志位(FIN)：开启时表明释放一个连接

**窗口大小** 表明期望接受到的数据包字节数，用于拥塞控制。

**校验和** 实现对TCP报文头以及数据区进行校验。

**紧急指针** 在紧急状态下(URG打开)，指出窗口中紧急数据的位置(末端)。

**选项(可变)** 用于支持一些特殊的变量，比如最大分组长度(MSS)。

**填充** 用于保证可变选项为32 bit的整数倍。

## **工作流程**

TCP 正常的通讯流程，会包含建链(建立连接)、传输数据、拆链(关闭连接)

![](/images/tcp/three.png)

(图来自网络)

据上图所示，在进行 TCP 进行数据传输时，都不可避免的会经过这两个阶段：

- 三次握手建立连接
- 执行数据传输、双方读写
- 四次挥手释放连接

### 三次握手

![](/images/tcp/tcp-three.png)

在建立TCP连接时，需要经过三次交互，也成为三次握手(HandShake)。

1. 客户端发起连接请求，发送 SYN包（SYN=i）到服务器，并进入到**SYN-SEND**状态，等待服务器确认. 
2. 服务器收到SYN包后，必须确认客户的 SYN（ack=i+1），同时自己也发送一个SYN包（SYN=k），即SYN+ACK包，此时服务器进入**SYN-RECV**状态 .
3. 客户端收到服务器的SYN+ACK包，向服务器发送确认报ACK（ack=k+1），此后客户端和服务器进入**ESTABLISHED**状态，双方可以开始传送数据。

**为什么是三次握手**?

TCP 是可靠的传输，在建立连接时就应该经过两端的确认过程，如上面的流程，
只有在三次握手的情况下，客户端和服务端都经过了一次真正(SYN+ACK)的确认过程。这样的连接便认为是可信的。此外，如果仅仅只是两次握手，一旦网络不稳定造成 SYN 包重传则会直接导致重复建立连接，浪费资源。

### 四次挥手

![](/images/tcp/four.png)

流程如下：

1. 客户端发送一个FIN，用来关闭客户端到服务器的数据传送，客户端进入FINWAIT1状态。
2.  服务器收到FIN后，发送一个ACK给客户端，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），服务器进入CLOSEWAIT状态，而客户端进入FINWAIT2状态。 
3. 服务器发送一个FIN，用来关闭服务器到客户端的数据传送，服务器进入LASTACK状态。
4.  客户端收到FIN后，客户端进入TIMEWAIT状态，接着发送一个ACK给服务器，确认序号为收到序号+1，服务器进入CLOSED状态，完成释放。

*关闭连接有主动关闭和被动关闭一说，这里为了简化理解，我们以客户端作为主动关闭方，服务器为被动关闭方。*

**为什么是四次挥手?**

发送FIN的一方就是主动关闭(客户端)，而另一方则为被动关闭(服务器)。
当一方发送了FIN，则表示在这一方不再会有数据的发送。
其中当被动关闭方受到对方的FIN时，此时往往可能还有数据需要发送过去，因此无法立即发送FIN(也就是无法将FIN与ACK合并发送)，
而是在等待自己的数据发送完毕后再单独发送FIN，因此整个过程需要四次交互。

**什么是半关闭?**

客户端在收到第一个FIN的ACK响应后，会进入FINWAIT2 状态时，此时服务器处于 CLOSEWAIT状态，这种状态就称之为**半关闭**。从半关闭到全关闭，需要等待第二次FIN的确认才算结束。此时，客户端要等到服务器的FIN才能进入TIMEWAIT，如果对方迟迟不发送FIN呢，则会等待一段时间后超时，这个可以通过内核参数**tcp** **fin_timeout**控制，默认是60s。

**服务器会有大量 closewait?**

半关闭的状态下的服务器连接会处于 closewait 状态，直到服务器发送了FIN。 那么在应用层则是调用**socket.close()**会执行FIN的发送，如果服务器出现大量CLOSE_WAIT状态的连接，那么有可能的原因：

- 服务器压力过大，根本来不及调用close
- 存在连接泄露问题(Bug)，服务器未及时关闭连接

**timewait 会带来什么问题？**

当客户端收到了对方的FIN时，会进入TIMEWAIT状态，此时会保持一段时间再进入CLOSE状态。 这么做的原因主要还是为了可靠的关闭连接。在将TCP 进行可靠性设计之时就考虑了许多网络的不稳定性的因素，比如：

**发送给对方的ACK 可能会无法及时收到，此时对方可能重传FIN过来，如果提前进入CLOSE则会返回RST而不是ACK，就会影响关闭流程。**

因此 TIMEWAIT 状态默认会持续一段时间，直到确认不会再有重传的数据包之后再安全的关闭。

如果频繁的主动关闭连接，可能会产生大量 timewait，由于timewait 的连接占用了一个句柄及少量内存(4K)，那么就有可能会影响其他连接的建立，比如：**出现 too many open files 异常..**

如何解决：

- 重用连接，避免频繁关闭，比如使用连接池
- 参数调优，比如开启**tcptwreuse**选项支持timewait连接的重复使用。

> HTTP 协议里头发现了timewait的问题，于是在 HTTP 1.1 中定义了 KeepAlive 用来支持连接的重用。